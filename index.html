<!DOCTYPE html>
<html lang="ja">

<head>


  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>統合版（電子書籍＋プランナー）</title>
  <script>
    // preload performance mode to avoid initial heavy paints
    try { if (localStorage.getItem('performance-mode') === '1') { document.documentElement.classList.add('performance-mode'); } } catch (e) { }
  </script>
  <style>
    :root {
      --bg: #0b0e13;
      --panel: #121823;
      --muted: #98a2b3;
      --text: #e6eaf0;
      --app-font: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      --miss-font: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      --clock-font: 'SFMono-Regular', 'Menlo', 'Consolas', monospace;
      --brand: #4f8cff;
      --brand2: #6ee7b7;
      --accent: #ffd166;
      --danger: #ff6b6b;
      --ok: #22c55e;
      --card: #0f1420;
      --chip: #0f1624;
      --topbar-h: 52px;
      --vh-safe: 100vh;
      --page-filter: none;
      --stage-bg1: #ffffff;
      --stage-bg2: #f6f7fb;
      --stage-bg3: #eef0f6;
      --stage-host1: #f4f5f9;
      --stage-host2: #e9ecf2;
      --stage-tint-soft: rgba(120, 130, 150, .12);
      --stage-tint-glow: rgba(120, 130, 150, .08);
      --stage-tint-line: rgba(120, 130, 150, .12);
      --stage-border: #dfe4ee;
      --stage-base: #f6f7fb;
      --cursor-pen: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='28' height='28' viewBox='0 0 28 28'><path fill='%23fbbf24' stroke='%230f172a' stroke-width='1.2' d='M5 20l13-13 3.5 3.5-13 13-5 1.4z'/><path fill='%23fde68a' d='M6.8 19.4 18.6 7.6l1.2 1.2-11.8 11.8z'/><path fill='%23111827' d='m4.3 20.2 2.3 2.3-2.8.8z'/></svg>") 3 24, auto;
      --cursor-reticle: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='30' height='30' viewBox='0 0 30 30'><circle cx='15' cy='15' r='10' fill='none' stroke='%2381e6d9' stroke-width='2.2'/><circle cx='15' cy='15' r='3' fill='%2381e6d9'/><path stroke='%2381e6d9' stroke-width='2' d='M15 1v6M15 23v6M1 15h6M23 15h6'/></svg>") 15 15, auto;
      --cursor-cross: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='28' height='28' viewBox='0 0 28 28'><path stroke='%23e0f2fe' stroke-width='2.2' d='M14 2v24M2 14h24'/><circle cx='14' cy='14' r='4' fill='none' stroke='%230ea5e9' stroke-width='2'/></svg>") 14 14, auto;
      --cursor-ring: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'><circle cx='16' cy='16' r='9' fill='none' stroke='%23f472b6' stroke-width='2.2'/><circle cx='16' cy='16' r='4' fill='none' stroke='%23fda4af' stroke-width='2'/></svg>") 16 16, auto;
      --cursor-marker: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='30' height='30' viewBox='0 0 30 30'><path fill='%2322c55e' stroke='%230f172a' stroke-width='1.3' d='M6 22 20 6l4 4-14 16-5 .9z'/><path fill='%23bbf7d0' d='M7.5 21.2 19.2 7.5l1 1L8.5 22.2z'/></svg>") 4 26, auto;
      /* New cool cursors */
      --cursor-neon: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'><defs><filter id='glow'><feGaussianBlur stdDeviation='1.5' result='blur'/><feMerge><feMergeNode in='blur'/><feMergeNode in='SourceGraphic'/></feMerge></filter></defs><circle cx='16' cy='16' r='6' fill='%2300eaff' filter='url(%23glow)'/><circle cx='16' cy='16' r='3' fill='%23fff'/><path stroke='%237b5cff' stroke-width='2' filter='url(%23glow)' d='M16 4v5M16 23v5M4 16h5M23 16h5'/></svg>") 16 16, auto;
      --cursor-star: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'><path fill='%23fbbf24' stroke='%23f59e0b' stroke-width='1' d='M16 2l3.5 10.5H30l-8.5 6.5 3.5 11-9-7-9 7 3.5-11L2 12.5h10.5z'/><circle cx='16' cy='14' r='2' fill='%23fff'/></svg>") 16 16, auto;
      --cursor-diamond: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='28' height='28' viewBox='0 0 28 28'><path fill='%23a78bfa' stroke='%238b5cf6' stroke-width='1.2' d='M14 2L26 14 14 26 2 14z'/><path fill='%23c4b5fd' d='M14 6L22 14 14 22 6 14z'/><circle cx='14' cy='14' r='2' fill='%23fff'/></svg>") 14 14, auto;
      --cursor-laser: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'><line x1='16' y1='0' x2='16' y2='32' stroke='%23ef4444' stroke-width='1.5'/><line x1='0' y1='16' x2='32' y2='16' stroke='%23ef4444' stroke-width='1.5'/><circle cx='16' cy='16' r='4' fill='none' stroke='%23fca5a5' stroke-width='1.5'/><circle cx='16' cy='16' r='1.5' fill='%23ef4444'/></svg>") 16 16, auto;
      --cursor-blade: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'><path fill='%23374151' stroke='%231f2937' stroke-width='1' d='M4 28l4-4 16-16 4 4-16 16z'/><path fill='%239ca3af' d='M6 26l2-2 14-14 2 2-14 14z'/><path fill='%23f3f4f6' d='M22 6l2-2 2 2-2 2z'/><circle cx='8' cy='24' r='1' fill='%23fbbf24'/></svg>") 4 28, auto;
      --cursor-portal: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='32' height='32' viewBox='0 0 32 32'><circle cx='16' cy='16' r='10' fill='none' stroke='%239333ea' stroke-width='2'/><circle cx='16' cy='16' r='6' fill='none' stroke='%234f46e5' stroke-width='2'/><circle cx='16' cy='16' r='2' fill='%23a78bfa'/></svg>") 16 16, auto;
      --cursor-flame: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='28' height='32' viewBox='0 0 28 32'><path fill='%23fb923c' d='M14 2c0 0 8 8 8 16 0 6-4 10-8 10s-8-4-8-10c0-8 8-16 8-16z'/><path fill='%23fbbf24' d='M14 8c0 0 5 5 5 11 0 4-2 7-5 7s-5-3-5-7c0-6 5-11 5-11z'/><path fill='%23fef3c7' d='M14 14c0 0 3 3 3 7 0 2-1 4-3 4s-3-2-3-4c0-4 3-7 3-7z'/></svg>") 14 28, auto;
      --cursor-crystal: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='28' height='32' viewBox='0 0 28 32'><path fill='%2322d3ee' stroke='%230891b2' stroke-width='1' d='M14 2L24 12 14 30 4 12z'/><path fill='%2367e8f9' d='M14 6L20 12 14 26 8 12z'/><path fill='%23a5f3fc' d='M14 10L17 13 14 22 11 13z'/></svg>") 14 16, auto;
    }

    @supports (height: 100dvh) {
      :root {
        --vh-safe: 100dvh;
      }
    }

    * {
      box-sizing: border-box
    }

    html,
    body {
      height: 100%;
      min-height: 100%;
      overflow-y: auto;
    }

    body {
      margin: 0;
      background: linear-gradient(180deg, #0b0e13, #0c111a 40%, #0b0e13);
      color: var(--text);
      font-family: var(--app-font);
      font-size: 14px;
      line-height: 1.5;
      cursor: auto;
    }

    /* Cursor themes - Force apply to ALL elements */
    body.cursor-style-pen *,
    body.cursor-style-pen {
      cursor: var(--cursor-pen) !important;
    }

    body.cursor-style-reticle *,
    body.cursor-style-reticle {
      cursor: var(--cursor-reticle) !important;
    }

    body.cursor-style-cross *,
    body.cursor-style-cross {
      cursor: var(--cursor-cross) !important;
    }

    body.cursor-style-ring *,
    body.cursor-style-ring {
      cursor: var(--cursor-ring) !important;
    }

    body.cursor-style-marker *,
    body.cursor-style-marker {
      cursor: var(--cursor-marker) !important;
    }

    body.cursor-style-neon *,
    body.cursor-style-neon {
      cursor: var(--cursor-neon) !important;
    }

    body.cursor-style-star *,
    body.cursor-style-star {
      cursor: var(--cursor-star) !important;
    }

    body.cursor-style-diamond *,
    body.cursor-style-diamond {
      cursor: var(--cursor-diamond) !important;
    }

    body.cursor-style-laser *,
    body.cursor-style-laser {
      cursor: var(--cursor-laser) !important;
    }

    body.cursor-style-blade *,
    body.cursor-style-blade {
      cursor: var(--cursor-blade) !important;
    }

    body.cursor-style-portal *,
    body.cursor-style-portal {
      cursor: var(--cursor-portal) !important;
    }

    body.cursor-style-flame *,
    body.cursor-style-flame {
      cursor: var(--cursor-flame) !important;
    }

    body.cursor-style-crystal *,
    body.cursor-style-crystal {
      cursor: var(--cursor-crystal) !important;
    }

    /* Animated cursor overlay (for supported cursors) */
    .cursor-anim-glow {
      position: fixed;
      pointer-events: none;
      z-index: 99999;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      mix-blend-mode: screen;
      opacity: 0;
      transition: opacity 0.15s;
    }

    body.cursor-style-neon .cursor-anim-glow,
    body.cursor-style-portal .cursor-anim-glow,
    body.cursor-style-flame .cursor-anim-glow,
    body.cursor-style-crystal .cursor-anim-glow {
      opacity: 1;
    }

    body.cursor-style-neon .cursor-anim-glow {
      background: radial-gradient(circle, rgba(0, 234, 255, 0.5) 0%, rgba(123, 92, 255, 0.3) 40%, transparent 70%);
      animation: cursorPulse 1.2s ease-in-out infinite;
    }

    body.cursor-style-portal .cursor-anim-glow {
      width: 50px;
      height: 50px;
      background: radial-gradient(circle, rgba(147, 51, 234, 0.6) 0%, rgba(79, 70, 229, 0.3) 50%, transparent 70%);
      animation: cursorSpin 2s linear infinite, cursorPulse 1.5s ease-in-out infinite;
    }

    body.cursor-style-flame .cursor-anim-glow {
      width: 35px;
      height: 50px;
      background: radial-gradient(ellipse at 50% 70%, rgba(251, 146, 60, 0.7) 0%, rgba(239, 68, 68, 0.4) 40%, transparent 70%);
      animation: cursorFlame 0.5s ease-in-out infinite alternate;
      border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
    }

    body.cursor-style-crystal .cursor-anim-glow {
      background: radial-gradient(circle, rgba(165, 243, 252, 0.5) 0%, rgba(34, 211, 238, 0.2) 50%, transparent 70%);
      animation: cursorCrystal 2s ease-in-out infinite;
    }

    @keyframes cursorPulse {

      0%,
      100% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 0.7;
      }

      50% {
        transform: translate(-50%, -50%) scale(1.3);
        opacity: 1;
      }
    }

    @keyframes cursorSpin {
      from {
        filter: hue-rotate(0deg);
      }

      to {
        filter: hue-rotate(360deg);
      }
    }

    @keyframes cursorFlame {
      0% {
        transform: translate(-50%, -50%) scaleY(1) scaleX(1);
      }

      100% {
        transform: translate(-50%, -50%) scaleY(1.15) scaleX(0.9);
      }
    }

    @keyframes cursorCrystal {

      0%,
      100% {
        transform: translate(-50%, -50%) rotate(0deg) scale(1);
      }

      25% {
        transform: translate(-50%, -50%) rotate(90deg) scale(1.2);
      }

      50% {
        transform: translate(-50%, -50%) rotate(180deg) scale(1);
      }

      75% {
        transform: translate(-50%, -50%) rotate(270deg) scale(1.2);
      }
    }

    /* Exclude input/textarea from custom cursor for usability */
    body[class*="cursor-style-"] input,
    body[class*="cursor-style-"] textarea,
    body[class*="cursor-style-"] [contenteditable="true"] {
      cursor: text !important;
    }

    body[class*="cursor-style-"] select {
      cursor: pointer !important;
    }

    a {
      color: var(--brand)
    }

    .topbar {
      position: relative;
      z-index: 50;
      backdrop-filter: blur(12px);
      background: rgba(10, 14, 22, .7);
      border-bottom: 1px solid #1b2432;
      min-height: var(--topbar-h);
    }

    .topbar-inner {
      display: flex;
      gap: 6px;
      align-items: center;
      justify-content: space-between;
      padding: 4px 8px;
      max-width: 1200px;
      margin: auto
    }

    #topbarRestore {
      position: fixed;
      left: 12px;
      top: 12px;
      right: auto;
      bottom: auto;
      z-index: 200;
      display: none;
      place-items: center;
    }

    #topbarRestore .mini-menu {
      min-width: 44px;
      padding: 2px 6px;
      font-size: 10px;
      text-align: center;
      opacity: 0.86;
    }

    .brand {
      display: flex;
      gap: 10px;
      align-items: center
    }

    .logo {
      width: 28px;
      height: 28px;
      border-radius: 8px;
      background: conic-gradient(from 90deg, var(--brand), var(--brand2), var(--accent), var(--brand));
      box-shadow: 0 0 30px rgba(79, 140, 255, .25)
    }

    .brand h1 {
      display: none
    }

    .tabs {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
      flex: 0 0 auto
    }

    .open-tabs {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
      align-items: center;
      flex: 1;
      min-width: 120px
    }

    .open-tab {
      padding: 3px 8px;
      border: 1px solid #243249;
      background: rgba(14, 20, 32, .7);
      border-radius: 8px;
      cursor: pointer;
      user-select: none;
      font-size: 11px;
      line-height: 1.2;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      max-width: 220px
    }

    .open-tab .label {
      display: inline-block;
      max-width: 160px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap
    }

    .open-tab .close {
      border: none;
      background: transparent;
      color: #9fb0c9;
      cursor: pointer;
      font-size: 12px;
      padding: 0 2px;
      line-height: 1
    }

    .open-tab .close:hover {
      color: #fff
    }

    .open-tab.active {
      border-color: var(--brand);
      box-shadow: 0 0 0 1px rgba(79, 140, 255, .25) inset;
      color: #fff;
      background: rgba(79, 140, 255, .12)
    }

    /* ===== PuddingOS (desktop-like shell) ===== */
    body.pudding-os-mode {
      --topbar-h: 0px;
      overflow: hidden;
    }

    body.pudding-os-mode .topbar,
    body.pudding-os-mode #topbarRestore {
      display: none !important;
    }

    #puddingOsLayer {
      position: fixed;
      inset: 0;
      z-index: 9999;
      display: none;
      pointer-events: auto;
    }

    body.pudding-os-mode #puddingOsLayer {
      display: block;
    }

    .pudding-desktop {
      width: 100%;
      height: 100%;
      position: relative;
      overflow: hidden;
      background: radial-gradient(120% 120% at 10% 10%, rgba(111, 146, 255, 0.12), transparent 45%),
        radial-gradient(120% 120% at 90% 90%, rgba(110, 231, 183, 0.14), transparent 45%),
        linear-gradient(135deg, #0c111a 0%, #0b1220 45%, #0a0f1b 100%);
      backdrop-filter: blur(6px);
      pointer-events: auto;
    }

    .pudding-window {
      position: absolute;
      top: 6vh;
      left: 6vw;
      width: 88vw;
      height: 80vh;
      border-radius: 18px;
      background: rgba(12, 17, 30, 0.86);
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 30px 90px rgba(0, 0, 0, 0.45), 0 0 40px rgba(79, 140, 255, 0.22);
      overflow: hidden;
      display: grid;
      grid-template-rows: 46px 1fr;
      transition: box-shadow 160ms ease, transform 160ms ease;
    }

    .pudding-window.active {
      box-shadow: 0 36px 100px rgba(0, 0, 0, 0.52), 0 0 52px rgba(110, 231, 183, 0.25);
      transform: translateY(-2px);
    }

    .pw-titlebar {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 14px;
      background: linear-gradient(90deg, rgba(79, 140, 255, 0.28), rgba(110, 231, 183, 0.22));
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      cursor: grab;
      user-select: none;
    }

    .pw-title {
      font-weight: 700;
      letter-spacing: 0.3px;
      color: #eaf2ff;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.35);
    }

    .pw-controls {
      margin-left: auto;
      display: flex;
      gap: 6px;
    }

    .pw-btn {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.85), rgba(255, 255, 255, 0.65));
      color: #0b1220;
      font-weight: 800;
      font-size: 12px;
      box-shadow: inset 0 -1px 0 rgba(0, 0, 0, 0.14);
      transition: transform 120ms ease, box-shadow 120ms ease;
    }

    .pw-btn:hover {
      transform: translateY(-1px);
      box-shadow: inset 0 -1px 0 rgba(0, 0, 0, 0.2), 0 6px 14px rgba(0, 0, 0, 0.16);
    }

    .pw-btn.exit {
      background: radial-gradient(circle at 30% 30%, #ff9b9b, #ff5f5f);
      color: #fff;
    }

    .pw-body {
      position: relative;
      background: rgba(10, 15, 27, 0.82);
      backdrop-filter: blur(12px);
      overflow: hidden;
      border-radius: 0 0 18px 18px;
    }

    .pw-body>* {
      width: 100%;
      height: 100%;
    }

    .pw-resize {
      position: absolute;
      width: 18px;
      height: 18px;
      right: 6px;
      bottom: 6px;
      cursor: nwse-resize;
      border-radius: 4px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.25), rgba(79, 140, 255, 0.4));
      opacity: 0.8;
    }

    .pudding-dock {
      position: absolute;
      left: 50%;
      bottom: -120px;
      transform: translateX(-50%);
      display: inline-flex;
      gap: 10px;
      padding: 12px 14px;
      background: rgba(12, 17, 30, 0.8);
      border-radius: 18px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.35), 0 0 30px rgba(79, 140, 255, 0.18);
      transition: bottom 160ms ease, opacity 160ms ease;
      opacity: 0;
      pointer-events: none;
    }

    body.pudding-os-mode.pudding-dock-visible .pudding-dock,
    .pudding-dock:hover {
      bottom: 22px;
      opacity: 1;
      pointer-events: auto;
    }

    .pudding-dock button {
      border: none;
      border-radius: 12px;
      padding: 10px 12px;
      background: linear-gradient(145deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.02));
      color: #eaf2ff;
      cursor: pointer;
      min-width: 76px;
      display: grid;
      grid-template-rows: auto auto;
      gap: 4px;
      align-items: center;
      justify-items: center;
      font-weight: 600;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.06);
      transition: transform 120ms ease, box-shadow 120ms ease;
    }

    .pudding-dock button .icon {
      font-size: 18px;
    }

    .pudding-dock button:hover {
      transform: translateY(-2px);
      box-shadow: inset 0 0 0 1px rgba(110, 231, 183, 0.28), 0 10px 24px rgba(0, 0, 0, 0.22);
      background: linear-gradient(145deg, rgba(79, 140, 255, 0.18), rgba(110, 231, 183, 0.14));
    }

    .pudding-dock button.active {
      box-shadow: inset 0 0 0 1px rgba(79, 140, 255, 0.36), 0 10px 22px rgba(79, 140, 255, 0.25);
      background: linear-gradient(145deg, rgba(79, 140, 255, 0.22), rgba(110, 231, 183, 0.16));
    }

    .logo {
      cursor: pointer;
    }

    .tab {
      padding: 3px 7px;
      border: 1px solid #223047;
      background: #0e1420;
      border-radius: 7px;
      cursor: pointer;
      user-select: none;
      font-size: 10.5px;
      line-height: 1.1
    }

    .tab.active {
      border-color: var(--brand);
      box-shadow: 0 0 0 1px rgba(79, 140, 255, .2) inset;
      color: #fff
    }

    .actions {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap
    }

    .topbar .btn {
      padding: 4px 8px;
      border-radius: 7px;
      font-size: 11px;
      min-height: 0
    }

    .btn {
      padding: 6px 10px;
      border: 1px solid #2a384d;
      background: #0f1726;
      border-radius: 9px;
      color: #e6eaf0;
      cursor: pointer;
      font-size: 12px
    }

    .btn.primary {
      background: linear-gradient(180deg, #2a63ff, #2148c7);
      border-color: #3158f0
    }

    .btn.ghost {
      background: transparent;
      border-color: #253144
    }

    .btn.small {
      padding: 6px 10px;
      font-size: 12px
    }

    .btn.danger {
      border-color: #4a2530;
      background: #23131a
    }

    button:focus,
    button:focus-visible,
    .btn:focus,
    .btn:focus-visible,
    .mini-menu:focus,
    .mini-menu:focus-visible {
      outline: none;
      box-shadow: none;
    }

    .btn:hover {
      filter: brightness(1.05)
    }

    .layout {
      max-width: none;
      width: min(98vw, 1800px);
      margin: 16px auto;
      display: grid;
      grid-template-columns: 260px 1fr;
      gap: 14px;
      padding: 0 14px;
      min-height: 0;
    }

    .layout.settings-full {
      max-width: none;
      width: min(98vw, 1800px);
      grid-template-columns: 1fr;
    }

    .layout #main.fullwidth {
      grid-column: 1 / -1;
      width: 100%;
    }

    body.reading:not(.mainmode2) .layout {
      margin: 0 auto;
      padding: 0 8px;
      height: calc(var(--vh-safe) - var(--topbar-h));
      min-height: calc(var(--vh-safe) - var(--topbar-h));
    }

    #viewerView {
      padding: 12px;
    }

    body.reading:not(.mainmode2) #viewerView {
      padding: 0;
    }

    .panel {
      background: var(--panel);
      border: 1px solid #1f2a3a;
      border-radius: 14px;
      box-shadow: 0 8px 30px rgba(0, 0, 0, .2)
    }

    .side {
      padding: 12px
    }

    .side h3 {
      margin: 4px 0 10px;
      font-size: 13px;
      color: #b7c0cd
    }

    .input,
    select,
    textarea {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #263449;
      background: #0d1420;
      color: #e6eaf0
    }

    #settingsView {
      max-height: calc(var(--vh-safe, 100vh) - var(--topbar-h, 48px) - 16px);
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      touch-action: auto;
    }

    textarea {
      min-height: 72px;
      resize: vertical
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 9px;
      border: 1px solid #27354a;
      border-radius: 999px;
      background: var(--chip);
      color: #cbd5e1;
      font-size: 12px;
      margin: 4px 6px 0 0
    }

    .toggle {
      display: flex;
      gap: 6px;
      flex-wrap: wrap
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 12px;
      padding: 12px
    }

    .card {
      background: var(--card);
      border: 1px solid #1b2432;
      border-radius: 14px;
      overflow: hidden;
      display: flex;
      flex-direction: column
    }

    .thumb {
      aspect-ratio: 3/4;
      background: #0e1522;
      display: grid;
      place-items: center
    }

    .thumb img {
      max-width: 100%;
      max-height: 100%
    }

    .meta {
      padding: 10px
    }

    .title {
      font-weight: 600;
      margin: 0 0 4px
    }

    .muted {
      color: var(--muted);
      font-size: 12px
    }

    .row {
      display: flex;
      gap: 8px;
      align-items: center
    }

    .row.space {
      justify-content: space-between
    }

    .hidden {
      display: none !important
    }

    .viewer {
      position: relative;
      display: grid;
      grid-template-columns: 1fr var(--control-width, 340px);
      gap: 12px;
      height: calc(var(--vh-safe) - var(--topbar-h));
      max-height: calc(var(--vh-safe) - var(--topbar-h));
      min-height: 0;
      overflow: hidden
    }

    body.reading:not(.mainmode2) .viewer {
      height: calc(var(--vh-safe) - var(--topbar-h));
      max-height: calc(var(--vh-safe) - var(--topbar-h));
    }

    .stage-host {
      position: relative
    }

    #stageHost {
      position: relative
    }

    .stage {
      position: relative;
      background-color: var(--stage-base, #f6f7fb);
      background:
        radial-gradient(120% 95% at 50% 20%, var(--stage-bg1, #ffffff) 0%, var(--stage-bg2, #f6f7fb) 55%, var(--stage-bg3, #eef0f6) 100%),
        radial-gradient(85% 70% at 20% 25%, var(--stage-tint-soft, rgba(90, 98, 120, .12)) 0%, rgba(0, 0, 0, 0) 65%),
        radial-gradient(80% 65% at 80% 22%, var(--stage-tint-glow, rgba(120, 128, 150, .10)) 0%, rgba(0, 0, 0, 0) 70%),
        linear-gradient(180deg, rgba(255, 255, 255, .6) 0%, rgba(240, 242, 248, .35) 42%, rgba(228, 231, 238, .25) 72%, rgba(235, 238, 244, .6) 100%),
        radial-gradient(160% 140% at 50% -10%, var(--stage-tint-line, rgba(140, 150, 170, .14)) 0%, rgba(0, 0, 0, 0) 70%);
      border: 1px solid var(--stage-border, #dfe4ee);
      border-radius: 14px;
      overflow: hidden;
      touch-action: none;
      cursor: grab;
      box-shadow:
        inset 0 0 32px rgba(0, 0, 0, .035),
        0 10px 32px rgba(0, 0, 0, .05);
    }

    .stage-host,
    #stageHost {
      background-color: var(--stage-base, #f6f7fb);
      background: radial-gradient(120% 120% at 50% 15%, var(--stage-bg1, #ffffff) 0%, var(--stage-host1, #f4f5f9) 60%, var(--stage-host2, #e9ecf2) 100%);
    }

    .pie-menu {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 140;
      --pie-size: 360px;
      --pie-dial-size: 268px;
      --pie-accent: #38bdf8;
      --pie-accent-soft: rgba(56, 189, 248, 0.2);
      --pie-warn: #f59e0b;
      --pie-danger: #fb7185;
      --pie-progress: 0deg;
      --dial-rot: 0deg;
    }

    .pie-menu.active {
      pointer-events: none;
    }

    .pie-menu .pie-shell {
      position: absolute;
      left: var(--pie-x, 50%);
      top: var(--pie-y, 50%);
      width: var(--pie-size);
      height: var(--pie-size);
      transform: translate(-50%, -50%) scale(0.95);
      opacity: 0;
      transition: opacity 180ms ease, transform 220ms cubic-bezier(0.22, 0.61, 0.36, 1);
      display: grid;
      place-items: center;
      border-radius: 50%;
      isolation: isolate;
      pointer-events: none;
    }

    .pie-menu.active .pie-shell {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
      pointer-events: auto;
    }

    .pie-shell::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: 50%;
      background:
        radial-gradient(65% 65% at 50% 38%, rgba(255, 255, 255, 0.2), rgba(15, 23, 42, 0.75) 60%, rgba(9, 12, 24, 0.94) 100%),
        conic-gradient(from 120deg, rgba(255, 255, 255, 0.12), rgba(56, 189, 248, 0.16), rgba(255, 255, 255, 0.08));
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow:
        0 24px 60px rgba(0, 0, 0, 0.45),
        inset 0 0 26px rgba(255, 255, 255, 0.08);
      filter: drop-shadow(0 8px 30px rgba(56, 189, 248, 0.2));
      z-index: 0;
    }

    .pie-shell::after {
      content: "";
      position: absolute;
      inset: 14%;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: inset 0 0 24px rgba(255, 255, 255, 0.08);
      z-index: 0;
    }

    .pie-shell.mode-run {
      --pie-accent: #34d399;
      --pie-accent-soft: rgba(52, 211, 153, 0.2);
    }

    .pie-shell.mode-run.warn {
      --pie-accent: #f59e0b;
      --pie-accent-soft: rgba(245, 158, 11, 0.2);
    }

    .pie-shell.mode-run.danger,
    .pie-shell.overrun {
      --pie-accent: #fb7185;
      --pie-accent-soft: rgba(251, 113, 133, 0.22);
    }

    .pie-shell .pie-close {
      position: absolute;
      top: 18px;
      right: 18px;
      width: 34px;
      height: 34px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(15, 23, 42, 0.8);
      color: #e2e8f0;
      font-size: 18px;
      cursor: pointer;
      z-index: 3;
      transition: transform 150ms ease, background 150ms ease, box-shadow 150ms ease;
      display: grid;
      place-items: center;
    }

    .pie-shell .pie-close:hover {
      transform: scale(1.06);
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
      background: rgba(30, 41, 59, 0.9);
    }

    .pie-shell .pie-dial {
      position: relative;
      width: var(--pie-dial-size);
      height: var(--pie-dial-size);
      border-radius: 50%;
      display: grid;
      place-items: center;
      z-index: 2;
      touch-action: none;
      user-select: none;
    }

    .pie-shell .pie-dial-ring {
      position: absolute;
      inset: 14px;
      border-radius: 50%;
      background:
        conic-gradient(from -90deg,
          var(--pie-accent) 0deg,
          var(--pie-accent) var(--pie-progress),
          rgba(255, 255, 255, 0.08) var(--pie-progress),
          rgba(255, 255, 255, 0.06) 360deg);
      box-shadow:
        0 0 18px rgba(56, 189, 248, 0.35),
        inset 0 0 18px rgba(0, 0, 0, 0.35);
      transition: background 200ms ease, box-shadow 200ms ease;
    }

    .pie-shell .pie-dial-ring::after {
      content: "";
      position: absolute;
      inset: 14px;
      border-radius: 50%;
      background: radial-gradient(circle at 50% 30%, rgba(255, 255, 255, 0.18), rgba(15, 23, 42, 0.92) 70%);
      box-shadow: inset 0 0 24px rgba(255, 255, 255, 0.08);
    }

    .pie-shell .pie-dial-ticks {
      position: absolute;
      inset: 0;
      border-radius: 50%;
      transform: rotate(var(--dial-rot));
      transition: transform 160ms cubic-bezier(0.2, 0.9, 0.2, 1.1);
    }

    .pie-shell .pie-dial-mark {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: rotate(var(--angle)) translateY(calc(var(--pie-dial-size) * -0.44)) rotate(calc(var(--angle) * -1));
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 0.08em;
      color: rgba(226, 232, 240, 0.75);
      text-transform: uppercase;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
      user-select: none;
      pointer-events: none;
    }

    .pie-shell .pie-dial-indicator {
      position: absolute;
      top: 6px;
      left: 50%;
      width: 3px;
      height: 24px;
      border-radius: 999px;
      transform: translateX(-50%);
      background: linear-gradient(180deg, #ffffff, rgba(255, 255, 255, 0.12));
      box-shadow: 0 0 12px rgba(255, 255, 255, 0.5);
      z-index: 2;
    }

    .pie-shell .pie-dial-indicator::after {
      content: "";
      position: absolute;
      top: 18px;
      left: 50%;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      transform: translateX(-50%);
      background: var(--pie-accent);
      box-shadow: 0 0 12px var(--pie-accent);
    }

    .pie-shell .pie-dial-center {
      position: relative;
      z-index: 3;
      display: grid;
      gap: 6px;
      place-items: center;
      text-align: center;
      padding: 8px 10px;
    }

    .pie-shell .pie-mode-label {
      font-size: 10px;
      letter-spacing: 0.22em;
      color: rgba(148, 163, 184, 0.85);
      text-transform: uppercase;
    }

    .pie-shell .pie-time {
      font-size: 34px;
      font-weight: 800;
      color: #f8fafc;
      font-variant-numeric: tabular-nums;
      font-family: var(--viewer-clock-font, 'SFMono-Regular', 'Menlo', 'Consolas', monospace);
      text-shadow: 0 6px 18px rgba(0, 0, 0, 0.45);
    }

    .pie-shell .pie-sub {
      font-size: 12px;
      color: rgba(226, 232, 240, 0.75);
    }

    .pie-shell .pie-primary {
      margin-top: 4px;
      padding: 8px 18px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: linear-gradient(135deg, rgba(56, 189, 248, 0.9), rgba(59, 130, 246, 0.9));
      color: #f8fafc;
      font-size: 13px;
      font-weight: 700;
      cursor: pointer;
      transition: transform 140ms ease, box-shadow 140ms ease, filter 140ms ease;
      box-shadow: 0 12px 24px rgba(56, 189, 248, 0.28);
    }

    .pie-shell .pie-primary:hover {
      transform: translateY(-1px) scale(1.03);
      filter: brightness(1.05);
    }

    .pie-shell .pie-actions {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 3;
    }

    .pie-shell .pie-action {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 68px;
      height: 68px;
      transform: translate(-50%, -50%) translate(var(--act-x, 0px), var(--act-y, 0px));
      border-radius: 50%;
      background: rgba(15, 23, 42, 0.85);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: #f1f5f9;
      font-size: 12px;
      font-weight: 700;
      letter-spacing: 0.02em;
      display: grid;
      place-items: center;
      text-align: center;
      cursor: pointer;
      pointer-events: auto;
      transition: transform 140ms ease, box-shadow 140ms ease, background 140ms ease;
      box-shadow: 0 12px 26px rgba(0, 0, 0, 0.35);
    }

    .pie-shell .pie-action:hover {
      transform: translate(-50%, -50%) translate(var(--act-x, 0px), var(--act-y, 0px)) scale(1.05);
      background: rgba(30, 41, 59, 0.92);
    }

    .pie-shell .pie-action:disabled,
    .pie-shell .pie-action.disabled {
      opacity: 0.45;
      cursor: not-allowed;
      transform: translate(-50%, -50%) translate(var(--act-x, 0px), var(--act-y, 0px));
      box-shadow: none;
      background: rgba(15, 23, 42, 0.6);
    }

    .pie-shell .pie-action:active {
      transform: translate(-50%, -50%) translate(var(--act-x, 0px), var(--act-y, 0px)) scale(0.96);
    }

    .pie-shell .pie-action.primary {
      background: linear-gradient(135deg, rgba(56, 189, 248, 0.95), rgba(59, 130, 246, 0.95));
      border-color: rgba(255, 255, 255, 0.2);
      box-shadow: 0 14px 28px rgba(56, 189, 248, 0.3);
    }

    .pie-shell .pie-action.danger {
      background: linear-gradient(135deg, rgba(251, 113, 133, 0.9), rgba(244, 63, 94, 0.95));
      border-color: rgba(255, 255, 255, 0.2);
    }

    .pie-shell .pie-hint {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 11px;
      color: rgba(148, 163, 184, 0.8);
      letter-spacing: 0.08em;
      z-index: 2;
      text-align: center;
      white-space: nowrap;
      user-select: none;
    }

    @media (max-width: 560px) {
      .pie-menu {
        --pie-size: 300px;
        --pie-dial-size: 220px;
      }

      .pie-shell .pie-action {
        width: 58px;
        height: 58px;
        font-size: 11px;
      }

      .pie-shell .pie-time {
        font-size: 30px;
      }
    }

    .stage.pan-disabled {
      cursor: auto
    }

    .stage-inner {
      position: relative;
      min-height: 100%;
      display: grid;
      place-items: center
    }

    .stage img {
      display: block;
      max-width: 100%;
      height: auto;
      transition: none;
      will-change: transform;
    }

    .page-layer {
      position: relative;
      display: inline-block;
      contain: layout paint;
      will-change: transform;
    }

    .page-layer img {
      display: block;
    }

    /* Double-buffering for flicker-free page turns */
    .page-buffer {
      display: block;
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      /* GPU acceleration hints for smoother rendering */
      will-change: opacity, contents;
      contain: layout paint;
    }

    .page-buffer.back {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      opacity: 1;
      /* Render as soon as visible for faster swap */
      content-visibility: auto;
    }

    .page-buffer.front {
      position: relative;
      z-index: 2;
      /* Always render immediately */
      content-visibility: visible;
    }

    .draw-layer {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      touch-action: none;
      z-index: 5;
      will-change: transform;
    }

    .draw-layer.active {
      pointer-events: auto;
      cursor: crosshair;
    }

    .stage.draw-mode {
      cursor: crosshair;
    }

    .stage.is-panning {
      cursor: grabbing
    }

    body.selecting .stage {
      cursor: crosshair
    }

    /* アニメレイヤーも非半切時は縦基準で揃える */
    .viewer #stageHost:not(.slice-view) .page-turn img,
    .viewer #stageHost:not(.slice-view) .page-reveal img,
    .viewer #stageHost:not(.slice-view) .page-anim img,
    .viewer #stageHost:not(.slice-view) .drag-turn-layer img {
      height: 100%;
      width: auto;
      max-height: 100%;
      max-width: 100%;
      object-fit: contain;
    }

    .stage-buttons {
      position: absolute;
      top: 4px;
      display: flex;
      gap: 4px;
      z-index: 14;
      align-items: center
    }

    .draw-toolbar {
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      gap: 6px;
      z-index: 20;
      pointer-events: none;
    }

    .draw-toolbar.hidden {
      display: none;
    }

    .draw-toolbar .mini-menu {
      pointer-events: auto;
      min-width: 42px;
      justify-content: center;
      text-align: center;
    }

    .draw-toolbar .mini-menu .label {
      display: none;
    }

    .draw-toolbar .mini-menu .icon {
      font-size: 14px;
      line-height: 1;
    }

    .draw-settings-panel {
      position: absolute;
      left: 58px;
      top: 50%;
      transform: translateY(-50%);
      z-index: 24;
      background: rgba(10, 14, 22, 0.92);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      padding: 12px;
      width: 260px;
      max-height: 70vh;
      overflow-y: auto;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      display: none;
      backdrop-filter: blur(8px);
    }

    .draw-settings-panel.open {
      display: block;
    }

    .draw-settings-panel h4 {
      margin: 0 0 8px;
      font-size: 13px;
      letter-spacing: 0.1px;
    }

    .draw-settings-panel .row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
    }

    .draw-settings-panel label {
      display: inline-flex;
      gap: 6px;
      align-items: center;
      font-size: 12px;
      color: var(--muted);
      min-width: 80px;
    }

    .draw-settings-panel input[type="range"] {
      flex: 1;
    }

    .draw-settings-panel .color-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 6px;
    }

    .draw-settings-panel .color-swatch {
      width: 28px;
      height: 20px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      cursor: pointer;
    }

    .draw-settings-panel .layer-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-height: 120px;
      overflow-y: auto;
      padding: 6px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.03);
    }

    .draw-settings-panel .layer-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px;
      border-radius: 8px;
      cursor: pointer;
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid transparent;
    }

    .draw-settings-panel .layer-item.active {
      border-color: rgba(79, 140, 255, 0.4);
      background: rgba(79, 140, 255, 0.08);
    }

    .draw-settings-panel .layer-actions {
      display: flex;
      gap: 6px;
      margin-top: 8px;
    }

    .text-color-slots {
      display: flex;
      gap: 6px;
    }

    .text-color-slot {
      width: 34px;
      height: 26px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      cursor: pointer;
      position: relative;
      background: #111;
    }

    .text-color-slot.active {
      outline: 2px solid rgba(79, 140, 255, 0.6);
      outline-offset: 1px;
    }

    .selection-actions {
      position: absolute;
      top: -32px;
      right: 0;
      display: flex;
      gap: 6px;
      pointer-events: auto;
    }

    .selection-actions .mini-menu {
      padding: 4px 8px;
    }

    .draw-size-preview {
      position: fixed;
      width: 0;
      height: 0;
      border: 2px solid rgba(0, 0, 0, 0.9);
      border-radius: 999px;
      pointer-events: none;
      transform: translate(-50%, -50%);
      z-index: 999;
      display: none;
      background: rgba(0, 0, 0, 0.28);
    }

    .miss-panel {
      position: absolute;
      left: 8px;
      top: 50%;
      transform: translateY(-50%);
      z-index: 24;
      background: transparent;
      border: none;
      border-radius: 0;
      padding: 0;
      width: 56px;
      max-height: 70vh;
      overflow-y: auto;
      box-shadow: none;
      display: none;
      backdrop-filter: none;
    }

    .miss-panel.open {
      display: flex;
      flex-direction: column;
      gap: 6px;
      align-items: center;
    }

    .miss-panel h4 {
      display: none;
    }

    .miss-palette {
      display: flex;
      flex-direction: column;
      gap: 6px;
      align-items: center;
      margin: 0;
      padding: 0;
      touch-action: none;
    }

    .miss-chip {
      width: 36px;
      height: 36px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.22);
      background: var(--miss-color, #ef4444);
      color: #fff;
      font-weight: 700;
      font-size: 12px;
      display: grid;
      place-items: center;
      cursor: grab;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
      transition: transform 0.15s ease, box-shadow 0.15s ease;
      touch-action: none;
      user-select: none;
    }

    .miss-chip:active {
      cursor: grabbing;
      transform: scale(0.96);
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
    }

    .miss-panel .miss-field {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin: 0;
    }

    .miss-panel .miss-field label {
      font-size: 10px;
      color: var(--muted);
    }

    .miss-panel .miss-field .input,
    .miss-panel .miss-field textarea {
      font-size: 11px;
      padding: 4px 6px;
      font-family: var(--miss-font) !important;
    }

    .miss-panel .miss-hint {
      font-size: 9px;
      color: var(--muted);
      margin: 0;
      text-align: center;
      line-height: 1.2;
    }

    .miss-layer {
      position: absolute;
      inset: 0;
      z-index: 6;
      pointer-events: none;
    }

    .miss-marker {
      position: absolute;
      width: 30px;
      height: 30px;
      border-radius: 999px;
      background: var(--miss-color, #ef4444);
      color: #fff;
      font-weight: 700;
      font-size: 14px;
      display: grid;
      place-items: center;
      padding: 0;
      min-width: 0;
      min-height: 0;
      box-sizing: border-box;
      line-height: 1;
      text-align: center;
      appearance: none;
      -webkit-appearance: none;
      transform: translate(-50%, -50%);
      border: 2px solid rgba(255, 255, 255, 0.5);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.28);
      transition: transform 0.12s ease, box-shadow 0.12s ease;
      will-change: transform;
      pointer-events: auto;
      cursor: pointer;
      z-index: 1;
    }

    .miss-marker.danger {
      border-color: rgba(248, 113, 113, 0.9);
      box-shadow: 0 6px 16px rgba(248, 113, 113, 0.25), 0 0 0 2px rgba(248, 113, 113, 0.2);
    }

    #missLayer .miss-marker:hover {
      transform: translate(-50%, -50%) scale(1.06);
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.32);
    }

    #missLayer .miss-marker:active {
      transform: translate(-50%, -50%) scale(0.98);
    }

    .miss-marker.moving {
      outline: 2px dashed rgba(255, 255, 255, 0.8);
      outline-offset: 2px;
      cursor: grab;
    }

    .miss-marker .miss-count {
      position: absolute;
      right: -3px;
      top: -3px;
      min-width: 16px;
      height: 16px;
      padding: 0 4px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.75);
      color: #fff;
      font-size: 9px;
      font-weight: 700;
      display: grid;
      place-items: center;
      border: 1px solid rgba(255, 255, 255, 0.6);
    }

    .miss-marker .miss-count.negative {
      background: rgba(248, 113, 113, 0.9);
      border-color: rgba(248, 113, 113, 0.95);
      color: #fff;
    }

    .miss-marker.pulse {
      animation: missPulse 0.9s ease;
    }

    .miss-marker.pulse-strong {
      animation: missPulseStrong 1.4s ease-in-out 0s 2;
    }

    .miss-marker.message-glow {
      border-color: rgba(191, 219, 254, 0.95);
      box-shadow:
        0 6px 20px rgba(0, 0, 0, 0.45),
        0 0 0 4px rgba(30, 64, 175, 0.95),
        0 0 0 7px rgba(59, 130, 246, 0.7),
        0 0 24px rgba(96, 165, 250, 0.9),
        0 0 48px rgba(59, 130, 246, 0.7);
      z-index: 2;
      transform: translate(-50%, -50%) scale(1.08);
    }

    .miss-marker.message-glow::before {
      content: '';
      position: absolute;
      inset: -6px;
      border-radius: 999px;
      background: linear-gradient(135deg, rgba(30, 64, 175, 0.6), rgba(59, 130, 246, 0.5));
      z-index: -1;
      pointer-events: none;
    }

    .miss-marker.message-glow::after {
      content: '';
      position: absolute;
      inset: -16px;
      border-radius: 999px;
      border: 4px solid rgba(30, 64, 175, 0.85);
      box-shadow:
        0 0 0 2px rgba(0, 0, 0, 0.5),
        0 0 24px rgba(96, 165, 250, 0.95),
        0 0 60px rgba(59, 130, 246, 0.8);
      opacity: 1;
      pointer-events: none;
      animation: missMessageGlow 1.6s ease-in-out infinite;
    }

    @keyframes missPulse {
      0% {
        transform: translate(-50%, -50%) scale(1);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.28);
      }

      50% {
        transform: translate(-50%, -50%) scale(1.18);
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.35);
      }

      100% {
        transform: translate(-50%, -50%) scale(1);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.28);
      }
    }

    @keyframes missPulseStrong {
      0% {
        transform: translate(-50%, -50%) scale(1);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.28), 0 0 0 0 rgba(255, 255, 255, 0);
      }

      50% {
        transform: translate(-50%, -50%) scale(1.28);
        box-shadow: 0 14px 30px rgba(0, 0, 0, 0.45), 0 0 0 18px rgba(96, 165, 250, 0.45);
      }

      100% {
        transform: translate(-50%, -50%) scale(1);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.28), 0 0 0 0 rgba(255, 255, 255, 0);
      }
    }

    @keyframes missMessageGlow {
      0% {
        transform: scale(0.88);
        opacity: 0.7;
        box-shadow: 0 0 16px rgba(96, 165, 250, 0.55), 0 0 32px rgba(59, 130, 246, 0.45);
      }

      50% {
        transform: scale(1.16);
        opacity: 1;
        box-shadow: 0 0 28px rgba(96, 165, 250, 0.95), 0 0 60px rgba(59, 130, 246, 0.8);
      }

      100% {
        transform: scale(0.88);
        opacity: 0.7;
        box-shadow: 0 0 16px rgba(96, 165, 250, 0.55), 0 0 32px rgba(59, 130, 246, 0.45);
      }
    }

    .miss-focus-wave {
      position: absolute;
      width: 200px;
      height: 200px;
      border-radius: 999px;
      border: 2px solid rgba(96, 165, 250, 0.7);
      box-shadow: 0 0 24px rgba(96, 165, 250, 0.35);
      transform: translate(-50%, -50%) scale(2.4);
      opacity: 0;
      pointer-events: none;
      animation: missFocusWave 0.9s ease-out forwards;
      z-index: 0;
    }

    @keyframes missFocusWave {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(2.6);
      }

      25% {
        opacity: 0.9;
      }

      100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.85);
      }
    }

    /* Ripple find effect (Ctrl+missSpawn) */
    .miss-ripple-find {
      position: fixed;
      border-radius: 999px;
      border: 3px solid rgba(59, 130, 246, 0.9);
      box-shadow:
        0 0 0 2px rgba(30, 64, 175, 0.8),
        0 0 30px rgba(59, 130, 246, 0.6),
        0 0 60px rgba(96, 165, 250, 0.4);
      transform: translate(-50%, -50%) scale(0);
      opacity: 0;
      pointer-events: none;
      z-index: 9998;
      animation: missRippleFind 0.8s ease-out forwards;
    }

    @keyframes missRippleFind {
      0% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(0.1);
      }

      50% {
        opacity: 0.9;
      }

      100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(3);
      }
    }

    .miss-drag-ghost {
      position: fixed;
      width: 28px;
      height: 28px;
      border-radius: 999px;
      background: var(--miss-color, #ef4444);
      color: #fff;
      display: grid;
      place-items: center;
      font-weight: 700;
      font-size: 12px;
      box-shadow: 0 6px 14px rgba(0, 0, 0, 0.28);
      pointer-events: none;
      z-index: 9999;
      transform: translate(-50%, -50%);
    }

    .miss-pie-menu {
      position: absolute;
      pointer-events: none;
      z-index: 150;
      transform: translate(-50%, -50%);
      --miss-pie-radius: 78px;
      --miss-pie-size: 44px;
    }

    #missSpawnMenu {
      --miss-pie-radius: 78px;
      --miss-pie-size: 44px;
    }

    .miss-pie-menu.hidden {
      display: none;
    }

    .miss-pie-ring {
      position: relative;
      width: 0;
      height: 0;
    }

    .miss-pie-menu .miss-pie-btn {
      position: absolute;
      left: 0;
      top: 0;
      width: var(--miss-pie-size);
      height: var(--miss-pie-size);
      border-radius: 999px;
      background: rgba(18, 24, 36, 0.95);
      color: #fff;
      border: 1px solid rgba(255, 255, 255, 0.12);
      font-size: 11px;
      display: grid;
      place-items: center;
      box-sizing: border-box;
      padding: 0;
      line-height: 1;
      pointer-events: auto;
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.35);
      transform: translate(-50%, -50%) rotate(var(--angle)) translate(var(--miss-pie-radius)) rotate(calc(var(--angle) * -1)) scale(1);
      transition: transform 0.18s ease, background 0.18s ease, box-shadow 0.18s ease;
    }

    #missPieMenu .miss-pie-btn:hover {
      background: rgba(30, 42, 62, 0.98);
      transform: translate(-50%, -50%) rotate(var(--angle)) translate(var(--miss-pie-radius)) rotate(calc(var(--angle) * -1)) scale(1.08);
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.4);
    }

    #missSpawnMenu .miss-spawn-btn {
      background: var(--miss-color, #ef4444);
      color: #fff;
      font-weight: 700;
      font-size: 13px;
      border: 1px solid rgba(255, 255, 255, 0.38);
      box-shadow: 0 6px 14px rgba(0, 0, 0, 0.28);
    }

    #missSpawnMenu .miss-spawn-btn:hover {
      background: var(--miss-color, #ef4444);
      transform: translate(-50%, -50%) rotate(var(--angle)) translate(var(--miss-pie-radius)) rotate(calc(var(--angle) * -1)) scale(1.1);
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.35);
    }

    #missSpawnMenu .miss-spawn-lock {
      position: absolute;
      left: 0;
      top: 0;
      width: 56px;
      height: 56px;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }

    #missSpawnMenu .miss-spawn-lock .lock-ring {
      position: absolute;
      inset: 0;
      border: 2px solid rgba(96, 165, 250, 0.9);
      border-radius: 999px;
      box-shadow: 0 0 12px rgba(96, 165, 250, 0.45);
      animation: missLockPulse 1.6s ease-in-out infinite;
    }

    #missSpawnMenu .miss-spawn-lock .lock-ring.ring-2 {
      inset: 9px;
      border-color: rgba(147, 197, 253, 0.7);
      box-shadow: 0 0 10px rgba(147, 197, 253, 0.35);
      animation: missLockPulse 1.6s ease-in-out infinite 0.2s;
    }

    #missSpawnMenu .miss-spawn-lock .lock-cross {
      position: absolute;
      left: 50%;
      top: 50%;
      background: rgba(147, 197, 253, 0.9);
      box-shadow: 0 0 8px rgba(96, 165, 250, 0.5);
    }

    #missSpawnMenu .miss-spawn-lock .lock-cross.cross-x {
      width: 34px;
      height: 2px;
      transform: translate(-50%, -50%);
    }

    #missSpawnMenu .miss-spawn-lock .lock-cross.cross-y {
      width: 2px;
      height: 34px;
      transform: translate(-50%, -50%);
    }

    #missSpawnMenu .miss-spawn-lock .lock-dot {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: rgba(191, 219, 254, 0.95);
      transform: translate(-50%, -50%);
      box-shadow: 0 0 10px rgba(96, 165, 250, 0.8);
      animation: missLockDot 1.2s ease-in-out infinite;
    }

    @keyframes missLockPulse {
      0% {
        transform: scale(0.96);
        opacity: 0.75;
      }

      50% {
        transform: scale(1.06);
        opacity: 1;
      }

      100% {
        transform: scale(0.96);
        opacity: 0.75;
      }
    }

    @keyframes missLockDot {

      0%,
      100% {
        opacity: 0.6;
        transform: translate(-50%, -50%) scale(0.9);
      }

      50% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.2);
      }
    }

    #missPieMenu .miss-pie-split {
      position: absolute;
      left: 0;
      top: 0;
      width: var(--miss-pie-size);
      height: var(--miss-pie-size);
      transform: translate(-50%, -50%) rotate(var(--angle)) translate(var(--miss-pie-radius)) rotate(calc(var(--angle) * -1));
      display: flex;
      flex-direction: column;
      pointer-events: auto;
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.35);
      border-radius: 999px;
      overflow: hidden;
    }

    #missPieMenu .miss-pie-split-btn {
      flex: 1;
      background: rgba(18, 24, 36, 0.95);
      color: #fff;
      border: 1px solid rgba(255, 255, 255, 0.12);
      font-size: 10px;
      padding: 0;
      line-height: 1;
      display: grid;
      place-items: center;
      cursor: pointer;
      transition: background 0.18s ease;
    }

    #missPieMenu .miss-pie-split-btn.down {
      border-top: none;
    }

    #missPieMenu .miss-pie-split-btn:hover {
      background: rgba(30, 42, 62, 0.98);
    }

    .miss-pie-center {
      position: absolute;
      left: 0;
      top: 0;
      width: 52px;
      height: 52px;
      border-radius: 999px;
      transform: translate(-50%, -50%) scale(1);
      background: rgba(12, 16, 24, 0.92);
      border: 1px solid rgba(255, 255, 255, 0.12);
      color: #fff;
      font-weight: 700;
      font-size: 16px;
      display: grid;
      place-items: center;
      box-sizing: border-box;
      padding: 0;
      line-height: 1;
      pointer-events: auto;
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.35);
      transition: transform 0.18s ease, background 0.18s ease, box-shadow 0.18s ease;
    }

    .miss-pie-center:hover {
      background: rgba(22, 30, 46, 0.96);
      transform: translate(-50%, -50%) scale(1.06);
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);
    }

    .miss-type-picker {
      position: absolute;
      display: none;
      gap: 6px;
      padding: 8px;
      background: rgba(10, 14, 22, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      z-index: 151;
      flex-wrap: wrap;
      max-width: 220px;
    }

    .miss-type-picker.open {
      display: flex;
    }

    .miss-type-picker .miss-chip {
      width: 40px;
      height: 40px;
      font-size: 12px;
    }

    .miss-edit-popover {
      position: absolute;
      display: none;
      z-index: 152;
      min-width: 180px;
      max-width: 240px;
      padding: 8px;
      border-radius: 10px;
      background: rgba(12, 16, 24, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.12);
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.35);
      transform: translate(-50%, -50%);
    }

    .miss-edit-popover::after {
      content: '';
      position: absolute;
      left: -6px;
      top: 50%;
      transform: translateY(-50%);
      border-width: 6px 6px 6px 0;
      border-style: solid;
      border-color: transparent rgba(12, 16, 24, 0.9) transparent transparent;
    }

    .miss-edit-popover.open {
      display: block;
    }

    .miss-edit-popover label {
      font-size: 10px;
      color: var(--muted);
    }

    .miss-edit-popover .input {
      font-size: 11px;
      padding: 4px 6px;
    }

    .miss-edit-actions {
      display: flex;
      justify-content: space-between;
      gap: 6px;
      margin-top: 6px;
    }

    .miss-message-box {
      position: absolute;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      width: min(880px, 92%);
      min-height: 140px;
      max-height: min(52%, 340px);
      padding: 18px 20px 24px;
      border-radius: 10px;
      border: 3px solid #4f8cff;
      background: rgba(0, 0, 10, 0.78);
      color: #fff;
      z-index: 149;
      pointer-events: auto;
      font-family: "DotGothic16", "MS Gothic", ui-monospace, monospace;
      box-shadow: 0 0 18px rgba(79, 140, 255, 0.6), 0 18px 40px rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(4px);
      resize: both;
      overflow: auto;
    }

    .miss-message-box.hidden {
      display: none;
    }

    .miss-message-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }

    .miss-message-title {
      display: inline-flex;
      align-items: center;
      padding: 4px 12px;
      background: #4f8cff;
      color: #000;
      font-weight: 700;
      font-size: 14px;
      border-radius: 4px;
      box-shadow: 0 0 10px rgba(79, 140, 255, 0.45);
    }

    .miss-message-actions {
      display: flex;
      gap: 6px;
    }

    .miss-message-actions .mini-menu,
    .miss-message-actions .mini-menu.ghost {
      background: rgba(0, 0, 0, 0.35);
      border: 1px solid rgba(79, 140, 255, 0.4);
      color: #fff;
      font-size: 11px;
      padding: 4px 10px;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
    }

    .miss-message-actions .mini-menu:hover {
      background: rgba(79, 140, 255, 0.2);
    }

    .miss-message-body {
      font-size: 20px;
      line-height: 1.6;
      white-space: pre-wrap;
      min-height: 78px;
      outline: none;
      cursor: text;
      user-select: text;
    }

    .draw-selection-box {
      position: absolute;
      border: 2px solid #ff3b3b;
      box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.65), 0 0 18px rgba(255, 59, 59, 0.7), inset 0 0 0 1px rgba(255, 255, 255, 0.35);
      background: linear-gradient(135deg, rgba(255, 59, 59, 0.2), rgba(255, 255, 255, 0.08));
      pointer-events: auto;
      z-index: 10;
      display: none;
      border-radius: 4px;
    }

    .draw-select-overlay {
      position: absolute;
      left: 0;
      top: 0;
      pointer-events: none;
      z-index: 11;
      mix-blend-mode: normal;
      filter: drop-shadow(0 0 10px rgba(0, 0, 0, 0.35)) drop-shadow(0 0 12px rgba(255, 64, 64, 0.45));
      display: none;
    }

    .page-progress-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 6;
      display: none;
    }

    .page-progress-overlay.visible {
      display: block;
    }

    .page-progress-fill {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 0%;
      background: rgba(96, 165, 250, 0.18);
      border: 1px solid rgba(96, 165, 250, 0.22);
      border-left: none;
      border-right: none;
      box-shadow: 0 8px 18px rgba(37, 99, 235, 0.12);
      transition: height .12s ease, background .12s ease, border-color .12s ease, box-shadow .12s ease;
      mix-blend-mode: multiply;
    }

    .page-progress-fill.charging {
      background: rgba(74, 222, 128, 0.2);
      border-color: rgba(74, 222, 128, 0.25);
      box-shadow: 0 10px 22px rgba(34, 197, 94, 0.18);
    }

    .page-progress-effect {
      position: absolute;
      inset: -8px;
      pointer-events: none;
      background: radial-gradient(circle at 50% 30%, rgba(74, 222, 128, 0.28), transparent 55%), radial-gradient(circle at 30% 70%, rgba(59, 130, 246, 0.22), transparent 60%);
      opacity: 0;
    }

    .page-progress-effect.run {
      animation: progressBurst 0.9s ease-out forwards;
    }

    @keyframes progressBurst {
      0% {
        opacity: 0.95;
        transform: scale(1);
      }

      40% {
        opacity: 1;
        transform: scale(1.02);
      }

      100% {
        opacity: 0;
        transform: scale(1.15);
      }
    }

    .stamp-preview {
      position: fixed;
      pointer-events: none;
      z-index: 998;
      transform: translate(-50%, -50%);
      display: none;
      filter: drop-shadow(0 6px 10px rgba(0, 0, 0, 0.35));
    }

    .stage-buttons.right {
      right: 10px
    }

    .stage-buttons.left {
      left: 10px
    }

    body.viewer-controls-bottom .stage-buttons {
      top: auto;
      bottom: 10px
    }

    .mini-menu {
      background: rgba(10, 14, 22, .3);
      color: #e5e9f5;
      border: 1px solid rgba(255, 255, 255, .08);
      border-radius: 999px;
      padding: 2px 6px;
      font-size: 10.5px;
      cursor: pointer;
      user-select: none;
      transition: background .05s ease, border-color .05s ease, opacity .05s ease;
      box-shadow: none;
    }

    .mini-menu:hover {
      background: rgba(10, 14, 22, .45);
      border-color: rgba(255, 255, 255, .12);
      opacity: 1;
      box-shadow: none;
    }

    button:focus-visible,
    .btn:focus-visible,
    .mini-menu:focus-visible,
    select:focus-visible,
    input:focus-visible {
      outline: none;
      box-shadow: none;
    }

    .draw-text-overlay {
      position: fixed;
      z-index: 1100;
      transform: translate(-50%, -50%);
      pointer-events: auto;
    }

    .draw-text-overlay input,
    .draw-text-overlay textarea {
      min-width: 200px;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid #1f2a3c;
      background: rgba(13, 20, 32, 0.95);
      color: #ffffff;
      font-size: 16px;
      resize: none;
      min-height: 0;
      height: auto;
      line-height: 1.25;
      overflow: hidden;
    }

    .mini-menu.active {
      background: rgba(79, 140, 255, .18);
      color: #fff;
      border-color: rgba(79, 140, 255, .35);
      box-shadow: none;
      opacity: 1;
    }

    .mini-menu.ghost {
      background: rgba(255, 255, 255, .06);
      border-color: rgba(255, 255, 255, .16);
      color: #e8edf7;
    }

    .mini-menu.draw-toggle {
      padding: 2px 6px;
      min-width: 28px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
    }

    .mini-menu.draw-toggle .draw-icon {
      position: relative;
      width: 12px;
      height: 12px;
      display: inline-block;
      transform: rotate(-15deg);
    }

    .mini-menu.draw-toggle .draw-icon::before {
      content: '';
      position: absolute;
      inset: 2px 3px 1px 0;
      background: linear-gradient(135deg, #9ca3af 0%, #4b5563 40%, #111827 100%);
      border-radius: 5px;
      box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.35);
    }

    .mini-menu.draw-toggle .draw-icon::after {
      content: '';
      position: absolute;
      right: -2px;
      bottom: -1px;
      width: 8px;
      height: 6px;
      background: #d1d5db;
      border-radius: 4px;
      box-shadow:
        inset 0 0 0 1px rgba(0, 0, 0, 0.35),
        -2px -3px 0 0 rgba(255, 255, 255, 0.5);
      transform: rotate(12deg);
    }

    /* 非半切時はステージ高さを固定し、画像を縦基準のcontainに */
    .viewer #stageHost:not(.slice-view),
    .viewer #stageHost:not(.slice-view) .stage,
    .viewer #stageHost:not(.slice-view) .stage-inner,
    .viewer #stageHost:not(.slice-view) .dual,
    .viewer #stageHost:not(.slice-view) .pane {
      height: 100%
    }

    .viewer #stageHost:not(.slice-view) .stage {
      display: grid
    }

    .viewer #stageHost:not(.slice-view) .stage-inner {
      align-items: stretch;
      justify-items: stretch
    }

    .stage img,
    .pane img,
    .page-turn img,
    .page-reveal img,
    .drag-turn-layer img {
      filter: var(--page-filter, none);
      transition: filter 180ms ease;
      image-rendering: -webkit-optimize-contrast;
      image-rendering: crisp-edges;
    }

    .viewer #stageHost:not(.slice-view) #pageImg,
    .viewer #stageHost:not(.slice-view) .pane img {
      height: 100%;
      width: auto;
      max-height: 100%;
      max-width: 100%;
      object-fit: contain;
    }

    #stageHost.slice-view {
      max-width: none;
      width: 100%;
      margin: 0 auto;
      padding: 0 2px;
      height: calc(var(--vh-safe) - var(--topbar-h));
    }

    #stageHost.slice-view .stage,
    #stageHost.slice-view .dual {
      height: 100%;
      max-height: none;
      min-height: 0;
      overflow: hidden;
    }

    #stageHost.slice-view .stage-inner {
      align-items: start;
      align-content: start;
      justify-items: center;
      min-height: 100%;
    }

    #stageHost.slice-view .stage img,
    #stageHost.slice-view .pane img {
      width: 100%;
      max-width: none;
      height: auto;
      max-height: 100%;
    }

    .compare-window.slice-view .compare-stage {
      align-items: flex-start;
    }

    .compare-window.slice-view .compare-stage img {
      width: 100%;
      max-width: none;
      height: auto;
      max-height: none;
      object-fit: contain;
    }

    body.mainmode2 #stageHost.slice-view {
      width: 100%;
      max-width: 100vw;
      margin: 0 auto;
      padding: 0;
      height: var(--vh-safe);
    }

    body.mainmode2 #stageHost.slice-view .stage,
    body.mainmode2 #stageHost.slice-view .dual {
      height: 100%;
      max-height: none;
    }

    body.mainmode2 #stageHost.slice-view .stage-inner {
      align-items: start;
      align-content: start;
      justify-items: center;
    }

    body.mainmode2 #stageHost:not(.slice-view),
    body.mainmode2 #stageHost:not(.slice-view) .stage,
    body.mainmode2 #stageHost:not(.slice-view) .stage-inner,
    body.mainmode2 #stageHost:not(.slice-view) .dual,
    body.mainmode2 #stageHost:not(.slice-view) .pane {
      height: var(--vh-safe);
      max-height: var(--vh-safe);
    }

    body.mainmode2 #stageHost:not(.slice-view) #pageImg,
    body.mainmode2 #stageHost:not(.slice-view) .pane img {
      height: 100%;
      width: auto;
      max-height: 100%;
      object-fit: contain;
    }

    .interaction-hint {
      position: absolute;
      left: 16px;
      top: 16px;
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(15, 23, 39, .7);
      border: 1px solid rgba(255, 255, 255, .1);
      font-size: 12px;
      z-index: 6;
      transition: opacity .2s ease, transform .2s ease;
      display: none !important
    }

    .interaction-hint.hidden {
      opacity: 0;
      pointer-events: none;
      transform: translateY(-6px)
    }

    .stage-arrows {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      pointer-events: none;
      padding: 90px 10px 20px;
      z-index: 8
    }

    body.viewer-controls-bottom .stage-arrows {
      align-items: flex-end;
      padding: 20px 10px 140px;
      /* 下部コントロールに埋もれないよう余白を広めに確保 */
    }

    /* 半切り＋下寄せ時は画面基準で固定配置（長いページでも隠れないように） */
    body.viewer-controls-bottom #stageHost.slice-view .stage-arrows {
      position: fixed;
      inset: 0;
      align-items: flex-end;
      justify-content: space-between;
      padding: 0 12px 140px;
      pointer-events: none;
      z-index: 90;
    }

    .stage-arrow {
      pointer-events: auto;
      background: rgba(18, 24, 36, .38);
      backdrop-filter: blur(14px);
      border: 1px solid rgba(255, 255, 255, .2);
      color: #f0f4ff;
      width: 22px;
      height: 82px;
      border-radius: 14px;
      display: grid;
      place-items: center;
      font-size: 18px;
      cursor: pointer;
      transition: background .15s, transform .15s, box-shadow .15s, border-color .15s, opacity .15s;
      box-shadow: 0 10px 28px rgba(0, 0, 0, .28), inset 0 1px 0 rgba(255, 255, 255, .2);
      opacity: 0.8;
      -webkit-touch-callout: none;
      user-select: none;
    }

    .stage-arrow:hover {
      background: rgba(34, 46, 66, .52);
      border-color: rgba(255, 255, 255, .32);
      transform: translateY(-2px);
      box-shadow: 0 12px 30px rgba(0, 0, 0, .38), inset 0 1px 0 rgba(255, 255, 255, .26);
      opacity: 1;
    }

    .stage-arrow:focus,
    .stage-arrow:focus-visible,
    .pane-arrow:focus,
    .pane-arrow:focus-visible,
    #prevBtn:focus,
    #prevBtn:focus-visible,
    #nextBtn:focus,
    #nextBtn:focus-visible {
      outline: none;
      box-shadow: none;
    }

    .pane-arrows {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      padding: 90px 10px 18px;
      pointer-events: none;
      z-index: 6
    }

    .pane-arrow {
      pointer-events: auto;
      background: rgba(18, 24, 36, .38);
      backdrop-filter: blur(14px);
      border: 1px solid rgba(255, 255, 255, .2);
      color: #f0f4ff;
      width: 20px;
      height: 68px;
      border-radius: 12px;
      display: grid;
      place-items: center;
      font-size: 16px;
      cursor: pointer;
      transition: background .15s, transform .15s, box-shadow .15s, border-color .15s, opacity .15s;
      box-shadow: 0 8px 22px rgba(0, 0, 0, .28), inset 0 1px 0 rgba(255, 255, 255, .2);
      opacity: 0.82;
      -webkit-touch-callout: none;
      user-select: none;
    }

    .pane-arrow:hover {
      background: rgba(34, 46, 66, .52);
      border-color: rgba(255, 255, 255, .32);
      transform: translateY(-2px);
      box-shadow: 0 11px 26px rgba(0, 0, 0, .35), inset 0 1px 0 rgba(255, 255, 255, .25);
      opacity: 1;
    }

    .control {
      background: #0f1522;
      border: 1px solid #1c2636;
      border-radius: 14px;
      padding: 10px;
      height: 100%;
      display: flex;
      flex-direction: column
    }

    .viewer .control {
      min-height: 0;
      max-height: 100%;
      overflow: auto;
    }

    .viewer>* {
      min-height: 0;
    }

    body.reading:not(.mainmode2) .control {
      overflow: auto;
    }

    .control h3 {
      margin: 6px 0 8px
    }

    .memo-panel {
      margin-bottom: 10px
    }

    .memo-body {
      margin-top: 6px
    }

    .memo-body.hidden {
      display: none
    }

    .list {
      padding: 10px;
      max-height: 40vh;
      overflow: auto;
      border: 1px dashed #253146;
      border-radius: 10px
    }

    .list .item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px;
      border-radius: 8px;
      cursor: pointer
    }

    .list .item.dragging {
      opacity: .4;
      scale: .98;
    }

    .list .item.active {
      background: #182132;
      outline: 1px solid #2a3a55
    }

    .list .item.dragover {
      outline: 2px dashed var(--brand)
    }

    .list .item.placeholder {
      padding: 0;
      margin: 4px 0;
      height: 0;
      border: none;
      pointer-events: none;
    }

    .list .item.placeholder .placeholder-line {
      height: 6px;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(125, 211, 252, .9), rgba(147, 197, 253, .9));
      box-shadow: 0 4px 16px rgba(125, 211, 252, .35);
      transform: translateY(-3px);
      animation: pulseGlow 900ms ease-in-out infinite alternate;
    }

    @keyframes pulseGlow {
      from {
        opacity: .7;
        filter: drop-shadow(0 0 6px rgba(125, 211, 252, .45));
      }

      to {
        opacity: 1;
        filter: drop-shadow(0 0 10px rgba(147, 197, 253, .6));
      }
    }

    .split {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px
    }

    .pill {
      padding: 4px 8px;
      border-radius: 999px;
      background: #0f1624;
      border: 1px solid #223149
    }

    .star {
      color: #ffd166
    }

    .weak {
      color: #ff6b6b
    }

    .done {
      color: #22c55e
    }

    .toast {
      position: fixed;
      right: 16px;
      bottom: 16px;
      background: #0f1726;
      border: 1px solid #2a394f;
      border-radius: 12px;
      padding: 10px 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, .3);
      min-width: 200px
    }

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(4, 7, 12, .6);
      backdrop-filter: blur(6px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 100
    }

    .modal.window {
      background: transparent;
      backdrop-filter: none;
      align-items: flex-start;
      justify-content: flex-end;
      pointer-events: none;
      padding: 16px;
      gap: 0
    }

    .modal.window .box {
      position: fixed;
      top: 76px;
      right: 16px;
      margin: 0;
      pointer-events: auto;
      width: min(480px, 92vw);
      padding: 14px;
      border-radius: 12px
    }

    .modal.window.compact .box {
      width: min(380px, 90vw)
    }

    .modal .box {
      width: min(640px, 90vw);
      background: #0f1522;
      border: 1px solid #2a394f;
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 14px 44px rgba(0, 0, 0, .45)
    }

    .modal .box h3 {
      margin: 0 0 8px
    }

    .modal .box .box-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin: -2px 0 10px
    }

    .modal .box .box-head .mini-menu {
      padding: 4px 8px
    }

    .snip-preview {
      background: #0a0f18;
      border: 1px solid #1f2a3a;
      border-radius: 10px;
      overflow: hidden;
      padding: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 8px
    }

    .snip-preview {
      padding: 4px;
      border-radius: 10px
    }

    .snip-preview img {
      max-width: 100%;
      max-height: 220px;
      display: block;
      border-radius: 8px
    }

    .snip-meta {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 6px
    }

    .chip-check {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      border: 1px solid #2a3a55;
      border-radius: 999px;
      background: rgba(13, 20, 32, .7);
      cursor: pointer;
      font-size: 12px
    }

    .chip-check input {
      margin: 0
    }

    .answer-hint {
      font-size: 11px;
      color: var(--muted);
      margin-top: 4px
    }

    .tight-row {
      display: flex;
      gap: 6px;
      align-items: center;
      flex-wrap: wrap
    }

    .answer-target {
      outline: 2px dashed rgba(255, 209, 102, .8);
      outline-offset: 2px;
      box-shadow: 0 0 0 1px rgba(255, 209, 102, .35) inset
    }

    canvas.crop {
      position: absolute;
      border: 2px solid rgba(255, 86, 110, .95);
      border-radius: 14px;
      pointer-events: none;
      z-index: 6;
      background: linear-gradient(135deg, rgba(255, 86, 110, .18), rgba(255, 132, 124, .12));
      background-size: 220% 220%;
      box-shadow:
        0 0 0 1px rgba(255, 86, 110, .55),
        0 12px 36px rgba(255, 86, 110, .25),
        inset 0 0 0 1px rgba(255, 255, 255, .18);
      animation: cropPulse 1.8s ease-in-out infinite;
    }

    @keyframes cropPulse {
      0% {
        background-position: 0% 50%;
        box-shadow: 0 0 0 1px rgba(255, 86, 110, .55), 0 12px 36px rgba(255, 86, 110, .25), inset 0 0 0 1px rgba(255, 255, 255, .18);
      }

      50% {
        background-position: 100% 50%;
        box-shadow: 0 0 0 1px rgba(255, 120, 120, .7), 0 16px 40px rgba(255, 120, 120, .32), inset 0 0 0 1px rgba(255, 255, 255, .24);
      }

      100% {
        background-position: 0% 50%;
        box-shadow: 0 0 0 1px rgba(255, 86, 110, .55), 0 12px 36px rgba(255, 86, 110, .25), inset 0 0 0 1px rgba(255, 255, 255, .18);
      }
    }

    .toolbar {
      display: flex;
      gap: 6px;
      flex-wrap: wrap
    }

    .shelf {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
      gap: 16px;
      padding: 12px
    }

    .empty {
      padding: 24px;
      text-align: center;
      color: #9fb0c9
    }

    .viewer {
      position: relative
    }

    .book-menu {
      position: absolute;
      top: 16px;
      left: 16px;
      width: 220px;
      max-height: 72vh;
      overflow: auto;
      padding: 10px;
      border-radius: 14px;
      background: rgba(9, 14, 24, .92);
      border: 1px solid #1f2a3a;
      box-shadow: 0 18px 40px rgba(0, 0, 0, .55);
      backdrop-filter: blur(10px);
      display: none;
      z-index: 40
    }

    .book-menu.compact {
      width: 200px;
      padding: 8px;
      border-radius: 12px
    }

    .book-menu.compact .menu-actions {
      grid-template-columns: 1fr;
      gap: 4px
    }

    .book-menu.compact .menu-actions button {
      padding: 6px 8px;
      font-size: 11px
    }

    .book-menu.open {
      display: block
    }

    .book-menu .menu-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 13px;
      margin-bottom: 6px;
      cursor: grab
    }

    .book-menu.dragging .menu-header {
      cursor: grabbing
    }

    .book-menu .menu-header button {
      background: transparent;
      border: none;
      color: #93a4c5;
      font-size: 16px;
      cursor: pointer
    }

    .book-menu .menu-body {
      display: flex;
      flex-direction: column;
      gap: 8px
    }

    .book-menu .menu-actions {
      display: grid;
      grid-template-columns: repeat(2, minmax(80px, 1fr));
      gap: 6px
    }

    .book-menu .menu-actions button {
      width: 100%;
      padding: 6px 0;
      font-size: 12px
    }

    .book-menu .menu-actions button:disabled {
      opacity: .4;
      cursor: not-allowed
    }

    .book-menu .menu-actions .quick-field {
      grid-column: span 2;
      display: flex;
      gap: 6px;
      align-items: center
    }

    .book-menu .menu-actions .quick-field input {
      flex: 1;
      min-width: 0
    }

    .menu-actions .quick-slider {
      grid-column: span 2;
      padding: 4px 0
    }

    .menu-actions .quick-slider input {
      width: 100%
    }

    .linked-answer-bar {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      margin: 8px 0
    }

    .linked-answer-chips {
      display: flex;
      gap: 6px;
      flex-wrap: wrap
    }

    .answer-chip {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid #253146;
      background: rgba(13, 20, 32, .65);
      font-size: 12px
    }

    .answer-chip strong {
      max-width: 160px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap
    }

    .answer-chip button {
      background: transparent;
      border: none;
      color: #9fb0c9;
      font-size: 12px;
      cursor: pointer;
      padding: 0 4px;
      border-radius: 6px
    }

    .answer-chip button:hover {
      color: #fff;
      background: rgba(255, 255, 255, .12)
    }

    @media(max-width:600px) {
      .answer-chip strong {
        max-width: 120px
      }
    }

    .linked-answer-manage {
      display: flex;
      gap: 6px;
      align-items: center;
      margin: 6px 0 10px
    }

    .linked-answer-manage select {
      flex: 1
    }

    .linked-answer-manage button {
      flex: 0 0 auto
    }

    .memo-window {
      position: absolute;
      top: 160px;
      left: 16px;
      width: 220px;
      max-height: 60vh;
      padding: 10px;
      border-radius: 14px;
      background: rgba(9, 14, 24, .92);
      border: 1px solid #1f2a3a;
      box-shadow: 0 18px 40px rgba(0, 0, 0, .55);
      backdrop-filter: blur(10px);
      display: none;
      flex-direction: column;
      gap: 8px;
      z-index: 38
    }

    .memo-window.open {
      display: flex
    }

    .memo-window.dragging {
      cursor: grabbing
    }

    .memo-window textarea {
      min-height: 150px;
      resize: vertical;
      background: #0d1420;
      border: 1px solid #263449;
      border-radius: 10px;
      color: #e6eaf0;
      padding: 10px
    }

    .compare-window {
      position: absolute;
      top: 120px;
      right: 16px;
      width: 480px;
      min-width: 240px;
      min-height: 220px;
      max-width: 96vw;
      max-height: 92vh;
      padding: 4px;
      border-radius: 12px;
      background: rgba(8, 12, 20, .95);
      border: 1px solid #1f2a3a;
      box-shadow: 0 18px 40px rgba(0, 0, 0, .55);
      backdrop-filter: blur(10px);
      display: none;
      flex-direction: column;
      gap: 4px;
      z-index: 39;
      resize: both;
      overflow: hidden
    }

    .compare-window.open {
      display: flex;
      animation: comparePop .34s cubic-bezier(.24, .86, .32, 1.05);
    }

    .compare-window.minimized {
      display: none !important
    }

    .compare-window.transparent {
      opacity: 1;
      transition: opacity .15s ease;
      background: transparent;
      border: 1px solid rgba(255, 255, 255, .16);
      box-shadow: 0 18px 40px rgba(0, 0, 0, .3), inset 0 1px 0 rgba(255, 255, 255, .15);
      backdrop-filter: none;
    }

    .compare-window.transparent:hover {
      opacity: 1
    }

    .compare-window.transparent .compare-stage {
      background: transparent;
      border: 1px solid rgba(255, 255, 255, .12);
    }

    .compare-window.transparent .compare-body {
      background: transparent;
    }

    .compare-window.transparent .compare-controls {
      background: transparent;
    }

    .compare-window.transparent .compare-header {
      background: transparent;
      border-bottom: 1px solid rgba(255, 255, 255, .12);
      backdrop-filter: none;
    }

    .compare-window.transparent .compare-quick {
      background: transparent;
    }

    @keyframes comparePop {
      0% {
        opacity: 0;
        transform: translate3d(0, 14px, 0) scale(0.986);
        box-shadow: 0 10px 24px rgba(0, 0, 0, .28);
      }

      55% {
        opacity: 1;
        transform: translate3d(0, -2px, 0) scale(1.006);
        box-shadow: 0 16px 36px rgba(0, 0, 0, .40);
      }

      100% {
        opacity: 1;
        transform: translate3d(0, 0, 0) scale(1);
        box-shadow: 0 12px 30px rgba(0, 0, 0, .32);
      }
    }

    .compare-window.dragging {
      cursor: grabbing
    }

    .compare-window .compare-body {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-height: 0;
      position: relative
    }

    .compare-window .compare-header {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 0 4px;
      cursor: grab;
      user-select: none
    }

    .compare-window.dragging .compare-header {
      cursor: grabbing
    }

    .compare-window .compare-title {
      font-size: 12px;
      color: #cfd7eb;
      flex: 1;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis
    }

    .compare-window .compare-quick {
      display: flex;
      align-items: center;
      gap: 4px;
      flex-wrap: nowrap;
      justify-content: flex-end;
      white-space: nowrap;
      overflow-x: auto;
      padding: 2px 0
    }

    .compare-window .compare-quick::-webkit-scrollbar {
      display: none
    }

    .compare-window .compare-stage {
      background: #05070d;
      border: 1px solid #1b2432;
      border-radius: 10px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 240px;
      flex: 1;
      position: relative;
      cursor: grab;
      overflow: hidden;
      touch-action: none
    }

    .compare-window .compare-stage.grabbing {
      cursor: grabbing
    }

    .compare-window .compare-stage.pan-disabled {
      cursor: auto
    }

    .compare-window .compare-stage img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      border-radius: 0;
      display: block;
      transform-origin: center center;
      transition: transform .08s ease-out;
      pointer-events: none
    }

    .compare-window .compare-stage .stage-arrows.compare-arrows {
      padding: 0 8px;
      align-items: center;
      justify-content: space-between;
    }

    .compare-window .compare-stage .stage-arrows.compare-arrows .stage-arrow {
      width: 22px;
      height: 72px;
      font-size: 18px;
    }

    .compare-window .compare-placeholder {
      color: var(--muted);
      font-size: 12px;
      text-align: center
    }

    .compare-window:not(.has-book) .compare-stage img {
      display: none
    }

    .compare-window.has-book .compare-placeholder {
      display: none
    }

    .compare-window .mini-menu,
    .compare-window .btn.small {
      padding: 3px 8px;
      font-size: 10px;
      line-height: 1.1
    }

    .compare-window .compare-controls .btn.small,
    .compare-window .compare-controls .mini-menu {
      background: rgba(18, 24, 36, .3);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, .18);
      color: #f0f4ff;
      box-shadow: 0 10px 26px rgba(0, 0, 0, .2), inset 0 1px 0 rgba(255, 255, 255, .14);
      opacity: 0.8;
      transition: opacity .15s;
    }

    .compare-window .compare-controls .btn.small:hover,
    .compare-window .compare-controls .mini-menu:hover {
      background: rgba(34, 46, 66, .42);
      border-color: rgba(255, 255, 255, .26);
      opacity: 1;
    }

    .compare-window.transparent .compare-controls .btn.small,
    .compare-window.transparent .compare-controls .mini-menu {
      opacity: 0.6;
    }

    /* 解答ウィンドウ専用: 透明モードを鮮烈な赤で強調 */
    #boxAnswerWindow.transparent {
      background: linear-gradient(180deg, rgba(255, 24, 68, .42) 0%, rgba(255, 0, 48, .34) 45%, rgba(0, 0, 0, 0) 100%);
      border: 1px solid rgba(255, 56, 56, .9);
      box-shadow:
        0 18px 48px rgba(255, 24, 68, .45),
        0 0 24px rgba(255, 64, 64, .38),
        inset 0 1px 0 rgba(255, 180, 180, .9);
    }

    #boxAnswerWindow.transparent .compare-header {
      background: rgba(255, 0, 40, .25);
      border-bottom: 1px solid rgba(255, 90, 90, .9);
      box-shadow: inset 0 -1px 0 rgba(0, 0, 0, .25);
    }

    #boxAnswerWindow.transparent .compare-title {
      color: #ffe7eb;
    }

    #boxAnswerWindow.transparent .mini-menu {
      color: #ffe7eb;
    }

    #boxAnswerWindow.transparent .mini-menu:hover {
      background: rgba(255, 255, 255, .08);
    }

    #boxAnswerWindow.transparent .compare-stage {
      background: radial-gradient(120% 90% at 50% 35%, rgba(255, 0, 48, .16) 0%, rgba(255, 0, 32, .08) 42%, rgba(255, 0, 32, .02) 70%, transparent 100%);
      border: 1px solid rgba(255, 80, 80, .9);
      box-shadow: inset 0 0 28px rgba(255, 32, 64, .25);
    }

    .compare-window .input {
      padding: 4px 6px;
      font-size: 11px;
      background: rgba(0, 0, 0, .18);
      border-color: rgba(255, 255, 255, .12);
      color: #e6eaf0
    }

    .compare-window .compare-meta {
      display: none
    }

    .compare-page-badge {
      position: absolute;
      bottom: 10px;
      right: 10px;
      background: rgba(255, 255, 255, .9);
      color: #000;
      border-radius: 8px;
      padding: 2px 6px;
      font-size: 10px;
      border: 1px solid rgba(0, 0, 0, .14);
      box-shadow: 0 6px 16px rgba(0, 0, 0, .2);
      cursor: pointer;
      pointer-events: auto;
      user-select: none;
      min-width: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      line-height: 1.2
    }

    .compare-page-badge:focus {
      outline: 2px solid #5a7abf;
      outline-offset: 2px
    }

    .compare-page-badge input {
      width: 42px;
      border: 1px solid rgba(0, 0, 0, .18);
      border-radius: 7px;
      padding: 2px 4px;
      font-size: 11px;
      background: rgba(255, 255, 255, .92);
      color: #000;
      outline: none;
      line-height: 1.1;
      -moz-appearance: textfield
    }

    .compare-page-badge input::-webkit-inner-spin-button,
    .compare-page-badge input::-webkit-outer-spin-button {
      appearance: none;
      margin: 0
    }

    .memo-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 13px;
      cursor: grab
    }

    .memo-header button {
      background: transparent;
      border: none;
      color: #93a4c5;
      font-size: 16px;
      cursor: pointer
    }

    img {
      -webkit-user-drag: none;
      user-select: none
    }

    .stage,
    .stage * {
      -webkit-user-drag: none;
      user-select: none
    }

    /* box viewer: maximize stage usage in non-slice mode */
    .box-viewer .stage-host,
    .box-viewer #stageSingle,
    .box-viewer .stage-inner {
      height: 100%
    }

    .box-viewer #stageHost:not(.slice-view) .stage {
      display: grid
    }

    .box-viewer #stageHost:not(.slice-view) .stage-inner {
      align-items: stretch;
      justify-items: stretch
    }

    .box-viewer #stageHost:not(.slice-view) #pageImg {
      width: 100%;
      height: 100%;
      max-width: none;
      max-height: none;
      object-fit: contain;
    }

    .mainmode .side,
    .mainmode2 .side {
      display: none
    }

    .mainmode .layout,
    .mainmode2 .layout {
      grid-template-columns: 1fr
    }

    .mainmode .tabs {
      display: none
    }

    .mainmode2 .tabs {
      display: none
    }

    .mainmode2 #topbarRestore {
      display: grid
    }

    .mainmode #main,
    .mainmode2 #main {
      padding: 0
    }

    .reading:not(.mainmode2) #main {
      padding: 0;
      background: transparent;
      border: none;
      box-shadow: none;
    }

    .reading:not(.mainmode2) #readerLayout {
      gap: 10px;
    }

    .mainmode2 #viewerView {
      padding: 0;
    }

    .mainmode2.reading #readerLayout {
      padding: 0;
    }

    .mainmode2 .viewer {
      grid-template-columns: 1fr
    }

    .mainmode2 .control {
      display: none
    }

    .mainmode2 .topbar {
      display: none
    }

    .mainmode2 .layout {
      max-width: 100%;
      width: 100%;
      padding: 0;
      margin: 0 auto;
    }

    .mainmode2 .viewer {
      height: var(--vh-safe);
      max-height: var(--vh-safe);
    }

    body.reading {
      overflow: hidden;
    }

    body.reading .side {
      display: none
    }

    body.reading .layout {
      grid-template-columns: 1fr;
      max-width: 100%;
      width: 100%;
      padding: 0 8px
    }

    body.reading .viewer {
      grid-template-columns: 1fr var(--control-width, 340px);
    }

    body.reading.mainmode2 .viewer {
      grid-template-columns: 1fr;
    }

    .floatbar {
      position: absolute;
      left: 12px;
      right: 12px;
      bottom: 12px;
      display: flex;
      gap: 8px;
      justify-content: center;
      z-index: 20
    }

    .floatbar .btn {
      backdrop-filter: blur(6px);
      background: rgba(16, 24, 38, .35);
      border-color: #2a3a55;
      transition: background .15s, opacity .15s
    }

    .selecting .stage {
      touch-action: none
    }

    .stage-buttons .page-title {
      font-size: 12px;
      color: var(--muted);
      max-width: 220px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Viewer clock */
    .viewer-clock-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 32;
    }

    .viewer-clock-wrap {
      position: absolute;
      transition: transform 220ms ease, opacity 180ms ease;
      opacity: 0;
      --clock-pos-x: 0;
      --clock-pos-y: 0;
      --viewer-clock-font-size: 16px;
      --viewer-clock-text-scale: 1.3;
      --viewer-clock-min-width: 120px;
      --viewer-clock-padding: 6px 12px;
      transform: translate(calc(var(--clock-pos-x, 0) + var(--clock-off-x, 0)), calc(var(--clock-pos-y, 0) + var(--clock-off-y, -14px))) scale(0.98);
      pointer-events: auto;
      display: flex;
      flex-direction: column;
      gap: 6px;
      align-items: flex-end;
    }

    .viewer-clock-wrap.active {
      opacity: 1;
      transform: translate(var(--clock-pos-x, 0), var(--clock-pos-y, 0)) scale(1);
    }

    .viewer-clock-wrap.clock-hidden {
      opacity: 0 !important;
      transform: translate(var(--clock-off-x, 0), var(--clock-off-y, -14px)) scale(0.94) !important;
      pointer-events: none;
    }

    .viewer-clock-wrap.pos-top-right {
      top: 10px;
      right: 14px;
      --clock-off-x: 0;
      --clock-off-y: -14px;
      --clock-pos-x: 0;
      --clock-pos-y: 0;
    }

    .viewer-clock-wrap.pos-top-left {
      top: 10px;
      left: 14px;
      --clock-off-x: 0;
      --clock-off-y: -14px;
      --clock-pos-x: 0;
      --clock-pos-y: 0;
    }

    .viewer-clock-wrap.pos-bottom-right {
      bottom: 12px;
      right: 14px;
      --clock-off-x: 0;
      --clock-off-y: 18px;
      --clock-pos-x: 0;
      --clock-pos-y: 0;
    }

    .viewer-clock-wrap.pos-bottom-left {
      bottom: 12px;
      left: 14px;
      --clock-off-x: 0;
      --clock-off-y: 18px;
      --clock-pos-x: 0;
      --clock-pos-y: 0;
    }

    .viewer-clock-wrap.pos-top {
      top: 10px;
      left: 50%;
      --clock-off-x: -50%;
      --clock-off-y: -18px;
      --clock-pos-x: -50%;
      --clock-pos-y: 0;
    }

    .viewer-clock-wrap.pos-bottom {
      bottom: 10px;
      left: 50%;
      --clock-off-x: -50%;
      --clock-off-y: 20px;
      --clock-pos-x: -50%;
      --clock-pos-y: 0;
    }

    .viewer-clock-wrap.pos-left {
      top: 50%;
      left: 10px;
      --clock-off-x: -18px;
      --clock-off-y: -50%;
      --clock-pos-x: 0;
      --clock-pos-y: -50%;
    }

    .viewer-clock-wrap.pos-right {
      top: 50%;
      right: 10px;
      --clock-off-x: 18px;
      --clock-off-y: -50%;
      --clock-pos-x: 0;
      --clock-pos-y: -50%;
    }

    .viewer-clock-wrap.pos-top-left,
    .viewer-clock-wrap.pos-bottom-left,
    .viewer-clock-wrap.pos-left {
      align-items: flex-start;
    }

    .viewer-clock-wrap.pos-top,
    .viewer-clock-wrap.pos-bottom {
      align-items: center;
    }

    .viewer-clock {
      pointer-events: auto;
      min-width: var(--viewer-clock-min-width, 120px);
      padding: var(--viewer-clock-padding, 6px 12px);
      border-radius: 10px;
      border: 1px solid var(--viewer-clock-border, rgba(255, 255, 255, 0.08));
      color: var(--viewer-clock-text, #e2e8f0);
      font-variant-numeric: tabular-nums;
      font-feature-settings: "tnum";
      letter-spacing: 0.06em;
      text-align: center;
      font-family: var(--viewer-clock-font, 'SFMono-Regular', 'Menlo', 'Consolas', monospace);
      font-weight: 700;
      font-size: var(--viewer-clock-font-size, 16px);
      line-height: 1.1;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.16);
      user-select: none;
    }

    .viewer-clock-inline {
      position: relative;
      display: inline-flex;
      flex-direction: column;
      gap: 6px;
      align-items: center;
      inset: auto;
      transform: none !important;
      opacity: 1 !important;
      pointer-events: none;
      margin: 0 6px;
    }

    .viewer-clock-inline.clock-hidden {
      display: none !important;
    }

    .viewer-clock-inline .viewer-clock {
      pointer-events: auto;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.15);
    }

    .viewer-clock .clock-text {
      display: inline-block;
      padding: 2px 0;
      min-width: 96px;
      transform: scale(var(--viewer-clock-text-scale, 1));
      transform-origin: center;
    }

    .viewer-clock.viewer-timer {
      font-size: var(--viewer-clock-font-size, 16px);
      min-width: var(--viewer-clock-min-width, 120px);
      padding: var(--viewer-clock-padding, 6px 12px);
      opacity: 0.95;
      color: #0f172a;
      transition: border-color 180ms ease, color 180ms ease, transform 180ms ease;
    }

    .viewer-timer-stack {
      display: flex;
      flex-direction: column;
      gap: 6px;
      align-items: flex-end;
    }

    .viewer-clock.viewer-timer.viewer-timer-item {
      cursor: pointer;
      position: relative;
    }

    .viewer-clock.viewer-timer.viewer-timer-lesson:not(.vc-style-bare) {
      border-color: rgba(239, 68, 68, 0.65);
      box-shadow:
        0 8px 20px rgba(0, 0, 0, 0.18),
        0 0 0 1px rgba(239, 68, 68, 0.45),
        0 0 16px rgba(239, 68, 68, 0.35);
    }

    .viewer-clock.viewer-timer.strong {
      border-color: rgba(34, 197, 94, 0.45);
    }

    .viewer-clock.viewer-timer.warn {
      border-color: rgba(245, 158, 11, 0.55);
    }

    .viewer-clock.viewer-timer.danger {
      border-color: rgba(244, 63, 94, 0.6);
    }

    /* Clock designs */
    .vc-style-bare {
      background: transparent;
      color: #e2e8f0;
      border: none;
      box-shadow: none;
      padding: 0;
    }

    .vc-style-minimal {
      background: rgba(16, 24, 38, 0.78);
      color: #e2e8f0;
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .vc-style-glass {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.32), rgba(255, 255, 255, 0.12));
      color: #0f172a;
      border: 1px solid rgba(255, 255, 255, 0.4);
      backdrop-filter: blur(12px) saturate(140%);
      box-shadow:
        0 14px 30px rgba(15, 23, 42, 0.22),
        inset 0 0 0 1px rgba(255, 255, 255, 0.26),
        inset 0 1px 0 rgba(255, 255, 255, 0.4);
    }

    .vc-style-glass-clear {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0.02));
      color: #0b1224;
      border: 1px solid rgba(255, 255, 255, 0.42);
      backdrop-filter: blur(16px) saturate(160%);
      box-shadow:
        0 16px 32px rgba(15, 23, 42, 0.18),
        inset 0 0 0 1px rgba(255, 255, 255, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.36);
    }

    .vc-style-wood {
      background: linear-gradient(120deg, #5c3b22, #7b4a28 55%, #5c3b22 100%);
      color: #fef3c7;
      border: 1px solid rgba(255, 255, 255, 0.12);
      box-shadow:
        inset 0 0 0 1px rgba(0, 0, 0, 0.25),
        0 10px 24px rgba(44, 23, 8, 0.4);
    }

    .vc-style-neon {
      background: radial-gradient(circle at 10% 10%, rgba(83, 255, 209, 0.3), rgba(25, 16, 66, 0.6));
      color: #7cfff1;
      border: 1px solid rgba(124, 255, 241, 0.5);
      text-shadow: 0 0 10px rgba(124, 255, 241, 0.8);
      box-shadow:
        0 0 18px rgba(124, 255, 241, 0.45),
        inset 0 0 0 1px rgba(255, 255, 255, 0.06);
    }

    .vc-style-lcd {
      background: #0a0f14;
      color: #c5f36b;
      border: 1px solid rgba(181, 217, 92, 0.4);
      box-shadow:
        inset 0 1px 0 rgba(255, 255, 255, 0.05),
        inset 0 -1px 0 rgba(0, 0, 0, 0.4),
        0 10px 20px rgba(0, 0, 0, 0.25);
      letter-spacing: 0.08em;
    }

    .vc-style-ribbon {
      background: linear-gradient(135deg, #2563eb, #0ea5e9);
      color: #e0f2fe;
      border-radius: 12px 4px 12px 4px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      box-shadow:
        0 12px 24px rgba(37, 99, 235, 0.24),
        inset 0 0 0 1px rgba(255, 255, 255, 0.14);
    }

    .vc-style-planner {
      background: rgba(15, 23, 42, 0.16);
      color: #f8fafc;
      border: 1px dashed rgba(255, 255, 255, 0.35);
      backdrop-filter: blur(6px);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.12);
    }

    .vc-style-numberline {
      background: linear-gradient(180deg, rgba(15, 23, 42, 0.92), rgba(15, 23, 42, 0.82));
      color: #facc15;
      border: 1px solid rgba(250, 204, 21, 0.5);
      padding: 8px 12px;
      box-shadow:
        0 12px 22px rgba(0, 0, 0, 0.32),
        inset 0 0 0 1px rgba(255, 255, 255, 0.08);
    }

    .vc-style-numberline .clock-text {
      position: relative;
      display: inline-block;
      padding: 4px 0 10px;
    }

    .vc-style-numberline .clock-text::after {
      content: '';
      position: absolute;
      left: 8px;
      right: 8px;
      bottom: 2px;
      height: 2px;
      background: linear-gradient(90deg, transparent, #facc15, transparent);
      box-shadow: 0 0 8px rgba(250, 204, 21, 0.6);
    }

    /* Planner/numberline fly-in overlays */
    .fly-clock-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 40;
    }

    /* allow smooth custom-prop animation for bounce */
    @property --fly-bounce-x {
      syntax: '<length>';
      inherits: false;
      initial-value: 0px;
    }

    @property --fly-bounce-y {
      syntax: '<length>';
      inherits: false;
      initial-value: 0px;
    }

    .fly-clock {
      position: absolute;
      pointer-events: auto;
      transition:
        transform 360ms cubic-bezier(0.19, 0.7, 0.28, 1.1),
        --fly-bounce-x 260ms cubic-bezier(0.18, 0.8, 0.22, 1),
        --fly-bounce-y 260ms cubic-bezier(0.18, 0.8, 0.22, 1),
        opacity 240ms ease,
        filter 280ms ease;
      opacity: 0;
      --fly-in-x: 0px;
      --fly-in-y: -120%;
      --fly-show-x: 0px;
      --fly-show-y: 0px;
      --fly-drag-x: 0px;
      --fly-drag-y: 0px;
      --fly-anim-x: 0px;
      --fly-anim-y: 0px;
      --fly-bounce-x: 0px;
      --fly-bounce-y: 0px;
      transform: translate3d(calc(var(--fly-in-x) + var(--fly-drag-x) + var(--fly-bounce-x)), calc(var(--fly-in-y) + var(--fly-drag-y) + var(--fly-bounce-y)), 0) scale(0.9);
      display: grid;
      place-items: center;
      filter: drop-shadow(0 16px 28px rgba(0, 0, 0, 0.35));
      user-select: none;
    }

    .fly-clock.no-anim {
      transition: none !important;
      filter: none !important;
    }

    .fly-clock.active {
      opacity: 1;
      transform: translate3d(calc(var(--fly-show-x) + var(--fly-drag-x) + var(--fly-bounce-x)), calc(var(--fly-show-y) + var(--fly-drag-y) + var(--fly-bounce-y)), 0) scale(1);
      filter: drop-shadow(0 10px 20px rgba(0, 0, 0, 0.28));
    }

    .fly-clock.anim-enter {
      opacity: 0;
      transform: translate3d(calc(var(--fly-show-x) + var(--fly-drag-x) + var(--fly-anim-x) + var(--fly-bounce-x)), calc(var(--fly-show-y) + var(--fly-drag-y) + var(--fly-anim-y) + var(--fly-bounce-y)), 0) scale(0.82);
      filter: drop-shadow(0 18px 32px rgba(0, 0, 0, 0.32));
    }

    .fly-pos-top {
      top: 10px;
      left: 50%;
      --fly-in-x: -50%;
      --fly-in-y: -120%;
      --fly-show-x: -50%;
      --fly-show-y: 0%;
    }

    .fly-pos-bottom {
      bottom: 10px;
      left: 50%;
      --fly-in-x: -50%;
      --fly-in-y: 120%;
      --fly-show-x: -50%;
      --fly-show-y: 0%;
    }

    .fly-pos-left {
      top: 50%;
      left: 10px;
      --fly-in-x: -120%;
      --fly-in-y: -50%;
      --fly-show-x: 0%;
      --fly-show-y: -50%;
    }

    .fly-pos-right {
      top: 50%;
      right: 10px;
      --fly-in-x: 120%;
      --fly-in-y: -50%;
      --fly-show-x: 0%;
      --fly-show-y: -50%;
    }

    .fly-clock .fly-body {
      display: grid;
      place-items: center;
      user-select: none;
    }

    .fly-clock .clock-wrap {
      width: 220px;
      height: 220px;
      background: transparent;
      border-radius: 16px;
      backdrop-filter: none;
      box-shadow: none;
    }

    .fly-clock .clock-wrap svg {
      width: 100%;
      height: 100%;
      display: block;
    }

    .fly-numberline .nl-row {
      display: block;
      grid-template-columns: 1fr;
      margin: 10px 0 16px;
      padding: 0;
      animation: none;
    }

    .fly-numberline .nl-rail,
    .fly-numberline .nl-scale,
    .fly-numberline .nl-ticks {
      width: 100%;
      margin: 0;
    }

    .fly-clock .fly-numberline {
      width: 100%;
      padding: 10px 14px;
    }

    .fly-clock .fly-numberline .line {
      position: relative;
      height: 8px;
      background: linear-gradient(90deg, rgba(148, 163, 184, 0.4), rgba(226, 232, 240, 0.7), rgba(148, 163, 184, 0.4));
      border-radius: 999px;
      box-shadow: 0 0 10px rgba(56, 189, 248, 0.4), 0 0 20px rgba(255, 255, 255, 0.08);
      overflow: hidden;
    }

    .fly-clock .fly-numberline .indicator {
      position: absolute;
      top: -6px;
      width: 2px;
      height: 16px;
      background: #22d3ee;
      box-shadow: 0 0 12px rgba(34, 211, 238, 0.8), 0 0 2px rgba(255, 255, 255, 0.7);
      transform: translateX(-50%);
    }

    .fly-clock .fly-numberline .ticks {
      display: flex;
      justify-content: space-between;
      margin-top: 8px;
      font-size: 11px;
      color: #cbd5e1;
      opacity: 0.85;
      letter-spacing: 0.02em;
    }

    .fly-numberline-wrap {
      position: relative;
      width: var(--fly-nl-width, 480px);
      min-width: 260px;
      max-width: 1200px;
    }

    .fly-numberline-resize {
      position: absolute;
      right: -8px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 48px;
      cursor: ew-resize;
      background: radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.05));
      border-radius: 12px;
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.2);
      opacity: 0.4;
      transition: opacity 0.12s ease, transform 0.12s ease;
      pointer-events: auto;
    }

    .fly-numberline-resize:hover {
      opacity: 0.8;
      transform: translateY(-50%) scale(1.04);
    }

    .fly-analog {
      width: 200px;
      height: 200px;
    }

    .fly-analog .face {
      fill: rgba(15, 23, 42, 0.5);
      stroke: rgba(255, 255, 255, 0.16);
      stroke-width: 2;
      filter: drop-shadow(0 12px 20px rgba(0, 0, 0, 0.35));
    }

    .fly-analog .tick {
      stroke: rgba(255, 255, 255, 0.65);
      stroke-width: 2;
    }

    .fly-analog .hand-hour {
      stroke: #e2e8f0;
      stroke-width: 6;
      stroke-linecap: round;
    }

    .fly-analog .hand-min {
      stroke: #38bdf8;
      stroke-width: 4;
      stroke-linecap: round;
    }

    .fly-analog .hand-sec {
      stroke: #fbbf24;
      stroke-width: 2;
      stroke-linecap: round;
    }

    .fly-analog .center {
      fill: #e2e8f0;
      stroke: #0ea5e9;
      stroke-width: 2;
    }

    .fly-analog .glow {
      filter: drop-shadow(0 0 12px rgba(14, 165, 233, 0.6));
    }

    @keyframes vcWaterFlow {
      0% {
        background-position: 0% 50%;
      }

      50% {
        background-position: 100% 50%;
      }

      100% {
        background-position: 0% 50%;
      }
    }

    @keyframes vcWaterShine {
      0% {
        opacity: 0.4;
        transform: translateX(-20%);
      }

      50% {
        opacity: 0.8;
        transform: translateX(120%);
      }

      100% {
        opacity: 0.4;
        transform: translateX(-20%);
      }
    }

    .vc-style-water {
      position: relative;
      overflow: hidden;
      color: #e0f2fe;
      border-radius: 12px;
      padding: 8px 14px;
      border: 1px solid rgba(125, 211, 252, 0.6);
      background: linear-gradient(120deg, rgba(59, 130, 246, 0.65), rgba(14, 165, 233, 0.6), rgba(34, 211, 238, 0.6));
      background-size: 200% 200%;
      box-shadow:
        0 14px 24px rgba(14, 165, 233, 0.32),
        inset 0 0 0 1px rgba(255, 255, 255, 0.12);
      animation: vcWaterFlow 7s ease-in-out infinite;
    }

    .vc-style-water::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(ellipse at top, rgba(255, 255, 255, 0.28), transparent 55%);
      opacity: 0.7;
      pointer-events: none;
      animation: vcWaterShine 6s linear infinite;
    }

    .stage-buttons .page-badge {
      position: static;
      z-index: 14;
      background: rgba(255, 255, 255, .9);
      border: 1px solid rgba(0, 0, 0, .12);
      border-radius: 10px;
      padding: 2px 6px;
      font-size: 11px;
      letter-spacing: .02em;
      line-height: 1.2;
      margin-left: 4px;
      color: #000;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      min-width: 44px;
    }

    .stage-buttons .page-badge:focus {
      outline: 2px solid #5a7abf;
      outline-offset: 2px;
    }

    .stage-buttons .page-badge input {
      width: 48px;
      border: 1px solid rgba(0, 0, 0, .18);
      border-radius: 8px;
      padding: 2px 5px;
      font-size: 11px;
      background: rgba(255, 255, 255, .92);
      color: #000;
      outline: none;
    }

    .control-resizer {
      position: absolute;
      top: 0;
      bottom: 0;
      right: calc(var(--control-width, 340px) + 6px);
      width: 12px;
      margin-right: -6px;
      cursor: col-resize;
      z-index: 16;
      background: transparent
    }

    .statebar {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 8px
    }

    .statebar .toggle {
      gap: 6px
    }

    .tag {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid #2a3a55;
      background: #0f1624;
      font-size: 12px
    }

    .tag .x {
      cursor: pointer;
      opacity: .8
    }

    .thumbGrid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 10px
    }

    .thumbCell {
      border: 1px solid #253146;
      border-radius: 8px;
      padding: 4px;
      display: flex;
      flex-direction: column;
      gap: 4px
    }

    @media(max-width:1100px) {
      .layout {
        display: flex;
        flex-direction: column
      }

      .topbar-inner {
        flex-wrap: wrap;
        justify-content: flex-start
      }

      .actions {
        width: 100%
      }

      .actions .search {
        flex: 1;
        min-width: 200px
      }
    }

    @media(max-width:720px) {
      .viewer {
        grid-template-columns: 1fr
      }
    }

    .thumbCell img {
      width: 100%;
      height: auto;
      display: block
    }

    .thumbCell .small {
      font-size: 11px;
      color: #9fb0c9
    }

    .dual {
      position: relative;
      display: flex;
      gap: 10px;
      align-items: stretch;
      padding: 10px
    }

    .pane {
      position: relative;
      flex: 1;
      background: #0a0f18;
      border: 1px solid #1b2432;
      border-radius: 14px;
      overflow: hidden;
      display: grid;
      place-items: center;
      cursor: grab
    }

    .pane.is-panning {
      cursor: grabbing
    }

    .pane img {
      display: block;
      max-width: 100%;
      height: auto;
      transition: transform .08s ease-out;
      will-change: transform
    }

    .pane .pane-badge {
      position: absolute;
      top: 8px;
      right: 10px;
      background: rgba(16, 24, 38, .5);
      border: 1px solid #2a3a55;
      border-radius: 999px;
      padding: 3px 8px;
      font-size: 12px
    }

    .pane .pane-controls {
      display: none
    }

    .dual .pane canvas.crop {
      position: absolute
    }

    .pane.hidden-content img {
      opacity: 0;
      filter: blur(3px)
    }

    .pane.hidden-content::after {
      content: '右側は非表示';
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(8, 11, 22, .8);
      color: #e5e9f5;
      font-size: 14px;
      font-weight: 600;
      letter-spacing: .05em;
      border-radius: inherit
    }

    .pane-divider {
      position: absolute;
      top: 8px;
      bottom: 8px;
      width: 12px;
      margin-left: -6px;
      border-radius: 12px;
      background: rgba(255, 255, 255, .05);
      cursor: col-resize;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 13;
      transition: background .15s
    }

    .pane-divider::after {
      content: '';
      width: 2px;
      height: 40px;
      background: rgba(255, 255, 255, .5);
      border-radius: 1px
    }

    .pane-divider.active {
      background: rgba(79, 140, 255, .18)
    }


    /* Translucent inputs on overlay bars */
    .floatbar .input,
    .pane-controls .input {
      background: rgba(13, 20, 32, .35);
      border-color: #2a3a55;
      outline: none;
    }

    .floatbar .input::placeholder,
    .pane-controls .input::placeholder {
      color: #9fb0c9
    }

    .floatbar .input:focus,
    .pane-controls .input:focus {
      background: rgba(13, 20, 32, .6);
      border-color: #3a5aa0;
    }

    /* Hover brings a bit more opacity for better readability */
    .floatbar:hover .btn {
      background: rgba(16, 24, 38, .55);
    }

    .pane-controls:hover {
      background: rgba(16, 24, 38, .5);
    }

    /* Reset flash */
    .reset-anim {
      animation: resetFlash .55s cubic-bezier(.18, .72, .28, 1), resetScale .5s cubic-bezier(.2, .82, .3, 1);
    }

    @keyframes resetFlash {
      0% {
        box-shadow: 0 0 0 0 rgba(79, 140, 255, .0);
      }

      30% {
        box-shadow: 0 0 0 12px rgba(79, 140, 255, .25);
      }

      65% {
        box-shadow: 0 0 0 6px rgba(79, 140, 255, .12);
      }

      100% {
        box-shadow: 0 0 0 0 rgba(79, 140, 255, .0);
      }
    }

    @keyframes resetScale {
      0% {
        transform: scale(1.02);
      }

      45% {
        transform: scale(1.006);
      }

      100% {
        transform: scale(1);
      }
    }

    /* Page flip animation (slide) */
    .stage,
    .pane {
      perspective: 1400px;
      transform-style: preserve-3d;
    }

    .page-turn,
    .page-reveal {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
      overflow: hidden;
    }

    .page-turn {
      z-index: 7;
      filter: drop-shadow(0 16px 32px rgba(0, 0, 0, .42));
    }

    .page-turn img,
    .page-reveal img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      border-radius: 12px;
      backface-visibility: hidden;
      background: rgba(10, 15, 24, .9);
    }

    .page-turn::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(120deg, rgba(255, 255, 255, .18), rgba(0, 0, 0, 0) 50%, rgba(0, 0, 0, .3));
      mix-blend-mode: soft-light;
      opacity: 0;
      animation: pageTurnShade .45s ease;
    }

    .page-turn-next img {
      transform-origin: left center;
      animation: pageTurnNext .45s cubic-bezier(.3, .7, .2, 1);
    }

    .page-turn-prev img {
      transform-origin: right center;
      animation: pageTurnPrev .45s cubic-bezier(.3, .7, .2, 1);
    }

    @keyframes pageTurnNext {
      0% {
        transform: rotateY(0deg) translateX(0);
        opacity: 1;
        filter: brightness(1);
      }

      40% {
        filter: brightness(.95);
      }

      100% {
        transform: rotateY(-95deg) translateX(-12px);
        opacity: 0;
        filter: brightness(.82);
      }
    }

    @keyframes pageTurnPrev {
      0% {
        transform: rotateY(0deg) translateX(0);
        opacity: 1;
        filter: brightness(1);
      }

      40% {
        filter: brightness(.95);
      }

      100% {
        transform: rotateY(95deg) translateX(12px);
        opacity: 0;
        filter: brightness(.82);
      }
    }

    @keyframes pageTurnShade {
      0% {
        opacity: 0;
      }

      30% {
        opacity: 0.22;
      }

      100% {
        opacity: 0;
      }
    }

    .page-reveal {
      z-index: 6;
      opacity: 0;
    }

    .page-reveal-next img {
      transform-origin: left center;
      animation: pageRevealNext .42s cubic-bezier(.25, .72, .22, 1);
    }

    .page-reveal-prev img {
      transform-origin: right center;
      animation: pageRevealPrev .42s cubic-bezier(.25, .72, .22, 1);
    }

    /* 非半切時はアニメも縦基準のcontainに揃える（幅フィット化を防止） */
    .viewer #stageHost:not(.slice-view) .page-turn img,
    .viewer #stageHost:not(.slice-view) .page-reveal img,
    .viewer #stageHost:not(.slice-view) .page-anim img,
    .viewer #stageHost:not(.slice-view) .drag-turn-layer img {
      width: auto;
      height: 100%;
      max-height: 100%;
      max-width: 100%;
      object-fit: contain;
    }

    .viewer #stageHost:not(.slice-view) .page-turn,
    .viewer #stageHost:not(.slice-view) .page-reveal,
    .viewer #stageHost:not(.slice-view) .page-anim,
    .viewer #stageHost:not(.slice-view) .drag-turn-layer {
      align-items: stretch;
      justify-items: center;
    }

    .page-reveal.run {
      opacity: 1;
    }

    @keyframes pageRevealNext {
      0% {
        transform: translateX(32px) rotateY(10deg) scale(.98);
        opacity: 0;
      }

      100% {
        transform: translateX(0) rotateY(0deg) scale(1);
        opacity: 1;
      }
    }

    @keyframes pageRevealPrev {
      0% {
        transform: translateX(-32px) rotateY(-10deg) scale(.98);
        opacity: 0;
      }

      100% {
        transform: translateX(0) rotateY(0deg) scale(1);
        opacity: 1;
      }
    }

    .page-anim {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
      overflow: hidden;
      z-index: 7;
    }

    .page-anim img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      border-radius: 12px;
      background: rgba(10, 15, 24, .9);
      backface-visibility: hidden;
    }

    /* Drag-to-turn live preview */
    .drag-turn-layer {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
      overflow: hidden;
      z-index: 8;
    }

    .drag-turn-layer img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      border-radius: 12px;
      background: rgba(10, 15, 24, .9);
      box-shadow: 0 10px 28px rgba(0, 0, 0, .32);
      transition: none;
    }

    .drag-turn-layer.smooth img {
      transition: transform .24s cubic-bezier(.25, .72, .25, 1);
    }

    /* slide (afterimage抑制: 早めにフェードアウト) */
    .page-slide-out-next {
      animation: pageSlideOutNext .22s cubic-bezier(.3, .7, .2, 1);
    }

    .page-slide-out-prev {
      animation: pageSlideOutPrev .22s cubic-bezier(.3, .7, .2, 1);
    }

    .page-slide-in-next {
      animation: pageSlideInNext .28s cubic-bezier(.25, .85, .22, 1);
    }

    .page-slide-in-prev {
      animation: pageSlideInPrev .28s cubic-bezier(.25, .85, .22, 1);
    }

    @keyframes pageSlideOutNext {
      0% {
        transform: translateX(0);
        opacity: 1;
      }

      55% {
        opacity: 0;
      }

      100% {
        transform: translateX(-12%);
        opacity: 0;
      }
    }

    @keyframes pageSlideOutPrev {
      0% {
        transform: translateX(0);
        opacity: 1;
      }

      55% {
        opacity: 0;
      }

      100% {
        transform: translateX(12%);
        opacity: 0;
      }
    }

    @keyframes pageSlideInNext {
      0% {
        transform: translateX(18%);
        opacity: 0;
        filter: brightness(.95);
      }

      100% {
        transform: translateX(0);
        opacity: 1;
        filter: brightness(1);
      }
    }

    @keyframes pageSlideInPrev {
      0% {
        transform: translateX(-18%);
        opacity: 0;
        filter: brightness(.95);
      }

      100% {
        transform: translateX(0);
        opacity: 1;
        filter: brightness(1);
      }
    }

    /* glide (softだが早めフェード) */
    .page-glide-out-next {
      animation: pageGlideOutNext .3s cubic-bezier(.2, .75, .2, 1);
    }

    .page-glide-out-prev {
      animation: pageGlideOutPrev .3s cubic-bezier(.2, .75, .2, 1);
    }

    .page-glide-in-next {
      animation: pageGlideInNext .34s cubic-bezier(.16, .82, .16, 1);
    }

    .page-glide-in-prev {
      animation: pageGlideInPrev .34s cubic-bezier(.16, .82, .16, 1);
    }

    @keyframes pageGlideOutNext {
      0% {
        transform: translateX(0) scale(1);
        opacity: 1;
      }

      40% {
        opacity: 0;
      }

      100% {
        transform: translateX(-18%) scale(.99);
        opacity: 0;
      }
    }

    @keyframes pageGlideOutPrev {
      0% {
        transform: translateX(0) scale(1);
        opacity: 1;
      }

      40% {
        opacity: 0;
      }

      100% {
        transform: translateX(18%) scale(.99);
        opacity: 0;
      }
    }

    @keyframes pageGlideInNext {
      0% {
        transform: translateX(26%) scale(.985);
        opacity: 0;
      }

      100% {
        transform: translateX(0) scale(1);
        opacity: 1;
      }
    }

    @keyframes pageGlideInPrev {
      0% {
        transform: translateX(-26%) scale(.985);
        opacity: 0;
      }

      100% {
        transform: translateX(0) scale(1);
        opacity: 1;
      }
    }

    /* slide simple: 新ページのみをサッと入れる（残像なし） */
    .page-simple-in-next {
      animation: pageSimpleInNext .22s cubic-bezier(.25, .8, .25, 1);
    }

    .page-simple-in-prev {
      animation: pageSimpleInPrev .22s cubic-bezier(.25, .8, .25, 1);
    }

    @keyframes pageSimpleInNext {
      0% {
        transform: translateX(18%);
        opacity: 0.01;
      }

      100% {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes pageSimpleInPrev {
      0% {
        transform: translateX(-18%);
        opacity: 0.01;
      }

      100% {
        transform: translateX(0);
        opacity: 1;
      }
    }

    /* Performance friendly mode (viewerは除外) */
    .performance-mode body {
      background: #0b0e13 !important;
    }

    .performance-mode body::before,
    .performance-mode body::after {
      content: none !important;
      display: none !important;
    }

    /* プランナー/設定/リストなど限定でアニメ無効＆軽量化 */
    .performance-mode #plannerApp *,
    .performance-mode #plannerApp *::before,
    .performance-mode #plannerApp *::after,
    .performance-mode #settingsView *,
    .performance-mode #libraryView *,
    .performance-mode #boxesView *,
    .performance-mode #uploadView *,
    .performance-mode #sidebar *,
    .performance-mode .topbar,
    .performance-mode .topbar * {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0ms !important;
      transition-delay: 0ms !important;
      box-shadow: none !important;
      backdrop-filter: none !important;
    }

    .performance-mode .tabs::before,
    .performance-mode #plannerApp .tabs::before {
      display: none !important;
    }

    .performance-mode .logo {
      box-shadow: none !important;
    }

    .performance-mode #plannerApp main,
    .performance-mode .tab-content {
      animation: none !important;
    }

    .performance-mode .tabs,
    .performance-mode #plannerApp .tabs {
      backdrop-filter: none !important;
    }

    .performance-mode .hud-pill,
    .performance-mode .btn,
    .performance-mode button {
      box-shadow: none !important;
    }

    .performance-mode .notification {
      animation: none !important;
    }

    .performance-mode .drag-hint {
      display: none !important;
    }

    .performance-mode .timeline-container {
      border-color: #1f2a3a !important;
    }

    .performance-mode .timeline-container .timeline-scroll {
      scroll-behavior: auto !important;
    }

    /* ===== Thumbnail Grid Modal ===== */
    .thumb-grid-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(8px);
      z-index: 9999;
      display: flex;
      flex-direction: column;
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
      transition: opacity .25s ease, visibility .25s ease;
    }

    .thumb-grid-overlay.open {
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
    }

    .thumb-grid-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 24px;
      background: linear-gradient(135deg, #1a1f2e 0%, #0f1319 100%);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      flex-shrink: 0;
    }

    .thumb-grid-header h2 {
      margin: 0;
      font-size: 1.2rem;
      color: #e0e6ed;
    }

    .thumb-grid-toolbar {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .thumb-grid-filter {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .thumb-grid-filter select,
    .thumb-grid-filter input {
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 6px;
      color: #e0e6ed;
      padding: 6px 10px;
      font-size: 0.85rem;
    }

    .thumb-grid-close {
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: #e0e6ed;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      font-size: 1.3rem;
      cursor: pointer;
      transition: background .15s;
    }

    .thumb-grid-close:hover {
      background: rgba(255, 100, 100, 0.3);
    }

    .thumb-grid-body {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }

    .thumb-grid-container {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(var(--thumb-size, 140px), 1fr));
      gap: 16px;
      max-width: 1600px;
      margin: 0 auto;
      touch-action: pan-y;
      /* Disable browser's lazy rendering - force render all items */
      content-visibility: visible;
    }

    .thumb-grid-item {
      position: relative;
      aspect-ratio: 3/4;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      overflow: hidden;
      cursor: pointer;
      transition: transform .15s ease, box-shadow .15s ease;
      border: 2px solid transparent;
      /* Force immediate rendering */
      content-visibility: visible;
      contain-intrinsic-size: auto var(--thumb-size, 140px) auto calc(var(--thumb-size, 140px) * 1.33);
    }

    .thumb-grid-item:hover {
      transform: scale(1.05);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
      border-color: rgba(100, 180, 255, 0.5);
    }

    .thumb-grid-item.current {
      border-color: #4ade80;
      box-shadow: 0 0 20px rgba(74, 222, 128, 0.3);
    }

    .thumb-grid-item.fav {
      border-color: #fbbf24;
    }

    .thumb-grid-item.weak {
      border-color: #f87171;
    }

    .thumb-grid-item.done {
      border-color: #60a5fa;
    }

    .thumb-grid-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      pointer-events: none;
    }

    .thumb-grid-badge {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
      padding: 20px 8px 8px;
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
    }

    .thumb-grid-page {
      font-size: 0.85rem;
      font-weight: 600;
      color: #fff;
    }

    .thumb-grid-status {
      display: flex;
      gap: 4px;
      font-size: 0.75rem;
    }

    .thumb-grid-status span {
      background: rgba(0, 0, 0, 0.5);
      padding: 2px 5px;
      border-radius: 4px;
    }

    .thumb-grid-preload-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: rgba(255, 255, 255, 0.1);
    }

    .thumb-grid-preload-bar .bar {
      height: 100%;
      background: linear-gradient(90deg, #4ade80, #22d3ee);
      transition: width .3s ease;
    }

    .thumb-grid-footer {
      padding: 12px 24px;
      background: rgba(0, 0, 0, 0.3);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-shrink: 0;
    }

    .thumb-grid-info {
      color: rgba(255, 255, 255, 0.6);
      font-size: 0.85rem;
    }

    .thumb-grid-actions {
      display: flex;
      gap: 10px;
    }
  </style>
  <script>
    (() => {
      const KEY = 'cursor-style';
      const ALL_STYLES = ['pen', 'reticle', 'cross', 'ring', 'marker', 'neon', 'star', 'diamond', 'laser', 'blade', 'portal', 'flame', 'crystal'];
      const ANIMATED_CURSORS = ['neon', 'portal', 'flame', 'crystal'];
      let glowEl = null;
      let rafId = null;
      let curMouseX = 0, curMouseY = 0;

      function createGlowElement() {
        if (glowEl) return;
        glowEl = document.createElement('div');
        glowEl.className = 'cursor-anim-glow';
        document.body.appendChild(glowEl);
      }

      function updateGlowPosition() {
        if (glowEl) {
          glowEl.style.left = curMouseX + 'px';
          glowEl.style.top = curMouseY + 'px';
        }
        rafId = requestAnimationFrame(updateGlowPosition);
      }

      function startGlowTracking() {
        createGlowElement();
        if (!rafId) {
          rafId = requestAnimationFrame(updateGlowPosition);
        }
        document.addEventListener('mousemove', onMouseMove, { passive: true });
        document.addEventListener('touchmove', onTouchMove, { passive: true });
      }

      function stopGlowTracking() {
        if (rafId) {
          cancelAnimationFrame(rafId);
          rafId = null;
        }
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('touchmove', onTouchMove);
      }

      function onMouseMove(e) {
        curMouseX = e.clientX;
        curMouseY = e.clientY;
      }

      function onTouchMove(e) {
        if (e.touches.length > 0) {
          curMouseX = e.touches[0].clientX;
          curMouseY = e.touches[0].clientY;
        }
      }

      function applyCursorStyle(style) {
        const body = document.body;
        if (!body) return;
        // Remove all cursor classes
        ALL_STYLES.forEach(s => body.classList.remove(`cursor-style-${s}`));

        // Apply new style
        if (style && style !== 'default' && ALL_STYLES.includes(style)) {
          body.classList.add(`cursor-style-${style}`);
        }

        // Handle animated cursor glow
        if (ANIMATED_CURSORS.includes(style)) {
          startGlowTracking();
        } else {
          stopGlowTracking();
        }

        try { localStorage.setItem(KEY, style); } catch (_) { }
      }

      function initCursorStyle() {
        const saved = (() => { try { return localStorage.getItem(KEY) || 'default'; } catch (_) { return 'default'; } })();
        const select = document.getElementById('cursorStyleSelect');
        if (select) {
          select.value = saved || 'default';
          select.addEventListener('change', () => applyCursorStyle(select.value || 'default'));
        }
        applyCursorStyle(saved || 'default');
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initCursorStyle);
      } else {
        initCursorStyle();
      }
    })();
  </script>

  <!-- Planner styles -->
  <style data-planner-style="1" media="not all">
    :root {
      --bg: #0d1015;
      --fg: #e8e8eb;
      --muted: #a7adba;
      --face: #0d1015;
      --ring: #222834;
      --tickMajor: #3a4150;
      --tickMinor: #262c37;
      --handH: #ffffff;
      --handM: #e2e5ea;
      --handS: #4da3ff;
      --accent: #4da3ff;
      --arcShadow: drop-shadow(0 2px 3px rgba(0, 0, 0, .4));
      --ease-soft: cubic-bezier(.4, 0, .2, 1);
      --ease-emph: cubic-bezier(.15, .75, .25, 1);
      --dur-xs: .18s;
      --dur-sm: .28s;
      --dur-md: .45s;
      --dur-lg: .8s;
      --glass: rgba(15, 18, 26, .7);
    }

    .theme-minimal {}

    .theme-classic {
      --bg: #f1f2f6;
      --fg: #1b1f28;
      --muted: #5a6477;
      --face: #f7f8fb;
      --ring: #cfd6e3;
      --tickMajor: #7e8aa1;
      --tickMinor: #b6bfce;
      --handH: #1b1f28;
      --handM: #2b3240;
      --handS: #d1382f;
      --accent: #2b7cff;
    }

    .theme-neon {
      --bg: #0a0b10;
      --fg: #eaf2ff;
      --muted: #8aa7ff;
      --face: #0a0b10;
      --ring: #162036;
      --tickMajor: #1e2a4a;
      --tickMinor: #121a30;
      --handH: #eaf2ff;
      --handM: #b7c7ff;
      --handS: #00eaff;
      --accent: #7b5cff;
      --arcShadow: drop-shadow(0 0 8px rgba(123, 92, 255, .75)) drop-shadow(0 0 14px rgba(0, 234, 255, .45));
    }

    .theme-paper {
      --bg: #faf7f0;
      --fg: #2c2a25;
      --muted: #6f6a5e;
      --face: #fffaf0;
      --ring: #e7ddc5;
      --tickMajor: #b9ac8e;
      --tickMinor: #d9cfb7;
      --handH: #2c2a25;
      --handM: #444136;
      --handS: #b76e79;
      --accent: #b76e79;
    }

    .theme-glass {
      --bg: #0b0f14;
      --fg: #e7f2ff;
      --muted: #9fb7d6;
      --face: rgba(255, 255, 255, .06);
      --ring: #2a3544;
      --tickMajor: #3b4a61;
      --tickMinor: #253042;
      --handH: #e7f2ff;
      --handM: #bcd4f3;
      --handS: #79c2ff;
      --accent: #79c2ff;
      backdrop-filter: blur(8px);
    }

    .theme-pudding {
      --bg: #fef6e4;
      --fg: #5a4a2f;
      --muted: #a89268;
      --face: #fff9ea;
      --ring: #e6d5a8;
      --tickMajor: #d4b77a;
      --tickMinor: #e8ddb8;
      --handH: #5a4a2f;
      --handM: #7a6a4f;
      --handS: #d4a574;
      --accent: #d4a574;
    }

    .theme-metal {
      --bg: #1a1d23;
      --fg: #e4e7ec;
      --muted: #8a909d;
      --face: #2a2d35;
      --ring: #3f454f;
      --tickMajor: #5a616e;
      --tickMinor: #434952;
      --handH: #e4e7ec;
      --handM: #c5c9d1;
      --handS: #4db8ff;
      --accent: #4db8ff;
    }

    * {
      box-sizing: border-box
    }

    html,
    body {
      height: 100%;
      margin: 0
    }

    body {
      background: var(--bg);
      color: var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
      overflow-x: hidden;
      min-height: 100%;
    }

    body::before,
    body::after {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: -1;
      background: radial-gradient(circle at 20% 20%, rgba(77, 163, 255, .15), transparent 45%),
        radial-gradient(circle at 80% 0%, rgba(123, 92, 255, .18), transparent 40%);
      animation: bgPulse 18s ease-in-out infinite alternate;
      opacity: .8;
    }

    body::after {
      background: radial-gradient(circle at 70% 80%, rgba(0, 214, 255, .12), transparent 45%),
        radial-gradient(circle at 10% 60%, rgba(255, 255, 255, .06), transparent 35%);
      mix-blend-mode: screen;
      filter: blur(30px);
      animation-duration: 24s;
    }

    @keyframes bgPulse {
      0% {
        transform: translate3d(-2%, 0, 0) scale(1);
      }

      50% {
        transform: translate3d(2%, 1%, 0) scale(1.05);
      }

      100% {
        transform: translate3d(-1%, 0, 0) scale(1);
      }
    }

    #plannerApp header {
      padding: 12px;
      border-bottom: 1px solid var(--ring);
      position: sticky;
      top: 0;
      backdrop-filter: blur(10px);
      background: rgba(5, 7, 12, .85);
      z-index: 50;
      animation: slideDown var(--dur-md) var(--ease-soft) both;
    }

    #plannerApp header h1 {
      margin: 0;
      font-size: 18px;
      font-weight: 700;
      letter-spacing: .05em
    }

    #plannerApp .tabs {
      display: flex;
      gap: 4px;
      padding: 8px 12px;
      background: rgba(0, 0, 0, .25);
      flex-wrap: wrap;
      position: relative;
      width: 100%;
      margin: 0 auto 8px;
      border-bottom: 1px solid rgba(255, 255, 255, .05);
      backdrop-filter: blur(18px);
    }

    #plannerApp .tabs::before {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, rgba(255, 255, 255, .06), transparent 30%, transparent 70%, rgba(255, 255, 255, .06));
      opacity: .35;
      pointer-events: none;
    }

    #plannerApp .tab {
      padding: 10px 16px;
      cursor: pointer;
      border-radius: 10px;
      background: transparent;
      color: var(--muted);
      border: none;
      font-size: 14px;
      position: relative;
      transition: color var(--dur-xs) var(--ease-soft), transform var(--dur-xs) var(--ease-soft);
    }

    #plannerApp .tab::after {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: rgba(255, 255, 255, .08);
      opacity: 0;
      transition: opacity var(--dur-xs) var(--ease-soft);
      pointer-events: none;
    }

    #plannerApp .tab:hover {
      color: var(--fg);
      transform: translateY(-1px);
    }

    #plannerApp .tab:hover::after {
      opacity: .35;
    }

    #plannerApp .tab.active {
      color: #fff;
    }

    #plannerApp .tab.active::after {
      opacity: .9;
      background: linear-gradient(120deg, rgba(77, 163, 255, .45), rgba(123, 92, 255, .4));
    }

    #plannerApp .tab-indicator {
      position: absolute;
      bottom: 4px;
      left: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--accent), rgba(255, 255, 255, .88));
      border-radius: 999px;
      transform-origin: left center;
      transition: transform var(--dur-sm) var(--ease-emph), width var(--dur-sm) var(--ease-emph);
      pointer-events: none;
      z-index: 2;
    }

    /* Unify planner header/tabs with slim reader style */
    #plannerApp>header {
      display: none;
    }

    #tabs {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
      flex: 0 0 auto;
      padding: 0;
      background: transparent;
      border: none;
    }

    #plannerApp .tabs {
      padding: 6px 4px;
      background: transparent;
      border-bottom: 1px solid #1b2432;
      gap: 4px;
      flex-wrap: wrap;
    }

    #plannerApp .tab {
      padding: 4px 10px;
      border: 1px solid #223047;
      background: #0e1420;
      border-radius: 7px;
      color: var(--muted);
      font-size: 12px;
    }

    #plannerApp .tab::after {
      display: none;
    }

    #plannerApp .tab.active {
      border-color: var(--brand);
      box-shadow: 0 0 0 1px rgba(79, 140, 255, .2) inset;
      color: var(--text);
      background: rgba(79, 140, 255, .12);
    }

    #plannerApp .tab-indicator {
      display: none !important;
    }

    /* Keep reader top tabs slim even when planner styles are enabled */
    #tabs .tab {
      padding: 3px 7px;
      border: 1px solid #223047;
      background: #0e1420;
      border-radius: 7px;
      cursor: pointer;
      user-select: none;
      font-size: 10.5px;
      line-height: 1.1;
    }

    #tabs .tab::after {
      display: none;
    }

    #tabs .tab.active {
      border-color: var(--brand);
      box-shadow: 0 0 0 1px rgba(79, 140, 255, .2) inset;
      color: #fff;
      background: rgba(79, 140, 255, .12);
    }

    #plannerApp .tab-content {
      display: none;
      padding: 6px 0 28px;
      opacity: 0;
      transform: translateY(8px);
      transition: opacity var(--dur-sm) var(--ease-soft), transform var(--dur-sm) var(--ease-soft);
    }

    #plannerApp .tab-content.active {
      display: block;
      opacity: 1;
      transform: translateY(0);
    }

    #plannerApp main {
      max-width: 1280px;
      margin: 0 auto;
      padding: 12px 12px 24px;
      animation: fadeSlideUp var(--dur-lg) var(--ease-soft) both;
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 0;
    }

    @media (max-width:640px) {
      #plannerApp main {
        padding: 14px 8px 20px;
      }
    }

    /* Calendar tab */
    #plannerApp .calendar-layout {
      display: grid;
      grid-template-columns: minmax(520px, 1.35fr) minmax(280px, 0.9fr);
      gap: 12px;
      align-items: start;
    }

    #plannerApp .calendar-grid {
      display: grid;
      grid-template-columns: repeat(7, minmax(0, 1fr));
      gap: 6px;
      margin-top: 8px;
    }

    #plannerApp .cal-day {
      padding: 10px;
      border: 1px solid #1e2838;
      border-radius: 12px;
      min-height: 120px;
      background: linear-gradient(160deg, rgba(255, 255, 255, .05), rgba(255, 255, 255, .02));
      display: flex;
      flex-direction: column;
      gap: 6px;
      cursor: pointer;
      transition: transform .12s ease, border-color .12s ease, box-shadow .12s ease;
    }

    #plannerApp .cal-day:hover {
      transform: translateY(-2px);
      border-color: var(--brand);
    }

    #plannerApp .cal-day.today {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(255, 209, 102, .35);
    }

    #plannerApp .cal-day.active {
      box-shadow: 0 8px 30px rgba(0, 0, 0, .35), 0 0 0 1px rgba(79, 140, 255, .35);
    }

    #plannerApp .cal-day.muted {
      opacity: .7;
    }

    #plannerApp .cal-day-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-weight: 700;
    }

    #plannerApp .cal-day-head .cal-week {
      font-size: 11px;
      color: var(--muted);
    }

    #plannerApp .cal-day-events {
      display: flex;
      flex-direction: column;
      gap: 4px;
      flex: 1;
      min-height: 0;
    }

    #plannerApp .cal-event-chip {
      padding: 4px 6px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, .08);
      background: rgba(255, 255, 255, .05);
      font-size: 12px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    #plannerApp .cal-more {
      font-size: 11px;
      color: var(--muted);
    }

    #plannerApp .calendar-side {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    #plannerApp .cal-card {
      background: linear-gradient(180deg, rgba(255, 255, 255, .06), rgba(255, 255, 255, .02));
      border: 1px solid #1f2b3c;
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 14px 32px rgba(0, 0, 0, .25);
    }

    #plannerApp .cal-card h4 {
      margin: 0 0 6px;
      font-size: 14px;
    }

    #plannerApp .cal-day-row {
      border-left: 3px solid var(--accent);
      padding: 6px 8px;
      margin-bottom: 6px;
      background: rgba(255, 255, 255, .03);
      border-radius: 10px;
    }

    #plannerApp .cal-day-row .cal-title {
      font-weight: 700;
    }

    #plannerApp .cal-day-row .cal-time {
      font-family: monospace;
      font-size: 12px;
      color: var(--muted);
    }

    #plannerApp .cal-day-row .cal-meta {
      font-size: 12px;
      color: var(--muted);
    }

    #plannerApp .calendar-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }

    #plannerApp .calendar-mini-input {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 6px;
    }

    #plannerApp .cal-agenda {
      margin-top: 8px;
      display: grid;
      gap: 6px;
    }

    #plannerApp .cal-agenda-row {
      border: 1px solid #1f2b3c;
      border-radius: 12px;
      padding: 8px;
      background: rgba(255, 255, 255, .02);
      display: grid;
      grid-template-columns: 140px 1fr;
      gap: 10px;
      align-items: center;
    }

    #plannerApp .cal-agenda-date {
      font-weight: 700;
      color: var(--text);
    }

    #plannerApp .cal-agenda-body {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    #plannerApp .cal-agenda-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid #2f4361;
      background: rgba(79, 140, 255, .08);
      font-size: 12px;
      margin: 2px;
    }

    #plannerApp .cal-tag {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid #26354a;
      font-size: 12px;
      color: var(--muted);
    }

    #plannerApp .cal-section-title {
      font-size: 13px;
      font-weight: 700;
      margin: 0 0 6px;
    }

    #plannerApp .cal-note {
      font-size: 12px;
      color: var(--muted);
    }

    /* ========== Study Calendar Styles ========== */
    #plannerApp {
      --sc-zoom: 1;
      --sc-h-width: 120px;
      --sc-week-height: 1.1;
      --sc-aside-width: 400px;
      --sc-shell-gap: 14px;
      height: calc(var(--vh-safe, 100vh) - var(--topbar-h, 52px));
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .study-calendar-main {
      background: linear-gradient(135deg, rgba(15, 20, 30, 0.95), rgba(20, 25, 35, 0.9));
      border: 1px solid rgba(79, 140, 255, 0.2);
    }

    #plannerApp main {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      padding: 8px 10px 10px;
    }

    #plannerApp .tab-content {
      overflow: auto;
      min-height: 0;
    }

    #plannerApp .tab-content[data-content="calendar"] {
      padding: 0;
      display: none;
      flex: 1;
      min-height: 0;
      flex-direction: column;
      overflow: hidden;
    }

    #plannerApp .tab-content[data-content="calendar"].active {
      display: flex;
    }

    #plannerApp .calendar-shell {
      display: grid;
      grid-template-columns: minmax(0, 1.55fr) 8px minmax(300px, clamp(300px, var(--sc-aside-width), 520px));
      grid-template-rows: 1fr;
      gap: 6px;
      align-items: stretch;
      width: 100%;
      height: 100%;
      min-height: 0;
      overflow: hidden;
      align-content: stretch;
      grid-auto-rows: 1fr;
      max-height: 100%;
      flex: 1;
    }

    #plannerApp .calendar-shell>* {
      min-height: 0;
    }

    #plannerApp .calendar-shell.immersive {
      grid-template-columns: 1fr;
      height: 100%;
    }

    #plannerApp .calendar-shell.immersive .calendar-aside,
    #plannerApp .calendar-shell.immersive .calendar-resizer {
      display: none;
    }

    #plannerApp .calendar-main {
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-height: 0;
      height: 100%;
      padding: 10px;
      overflow: hidden;
      max-height: 100%;
    }

    #plannerApp .calendar-main.card {
      height: 100%;
    }

    #plannerApp .calendar-aside {
      position: relative;
      height: 100%;
      max-height: 100%;
      min-height: 0;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      flex: 1;
      align-self: stretch;
    }

    #plannerApp .calendar-aside .card {
      overflow: visible;
      position: relative;
    }

    #plannerApp .calendar-resizer {
      width: 12px;
      cursor: col-resize;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.25;
      transition: opacity 0.15s ease, background 0.15s ease;
      border-radius: 8px;
      touch-action: none;
      user-select: none;
      height: 100%;
      grid-column: 2;
      grid-row: 1;
      position: relative;
      z-index: 3;
      pointer-events: auto;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.02));
    }

    #plannerApp .panel-toggle {
      position: absolute;
      top: 6px;
      right: 6px;
      padding: 4px 6px;
      font-size: 11px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.04);
      color: #e5e7eb;
      cursor: pointer;
      line-height: 1;
      transition: background 0.15s ease, border-color 0.15s ease, color 0.15s ease;
    }

    #plannerApp .panel-toggle:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(255, 255, 255, 0.18);
    }

    #plannerApp .card.collapsed {
      padding-top: 12px;
    }

    #plannerApp .card.collapsed> :not(.panel-toggle):not(:first-child) {
      display: none !important;
    }

    #plannerApp .card.collapsed .panel-toggle {
      color: #a5b4fc;
    }

    #plannerApp .calendar-resizer::after {
      content: "";
      width: 2px;
      height: 48px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.4);
    }

    #plannerApp .calendar-resizer:hover,
    body.resizing-calendar #plannerApp .calendar-resizer {
      opacity: 0.65;
      background: rgba(255, 255, 255, 0.04);
    }

    #plannerApp .calendar-aside-scroll {
      display: flex;
      flex-direction: column;
      gap: 10px;
      height: 100%;
      flex: 1 1 auto;
      max-height: none;
      overflow-y: auto;
      padding-right: 8px;
      min-height: 0;
      overscroll-behavior: contain;
    }

    #plannerApp .calendar-aside-scroll::-webkit-scrollbar {
      width: 8px;
    }

    #plannerApp .calendar-aside-scroll::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.12);
      border-radius: 999px;
    }

    @media (max-width: 1100px) {
      #plannerApp .calendar-shell {
        grid-template-columns: 1fr;
        gap: 10px;
        height: calc(var(--vh-safe, 100vh) - var(--topbar-h, 52px) - 12px);
      }

      #plannerApp .calendar-resizer {
        display: none;
      }

      #plannerApp .calendar-main {
        min-height: calc(var(--vh-safe, 100vh) - var(--topbar-h, 52px) - 32px);
      }

      #plannerApp .calendar-aside-scroll {
        max-height: none;
        height: auto;
      }
    }

    body.mainmode #plannerApp .calendar-shell,
    body.mainmode2 #plannerApp .calendar-shell {
      display: flex;
      flex-direction: column;
      width: 100% !important;
      max-width: none;
      height: 100%;
      gap: 0;
    }

    body.mainmode #plannerApp .calendar-aside,
    body.mainmode #plannerApp .calendar-resizer,
    body.mainmode2 #plannerApp .calendar-aside,
    body.mainmode2 #plannerApp .calendar-resizer {
      display: none;
    }

    /* Calendar tab: disable text selection except form controls */
    #plannerApp .tab-content[data-content="calendar"] {
      -webkit-user-select: none;
      user-select: none;
    }

    #plannerApp .tab-content[data-content="calendar"] input,
    #plannerApp .tab-content[data-content="calendar"] select,
    #plannerApp .tab-content[data-content="calendar"] textarea,
    #plannerApp .tab-content[data-content="calendar"] option {
      -webkit-user-select: text;
      user-select: text;
    }

    /* Chip info popover */
    #scChipInfo {
      position: fixed;
      top: 80px;
      left: 80px;
      min-width: 240px;
      min-height: 140px;
      max-width: 360px;
      background: rgba(12, 16, 24, 0.96);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 12px;
      box-shadow: 0 16px 40px rgba(0, 0, 0, 0.45);
      color: #e5e7eb;
      padding: 10px;
      z-index: 2000;
      display: none;
      resize: both;
      overflow: auto;
      box-sizing: border-box;
    }

    #scChipInfo .chip-info-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      cursor: move;
      user-select: none;
    }

    #scChipInfo .chip-info-body {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 12px;
    }

    #scChipInfo .chip-info-actions {
      display: flex;
      gap: 4px;
      flex-wrap: nowrap;
      align-items: center;
      justify-content: flex-end;
      margin-top: 6px;
    }

    #scChipInfo .chip-info-actions .sc-chip-sort {
      height: 22px;
      padding: 0 4px;
      font-size: 10.5px;
      border-radius: 5px;
      background: rgba(255, 255, 255, 0.08);
      color: #e5e7eb;
      border: 1px solid rgba(255, 255, 255, 0.18);
    }

    #scChipInfo .chip-info-actions .btn {
      height: 22px;
      padding: 0 6px;
      font-size: 10.5px;
      border-radius: 5px;
      line-height: 1;
    }

    /* Main mode: use full width for calendar */
    body.mainmode #plannerApp main {
      max-width: 100%;
      width: 100%;
      padding: 8px 8px 10px;
      margin: 0;
    }

    body.mainmode #plannerApp .tab-content[data-content="calendar"],
    body.mainmode2 #plannerApp .tab-content[data-content="calendar"] {
      width: 100%;
      max-width: none;
      flex: 1;
      min-height: 0;
    }

    body.mainmode #plannerApp .calendar-main,
    body.mainmode2 #plannerApp .calendar-main {
      width: 100%;
      height: 100%;
      max-width: none;
      flex: 1;
    }

    .sc-header {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 6px 8px;
      margin-bottom: 6px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(255, 255, 255, 0.015);
      flex-wrap: nowrap;
      min-width: 0;
    }

    .sc-nav {
      display: flex;
      align-items: center;
      gap: 4px;
      flex: 1;
      min-width: 0;
      flex-wrap: wrap;
    }

    .sc-title {
      margin: 0;
      font-size: 1rem;
      font-weight: 800;
      background: linear-gradient(135deg, #7dd3fc, #a78bfa);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .sc-views {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
      justify-content: center;
      flex: 1;
      min-width: 0;
    }

    .sc-view-btn.active {
      background: var(--accent);
      color: #fff;
    }

    #scRefresh {
      display: none !important;
    }

    #scTodoRefresh {
      display: none !important;
    }

    .sc-options {
      display: flex;
      gap: 4px;
      align-items: center;
      flex-wrap: nowrap;
      justify-content: flex-end;
      flex: 1;
      min-width: 0;
    }

    .sc-options .btn:disabled {
      opacity: 0.45;
      cursor: default;
    }

    .sc-header .btn,
    .sc-views .btn,
    .sc-options .btn,
    .sc-options .input,
    .sc-nav select {
      padding: 5px 7px;
      font-size: 11.5px;
      min-height: 0;
    }

    .sc-views .btn {
      border-radius: 8px;
    }

    .sc-layout-bar {
      display: none;
    }

    .sc-slider {
      display: none;
    }

    .sc-slider.inline {
      min-width: 150px;
    }

    .sc-slider label {
      font-size: 11px;
      color: var(--muted);
    }

    .sc-slider input[type="range"] {
      width: 100%;
      accent-color: var(--brand);
    }

    .sc-layout-actions {
      display: flex;
      gap: 6px;
      justify-content: flex-end;
      flex-wrap: wrap;
    }

    /* Stats */
    .sc-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 10px;
      margin: 4px 0 6px;
    }

    .sc-stat {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 4px;
      padding: 7px 9px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      min-width: 0;
    }

    .sc-stat.urgent {
      border-color: rgba(239, 68, 68, 0.5);
      background: rgba(239, 68, 68, 0.1);
    }

    .sc-stat-value {
      font-size: 1.25rem;
      font-weight: 700;
      color: #7dd3fc;
      line-height: 1.1;
    }

    .sc-stat.urgent .sc-stat-value {
      color: #ef4444;
    }

    .sc-stat-label {
      font-size: 11px;
      color: var(--muted);
    }

    /* Width control for horizontal view */
    .sc-width-control {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 3px 5px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.02);
      font-size: 10.5px;
      flex-wrap: nowrap;
      flex-shrink: 1;
    }

    .sc-width-control button {
      padding: 3px 6px;
      font-size: 10.5px;
      border-radius: 6px;
      min-height: 0;
      line-height: 1;
      flex-shrink: 0;
    }

    .sc-width-control input[type="range"] {
      width: 110px;
    }

    .sc-width-control .mini-label {
      color: var(--muted);
      font-size: 10px;
      white-space: nowrap;
    }

    #plannerApp .calendar-main .sc-month-view,
    #plannerApp .calendar-main .sc-week-view,
    #plannerApp .calendar-main .sc-horizontal-view,
    #plannerApp .calendar-main .sc-agenda-view {
      flex: 1;
      min-height: 0;
      padding: 6px 8px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.015);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.03);
    }

    #plannerApp .calendar-main .sc-month-view {
      overflow: auto;
    }

    #plannerApp .calendar-main .sc-week-view,
    #plannerApp .calendar-main .sc-horizontal-view,
    #plannerApp .calendar-main .sc-agenda-view {
      overflow: auto;
    }

    /* Month View */
    .sc-month-view {
      margin: 0;
      min-height: clamp(220px, calc(260px * var(--sc-zoom)), 520px);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .sc-weekdays {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 2px;
      margin-bottom: 4px;
    }

    .sc-weekday {
      text-align: center;
      font-size: 12px;
      font-weight: 600;
      color: var(--muted);
      padding: 6px;
    }

    .sc-weekday.weekend {
      color: #f87171;
    }

    .sc-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      grid-auto-rows: minmax(clamp(60px, calc(70px * var(--sc-zoom)), 160px), 1fr);
      gap: 4px;
      min-height: clamp(220px, calc(260px * var(--sc-zoom)), 520px);
      flex: 1;
      align-content: stretch;
    }

    .sc-day {
      min-height: clamp(60px, calc(70px * var(--sc-zoom)), 160px);
      height: 100%;
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 8px;
      padding: calc(4px * var(--sc-zoom));
      transition: all 0.2s;
      cursor: pointer;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .sc-day:hover {
      background: rgba(79, 140, 255, 0.1);
      border-color: rgba(79, 140, 255, 0.3);
    }

    .sc-day.today {
      background: rgba(79, 140, 255, 0.15);
      border-color: rgba(79, 140, 255, 0.5);
      box-shadow: 0 0 12px rgba(79, 140, 255, 0.3);
    }

    .sc-day.selected {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(255, 209, 102, 0.35);
    }

    .sc-day.other-month {
      opacity: 0.4;
    }

    .sc-day.weekend {
      background: rgba(239, 68, 68, 0.05);
    }

    .sc-day-num {
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 4px;
      color: var(--fg);
    }

    .sc-day.today .sc-day-num {
      background: var(--accent);
      color: #fff;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .sc-day-tasks {
      display: flex;
      flex-direction: column;
      gap: 2px;
      max-height: none;
      overflow-y: auto;
      flex: 1;
      min-height: 0;
      align-items: stretch;
    }

    .sc-task-chip,
    .sc-h-task {
      font-size: 10.5px;
      padding: 3px 6px;
      border-radius: 6px;
      background: rgba(79, 140, 255, 0.12);
      color: #bfdbfe;
      border: 1px solid rgba(79, 140, 255, 0.28);
      display: flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
      min-height: 22px;
      flex-shrink: 0;
    }

    .sc-task-chip {
      border-left: 3px solid var(--accent);
    }

    .sc-task-chip.break,
    .sc-h-task.break {
      background: rgba(249, 115, 22, 0.18);
      color: #fed7aa;
      border-color: rgba(249, 115, 22, 0.35);
      border-left-color: #f97316;
    }

    .sc-task-chip.due,
    .sc-h-task.due {
      background: rgba(239, 68, 68, 0.12);
      border-color: rgba(239, 68, 68, 0.3);
      color: #fecdd3;
    }

    .sc-task-chip.scheduled,
    .sc-h-task.scheduled {
      border-left-color: var(--accent);
    }

    .sc-task-chip.done,
    .sc-h-task.done {
      opacity: 0.6;
      text-decoration: line-through;
    }

    .sc-chip-title {
      flex: 1;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      font-weight: 600;
      color: #e2e8f0;
    }

    .sc-chip-meta {
      font-size: 10px;
      color: var(--muted);
      white-space: nowrap;
      flex-shrink: 0;
    }

    .sc-chip-tag {
      font-size: 10px;
      padding: 1px 4px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.1);
      color: #e5e7eb;
      flex-shrink: 0;
    }

    .sc-chip-delete {
      background: none;
      border: none;
      color: #fca5a5;
      font-size: 12px;
      line-height: 1;
      padding: 0 2px;
      cursor: pointer;
      flex-shrink: 0;
    }

    .sc-more {
      font-size: 10px;
      color: var(--muted);
      text-align: center;
    }

    /* Mini lesson + break planner */
    .sc-mini-card {
      background: linear-gradient(135deg, rgba(18, 24, 36, 0.95), rgba(15, 20, 30, 0.92));
      border: 1px solid rgba(79, 140, 255, 0.22);
    }

    .sc-mini-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 10px;
      margin: 10px 0;
    }

    .sc-mini-stat {
      display: flex;
      flex-direction: column;
      gap: 2px;
      padding: 10px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(255, 255, 255, 0.03);
    }

    .sc-mini-stat .label {
      font-size: 12px;
      color: var(--muted);
    }

    .sc-mini-stat .value {
      font-size: 16px;
      font-weight: 700;
      color: #7dd3fc;
    }

    .sc-mini-log {
      margin-top: 10px;
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 10px;
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .sc-mini-log-row {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      font-size: 12px;
      color: var(--muted);
    }

    .sc-mini-log-row .title {
      color: var(--fg);
      font-weight: 600;
    }

    .sc-mini-log-row .meta {
      font-size: 11px;
      color: var(--muted);
    }

    .sc-mini-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 8px;
    }

    .sc-mini-quick {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 8px;
      margin-top: 6px;
    }

    /* Original lesson planner */
    #plannerApp .ol-hero {
      background: linear-gradient(135deg, rgba(15, 23, 42, 0.94), rgba(10, 15, 24, 0.92));
      border: 1px solid rgba(125, 211, 252, 0.24);
    }

    #plannerApp .ol-stat-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
      gap: 8px;
      min-width: 240px;
    }

    #plannerApp .ol-stat {
      display: flex;
      flex-direction: column;
      gap: 4px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(255, 255, 255, 0.03);
    }

    #plannerApp .ol-stat .label {
      font-size: 11px;
      color: var(--muted);
    }

    #plannerApp .ol-stat .value {
      font-size: 15px;
      font-weight: 700;
      color: #7dd3fc;
    }

    #plannerApp .ol-form-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 10px;
      margin-top: 12px;
    }

    #plannerApp .ol-weekdays,
    #plannerApp .ol-quick-row,
    #plannerApp .ol-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 4px;
    }

    #plannerApp .ol-weekdays .chip-btn {
      padding: 6px 10px;
      font-size: 11px;
    }

    #plannerApp .ol-weekdays .chip-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: #0b0f14;
    }

    #plannerApp .ol-layout {
      display: grid;
      grid-template-columns: minmax(0, 1fr) 320px;
      gap: 12px;
      margin-top: 12px;
    }

    @media (max-width: 900px) {
      #plannerApp .ol-layout {
        grid-template-columns: 1fr;
      }
    }

    #plannerApp .ol-timeline-toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    #plannerApp .ol-timeline-range {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
    }

    #plannerApp .ol-day-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 10px;
    }

    #plannerApp .ol-day-item {
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(255, 255, 255, 0.03);
      border-radius: 10px;
      padding: 8px 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    #plannerApp .ol-day-item.done {
      opacity: 0.6;
      text-decoration: line-through;
    }

    #plannerApp .ol-day-item .meta {
      font-size: 11px;
      color: var(--muted);
    }

    #plannerApp .ol-day-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    #plannerApp .ol-empty {
      margin-top: 10px;
      padding: 10px;
      border-radius: 10px;
      border: 1px dashed rgba(255, 255, 255, 0.15);
      color: var(--muted);
      text-align: center;
    }

    #plannerApp .ol-session-card {
      border: 1px solid rgba(59, 130, 246, 0.3);
      background: linear-gradient(135deg, rgba(15, 23, 42, 0.96), rgba(12, 18, 28, 0.96));
    }

    #plannerApp .ol-session-status {
      font-size: 14px;
      font-weight: 700;
      color: #dbeafe;
    }

    #plannerApp .ol-session-meta {
      font-size: 12px;
      color: var(--muted);
      margin-top: 6px;
      min-height: 36px;
    }

    #plannerApp .ol-progress {
      height: 8px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      overflow: hidden;
      margin: 10px 0 6px;
    }

    #plannerApp .ol-progress-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #38bdf8, #6366f1);
      transition: width 0.2s ease;
    }

    #plannerApp .ol-session-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 6px;
    }

    #plannerApp .ol-clock-panel {
      margin-top: 6px;
      padding: 6px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(255, 255, 255, 0.03);
    }

    #plannerApp .ol-clock-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }

    #plannerApp .ol-clock-toggle {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    #plannerApp .ol-clock-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 6px;
      align-items: start;
    }

    #plannerApp .ol-clock-block {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 3px;
      padding: 4px 4px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(255, 255, 255, 0.03);
    }

    #plannerApp .ol-clock-label {
      font-size: 11px;
      color: var(--muted);
      letter-spacing: .08em;
      text-transform: uppercase;
    }

    #plannerApp .ol-clock-panel .chip-btn {
      padding: 6px 10px;
      font-size: 11px;
    }

    #plannerApp .ol-clock-panel .chip-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: #0b0f14;
    }

    #plannerApp .ol-clock-body {
      display: flex;
      flex-direction: column;
      gap: 4px;
      align-items: stretch;
      flex-wrap: wrap;
      margin-top: 4px;
    }

    #plannerApp .ol-clock {
      width: 168px;
      height: 168px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 20%, rgba(56, 189, 248, 0.08), transparent 60%);
      border: 1px solid rgba(255, 255, 255, 0.08);
      display: grid;
      place-items: center;
      cursor: pointer;
      touch-action: none;
    }

    #plannerApp .ol-clock svg {
      width: 148px;
      height: 148px;
    }

    #plannerApp .ol-clock-hand {
      stroke: #94a3b8;
      stroke-width: 2;
      stroke-linecap: round;
    }

    #plannerApp .ol-clock-hand.active {
      stroke: #38bdf8;
      stroke-width: 3;
    }

    #plannerApp .ol-clock-number {
      fill: #e2e8f0;
      font-size: 12px;
      font-weight: 600;
      text-anchor: middle;
      dominant-baseline: middle;
    }

    #plannerApp .ol-clock-readout {
      font-size: 17px;
      font-weight: 700;
      color: #e2e8f0;
      font-variant-numeric: tabular-nums;
      text-align: center;
    }

    #plannerApp .ol-clock-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }

    #plannerApp .ol-edit-overlay {
      position: fixed;
      inset: 0;
      background: rgba(4, 9, 18, 0.45);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10003;
    }

    #plannerApp .ol-edit-overlay.hidden {
      display: none;
    }

    #plannerApp .ol-edit-modal {
      width: min(620px, 94vw);
      max-height: 90vh;
      overflow: auto;
      padding: 16px;
      position: relative;
      box-shadow: 0 20px 50px rgba(3, 8, 20, 0.55);
    }

    #plannerApp .ol-edit-overlay[data-anchor="1"] {
      align-items: flex-start;
      justify-content: flex-start;
      padding: 16px;
    }

    #plannerApp .ol-edit-overlay[data-anchor="1"] .ol-edit-modal {
      position: absolute;
      left: var(--ol-edit-left, 50%);
      top: var(--ol-edit-top, 50%);
      transform: translate(var(--ol-edit-shift-x, -50%), var(--ol-edit-shift-y, 0));
    }

    #plannerApp .ol-edit-overlay[data-anchor="1"] .ol-edit-modal::before {
      content: "";
      position: absolute;
      border: 10px solid transparent;
    }

    #plannerApp .ol-edit-overlay[data-anchor="1"][data-placement="bottom"] .ol-edit-modal::before {
      top: -20px;
      left: var(--ol-edit-arrow-left, 32px);
      border-bottom-color: rgba(15, 23, 42, 0.98);
    }

    #plannerApp .ol-edit-overlay[data-anchor="1"][data-placement="top"] .ol-edit-modal::before {
      bottom: -20px;
      left: var(--ol-edit-arrow-left, 32px);
      border-top-color: rgba(15, 23, 42, 0.98);
    }

    #plannerApp .ol-edit-overlay[data-anchor="1"][data-placement="left"] .ol-edit-modal::before {
      right: -20px;
      top: var(--ol-edit-arrow-top, 24px);
      border-left-color: rgba(15, 23, 42, 0.98);
    }

    #plannerApp .ol-edit-overlay[data-anchor="1"][data-placement="right"] .ol-edit-modal::before {
      left: -20px;
      top: var(--ol-edit-arrow-top, 24px);
      border-right-color: rgba(15, 23, 42, 0.98);
    }

    #plannerApp .ol-edit-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }

    #plannerApp .ol-day-copy {
      margin-top: 10px;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(255, 255, 255, 0.03);
    }

    #plannerApp .ol-day-copy .input {
      max-width: 160px;
    }

    #plannerApp .ol-edit-quick {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 10px;
    }

    #plannerApp .ol-edit-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: flex-end;
      margin-top: 12px;
    }


    /* Week View */
    .sc-week-view {
      overflow-x: auto;
      min-height: clamp(240px, calc(300px * var(--sc-week-height)), 520px);
      display: flex;
      flex-direction: column;
      gap: 6px;
      height: 100%;
    }

    .sc-week-grid {
      display: grid;
      grid-template-columns: repeat(7, minmax(120px, 1fr));
      gap: 4px;
      min-height: 0;
      flex: 1;
    }

    .sc-week-day {
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 10px;
      padding: 8px;
      min-height: calc(220px * var(--sc-week-height));
    }

    .sc-week-day-header {
      text-align: center;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      margin-bottom: 8px;
    }

    .sc-week-day-name {
      font-size: 12px;
      color: var(--muted);
    }

    .sc-week-day-num {
      font-size: 18px;
      font-weight: 700;
    }

    /* Horizontal Timeline */
    .sc-horizontal-view {
      overflow-x: auto;
      padding-bottom: 12px;
      min-height: clamp(220px, calc(280px * var(--sc-week-height)), 520px);
      display: flex;
      flex-direction: column;
      gap: 6px;
      height: 100%;
      flex: 1;
      min-height: 0;
    }

    .sc-h-timeline {
      display: flex;
      gap: 6px;
      min-width: max-content;
      padding: 10px 2px;
      flex: 1;
      height: 100%;
      align-items: stretch;
    }

    .sc-h-day {
      width: var(--sc-h-width);
      min-width: var(--sc-h-width);
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      padding: 10px 8px;
      flex-shrink: 0;
      transition: all 0.2s;
      min-height: calc(200px * var(--sc-week-height));
      height: 100%;
      display: flex;
      flex-direction: column;
      position: relative;
    }

    .sc-h-day:hover {
      background: rgba(79, 140, 255, 0.1);
      border-color: rgba(79, 140, 255, 0.3);
      transform: translateY(-2px);
    }

    .sc-h-day.today {
      background: rgba(79, 140, 255, 0.15);
      border-color: rgba(79, 140, 255, 0.5);
      box-shadow: 0 4px 16px rgba(79, 140, 255, 0.3);
      outline: 2px solid rgba(79, 140, 255, 0.55);
      outline-offset: 0;
    }

    .sc-h-day.today::before {
      content: "今日";
      position: absolute;
      top: 6px;
      left: 6px;
      padding: 2px 6px;
      border-radius: 999px;
      background: #4da3ff;
      color: #0b0f14;
      font-size: 10px;
      font-weight: 700;
    }

    .sc-week-day.selected,
    .sc-h-day.selected {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(255, 209, 102, 0.25);
    }

    .sc-h-day.weekend {
      background: rgba(239, 68, 68, 0.05);
      border-color: rgba(239, 68, 68, 0.2);
    }

    .sc-h-day-header {
      text-align: center;
      margin-bottom: 8px;
      padding-bottom: 6px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .sc-h-day-date {
      font-size: 14px;
      font-weight: 700;
    }

    .sc-h-day-name {
      font-size: 10px;
      color: var(--muted);
    }

    .sc-h-day-tasks {
      display: flex;
      flex-direction: column;
      gap: 4px;
      flex: 1;
      min-height: 0;
    }

    .sc-h-task:hover {
      background: rgba(79, 140, 255, 0.22);
      transform: translateY(-1px);
    }

    /* Completed pages panel */
    .sc-completed-wrap {
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      padding: 6px;
      background: rgba(255, 255, 255, 0.02);
      height: 200px;
      overflow: auto;
      position: relative;
      transition: height 0.2s ease;
    }

    .sc-completed-wrap.collapsed {
      height: 0;
      padding: 0;
      border: none;
      overflow: hidden;
    }

    .sc-completed-resize {
      height: 10px;
      cursor: ns-resize;
      border-radius: 0 0 8px 8px;
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.04));
      margin-top: 6px;
    }

    /* Todo toolbar compact */
    .todo-toolbar {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-bottom: 8px;
    }

    .todo-toolbar-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 6px;
      align-items: center;
    }

    .todo-toolbar-grid .wide {
      grid-column: span 2;
    }

    .todo-toolbar-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
      justify-content: space-between;
    }

    .todo-view-switch {
      display: inline-flex;
      gap: 6px;
      align-items: center;
    }

    .todo-list.cards {
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    .todo-entry.compact {
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 6px;
      min-height: 180px;
    }

    /* Agenda View */
    .sc-agenda-view {
      max-height: none;
      min-height: clamp(220px, calc(280px * var(--sc-zoom)), 520px);
      overflow-y: auto;
      display: flex;
      flex-direction: column;
    }

    .sc-agenda-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .sc-agenda-item {
      display: grid;
      grid-template-columns: 100px 1fr;
      gap: 12px;
      padding: 10px;
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      align-items: center;
    }

    .sc-agenda-date {
      text-align: center;
    }

    .sc-agenda-date-num {
      font-size: 1.3rem;
      font-weight: 700;
      color: var(--accent);
    }

    .sc-agenda-date-day {
      font-size: 11px;
      color: var(--muted);
    }

    .sc-agenda-tasks {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .sc-agenda-task {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      background: rgba(79, 140, 255, 0.1);
      border: 1px solid rgba(79, 140, 255, 0.2);
      border-radius: 8px;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .sc-agenda-task:hover {
      background: rgba(79, 140, 255, 0.2);
      transform: translateY(-1px);
    }

    .sc-agenda-task.done {
      opacity: 0.5;
      text-decoration: line-through;
    }

    .sc-agenda-empty {
      text-align: center;
      padding: 32px;
      color: var(--muted);
    }

    /* Schedule Panel */
    .study-calendar-panel {
      background: linear-gradient(135deg, rgba(18, 24, 35, 0.95), rgba(15, 20, 28, 0.9));
      border: 1px solid rgba(167, 141, 250, 0.2);
    }

    .sc-hint {
      font-size: 12px;
      color: var(--muted);
      margin: 0 0 12px;
    }

    .sc-todo-select-area {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 12px;
    }

    .sc-todo-info {
      background: rgba(79, 140, 255, 0.1);
      border: 1px solid rgba(79, 140, 255, 0.2);
      border-radius: 10px;
      padding: 10px;
      margin-bottom: 12px;
    }

    .sc-todo-detail {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }

    .sc-todo-title {
      font-weight: 600;
      color: var(--fg);
    }

    .sc-todo-meta {
      font-size: 12px;
      color: var(--muted);
    }

    .sc-schedule-form {
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 12px;
    }

    .sc-form-row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }

    .sc-form-row:last-child {
      margin-bottom: 0;
    }

    .sc-form-group {
      flex: 1;
      min-width: 120px;
    }

    .sc-form-group label {
      display: block;
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 4px;
    }

    .sc-checkbox-label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
      cursor: pointer;
    }

    .sc-form-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
      margin-top: 12px;
    }

    .sc-preview-area {
      background: rgba(34, 197, 94, 0.05);
      border: 1px solid rgba(34, 197, 94, 0.2);
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 12px;
    }

    .sc-preview-area h4 {
      margin: 0 0 8px;
      font-size: 14px;
      color: #22c55e;
    }

    .sc-preview-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .sc-preview-item {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      background: rgba(34, 197, 94, 0.1);
      border-radius: 6px;
      font-size: 12px;
    }

    .sc-settings-section {
      margin-top: 12px;
    }

    .sc-settings-section summary {
      cursor: pointer;
      padding: 8px;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 8px;
      font-size: 13px;
      color: var(--muted);
    }

    .sc-settings-section details[open] summary {
      margin-bottom: 12px;
    }

    .todo-color-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 8px;
    }

    .todo-color-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .todo-color-item input[type="color"] {
      width: 36px;
      height: 28px;
      padding: 0;
      border: none;
      background: transparent;
    }

    .todo-color-hex {
      font-size: 11px;
      color: var(--muted);
      min-width: 60px;
      text-transform: uppercase;
      letter-spacing: 0.02em;
    }

    @media (max-width: 900px) {
      .sc-header {
        grid-template-columns: 1fr;
        row-gap: 8px;
      }

      .sc-options,
      .sc-views {
        justify-content: flex-start;
      }
    }

    @media (max-width: 768px) {
      .sc-grid {
        gap: 1px;
      }

      .sc-day {
        min-height: 60px;
        padding: 2px;
      }

      .sc-day-num {
        font-size: 11px;
      }

      .sc-h-day {
        width: 80px;
        min-width: 80px;
      }
    }

    @media (max-width: 960px) {
      #plannerApp .calendar-layout {
        grid-template-columns: 1fr;
      }

      #plannerApp .cal-agenda-row {
        grid-template-columns: 1fr;
      }
    }

    /* ========== Home View Styles ========== */
    :root {
      --home-accent: #7dd3fc;
      --home-surface: rgba(12, 16, 24, 0.94);
      --home-border: rgba(255, 255, 255, 0.08);
      --home-muted: var(--muted);
    }

    #homeView.hidden {
      display: none !important;
    }

    .home-shell {
      padding: clamp(14px, 2vw, 26px);
      max-width: none;
      width: 100%;
      margin: 0;
      display: flex;
      flex-direction: column;
      gap: 18px;
    }

    .home-hero {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 16px;
      background: linear-gradient(135deg, rgba(15, 23, 42, 0.95), rgba(22, 30, 45, 0.9));
      border: 1px solid var(--home-border);
      border-radius: 18px;
      padding: clamp(16px, 3vw, 22px);
      box-shadow: 0 18px 50px rgba(0, 0, 0, 0.3);
    }

    .home-hero-main {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .home-kicker {
      letter-spacing: .08em;
      text-transform: uppercase;
      font-size: 11px;
      color: var(--home-muted);
    }

    .home-header h1 {
      margin: 0;
      font-size: 2.2rem;
      font-weight: 800;
      background: linear-gradient(135deg, var(--home-accent), #a78bfa, #f472b6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .home-date {
      color: var(--home-muted);
      margin: 0;
      font-size: 1rem;
    }

    .home-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 4px;
    }

    .home-chip {
      border: 1px solid var(--home-border);
      background: rgba(255, 255, 255, 0.04);
      color: var(--fg);
      padding: 8px 12px;
      border-radius: 999px;
      font-size: 12px;
      cursor: pointer;
      transition: .2s;
    }

    .home-chip.primary {
      background: linear-gradient(135deg, var(--home-accent), #a78bfa);
      color: #0b1220;
      font-weight: 700;
    }

    .home-chip:hover {
      border-color: var(--home-accent);
      color: #fff;
    }

    .home-hero-side {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .home-lesson-card {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid var(--home-border);
      border-radius: 14px;
      padding: 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .home-lesson-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .home-lesson-summary {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    .home-lesson-chip {
      font-size: 11px;
      color: var(--home-muted);
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(255, 255, 255, 0.04);
      display: inline-flex;
      gap: 4px;
      align-items: center;
    }

    .home-lesson-chip strong {
      color: #e2e8f0;
      font-weight: 700;
    }

    .home-lesson-timetable {
      display: flex;
      gap: 10px;
      flex-wrap: nowrap;
      overflow-x: auto;
      padding-bottom: 4px;
    }

    .home-lesson-slot {
      position: relative;
      display: grid;
      grid-template-columns: 1fr;
      gap: 6px;
      align-items: start;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(255, 255, 255, 0.03);
      overflow: hidden;
      min-width: 180px;
    }

    .home-lesson-slot::before {
      content: "";
      position: absolute;
      inset: 0;
      background: var(--lesson-bg, rgba(96, 165, 250, 0.16));
      opacity: 0.55;
    }

    .home-lesson-time,
    .home-lesson-body,
    .home-lesson-title,
    .home-lesson-meta {
      position: relative;
      z-index: 1;
    }

    .home-lesson-time {
      font-size: 12px;
      color: var(--home-muted);
      font-variant-numeric: tabular-nums;
      letter-spacing: .02em;
    }

    .home-lesson-title {
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .home-lesson-period {
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      background: rgba(255, 255, 255, 0.08);
    }

    .home-lesson-meta {
      font-size: 11px;
      color: var(--home-muted);
    }

    .home-lesson-slot.done {
      opacity: 0.6;
      text-decoration: line-through;
    }

    .home-pref {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid var(--home-border);
      border-radius: 14px;
      padding: 14px;
    }

    .home-pref-title {
      font-size: 13px;
      color: var(--home-muted);
      margin-bottom: 6px;
      letter-spacing: .02em;
    }

    .home-toggle {
      display: flex;
      gap: 8px;
      align-items: center;
      font-size: 13px;
    }

    .home-accent-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .home-accent-btn {
      width: 30px;
      height: 30px;
      border-radius: 10px;
      border: 2px solid transparent;
      background: var(--swatch);
      cursor: pointer;
      transition: .2s;
    }

    .home-accent-btn.active {
      border-color: #fff;
      box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.08);
    }

    .home-tip {
      font-size: 12px;
      color: var(--home-muted);
      background: rgba(255, 255, 255, 0.02);
      border: 1px dashed var(--home-border);
      border-radius: 10px;
      padding: 10px;
    }

    .home-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 16px;
      align-items: stretch;
    }

    .home-card {
      background: var(--home-surface);
      border: 1px solid var(--home-border);
      border-radius: 16px;
      padding: 18px;
      transition: all 0.3s;
      min-height: 200px;
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.3);
    }

    .home-card.accent {
      background: linear-gradient(135deg, rgba(125, 211, 252, 0.14), rgba(15, 23, 42, 0.9));
      border-color: rgba(125, 211, 252, 0.4);
    }

    .home-card:hover {
      transform: translateY(-3px);
      border-color: rgba(125, 211, 252, 0.3);
    }

    .home-card h3 {
      margin: 0 0 10px;
      font-size: 1rem;
      color: var(--fg);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .home-card-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 10px;
    }

    .home-card-header h3 {
      margin: 0;
    }

    .home-completed-controls {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      min-width: 0;
      padding: 2px 0;
    }

    .home-completed-date-wrap {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      min-width: 140px;
    }

    .home-completed-date {
      font-size: 12px;
      color: var(--home-muted);
      padding: 6px 12px;
      border-radius: 10px;
      border: 1px solid var(--home-border);
      background: rgba(255, 255, 255, 0.06);
      white-space: nowrap;
      cursor: pointer;
      transition: .2s;
      letter-spacing: .01em;
      text-align: center;
      min-width: 120px;
    }

    .home-completed-date:hover {
      border-color: var(--home-accent);
      color: #fff;
    }

    .home-completed-arrows {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      width: 100%;
      margin-top: -2px;
    }

    .home-arrow {
      padding: 2px 9px !important;
      font-size: 11px !important;
      min-height: 0;
      line-height: 1.1;
      border-radius: 10px;
      border: 1px solid var(--home-border);
      background: rgba(255, 255, 255, 0.03);
      opacity: 0.92;
      transition: .15s;
    }

    .home-arrow:hover {
      border-color: var(--home-accent);
      color: #fff;
    }

    .home-review-pill {
      padding: 4px 8px !important;
      font-size: 11px !important;
      border-radius: 999px;
      min-height: 0;
      line-height: 1.1;
      transition: .2s;
      border: 1px solid var(--home-border);
      background: rgba(255, 255, 255, 0.05);
    }

    .home-review-pill.active {
      background: linear-gradient(135deg, var(--home-accent), #a78bfa);
      color: #0b1220;
      font-weight: 700;
      border-color: transparent;
    }

    .home-date-input {
      position: absolute;
      opacity: 0;
      pointer-events: none;
      width: 1px;
      height: 1px;
    }

    .home-sub {
      font-size: 12px;
      color: var(--home-muted);
      margin: 0 0 10px;
    }

    .home-task-list,
    .home-book-list,
    .home-completed-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 230px;
      overflow-y: auto;
    }

    .home-task-item,
    .home-book-item,
    .home-completed-item {
      display: flex;
      gap: 10px;
      align-items: center;
      padding: 10px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .home-task-item:hover,
    .home-book-item:hover,
    .home-completed-item:hover {
      background: rgba(125, 211, 252, 0.12);
      border-color: rgba(125, 211, 252, 0.3);
    }

    .home-task-item.done {
      opacity: 0.6;
    }

    .home-task-title,
    .home-book-title,
    .home-completed-title {
      flex: 1;
      font-size: 13px;
      color: var(--fg);
    }

    .home-task-pages,
    .home-book-pages,
    .home-completed-pages {
      font-size: 12px;
      color: var(--home-muted);
    }

    .home-completed-main {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 1;
    }

    .home-completed-actions {
      display: flex;
      gap: 4px;
    }

    .home-completed-list {
      gap: 4px;
    }

    .home-completed-item {
      padding: 6px 8px;
      gap: 6px;
      border-radius: 7px;
    }

    .home-completed-pages {
      font-size: 10px;
    }

    .home-completed-title {
      font-size: 12px;
    }

    .home-review {
      background: var(--home-surface);
      border: 1px solid var(--home-border);
      border-radius: 16px;
      padding: 14px;
      margin-top: 0;
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.3);
      max-height: 0;
      opacity: 0;
      transform: translateY(12px);
      pointer-events: none;
      overflow: hidden;
      transition: max-height .35s ease, opacity .35s ease, transform .35s ease, padding .35s ease, border-color .35s ease;
      border-color: transparent;
      padding-top: 0;
      padding-bottom: 0;
    }

    #homeView.home-review-mode .home-review {
      max-height: none;
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
      border-color: var(--home-border);
      padding: 14px;
      margin-top: 0;
      overflow: visible;
    }

    .home-hero,
    .home-grid {
      transition: opacity .35s ease, transform .35s ease, max-height .35s ease, margin .35s ease, filter .35s ease;
      max-height: 2000px;
      filter: none;
    }

    #homeView.home-review-mode .home-hero,
    #homeView.home-review-mode .home-grid {
      display: none;
    }

    .home-review-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 10px;
    }

    .home-review-title {
      font-size: 1rem;
      font-weight: 700;
      color: var(--fg);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .home-review-controls {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px;
      border: 1px solid var(--home-border);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.02);
    }

    .home-review-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 6px;
    }

    #homeReviewRangeWrap,
    #homeReviewRecentWrap {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .home-review-row label {
      font-size: 11px;
      color: var(--home-muted);
      min-width: 40px;
    }

    .home-review-row .input,
    .home-review-row .btn {
      padding: 4px 6px;
      font-size: 11px;
      min-height: 0;
      min-width: 110px;
    }

    .home-review-summary {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .home-review-stat {
      padding: 6px 8px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid var(--home-border);
      font-size: 11px;
      color: var(--home-muted);
    }

    .home-review-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 65vh;
      overflow: auto;
    }

    #homeView.home-review-mode .home-review-list {
      max-height: calc(100vh - 180px);
    }

    .home-review-date {
      font-size: 12px;
      color: var(--home-muted);
      margin-top: 6px;
    }

    .home-review-body {
      display: grid;
      grid-template-columns: minmax(240px, 320px) 1fr;
      gap: 12px;
      align-items: start;
    }

    .home-review-side {
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-width: 0;
    }

    .home-review-main {
      min-width: 0;
    }

    .home-review-panel {
      border: 1px solid var(--home-border);
      border-radius: 12px;
      padding: 12px;
      background: rgba(255, 255, 255, 0.02);
      margin-bottom: 12px;
    }

    .home-review-panel-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 8px;
    }

    .home-review-panel-body {
      display: block;
    }

    .home-review-panel.collapsed .home-review-panel-body {
      display: none;
    }

    .home-review-panel.collapsed {
      padding-bottom: 8px;
    }

    .home-review-panel-title {
      font-size: 13px;
      font-weight: 700;
      color: var(--fg);
    }

    .home-review-page-meta {
      font-size: 11px;
      color: var(--home-muted);
      margin: 6px 0 8px;
    }

    .home-review-page-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(42px, 1fr));
      gap: 6px;
      max-height: 240px;
      overflow: auto;
      padding: 6px;
      border-radius: 10px;
      border: 1px dashed rgba(255, 255, 255, 0.12);
      background: rgba(0, 0, 0, 0.12);
    }

    .home-review-page-btn {
      padding: 8px 6px;
      border-radius: 8px;
      border: 1px solid var(--home-border);
      background: rgba(255, 255, 255, 0.03);
      color: var(--fg);
      font-size: 11px;
      cursor: pointer;
      transition: .15s;
      text-align: center;
    }

    .home-review-page-btn:hover {
      border-color: var(--home-accent);
      background: rgba(125, 211, 252, 0.12);
    }

    .home-review-page-btn.completed-range {
      background: #22c55e;
      border-color: #16a34a;
      color: #0b1220;
      font-weight: 700;
    }

    #homeReviewSearch {
      flex: 1;
      min-width: 140px;
    }

    @media (max-width: 980px) {
      .home-review-body {
        display: flex;
        flex-direction: column;
      }

      .home-review-main {
        order: -1;
      }
    }

    .home-stat-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      margin-bottom: 6px;
    }

    .home-stat-item {
      text-align: center;
      padding: 12px;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 10px;
      border: 1px solid var(--home-border);
    }

    .home-stat-value {
      display: block;
      font-size: 1.9rem;
      font-weight: 800;
      color: var(--home-accent);
    }

    .home-stat-label {
      font-size: 11px;
      color: var(--home-muted);
    }

    .home-card-footer {
      margin-top: 10px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .home-hint {
      font-size: 12px;
      color: var(--home-muted);
      margin-top: 6px;
    }

    .home-empty {
      text-align: center;
      padding: 18px;
      color: var(--home-muted);
      font-size: 13px;
      border: 1px dashed var(--home-border);
      border-radius: 12px;
    }

    .home-compact .home-card {
      padding: 14px;
      min-height: 150px;
    }

    .home-compact .home-stat-grid {
      gap: 8px;
    }

    .home-compact .home-card h3 {
      margin-bottom: 6px;
    }

    .completed-viewer {
      display: flex;
      flex-direction: column;
      gap: 14px;
      padding: 16px;
      background: linear-gradient(135deg, rgba(11, 17, 27, 0.95), rgba(18, 24, 37, 0.96));
      border: 1px solid var(--home-border);
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.35);
    }

    .completed-head {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 12px;
      flex-wrap: wrap;
    }

    .completed-kicker {
      font-size: 12px;
      letter-spacing: .05em;
      color: var(--home-muted);
      text-transform: uppercase;
    }

    .completed-title {
      margin: 2px 0 4px;
      font-size: 1.6rem;
      font-weight: 800;
    }

    .completed-sub {
      margin: 0;
      color: var(--home-muted);
      font-size: 13px;
    }

    .completed-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .completed-stage {
      position: relative;
      background: radial-gradient(circle at 20% 20%, rgba(125, 211, 252, 0.07), transparent 32%), radial-gradient(circle at 80% 40%, rgba(167, 139, 250, 0.07), transparent 28%), rgba(8, 12, 20, 0.9);
      border: 1px solid var(--home-border);
      border-radius: 14px;
      min-height: 60vh;
      display: grid;
      grid-template-columns: 1fr;
      place-items: center;
      overflow: hidden;
    }

    .completed-page-label {
      position: absolute;
      top: 12px;
      left: 12px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(12, 16, 24, 0.7);
      border: 1px solid var(--home-border);
      font-size: 12px;
      color: var(--fg);
    }

    .completed-arrow {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(0, 0, 0, 0.35);
      border: 1px solid var(--home-border);
      color: #fff;
      width: 40px;
      height: 40px;
      border-radius: 12px;
      display: grid;
      place-items: center;
      cursor: pointer;
      transition: all .15s;
    }

    .completed-arrow:hover {
      background: rgba(125, 211, 252, 0.2);
      border-color: rgba(125, 211, 252, 0.5);
    }

    .completed-arrow.prev {
      left: 12px;
    }

    .completed-arrow.next {
      right: 12px;
    }

    .completed-image {
      max-width: 100%;
      max-height: 65vh;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.45);
      object-fit: contain;
    }

    .completed-footer {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .completed-slider {
      width: 100%;
      accent-color: var(--home-accent);
    }

    .completed-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .completed-chips {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .completed-chip {
      border: 1px solid var(--home-border);
      background: rgba(255, 255, 255, 0.05);
      color: var(--fg);
      border-radius: 10px;
      padding: 6px 10px;
      font-size: 12px;
      cursor: pointer;
      transition: .15s;
    }

    .completed-chip.active {
      border-color: var(--home-accent);
      color: #fff;
      background: rgba(125, 211, 252, 0.18);
    }

    .completed-status {
      font-size: 12px;
      color: var(--home-muted);
    }

    .todo-quick-preview {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin: 8px 0;
    }

    .todo-quick-preview label {
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      padding: 6px 8px;
    }

    @media (max-width: 1080px) {
      .home-shell {
        padding: 14px;
        gap: 16px;
        width: 100%;
      }

      .home-hero {
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      }

      .home-grid {
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      }

      .home-card {
        min-height: 180px;
      }

      .home-stat-grid {
        grid-template-columns: repeat(2, 1fr);
      }

      .home-actions {
        gap: 6px;
      }
    }

    @media (max-width: 720px) {
      .home-shell {
        padding: 12px;
        gap: 14px;
        width: 100%;
      }

      .home-grid {
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
        gap: 12px;
      }

      .home-card {
        min-height: 170px;
      }

      .home-task-list,
      .home-book-list,
      .home-completed-list {
        max-height: 180px;
      }

      .home-header h1 {
        font-size: 1.6rem;
      }
    }

    /* ========== Day Detail Panel ========== */
    .sc-day-detail {
      background: linear-gradient(135deg, rgba(20, 25, 35, 0.98), rgba(15, 20, 28, 0.95));
      border: 1px solid rgba(79, 140, 255, 0.3);
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.35);
    }

    .sc-dd-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .sc-dd-header h3 {
      margin: 0;
      font-size: 1.2rem;
      background: linear-gradient(135deg, #7dd3fc, #a78bfa);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .sc-dd-section {
      margin-bottom: 20px;
    }

    .sc-dd-section h4 {
      margin: 0 0 10px;
      font-size: 14px;
      color: var(--fg);
    }

    .sc-dd-tasks,
    .sc-dd-completed {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: none;
      overflow: visible;
    }

    .sc-dd-task-item {
      display: flex;
      gap: 10px;
      align-items: center;
      padding: 10px;
      background: rgba(79, 140, 255, 0.1);
      border: 1px solid rgba(79, 140, 255, 0.2);
      border-radius: 10px;
      cursor: grab;
    }

    .sc-dd-task-item.planner {
      background: rgba(125, 211, 252, 0.08);
      border-color: rgba(125, 211, 252, 0.35);
    }

    .sc-dd-task-item:active {
      cursor: grabbing;
    }

    .sc-dd-task-item.dragging {
      opacity: 0.5;
      transform: scale(0.95);
    }

    .sc-dd-task-title {
      flex: 1;
      font-size: 13px;
    }

    .sc-dd-task-pages {
      font-size: 12px;
      color: var(--muted);
    }

    /* Timer finish toast */
    .timer-finish-toast {
      position: fixed;
      right: 16px;
      bottom: 16px;
      width: min(320px, 92vw);
      padding: 16px 16px 14px;
      border-radius: 16px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid rgba(255, 255, 255, 0.12);
      box-shadow:
        0 18px 40px rgba(0, 0, 0, 0.45),
        inset 0 0 24px rgba(255, 255, 255, 0.06);
      opacity: 0;
      transform: translateY(20px);
      pointer-events: none;
      transition: opacity 200ms ease, transform 240ms cubic-bezier(0.22, 0.61, 0.36, 1);
      z-index: 10001;
    }

    .timer-finish-toast::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: 16px;
      background: radial-gradient(120% 120% at 20% 0%, rgba(56, 189, 248, 0.2), transparent 60%);
      pointer-events: none;
      opacity: 0.6;
    }

    .timer-finish-toast.show {
      opacity: 1;
      transform: translateY(0);
      pointer-events: auto;
    }

    .timer-finish-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      position: relative;
      z-index: 1;
    }

    .timer-finish-title {
      font-size: 12px;
      font-weight: 800;
      letter-spacing: 0.18em;
      color: #e2e8f0;
    }

    .timer-finish-sub {
      font-size: 12px;
      color: rgba(226, 232, 240, 0.7);
      margin-top: 2px;
    }

    .timer-finish-close {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(30, 41, 59, 0.7);
      color: #e2e8f0;
      font-size: 18px;
      cursor: pointer;
      display: grid;
      place-items: center;
      transition: transform 140ms ease, background 140ms ease;
    }

    .timer-finish-close:hover {
      transform: scale(1.05);
      background: rgba(51, 65, 85, 0.9);
    }

    .timer-finish-body {
      margin-top: 10px;
      display: grid;
      gap: 4px;
      position: relative;
      z-index: 1;
    }

    .timer-finish-time {
      font-size: 28px;
      font-weight: 800;
      color: #f8fafc;
      font-variant-numeric: tabular-nums;
      font-family: var(--viewer-clock-font, 'SFMono-Regular', 'Menlo', 'Consolas', monospace);
    }

    .timer-finish-meta {
      font-size: 12px;
      color: rgba(226, 232, 240, 0.7);
    }

    .timer-finish-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
      margin-top: 12px;
      position: relative;
      z-index: 1;
    }

    /* Lesson toast (original lesson planner) */
    .timer-finish-toast.lesson-toast {
      border-color: rgba(56, 189, 248, 0.3);
    }

    .timer-finish-toast.lesson-toast::before {
      background: radial-gradient(120% 120% at 20% 0%, rgba(56, 189, 248, 0.26), transparent 60%);
    }

    .timer-finish-toast.lesson-toast.pre::before {
      background: radial-gradient(120% 120% at 20% 0%, rgba(251, 191, 36, 0.28), transparent 60%);
    }

    .timer-finish-toast.lesson-toast.active::before {
      background: radial-gradient(120% 120% at 20% 0%, rgba(34, 197, 94, 0.24), transparent 60%);
    }

    .timer-finish-toast.lesson-toast.end {
      border-color: rgba(248, 113, 113, 0.38);
    }

    .timer-finish-toast.lesson-toast.end::before {
      background: radial-gradient(120% 120% at 20% 0%, rgba(248, 113, 113, 0.28), transparent 60%);
    }

    .timer-finish-toast.lesson-toast.stacked {
      bottom: 120px;
    }

    .timer-finish-toast.lesson-toast .timer-finish-actions {
      flex-wrap: wrap;
      justify-content: flex-start;
    }

    .sc-dd-task-actions {
      display: flex;
      gap: 4px;
    }

    .sc-dd-task-btn {
      padding: 4px 8px;
      font-size: 11px;
      border-radius: 6px;
      cursor: pointer;
      border: none;
      background: rgba(255, 255, 255, 0.1);
      color: var(--fg);
      transition: all 0.2s;
    }

    .sc-dd-task-btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .sc-dd-task-btn.delete {
      background: rgba(239, 68, 68, 0.2);
      color: #f87171;
    }

    .sc-dd-task-btn.delete:hover {
      background: rgba(239, 68, 68, 0.4);
    }

    .sc-dd-completed-item {
      display: flex;
      gap: 10px;
      align-items: center;
      padding: 8px 12px;
      background: rgba(34, 197, 94, 0.1);
      border: 1px solid rgba(34, 197, 94, 0.2);
      border-radius: 8px;
      cursor: pointer;
    }

    .sc-dd-completed-item:hover {
      background: rgba(34, 197, 94, 0.2);
    }

    .sc-dd-page-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      max-height: none;
      overflow: visible;
      margin-top: 6px;
    }

    .sc-dd-page-btn {
      padding: 4px 6px;
      font-size: 11px;
      min-width: 36px;
      height: 24px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      cursor: pointer;
      color: var(--fg);
      transition: all 0.15s;
      line-height: 1.05;
    }

    .sc-dd-page-btn:hover {
      background: rgba(79, 140, 255, 0.2);
      border-color: rgba(79, 140, 255, 0.4);
    }

    .sc-dd-page-btn.selected {
      background: rgba(79, 140, 255, 0.3);
      border-color: rgba(79, 140, 255, 0.6);
    }

    .sc-dd-page-btn.completed {
      background: rgba(34, 197, 94, 0.25);
      border-color: rgba(34, 197, 94, 0.5);
      color: #d1fae5;
      text-decoration: none;
      opacity: 1;
      cursor: default;
    }

    .sc-dd-page-btn.assigned.completed {
      background: rgba(34, 197, 94, 0.3);
      border-color: rgba(34, 197, 94, 0.65);
      color: #e2fbd7;
    }

    .sc-dd-page-btn.assigned {
      border-color: rgba(125, 211, 252, 0.55);
      background: rgba(125, 211, 252, 0.08);
    }

    .sc-dd-page-btn.dragging {
      opacity: 0.45;
    }

    .sc-fly-chip {
      position: fixed;
      z-index: 2500;
      pointer-events: none;
      background: linear-gradient(135deg, rgba(79, 140, 255, 0.9), rgba(59, 130, 246, 0.9));
      color: #fff;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 11px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      transform: translate(0, 0) scale(1);
      opacity: 1;
      transition: transform 0.42s ease, opacity 0.42s ease;
    }

    /* ========== TODO Assignment Panel ========== */
    .sc-todo-assign-panel {
      background: linear-gradient(135deg, rgba(25, 18, 35, 0.95), rgba(20, 15, 28, 0.9));
      border: 1px solid rgba(167, 141, 250, 0.2);
    }

    .sc-tap-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .sc-tap-header h3 {
      margin: 0;
    }

    .sc-tap-content {
      margin-top: 16px;
    }

    .sc-tap-select {
      display: flex;
      gap: 8px;
      margin: 12px 0;
    }

    .sc-tap-info {
      margin-bottom: 12px;
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 8px;
      font-size: 13px;
      color: var(--muted);
    }

    .sc-tap-page-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      max-height: 200px;
      overflow-y: auto;
      padding: 8px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 10px;
    }

    .sc-tap-page-btn {
      padding: 8px 12px;
      font-size: 13px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      cursor: pointer;
      color: var(--fg);
      transition: all 0.2s;
      user-select: none;
    }

    .sc-tap-page-btn:hover {
      background: rgba(167, 141, 250, 0.2);
      border-color: rgba(167, 141, 250, 0.4);
    }

    .sc-tap-page-btn.selected {
      background: rgba(167, 141, 250, 0.3);
      border-color: rgba(167, 141, 250, 0.6);
      box-shadow: 0 0 8px rgba(167, 141, 250, 0.4);
    }

    .sc-tap-page-btn.scheduled {
      background: rgba(79, 140, 255, 0.2);
      border-color: rgba(79, 140, 255, 0.4);
    }

    .sc-tap-page-btn.completed {
      background: rgba(34, 197, 94, 0.2);
      border-color: rgba(34, 197, 94, 0.4);
      text-decoration: line-through;
    }

    .sc-tap-page-btn.dragging {
      opacity: 0.5;
      transform: scale(0.9);
    }

    .sc-tap-selected {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 12px;
      padding: 10px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 8px;
    }

    .sc-day.drop-target {
      background: rgba(167, 141, 250, 0.3) !important;
      border-color: rgba(167, 141, 250, 0.6) !important;
      box-shadow: 0 0 16px rgba(167, 141, 250, 0.4);
    }

    .sc-h-day.drop-target {
      background: rgba(167, 141, 250, 0.3) !important;
      border-color: rgba(167, 141, 250, 0.6) !important;
    }

    .card {
      background: rgba(255, 255, 255, .04);
      border: 1px solid var(--ring);
      border-radius: 14px;
      padding: 16px;
      margin-bottom: 12px;
      position: relative;
      overflow: hidden;
      transition: transform var(--dur-sm) var(--ease-soft), border-color var(--dur-xs), box-shadow var(--dur-sm);
      animation: cardFloat var(--dur-lg) var(--ease-soft) both;
    }

    .card::after {
      content: "";
      position: absolute;
      inset: -40% 0 60% 0;
      background: linear-gradient(120deg, rgba(255, 255, 255, .08), transparent 65%);
      opacity: .08;
      transform: translateX(-80%);
      filter: blur(8px);
      transition: transform 1.6s var(--ease-soft), opacity 1.4s var(--ease-soft);
      pointer-events: none;
    }

    .card:hover {
      transform: translateY(-6px);
      border-color: rgba(255, 255, 255, .2);
      box-shadow: 0 18px 45px rgba(0, 0, 0, .45);
    }

    .card:hover::after {
      transform: translateX(-10%);
      opacity: .2;
    }

    .row {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 8px
    }

    select,
    input[type="time"],
    input[type="text"],
    input[type="color"],
    input[type="number"] {
      background: rgba(0, 0, 0, .3);
      color: var(--fg);
      border: 1px solid var(--ring);
      border-radius: 8px;
      padding: 8px;
      font-size: 14px;
      transition: border-color var(--dur-xs), box-shadow var(--dur-xs);
    }

    select:focus-visible,
    input:focus-visible {
      outline: none;
      border-color: rgba(77, 163, 255, .8);
      box-shadow: 0 0 0 2px rgba(77, 163, 255, .25), 0 12px 26px rgba(0, 0, 0, .45);
    }

    button,
    .btn {
      appearance: none;
      border: none;
      border-radius: 999px;
      padding: 10px 16px;
      font-size: 13px;
      color: #fff;
      background: var(--accent);
      cursor: pointer;
      position: relative;
      overflow: hidden;
      transition: transform var(--dur-xs) var(--ease-soft), box-shadow var(--dur-xs), background var(--dur-xs), color var(--dur-xs);
      box-shadow: 0 8px 20px rgba(77, 163, 255, .35);
    }

    button::before,
    .btn::before {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(120deg, rgba(255, 255, 255, .35), transparent 60%);
      opacity: 0;
      transition: opacity var(--dur-xs);
      pointer-events: none;
    }

    button:hover::before,
    .btn:hover::before {
      opacity: .7;
    }

    button:hover,
    .btn:hover {
      transform: translateY(-1px) scale(1.01);
    }

    button:active,
    .btn:active {
      transform: translateY(1px) scale(.98);
    }

    button.ghost {
      background: transparent;
      color: var(--fg);
      border: 1px solid var(--ring);
      box-shadow: none;
    }

    button.ghost::before {
      display: none;
    }

    button.danger {
      background: #e74c3c;
      box-shadow: 0 10px 20px rgba(231, 76, 60, .45);
    }

    .list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 300px;
      overflow: auto
    }

    .item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      background: rgba(0, 0, 0, .2);
      border: 1px solid var(--ring);
      border-radius: 10px;
      padding: 10px;
      transition: transform var(--dur-xs), border-color var(--dur-xs), box-shadow var(--dur-xs);
    }

    .item:hover {
      transform: translateX(6px);
      border-color: rgba(255, 255, 255, .2);
      box-shadow: 0 10px 24px rgba(0, 0, 0, .35);
    }

    .badge {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      flex-shrink: 0
    }

    .tiny {
      font-size: 12px;
      color: var(--muted)
    }

    .notification {
      animation: slideDown var(--dur-sm) var(--ease-emph) both, pulseGlow 2.4s ease-out infinite;
    }

    @keyframes fadeSlideUp {
      0% {
        opacity: 0;
        transform: translate3d(0, 16px, 0);
      }

      100% {
        opacity: 1;
        transform: translate3d(0, 0, 0);
      }
    }

    @keyframes cardFloat {
      0% {
        opacity: 0;
        transform: translateY(14px);
      }

      60% {
        opacity: 1;
      }

      100% {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes slideDown {
      0% {
        opacity: 0;
        transform: translateY(-10px);
      }

      100% {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes pulseGlow {

      0%,
      100% {
        box-shadow: 0 12px 30px rgba(77, 163, 255, .25);
      }

      50% {
        box-shadow: 0 14px 40px rgba(255, 255, 255, .35);
      }
    }

    @keyframes fadeBackdrop {
      0% {
        opacity: 0;
      }

      100% {
        opacity: 1;
      }
    }

    @keyframes popCard {
      0% {
        opacity: 0;
        transform: translateY(12px) scale(.95);
      }

      60% {
        opacity: 1;
      }

      100% {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    @media (prefers-reduced-motion:reduce) {

      *,
      *::before,
      *::after {
        animation-duration: .01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: .01ms !important;
      }

      body::before,
      body::after {
        animation: none;
      }
    }

    .clock-wrap {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      position: relative;
      flex-direction: column
    }

    svg {
      max-width: 500px;
      width: 100%;
      height: auto;
      display: block;
      touch-action: none
    }

    .drag-hint {
      position: absolute;
      bottom: 30px;
      background: var(--accent);
      color: #fff;
      padding: 10px 16px;
      border-radius: 8px;
      font-size: 18px;
      font-weight: 700;
      pointer-events: none;
      opacity: 0;
      transition: .2s
    }

    .drag-hint.show {
      opacity: 1
    }

    #plannerDirectGroup {
      pointer-events: none;
    }

    #plannerDirectGroup .guide-fill {
      fill: rgba(77, 163, 255, 0.28);
      filter: url(#shadow);
    }

    #plannerDirectGroup .guide-edge {
      fill: none;
      stroke: rgba(255, 255, 255, 0.95);
      stroke-width: 2.2;
      stroke-dasharray: 10 6;
    }

    .planner-direct-label {
      position: absolute;
      top: 16px;
      right: 16px;
      padding: 6px 12px;
      border-radius: 10px;
      background: rgba(6, 10, 18, .65);
      border: 1px solid rgba(255, 255, 255, .2);
      color: var(--fg);
      font-size: 13px;
      font-weight: 700;
      letter-spacing: .02em;
      display: none;
      backdrop-filter: blur(6px);
    }

    .timer-item,
    .sw-item {
      background: rgba(0, 0, 0, .2);
      border: 1px solid var(--ring);
      border-radius: 10px;
      padding: 16px;
      margin-bottom: 8px;
      transition: transform var(--dur-sm), border-color var(--dur-xs), box-shadow var(--dur-sm);
      animation: fadeSlideUp var(--dur-md) var(--ease-soft) both;
    }

    .timer-item:hover,
    .sw-item:hover {
      transform: translateY(-4px);
      border-color: rgba(255, 255, 255, .2);
      box-shadow: 0 12px 28px rgba(0, 0, 0, .35);
    }

    .timer-display {
      font-size: clamp(56px, 9vw, 120px);
      font-weight: 700;
      text-align: center;
      margin: 16px 0;
      font-family: monospace;
      line-height: 1.05;
      letter-spacing: 0.04em
    }

    .timer-gauge {
      width: 100%;
      height: 10px;
      background: rgba(0, 0, 0, .3);
      border-radius: 10px;
      overflow: hidden;
      margin: 12px 0;
      position: relative
    }

    .timer-gauge-fill {
      height: 100%;
      transition: width .3s linear;
      position: absolute;
      left: 0;
      top: 0
    }

    .timer-btns {
      display: flex;
      gap: 8px;
      justify-content: center;
      flex-wrap: wrap
    }

    .sw-time {
      font-size: 32px;
      font-weight: 700;
      text-align: center;
      margin: 8px 0;
      font-family: monospace
    }

    .sw-btns {
      display: flex;
      gap: 8px;
      justify-content: center;
      margin-top: 12px
    }

    .status-bar {
      background: rgba(0, 0, 0, .3);
      border: 1px solid var(--ring);
      border-radius: 10px;
      padding: 12px;
      margin-top: 12px;
      text-align: center;
      font-size: 16px;
      font-weight: 700;
      font-family: monospace
    }

    @keyframes pulse {

      0%,
      100% {
        transform: scale(1)
      }

      50% {
        transform: scale(1.05)
      }
    }

    @keyframes shake {

      0%,
      100% {
        transform: translateX(0)
      }

      25% {
        transform: translateX(-10px)
      }

      75% {
        transform: translateX(10px)
      }
    }

    .alert {
      animation: pulse .5s ease-in-out 4
    }

    .notification {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--accent);
      color: #fff;
      padding: 16px 32px;
      border-radius: 12px;
      font-weight: 700;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0, 0, 0, .3);
      animation: shake .5s
    }

    .study-panel {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 12px
    }

    .study-stat {
      background: rgba(0, 0, 0, .2);
      border: 1px solid var(--ring);
      border-radius: 10px;
      padding: 12px;
      text-align: center
    }

    .study-stat-value {
      font-size: 28px;
      font-weight: 700;
      color: var(--accent);
      margin: 4px 0
    }

    .study-stat-label {
      font-size: 11px;
      color: var(--muted)
    }

    .page-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
      gap: 6px;
      margin-top: 12px;
      max-height: 300px;
      overflow: auto;
      padding: 4px
    }

    .page-btn {
      padding: 12px 8px;
      background: rgba(0, 0, 0, .2);
      border: 1px solid var(--ring);
      border-radius: 8px;
      cursor: pointer;
      transition: .2s;
      text-align: center;
      font-size: 13px
    }

    .page-btn:hover {
      background: rgba(0, 0, 0, .4)
    }

    .page-btn.completed {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent)
    }

    .todo-controls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      margin-bottom: 8px
    }

    .todo-list {
      display: block;
      column-gap: 10px;
    }

    .todo-list.cards {
      column-width: 260px;
    }

    .todo-entry {
      border: 1px solid var(--ring);
      border-radius: 12px;
      padding: 12px;
      background: rgba(0, 0, 0, .2);
      break-inside: avoid;
      width: 100%;
      margin-bottom: 10px;
    }

    .todo-head {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
      align-items: flex-start;
    }

    .todo-title {
      font-weight: 700;
      font-size: 15px;
    }

    .todo-meta {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      color: var(--muted);
      font-size: 12px;
    }

    .todo-pages {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin: 8px 0;
    }

    .todo-pages.collapsed {
      display: none;
    }

    .todo-chip {
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid var(--ring);
      background: rgba(255, 255, 255, .04);
      cursor: pointer;
      font-size: 12px;
    }

    .todo-chip.done {
      background: rgba(79, 140, 255, .2);
      border-color: var(--accent);
      color: #fff;
      text-decoration: line-through;
    }

    .todo-progress {
      height: 8px;
      background: rgba(255, 255, 255, .08);
      border-radius: 999px;
      overflow: hidden;
      margin: 6px 0;
    }

    .todo-progress .bar {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), #94a3b8);
    }

    .todo-actions {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    .todo-badge {
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(255, 255, 255, .08);
      border: 1px solid var(--ring);
      font-size: 11px;
      color: var(--muted);
    }

    .todo-summary {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      font-size: 12px;
      color: var(--muted);
      margin: 6px 0;
    }

    .todo-summary strong {
      color: var(--fg);
    }

    .todo-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }

    .todo-table th,
    .todo-table td {
      border-bottom: 1px solid var(--ring);
      padding: 6px 8px;
      text-align: left;
    }

    .todo-table tr.done td {
      color: var(--muted);
      text-decoration: line-through;
    }

    .todo-table .page-btn {
      padding: 4px 8px;
      font-size: 12px;
    }

    .todo-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border: 1px solid var(--ring);
      border-radius: 10px;
      background: rgba(255, 255, 255, .04);
    }

    .todo-quick {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      align-items: center;
      margin-top: 6px;
    }

    .todo-quick .chip-btn {
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid var(--ring);
      background: rgba(255, 255, 255, .04);
      cursor: pointer;
      font-size: 12px;
      color: var(--fg);
    }

    .todo-quick .chip-btn:hover {
      background: rgba(255, 255, 255, .08);
    }

    .todo-form.collapsed {
      display: none;
    }

    .todo-card {
      background: linear-gradient(180deg, rgba(21, 26, 38, .9) 0%, rgba(14, 18, 28, .92) 100%);
      border: 1px solid rgba(82, 112, 158, .25);
      box-shadow: 0 14px 35px rgba(0, 0, 0, .45), inset 0 1px 0 rgba(255, 255, 255, .04);
    }

    .todo-form h3,
    .todo-card h3 {
      letter-spacing: .02em;
    }

    .todo-meta-aux {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      font-size: 12px;
      color: var(--muted);
    }

    .todo-chip-date {
      padding: 6px 10px;
      border-radius: 10px;
      background: rgba(79, 140, 255, .15);
      border: 1px solid rgba(79, 140, 255, .35);
      color: #cfe2ff;
      font-weight: 600;
    }

    .page-blocks {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 6px;
    }

    .page-block {
      padding: 6px 9px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, .1);
      background: rgba(255, 255, 255, .04);
      color: #e8edf7;
      font-size: 11.5px;
      cursor: pointer;
      user-select: none;
    }

    .page-block:hover {
      background: rgba(255, 255, 255, .08);
    }

    .page-block.selected {
      background: rgba(79, 140, 255, .18);
      border-color: rgba(79, 140, 255, .4);
      color: #e1eaff;
    }

    .page-block.done {
      background: rgba(34, 197, 94, .16);
      border-color: rgba(74, 222, 128, .4);
      color: #d1fae5;
      text-decoration: line-through;
    }

    .page-block.scheduled {
      background: rgba(234, 179, 8, .16);
      border-color: rgba(234, 179, 8, .4);
      color: #fef9c3;
    }

    .todo-page-overlay {
      position: fixed;
      inset: 0;
      display: none;
      place-items: center;
      background: transparent;
      z-index: 3200;
    }

    .todo-page-overlay.open {
      display: grid;
    }

    .todo-page-sheet {
      width: min(900px, 96vw);
      max-height: 80vh;
      position: relative;
      background: linear-gradient(180deg, rgba(15, 20, 32, .98), rgba(10, 14, 24, .98));
      border: 1px solid rgba(79, 140, 255, .3);
      border-radius: 16px;
      box-shadow: 0 20px 50px rgba(0, 0, 0, .45);
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      cursor: grab;
    }

    .todo-page-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
      gap: 6px;
      overflow: auto;
      padding: 4px;
      min-height: 240px;
      max-height: 60vh;
    }

    /* DaiGPT launcher */
    #daiOverlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: flex-start;
      justify-content: center;
      background: transparent;
      z-index: 1800;
      pointer-events: none;
    }

    #daiPanel {
      position: fixed;
      left: 50%;
      top: 12vh;
      margin-top: 0;
      width: min(820px, 94vw);
      max-width: 96vw;
      min-width: 520px;
      min-height: 200px;
      max-height: 72vh;
      padding: 16px;
      border-radius: 18px;
      background: radial-gradient(140% 120% at 50% 0%, rgba(94, 126, 255, .24), rgba(12, 18, 30, .94));
      border: 1px solid rgba(122, 151, 255, .35);
      box-shadow: 0 20px 60px rgba(0, 0, 0, .55), 0 0 0 1px rgba(255, 255, 255, .05) inset;
      transform: translate(-50%, -8px) scale(.96);
      opacity: 0;
      transition: transform .28s cubic-bezier(.2, .7, .3, 1.1), opacity .28s ease, box-shadow .28s ease;
      pointer-events: auto;
      box-sizing: border-box;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      cursor: grab;
    }

    #daiPanel.dai-compact {
      min-height: auto;
      height: auto;
      max-height: 60vh;
      padding: 10px 14px 8px;
      transition: transform .28s cubic-bezier(.2, .7, .3, 1.1), opacity .28s ease, box-shadow .28s ease, height .22s ease, min-height .22s ease, padding .22s ease;
    }

    #daiPanel.dai-no-trans {
      transition: none !important;
    }

    #daiOverlay.open #daiPanel {
      opacity: 1;
      transform: translate(-50%, 0) scale(1);
      box-shadow: 0 26px 60px rgba(0, 0, 0, .65), 0 0 0 1px rgba(255, 255, 255, .08) inset, 0 0 30px rgba(123, 156, 255, .3);
      animation: daiGlow 1.6s ease forwards;
    }

    #daiPanel.dragging,
    #daiOverlay.open #daiPanel.dragging {
      transform: translate(0, 0) scale(1);
      cursor: grabbing;
    }

    #daiPanel.exec {
      animation: panelExec .38s ease;
    }

    .dai-resize-handle {
      position: absolute;
      background: transparent;
      z-index: 5;
      pointer-events: auto;
    }

    .dai-resize-e {
      cursor: ew-resize;
      top: 10px;
      right: -6px;
      bottom: 30px;
      width: 12px;
    }

    .dai-resize-s {
      cursor: ns-resize;
      left: 10px;
      right: 30px;
      bottom: -6px;
      height: 12px;
    }

    .dai-resize-se {
      cursor: nwse-resize;
      right: -7px;
      bottom: -7px;
      width: 16px;
      height: 16px;
    }

    @keyframes daiGlow {
      0% {
        box-shadow: 0 24px 48px rgba(0, 0, 0, .6), 0 0 0 1px rgba(255, 255, 255, .05) inset, 0 0 6px rgba(123, 156, 255, .2);
      }

      40% {
        box-shadow: 0 28px 64px rgba(0, 0, 0, .7), 0 0 0 1px rgba(255, 255, 255, .08) inset, 0 0 22px rgba(123, 156, 255, .36);
      }

      100% {
        box-shadow: 0 24px 60px rgba(0, 0, 0, .65), 0 0 0 1px rgba(255, 255, 255, .08) inset, 0 0 14px rgba(123, 156, 255, .28);
      }
    }

    @keyframes panelExec {
      0% {
        box-shadow: 0 28px 70px rgba(0, 0, 0, .7), 0 0 0 1px rgba(255, 255, 255, .1) inset, 0 0 20px rgba(123, 156, 255, .45);
        transform: scale(1.01) translateY(-1px);
      }

      100% {
        box-shadow: 0 24px 60px rgba(0, 0, 0, .65), 0 0 0 1px rgba(255, 255, 255, .08) inset, 0 0 14px rgba(123, 156, 255, .28);
        transform: scale(1) translateY(0);
      }
    }

    .dai-input-wrap {
      position: relative;
      width: 100%;
      margin-bottom: 10px;
    }

    #daiInput {
      width: 100%;
      padding: 14px 16px;
      padding-right: 104px;
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, .1);
      background: rgba(6, 10, 18, .8);
      color: #eaf2ff;
      font-size: 18px;
      font-weight: 700;
      outline: none;
      box-shadow: 0 12px 28px rgba(0, 0, 0, .4);
    }

    #daiSendBtn {
      position: absolute;
      top: 50%;
      right: 10px;
      transform: translateY(-50%);
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid rgba(123, 156, 255, .55);
      background: linear-gradient(135deg, rgba(123, 156, 255, .28), rgba(123, 156, 255, .12));
      color: #eaf2ff;
      cursor: pointer;
      box-shadow: 0 8px 20px rgba(0, 0, 0, .35);
    }

    #daiSendBtn:hover {
      background: linear-gradient(135deg, rgba(123, 156, 255, .35), rgba(123, 156, 255, .18));
    }

    #daiContent {
      display: grid;
      grid-template-columns: minmax(260px, 1fr) minmax(320px, 1.1fr);
      gap: 12px;
      margin-top: 4px;
      align-items: start;
      flex: 1;
      min-height: 110px;
      overflow: auto;
    }

    #daiPanel.dai-compact #daiContent {
      max-height: 0;
      min-height: 0;
      overflow: hidden;
      padding-top: 0;
      margin-top: 0;
      opacity: 0;
      flex: 0 0 auto;
      transition: max-height .2s ease, opacity .2s ease, padding .2s ease, margin .2s ease;
    }

    @media (max-width: 820px) {
      #daiContent {
        grid-template-columns: 1fr;
      }
    }

    #daiResultList {
      margin: 6px 0 0;
      padding: 0;
      list-style: none;
      max-height: 64vh;
      overflow: auto;
      display: grid;
      gap: 8px;
      font-weight: 500;
    }

    #daiDetail {
      max-height: 64vh;
      overflow: auto;
    }

    #daiResultList .item {
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: 8px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, .08);
      background: rgba(255, 255, 255, .02);
      color: #cdd8f5;
      font-size: 13px;
      transition: transform .12s ease, border-color .12s ease, background .12s ease;
    }

    #daiResultList .item:hover {
      transform: translateY(-1px);
      background: rgba(255, 255, 255, .05);
    }

    #daiResultList .item.active {
      border-color: rgba(123, 156, 255, .6);
      box-shadow: 0 0 0 1px rgba(123, 156, 255, .18) inset;
      background: rgba(123, 156, 255, .08);
    }

    #daiResultList .en {
      font-weight: 700;
      color: #eaf2ff;
      font-size: 14px;
    }

    #daiResultList .jp {
      color: #c7d4f0;
      font-size: 13px;
    }

    #daiResultList .pos {
      color: #8fa3c8;
      font-size: 12px;
    }

    #daiResultList .muted {
      color: #8fa3c8;
      font-size: 12px;
    }

    #daiResultList .fav {
      border: 1px solid rgba(255, 255, 255, .15);
      background: rgba(255, 255, 255, .06);
      border-radius: 8px;
      color: #ffd166;
      padding: 4px 8px;
      cursor: pointer;
      font-size: 12px;
    }

    #daiResultList .fav:hover {
      background: rgba(255, 255, 255, .12);
    }

    #daiDetail {
      padding: 12px;
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, .08);
      background: rgba(6, 10, 18, .65);
      min-height: 200px;
    }

    #daiDetail.hidden {
      display: none;
    }

    .timeline-container {
      position: relative;
      width: 100%;
      height: 120px;
      background: rgba(0, 0, 0, .3);
      border: 1px solid var(--ring);
      border-radius: 10px;
      overflow: hidden;
      margin-top: 12px
    }

    .timeline-scroll {
      position: relative;
      width: 100%;
      height: 100%;
      overflow-x: auto;
      scroll-behavior: smooth
    }

    .hp-bar-container {
      width: 100%;
      max-width: 520px;
      margin: 8px auto 0;
      display: none;
      --hp-segments: 12;
      --hp-base-transform: translateX(0);
      --hp-bar-height: 30px;
      --hp-bar-bg: linear-gradient(180deg, #0a1117 0%, #05090f 60%, #0a141d 100%);
      --hp-bar-border: #154432;
      --hp-bar-shadow: inset 0 1px 2px rgba(255, 255, 255, .08), inset 0 -2px 6px rgba(0, 0, 0, .55), 0 8px 20px rgba(0, 0, 0, .35);
      --hp-fill: linear-gradient(180deg, rgb(27, 181, 20) 0%, rgb(125, 235, 31) 100%);
      --hp-fill-shadow: inset 0 1px 2px rgba(255, 255, 255, .18), inset 0 -2px 4px rgba(0, 0, 0, .45), 0 0 16px rgba(16, 168, 110, .4);
      --hp-damage: linear-gradient(180deg, rgba(255, 72, 72, .85) 0%, rgba(207, 48, 48, .85) 100%);
      --hp-damage-shadow: 0 0 14px rgba(255, 72, 72, .35);
    }

    .hp-bar-container.active {
      display: block
    }

    .hp-bar-container.clickable {
      cursor: pointer;
      pointer-events: auto;
    }

    .hp-bar-outer {
      width: 100%;
      height: var(--hp-bar-height);
      background: var(--hp-bar-bg);
      border: 2px solid var(--hp-bar-border);
      border-radius: 10px;
      overflow: hidden;
      position: relative;
      box-shadow: var(--hp-bar-shadow);
    }

    .hp-bar-container.style-standard {}

    /* design variations */
    .hp-bar-container.style-glass {
      --hp-bar-bg: linear-gradient(180deg, rgba(255, 255, 255, 0.3) 0%, rgba(255, 255, 255, 0.12) 12%, rgba(12, 18, 26, 0.65) 100%);
      --hp-bar-border: rgba(255, 255, 255, 0.55);
      --hp-bar-shadow: inset 0 1px 2px rgba(255, 255, 255, .6), inset 0 -2px 6px rgba(0, 0, 0, .45), 0 10px 24px rgba(0, 0, 0, .35);
      --hp-damage: linear-gradient(180deg, rgba(255, 120, 120, .9) 0%, rgba(210, 60, 60, .95) 100%);
      --hp-damage-shadow: 0 0 18px rgba(255, 120, 120, .4);
    }

    .hp-bar-container.style-translucent {
      --hp-bar-bg: linear-gradient(180deg, rgba(15, 23, 35, 0.42) 0%, rgba(7, 12, 20, 0.38) 100%);
      --hp-bar-border: rgba(255, 255, 255, 0.18);
      --hp-bar-shadow: inset 0 1px 2px rgba(255, 255, 255, .12), inset 0 -2px 4px rgba(0, 0, 0, .35);
      --hp-fill: linear-gradient(180deg, rgba(67, 190, 120, .9) 0%, rgba(64, 220, 150, .8) 100%);
      --hp-fill-shadow: inset 0 1px 2px rgba(255, 255, 255, .15), inset 0 -2px 4px rgba(0, 0, 0, .35), 0 0 12px rgba(64, 220, 150, .35);
      --hp-damage: linear-gradient(180deg, rgba(255, 110, 110, .65) 0%, rgba(210, 70, 70, .75) 100%);
      --hp-damage-shadow: 0 0 10px rgba(255, 110, 110, .32);
    }

    .hp-bar-container.style-muted {
      --hp-bar-bg: linear-gradient(180deg, #0c131d 0%, #0a111a 100%);
      --hp-bar-border: #1f2a38;
      --hp-bar-shadow: inset 0 1px 2px rgba(255, 255, 255, .05), inset 0 -2px 4px rgba(0, 0, 0, .5);
      --hp-fill: linear-gradient(180deg, #1f8f54 0%, #28b56a 100%);
      --hp-fill-shadow: inset 0 1px 2px rgba(255, 255, 255, .12), inset 0 -2px 4px rgba(0, 0, 0, .45), 0 0 10px rgba(40, 181, 106, .28);
      --hp-damage: linear-gradient(180deg, rgba(220, 80, 80, .7) 0%, rgba(170, 40, 40, .8) 100%);
      --hp-damage-shadow: 0 0 10px rgba(220, 80, 80, .28);
    }

    /* size variations (色は変えない) */
    .hp-bar-container.size-normal {
      --hp-bar-height: 30px;
      max-width: 520px;
    }

    .hp-bar-container.size-short {
      --hp-bar-height: 22px;
      max-width: 520px;
    }

    .hp-bar-container.size-narrow {
      --hp-bar-height: 26px;
      width: 52% !important;
      max-width: 260px;
      min-width: 120px;
      margin-left: auto;
      margin-right: auto;
    }

    .hp-bar-bg {
      position: absolute;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: transparent;
      z-index: 0;
    }

    .hp-bar-ticks {
      position: absolute;
      inset: 3px;
      border-radius: 8px;
      pointer-events: none;
      --hp-tick: 1.6px;
      background-size: calc(100%/var(--hp-segments, 12)) 100%;
      background-position: 0 0;
      /* 1区画目の終端から刻み開始 */
      background-repeat: repeat-x;
      background-image: linear-gradient(to right,
          transparent 0,
          transparent calc(100% - var(--hp-tick)),
          rgba(235, 255, 245, .75) calc(100% - var(--hp-tick)),
          rgba(235, 255, 245, .75) 100%);
      mix-blend-mode: screen;
      opacity: .65;
      z-index: 5;
      clip-path: inset(0 calc((100% / var(--hp-segments, 12)) / 2) 0 calc((100% / var(--hp-segments, 12)) / 2));
      -webkit-clip-path: inset(0 calc((100% / var(--hp-segments, 12)) / 2) 0 calc((100% / var(--hp-segments, 12)) / 2));
    }

    .hp-bar-fill {
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      transition: width .45s cubic-bezier(0.33, 0, 0.2, 1);
      border-radius: 8px;
      background: var(--hp-fill);
      box-shadow: var(--hp-fill-shadow);
      will-change: width;
      z-index: 2;
    }

    .hp-bar-afterglow {
      display: none;
    }

    .hp-bar-damage {
      position: absolute;
      inset: 0;
      border-radius: 8px;
      pointer-events: none;
      background: var(--hp-damage);
      box-shadow: var(--hp-damage-shadow);
      width: 0%;
      opacity: 0;
      transition: width .55s cubic-bezier(.25, .7, .2, 1), opacity .35s ease;
      mix-blend-mode: screen;
      z-index: 3;
    }

    .hp-bar-shine {
      display: none;
    }

    .hp-bar-container.overtime .hp-bar-fill {
      background: linear-gradient(180deg, #7f1d1d 0%, #dc2626 55%, #fca5a5 100%);
      box-shadow:
        inset 0 1px 2px rgba(255, 255, 255, .12),
        inset 0 -2px 4px rgba(0, 0, 0, .55),
        0 0 16px rgba(239, 68, 68, .45);
    }

    .hp-bar-container.overtime .hp-bar-afterglow {
      display: none;
    }

    .hp-bar-container.overtime .hp-bar-label {
      color: #000;
    }

    .hp-bar-container.break .hp-bar-fill {
      background: linear-gradient(180deg, #1e40af 0%, #1e3a8a 65%, #172554 100%);
      box-shadow:
        inset 0 1px 2px rgba(255, 255, 255, .18),
        inset 0 -2px 4px rgba(0, 0, 0, .45),
        0 0 18px rgba(30, 64, 175, .45);
    }

    .hp-bar-container.break .hp-bar-damage {
      background: linear-gradient(180deg, rgba(30, 64, 175, .6) 0%, rgba(30, 58, 138, .75) 100%);
      box-shadow: 0 0 14px rgba(30, 64, 175, .35);
    }

    .hp-bar-container.break .hp-bar-label {
      color: #000;
    }

    .hp-bar-container {
      pointer-events: none;
    }

    .hp-bar-container.clickable {
      cursor: default;
    }

    .hp-bar-outer.click-target {
      pointer-events: auto;
      cursor: pointer;
    }

    .hp-bar-label {
      pointer-events: auto;
      cursor: pointer;
      user-select: none;
      display: block;
      text-align: center;
      width: auto;
      max-width: 520px;
      padding: 6px 8px 2px;
      margin: 8px auto 0;
      line-height: 1.3;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      box-sizing: border-box;
    }

    .hp-bar-container.clickable .hp-bar-label {
      cursor: pointer;
    }

    .hp-bar-container.clickable .hp-bar-outer {
      transition: transform .18s cubic-bezier(.17, .67, .35, 1.35), box-shadow .2s ease;
    }

    .hp-bar-container.clickable.press .hp-bar-outer {
      transform: scale(1.04);
      box-shadow: 0 12px 26px rgba(53, 176, 255, .25), var(--hp-bar-shadow);
    }

    .hp-bar-container.clickable.press .hp-bar-fill {
      filter: drop-shadow(0 0 10px rgba(79, 140, 255, .35));
    }

    @keyframes hpPressPop {
      0% {
        transform: var(--hp-base-transform) scale(1);
      }

      35% {
        transform: var(--hp-base-transform) scale(1.05);
      }

      70% {
        transform: var(--hp-base-transform) scale(0.985);
      }

      100% {
        transform: var(--hp-base-transform) scale(1);
      }
    }

    .hp-bar-container.clickable.burst {
      animation: hpPressPop .36s ease;
    }

    /* shake variations */
    @keyframes hpShakeX {
      0% {
        transform: var(--hp-base-transform) translateX(0);
      }

      18% {
        transform: var(--hp-base-transform) translateX(-1.6px);
      }

      36% {
        transform: var(--hp-base-transform) translateX(1.4px);
      }

      54% {
        transform: var(--hp-base-transform) translateX(-0.9px);
      }

      72% {
        transform: var(--hp-base-transform) translateX(0.6px);
      }

      88% {
        transform: var(--hp-base-transform) translateX(-0.3px);
      }

      100% {
        transform: var(--hp-base-transform) translateX(0);
      }
    }

    @keyframes hpShakeTilt {
      0% {
        transform: var(--hp-base-transform) translate(0, 0) rotate(0deg);
      }

      16% {
        transform: var(--hp-base-transform) translate(-1px, -0.35px) rotate(-0.45deg);
      }

      32% {
        transform: var(--hp-base-transform) translate(1.1px, 0.35px) rotate(0.4deg);
      }

      52% {
        transform: var(--hp-base-transform) translate(-0.8px, 0.1px) rotate(-0.28deg);
      }

      72% {
        transform: var(--hp-base-transform) translate(0.55px, 0) rotate(0.16deg);
      }

      90% {
        transform: var(--hp-base-transform) translate(-0.2px, 0) rotate(-0.08deg);
      }

      100% {
        transform: var(--hp-base-transform) translate(0, 0) rotate(0deg);
      }
    }

    @keyframes hpShakeBounce {
      0% {
        transform: var(--hp-base-transform) translate(0, 0);
      }

      18% {
        transform: var(--hp-base-transform) translate(-1.2px, -0.5px);
      }

      36% {
        transform: var(--hp-base-transform) translate(1px, 0.8px);
      }

      52% {
        transform: var(--hp-base-transform) translate(-0.8px, 0.35px);
      }

      70% {
        transform: var(--hp-base-transform) translate(0.5px, -0.2px);
      }

      88% {
        transform: var(--hp-base-transform) translate(-0.25px, 0.1px);
      }

      100% {
        transform: var(--hp-base-transform) translate(0, 0);
      }
    }

    @keyframes hpShakeRumble {
      0% {
        transform: var(--hp-base-transform) translate(0, 0);
      }

      10% {
        transform: var(--hp-base-transform) translate(-1.4px, 0.3px);
      }

      20% {
        transform: var(--hp-base-transform) translate(1.6px, -0.2px);
      }

      30% {
        transform: var(--hp-base-transform) translate(-1.1px, 0.2px);
      }

      40% {
        transform: var(--hp-base-transform) translate(0.9px, -0.4px);
      }

      50% {
        transform: var(--hp-base-transform) translate(-0.7px, 0.3px);
      }

      60% {
        transform: var(--hp-base-transform) translate(0.6px, -0.2px);
      }

      70% {
        transform: var(--hp-base-transform) translate(-0.4px, 0.1px);
      }

      80% {
        transform: var(--hp-base-transform) translate(0.25px, 0);
      }

      100% {
        transform: var(--hp-base-transform) translate(0, 0);
      }
    }

    @keyframes hpShakeQuake {
      0% {
        transform: var(--hp-base-transform) translate(0, 0) rotate(0deg) scale(1);
      }

      12% {
        transform: var(--hp-base-transform) translate(-2.4px, -0.4px) rotate(-0.9deg) scale(1.01);
      }

      24% {
        transform: var(--hp-base-transform) translate(2.2px, 0.6px) rotate(0.85deg) scale(1.01);
      }

      38% {
        transform: var(--hp-base-transform) translate(-1.9px, 0.2px) rotate(-0.65deg) scale(1.005);
      }

      52% {
        transform: var(--hp-base-transform) translate(1.6px, -0.3px) rotate(0.55deg) scale(1.003);
      }

      70% {
        transform: var(--hp-base-transform) translate(-1px, 0.1px) rotate(-0.4deg) scale(1.002);
      }

      88% {
        transform: var(--hp-base-transform) translate(0.6px, -0.05px) rotate(0.22deg) scale(1.001);
      }

      100% {
        transform: var(--hp-base-transform) translate(0, 0) rotate(0deg) scale(1);
      }
    }

    .hp-bar-container.hit {
      animation: hpShakeX .58s cubic-bezier(.25, .85, .3, 1.2)
    }

    .hp-bar-container.shake-tilt.hit {
      animation: hpShakeTilt .62s cubic-bezier(.2, .9, .28, 1.25)
    }

    .hp-bar-container.shake-bounce.hit {
      animation: hpShakeBounce .64s cubic-bezier(.2, .9, .28, 1.2)
    }

    .hp-bar-container.shake-rumble.hit {
      animation: hpShakeRumble .52s cubic-bezier(.3, .7, .35, 1.1)
    }

    .hp-bar-container.shake-quake.hit {
      animation: hpShakeQuake .64s cubic-bezier(.2, .95, .25, 1.3)
    }

    .hp-bar-label {
      display: block;
      text-align: center;
      margin: 8px auto 0;
      padding: 4px 10px;
      font-weight: 800;
      font-size: 14px;
      color: #000;
      text-shadow: none;
      border-radius: 10px;
      min-width: 0;
      max-width: 92%;
      width: fit-content;
    }

    /* Study menu (HPラベルから開くボトムシート) */
    .study-menu-backdrop {
      position: fixed;
      inset: 0;
      background: transparent;
      display: none;
      z-index: 4200;
      padding: 14px;
      pointer-events: none;
    }

    .study-menu-backdrop.open {
      display: block;
      pointer-events: none;
    }

    .study-menu-sheet {
      position: fixed;
      top: 18px;
      right: 18px;
      left: auto;
      width: min(760px, 94vw);
      min-width: 340px;
      min-height: 300px;
      max-height: 90vh;
      background: linear-gradient(145deg, rgba(17, 24, 39, .96), rgba(12, 19, 33, .94));
      border: 1px solid rgba(255, 255, 255, .12);
      box-shadow: 0 22px 54px rgba(0, 0, 0, .45), 0 12px 28px rgba(0, 0, 0, .28), 0 0 0 1px rgba(79, 140, 255, .22) inset;
      border-radius: 16px;
      padding: 8px 10px 10px;
      color: #e9edf5;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      transition: transform .1s ease, box-shadow .18s ease;
      animation: studySheetIn .18s ease-out both;
      pointer-events: auto;
      backdrop-filter: blur(14px) saturate(1.1);
      user-select: none;
      touch-action: none;
      resize: both;
      overflow: auto;
    }

    .study-menu-sheet.dragging {
      transition: none;
      box-shadow: 0 26px 60px rgba(0, 0, 0, .5), 0 0 0 1px rgba(79, 140, 255, .32) inset;
    }

    @keyframes studySheetIn {
      0% {
        transform: translateY(16px);
        opacity: 0;
      }

      100% {
        transform: translateY(0);
        opacity: 1;
      }
    }

    .study-menu-grip {
      display: none;
    }

    .study-menu-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 8px;
      cursor: grab;
      touch-action: none;
    }

    .study-menu-drag {
      flex: 1;
      min-height: 14px;
    }

    .study-menu-head-actions {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      align-items: center;
    }

    .study-menu-section {
      background: rgba(255, 255, 255, .02);
      border: 1px solid rgba(255, 255, 255, .08);
      border-radius: 10px;
      padding: 8px 10px;
      margin-bottom: 8px;
    }

    .study-menu-section h4 {
      margin: 0 0 6px;
      font-size: 13px;
      letter-spacing: .01em;
    }

    .study-menu-current {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .study-menu-current .label {
      color: var(--muted);
      font-size: 12px;
    }

    .study-menu-current .name {
      font-weight: 800;
      font-size: 16px;
    }

    .study-menu-current .time {
      font-size: 13px;
      color: #cbd5e1;
    }

    .study-menu-badges {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    .study-menu-badge {
      padding: 4px 8px;
      border-radius: 10px;
      background: rgba(79, 140, 255, .14);
      border: 1px solid rgba(79, 140, 255, .25);
      color: #d6e4ff;
      font-size: 11px;
      font-weight: 700;
      letter-spacing: .01em;
    }

    .study-menu-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .study-menu-actions .btn {
      flex: 1;
      min-width: 140px;
      box-shadow: none;
      background: rgba(255, 255, 255, .06);
      border-color: rgba(255, 255, 255, .12);
    }

    .study-menu-actions .btn.primary {
      background: #2b58ff;
      border-color: #2b58ff;
      box-shadow: none;
    }

    .study-menu-toolbar {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      padding: 4px 8px 2px;
      background: rgba(255, 255, 255, .03);
      border: 1px solid rgba(255, 255, 255, .06);
      border-radius: 12px;
      margin-bottom: 6px;
    }

    .study-menu-toolbar .chip-btn.complete-done {
      background: rgba(34, 197, 94, 0.18);
      border-color: rgba(34, 197, 94, 0.65);
      color: #22c55e;
      box-shadow: inset 0 0 0 1px rgba(34, 197, 94, 0.2);
    }

    .chip-btn {
      border: 1px solid rgba(255, 255, 255, .12);
      background: rgba(255, 255, 255, .06);
      color: #e9edf5;
      border-radius: 999px;
      padding: 7px 12px;
      font-size: 12px;
      font-weight: 700;
      cursor: pointer;
      transition: background .06s ease, border-color .06s ease;
    }

    .chip-btn:hover {
      background: rgba(255, 255, 255, .09);
    }

    .chip-btn:active {
      transform: none;
    }

    .chip-btn:disabled,
    .chip-btn.disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .chip-btn.primary {
      background: #1f4ce0;
      border-color: #1f4ce0;
      color: #fff;
    }

    .chip-btn.danger {
      background: #23131a;
      border-color: #4a2530;
      color: #fca5a5;
    }

    .chip-btn.break {
      background: rgba(30, 64, 175, 0.18);
      border-color: rgba(30, 64, 175, 0.5);
      color: #dbeafe;
    }

    .chip-btn.break.dragging {
      opacity: 0.7;
    }

    .study-break-config {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      color: #cbd5f5;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px dashed rgba(148, 163, 184, 0.35);
      background: rgba(255, 255, 255, 0.04);
    }

    .study-break-config input {
      width: 44px;
      padding: 2px 4px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: rgba(15, 23, 42, 0.6);
      color: #e2e8f0;
      font-size: 10px;
    }

    .study-menu-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 2px;
      width: 100%;
      max-width: 760px;
      margin: 0 auto;
    }

    .study-miss-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 8px;
    }

    .study-miss-controls .input {
      font-size: 11px;
      padding: 4px 6px;
      min-width: 120px;
    }

    .study-miss-meta {
      font-size: 11px;
      color: #cbd5f5;
      margin: 4px 0 8px;
    }

    .study-miss-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .study-miss-item {
      display: flex;
      gap: 10px;
      align-items: flex-start;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(255, 255, 255, 0.03);
      cursor: pointer;
      transition: transform 0.18s ease, border-color 0.18s ease, background 0.18s ease;
    }

    .study-miss-item:hover {
      transform: translateY(-1px);
      border-color: rgba(96, 165, 250, 0.4);
      background: rgba(96, 165, 250, 0.08);
    }

    .study-miss-item.danger {
      border-color: rgba(248, 113, 113, 0.45);
      background: rgba(248, 113, 113, 0.08);
    }

    .study-miss-item.danger:hover {
      border-color: rgba(248, 113, 113, 0.65);
      background: rgba(248, 113, 113, 0.12);
    }

    .study-miss-badge {
      width: 30px;
      height: 30px;
      border-radius: 999px;
      display: grid;
      place-items: center;
      font-weight: 700;
      color: #fff;
      background: var(--miss-color, #ef4444);
      border: 2px solid rgba(255, 255, 255, 0.3);
      flex-shrink: 0;
    }

    .study-miss-title {
      font-weight: 700;
      font-size: 13px;
      margin-bottom: 2px;
    }

    .study-miss-body {
      flex: 1;
      min-width: 0;
    }

    .study-miss-sub {
      font-size: 11px;
      color: #cbd5f5;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .study-miss-reason {
      font-size: 11px;
      color: #cbd5f5;
      margin-top: 4px;
      opacity: 0.85;
    }

    .study-miss-alert {
      color: #fecaca;
      font-weight: 700;
    }

    .study-miss-actions {
      margin-left: auto;
      display: flex;
      flex-direction: column;
      gap: 4px;
      align-items: flex-end;
    }

    .study-miss-actions .mini-menu {
      padding: 4px 8px;
      font-size: 11px;
    }

    .study-miss-actions .mini-menu.danger {
      background: rgba(239, 68, 68, 0.18);
      border-color: rgba(239, 68, 68, 0.5);
      color: #fecaca;
    }

    .study-map-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 8px;
      align-items: center;
    }

    .study-map-controls label {
      font-size: 11px;
      color: #cbd5f5;
    }

    .study-map-controls .input {
      font-size: 11px;
      padding: 4px 6px;
      min-width: 120px;
    }

    .study-map-meta {
      font-size: 11px;
      color: #cbd5f5;
      margin: 4px 0 8px;
    }

    .study-map-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(36px, 1fr));
      gap: 6px;
      max-height: 220px;
      overflow: auto;
      padding: 6px;
      border-radius: 10px;
      border: 1px dashed rgba(255, 255, 255, 0.12);
      background: rgba(0, 0, 0, 0.18);
    }

    .study-map-btn {
      padding: 6px 4px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      background: rgba(255, 255, 255, 0.04);
      color: #e2e8f0;
      font-size: 11px;
      text-align: center;
      cursor: pointer;
      transition: background 0.15s ease, border-color 0.15s ease;
    }

    .study-map-btn:hover {
      border-color: rgba(125, 211, 252, 0.5);
      background: rgba(125, 211, 252, 0.12);
    }

    .study-map-btn.done {
      background: #22c55e;
      border-color: #16a34a;
      color: #0b1220;
      font-weight: 700;
    }

    .study-miss-actions .mini-menu.danger:hover {
      background: rgba(239, 68, 68, 0.3);
      border-color: rgba(239, 68, 68, 0.7);
    }

    .study-menu-row {
      border: 1px solid rgba(255, 255, 255, .06);
      border-radius: 9px;
      padding: 4px 6px;
      background: rgba(255, 255, 255, .01);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      cursor: grab;
      min-height: 38px;
      position: relative;
      transition: transform 260ms cubic-bezier(0.22, 1, 0.36, 1), box-shadow 220ms ease, border-color 220ms ease, background 220ms ease;
      will-change: transform;
    }

    .study-menu-row:active {
      cursor: grabbing;
    }

    .study-menu-row.dragging {
      opacity: 0.45;
      transform: scale(0.985);
      box-shadow: 0 10px 18px rgba(15, 23, 42, 0.22);
    }

    .study-menu-row.break {
      border-color: rgba(30, 64, 175, 0.4);
      background: rgba(30, 64, 175, 0.08);
    }

    .study-menu-row.break .meta {
      color: #c7d2fe;
    }

    .study-menu-row.break-ghost {
      border-style: dashed;
      opacity: 0.8;
    }

    .study-menu-row.drop-target {
      background: rgba(96, 165, 250, 0.08);
      border-color: rgba(96, 165, 250, 0.45);
      box-shadow: 0 8px 18px rgba(37, 99, 235, 0.16);
    }

    .study-menu-row.drop-before::before,
    .study-menu-row.drop-after::after {
      content: "";
      position: absolute;
      left: 10px;
      right: 10px;
      height: 4px;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(96, 165, 250, 0) 0%, rgba(96, 165, 250, 0.95) 50%, rgba(96, 165, 250, 0) 100%);
      box-shadow: 0 0 10px rgba(96, 165, 250, 0.6);
      pointer-events: none;
    }

    .study-menu-row.drop-before::before {
      top: -6px;
    }

    .study-menu-row.drop-after::after {
      bottom: -6px;
    }

    .study-menu-row .title {
      font-weight: 700;
      font-size: 12.5px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .study-menu-row .meta {
      font-size: 11px;
      color: #aebbd4;
      display: inline-flex;
      gap: 6px;
      flex-wrap: wrap;
      line-height: 1.25;
    }

    .study-menu-row .status {
      padding: 2px 6px;
      border-radius: 7px;
      font-size: 10px;
      font-weight: 800;
    }

    .study-menu-row.active .status {
      background: rgba(79, 140, 255, .18);
      color: #d7e6ff;
    }

    .study-menu-row.upcoming .status {
      background: rgba(110, 231, 183, .12);
      color: #c7f9e9;
    }

    .study-menu-row.done {
      background: rgba(34, 197, 94, .08);
      border-color: rgba(74, 222, 128, .35);
    }

    .study-menu-row.done .title {
      color: #bbf7d0;
      text-decoration: line-through;
    }

    .study-menu-row.done .meta {
      color: #a6e3b1;
    }

    .study-menu-row.history {
      opacity: .9;
    }

    .study-menu-row-buttons {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .study-menu-row-buttons .mini-menu {
      background: rgba(255, 255, 255, .06);
      border-color: rgba(255, 255, 255, .12);
      padding: 6px 9px;
      font-size: 11px;
    }

    .study-menu-row-buttons .mini-menu:hover {
      background: rgba(255, 255, 255, .12);
    }

    .study-menu-row-buttons .mini-menu.disabled {
      opacity: .5;
      cursor: not-allowed;
    }

    .study-menu-empty {
      padding: 12px;
      text-align: center;
      color: #cbd5e1;
      font-weight: 700;
    }

    .study-menu-todo {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .study-menu-todo .row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    .study-menu-todo select {
      min-width: 180px;
    }

    .study-menu-footnote {
      font-size: 11px;
      color: var(--muted);
      line-height: 1.4;
    }

    .study-todo-inline {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .study-todo-chip {
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, .1);
      background: rgba(255, 255, 255, .05);
      color: #e5ebf5;
      font-size: 11.5px;
      cursor: pointer;
      user-select: none;
    }

    .study-todo-chip:hover {
      background: rgba(255, 255, 255, .12);
    }

    .study-todo-chip .meta {
      color: #9fb4d6;
      font-size: 10.5px;
      margin-left: 4px;
    }

    .study-todo-mini {
      border: 1px solid rgba(255, 255, 255, .08);
      background: rgba(255, 255, 255, .03);
      border-radius: 12px;
      padding: 8px 10px;
      width: 100%;
    }

    .study-todo-mini .head {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    .study-todo-mini .title {
      font-weight: 800;
      font-size: 13px;
    }

    .study-todo-mini .meta {
      color: #9fb4d6;
      font-size: 11px;
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    .study-todo-mini .actions {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      margin-top: 6px;
    }

    .study-todo-mini .actions .mini-menu {
      padding: 6px 9px;
      font-size: 11px;
    }

    .study-todo-mini .pages {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 6px;
    }

    .study-todo-page {
      padding: 6px 9px;
      border-radius: 9px;
      border: 1px solid rgba(255, 255, 255, .12);
      background: rgba(255, 255, 255, .06);
      color: #e5eaf5;
      font-size: 11px;
      cursor: pointer;
    }

    .study-todo-page:hover {
      background: rgba(255, 255, 255, .1);
    }

    .study-todo-page.today-assigned {
      outline: 2px solid rgba(239, 68, 68, .75);
      outline-offset: 1px;
      box-shadow: 0 0 0 1px rgba(239, 68, 68, .45), 0 0 12px rgba(239, 68, 68, .35);
    }

    .study-todo-page.today-assigned:hover {
      outline-color: rgba(239, 68, 68, .9);
      box-shadow: 0 0 0 1px rgba(239, 68, 68, .6), 0 0 16px rgba(239, 68, 68, .5);
    }

    .study-todo-page.done {
      opacity: .8;
      text-decoration: line-through;
      background: rgba(34, 197, 94, .18);
      border-color: rgba(74, 222, 128, .45);
      color: #d1fae5;
    }

    .study-todo-page.scheduled {
      background: rgba(79, 140, 255, .18);
      border-color: rgba(79, 140, 255, .45);
      color: #e0ecff;
    }

    .study-todo-page.paused {
      background: rgba(250, 204, 21, .22);
      border-color: rgba(250, 204, 21, .55);
      color: #fef9c3;
      cursor: pointer;
    }

    .study-todo-page.paused:hover {
      background: rgba(250, 204, 21, .4);
    }

    /* TODO Popup Window */
    .todo-popup-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: transparent;
      z-index: 10100;
      display: none;
      pointer-events: none;
    }

    .todo-popup-overlay.open {
      display: block;
    }

    .todo-popup-sheet {
      background: linear-gradient(145deg, #1e293b, #0f172a);
      border-radius: 12px;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5);
      min-width: 280px;
      max-width: 600px;
      width: 360px;
      height: 400px;
      display: flex;
      flex-direction: column;
      position: absolute;
      top: 80px;
      right: 20px;
      pointer-events: auto;
      overflow: hidden;
    }

    .todo-popup-resizer {
      position: absolute;
      right: 0;
      bottom: 0;
      width: 16px;
      height: 16px;
      cursor: se-resize;
      background: linear-gradient(135deg, transparent 50%, rgba(255, 255, 255, 0.2) 50%);
    }

    .todo-popup-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      font-weight: 600;
      color: #f1f5f9;
    }

    .todo-popup-actions {
      display: flex;
      gap: 8px;
    }

    .todo-popup-body {
      flex: 1;
      overflow-y: auto;
      padding: 12px 16px;
    }

    .todo-popup-item {
      margin-bottom: 16px;
    }

    .todo-popup-title {
      font-weight: 600;
      color: #e2e8f0;
      margin-bottom: 8px;
      font-size: 13px;
    }

    .todo-popup-pages {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .study-profiles {
      margin-top: 4px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .study-menu-scroll {
      overflow: auto;
      padding-right: 2px;
      flex: 1;
    }

    .study-menu-mode {
      display: inline-flex;
      gap: 6px;
      align-items: center;
      flex-wrap: wrap;
      font-size: 12px;
      color: #cbd5e1;
    }

    .study-page-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 6px;
      width: 100%;
      max-width: 720px;
      margin: 0 auto;
    }

    @media (min-width:980px) {
      .study-page-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    .study-page-chip {
      border: 1px solid rgba(255, 255, 255, .08);
      background: rgba(255, 255, 255, .04);
      border-radius: 10px;
      padding: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12.5px;
      color: #e9edf5;
    }

    .study-page-chip .pg-label {
      font-weight: 800;
    }

    .study-page-chip .pg-meta {
      font-size: 11px;
      color: #9fb4d6;
    }

    .study-page-chip.active {
      background: rgba(79, 140, 255, .14);
      border-color: rgba(79, 140, 255, .4);
    }

    .study-page-chip.upcoming {
      background: rgba(255, 255, 255, .05);
      border-color: rgba(255, 255, 255, .1);
    }

    .study-page-chip.done {
      background: rgba(34, 197, 94, .14);
      border-color: rgba(74, 222, 128, .45);
      color: #d1fae5;
    }

    .study-page-chip.break {
      background: rgba(59, 130, 246, 0.14);
      border-color: rgba(59, 130, 246, 0.45);
      color: #dbeafe;
    }

    .study-page-chip.history {
      opacity: .8;
    }

    /* Viewer用 HPバー位置（上部ボタン列の中央） */
    #readerHpBar {
      position: absolute;
      left: 50%;
      bottom: 10px;
      --hp-base-transform: translate(-50%, 0);
      transform: var(--hp-base-transform);
      width: 82%;
      max-width: 960px;
      z-index: 40;
      margin: 0;
      pointer-events: none;
      /* バー以外でボタンを遮らない */
    }

    #readerHpBar .hp-bar-outer,
    #readerHpBar .hp-bar-label {
      pointer-events: auto;
    }

    #readerHpBar.align-left {
      left: 12px;
      right: auto;
      transform: translate(0, 0);
      --hp-base-transform: translate(0, 0);
    }

    #readerHpBar.align-right {
      left: auto;
      right: 12px;
      transform: translate(0, 0);
      --hp-base-transform: translate(0, 0);
    }

    @media(max-width:960px) {
      #readerHpBar {
        width: 90%;
        bottom: 8px;
      }
    }

    @media(max-width:720px) {
      #readerHpBar {
        width: 96%;
        bottom: 6px;
      }
    }

    /* Study HP overlay (KH-style) */
    #hpBarLayer {
      position: absolute;
      left: 50%;
      top: 40px;
      transform: translate(-50%, 0);
      width: 92%;
      max-width: 900px;
      pointer-events: none;
      z-index: 28;
      opacity: 0;
      transition: opacity .25s ease, transform .25s ease;
      will-change: opacity, transform;
    }

    #hpBarLayer.active {
      opacity: 1;
      transform: translate(-50%, 0);
    }

    #hpBarLayer.hidden {
      opacity: 0;
      transform: translate(-50%, 0);
    }

    @media(max-width:720px) {
      #hpBarLayer {
        top: 34px;
        width: 94%;
      }
    }

    .hp-kh-shell {
      position: relative;
      height: 26px;
      background: linear-gradient(180deg, rgba(12, 16, 26, .95) 0%, rgba(7, 10, 18, .9) 100%);
      border-radius: 14px;
      box-shadow:
        0 10px 26px rgba(0, 0, 0, .42),
        inset 0 1px 0 rgba(255, 255, 255, .08),
        inset 0 -1px 0 rgba(0, 0, 0, .35);
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, .08);
    }

    .hp-kh-shell::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: radial-gradient(70% 140% at 10% 50%, rgba(255, 255, 255, .14), transparent 55%),
        linear-gradient(90deg, rgba(255, 255, 255, .06), transparent 30%, transparent 70%, rgba(255, 255, 255, .06));
      mix-blend-mode: screen;
      opacity: .7;
      pointer-events: none;
    }

    .hp-kh-track {
      position: absolute;
      inset: 2px;
      border-radius: 12px;
      background: linear-gradient(180deg, rgba(22, 30, 46, .9), rgba(9, 12, 20, .9));
      box-shadow: inset 0 2px 6px rgba(0, 0, 0, .55), inset 0 0 0 1px rgba(255, 255, 255, .05);
      overflow: hidden;
    }

    .hp-kh-fill {
      position: absolute;
      left: 2px;
      top: 2px;
      bottom: 2px;
      width: 100%;
      border-radius: 11px;
      background: linear-gradient(90deg, #0f6b3f 0%, #1fb26d 45%, #34d399 72%, #86efac 100%);
      box-shadow:
        inset 0 1px 2px rgba(255, 255, 255, .35),
        inset 0 -2px 4px rgba(0, 0, 0, .28),
        0 0 22px rgba(50, 216, 108, .35);
      transition: width .45s cubic-bezier(.25, .8, .2, 1);
    }

    .hp-kh-fill::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(120deg, rgba(255, 255, 255, .5), rgba(255, 255, 255, 0));
      mix-blend-mode: screen;
      opacity: .65;
      transform: translateX(-60%);
      animation: hpSheen 4s linear infinite;
    }

    .hp-kh-fill::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 100% 50%, rgba(255, 255, 255, .38), transparent 45%);
      opacity: 0;
      pointer-events: none;
    }

    .hp-kh-ticks {
      position: absolute;
      inset: 2px;
      border-radius: 11px;
      background: repeating-linear-gradient(to right,
          rgba(255, 255, 255, .22) 0px,
          rgba(255, 255, 255, .22) 2px,
          transparent 2px,
          transparent 100%);
      background-size: calc(100%/var(--hp-segments, 12)) 100%;
      mix-blend-mode: screen;
      opacity: .5;
      pointer-events: none;
    }

    .hp-kh-frame {
      position: absolute;
      inset: 0;
      border-radius: 14px;
      box-shadow:
        inset 0 0 0 1px rgba(255, 255, 255, .08),
        0 0 0 1px rgba(255, 255, 255, .05);
      pointer-events: none;
    }

    .hp-kh-label {
      margin-top: 6px;
      text-align: center;
      font-weight: 800;
      font-size: 14px;
      letter-spacing: .02em;
      color: #e9f7ff;
      text-shadow: 0 2px 8px rgba(0, 0, 0, .6), 0 0 16px rgba(79, 140, 255, .35);
      pointer-events: none;
    }

    #hpBarLayer.hit .hp-kh-shell {
      animation: hpHitShake .45s ease-out;
    }

    #hpBarLayer.hit .hp-kh-fill::before {
      animation: hpHitFlash .55s ease;
    }

    @keyframes hpSheen {
      0% {
        transform: translateX(-60%);
      }

      100% {
        transform: translateX(120%);
      }
    }

    @keyframes hpHitFlash {
      0% {
        opacity: .9;
        filter: drop-shadow(0 0 18px rgba(255, 80, 80, .9));
      }

      60% {
        opacity: 0;
      }

      100% {
        opacity: 0;
      }
    }

    @keyframes hpHitShake {
      0% {
        transform: translateX(0);
      }

      25% {
        transform: translateX(-1.2px);
      }

      50% {
        transform: translateX(1px);
      }

      75% {
        transform: translateX(-0.8px);
      }

      100% {
        transform: translateX(0);
      }
    }

    .pomo-panel {
      margin-top: 12px;
      padding: 12px;
      border: 1px solid var(--ring);
      border-radius: 12px;
      background: rgba(255, 255, 255, .04);
      display: none;
      flex-direction: column;
      gap: 10px
    }

    .pomo-panel input[type="number"] {
      width: 80px;
      padding: 6px;
      border-radius: 8px;
      border: 1px solid var(--ring);
      background: rgba(0, 0, 0, .15);
      color: var(--fg)
    }

    .pomo-panel .row {
      width: 100%;
      margin-bottom: 0
    }

    .pomo-panel .btn {
      flex: 1
    }

    #pomoClockHUD {
      margin-top: 8px;
      display: none
    }

    /* Timers */
    .timer-form {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 8px;
      align-items: center
    }

    .timer-form .input {
      width: 100%
    }

    .timer-list {
      display: grid;
      gap: 10px;
      margin-top: 12px
    }

    .timer-item-modern {
      padding: 12px;
      border: 1px solid #1f2a3a;
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(255, 255, 255, .05), rgba(255, 255, 255, .015));
      box-shadow: 0 10px 28px rgba(0, 0, 0, .25);
    }

    .timer-item-modern.kitchen {
      background: linear-gradient(145deg, #0f1624, #0b0f1a);
      border-color: #2b3950;
    }

    .timer-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 8px
    }

    .timer-title {
      font-weight: 700;
      font-size: 14px
    }

    .timer-controls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center
    }

    .timer-display-large {
      font-family: 'SFMono-Regular', Menlo, Consolas, monospace;
      font-size: clamp(38px, 6vw, 88px);
      font-weight: 800;
      letter-spacing: 1px;
      text-align: center;
      padding: 8px 0;
    }

    .timer-eta {
      font-size: 12px;
      color: var(--muted);
      text-align: center;
      margin-top: -4px;
      margin-bottom: 6px
    }

    .timer-bar {
      height: 10px;
      background: #101726;
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid #1f2a3a
    }

    .timer-bar .fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--brand), var(--brand2));
      transition: width .2s ease;
    }

    .timer-actions {
      display: flex;
      gap: 6px;
      justify-content: center;
      flex-wrap: wrap;
      margin-top: 8px
    }

    .timer-actions .btn {
      padding: 6px 10px;
      font-size: 12px;
      border-radius: 9px
    }

    .timer-actions .btn.ghost {
      box-shadow: none;
      border: 1px solid #253347;
      background: rgba(255, 255, 255, .04)
    }

    .timer-actions .btn.danger {
      background: #2d141a;
      border-color: #4a1f2a
    }

    .timer-actions .btn.primary {
      box-shadow: 0 8px 18px rgba(79, 140, 255, .3);
    }

    .timer-actions .btn.compact {
      min-width: 0;
      padding: 6px 12px
    }

    .timer-meta {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      font-size: 12px;
      color: var(--muted);
      margin-top: 6px
    }

    .timer-tag {
      padding: 2px 8px;
      border-radius: 10px;
      border: 1px solid #243249;
      font-size: 11px;
      display: inline-flex;
      align-items: center;
      gap: 6px
    }

    .timer-fullscreen {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at 50% 30%, rgba(79, 140, 255, .12), rgba(10, 14, 22, .94));
      backdrop-filter: blur(8px);
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 12px;
    }

    .timer-fullscreen .time {
      font-family: 'SFMono-Regular', Menlo, Consolas, monospace;
      font-size: clamp(80px, 18vw, 240px);
      font-weight: 900;
      letter-spacing: 2px;
      text-shadow: 0 14px 40px rgba(0, 0, 0, .55);
    }

    .timer-fullscreen .fs-actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center
    }

    .timer-fullscreen .fs-bar {
      width: min(720px, 90vw);
      height: 14px;
      border-radius: 999px;
      border: 1px solid #1f2a3a;
      background: #0a1020;
      overflow: hidden
    }

    .timer-fullscreen .fs-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #6ee7b7, #4f8cff);
    }

    /* Digital clock */
    .digital-wrap {
      display: grid;
      place-items: center;
      padding: 20px;
    }

    .digital-big {
      font-family: 'SFMono-Regular', Menlo, Consolas, monospace;
      font-weight: 800;
      font-size: clamp(96px, 18vw, 220px);
      letter-spacing: 2px;
    }

    .nl-row {
      position: relative
    }


    .page-complete-btn.active {
      display: block
    }

    .page-complete-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 32px rgba(102, 126, 234, .6)
    }

    .page-complete-btn:active {
      transform: translateY(0)
    }

    @media(max-width:600px) {
      .study-panel {
        grid-template-columns: 1fr
      }
    }

    .study-overall {
      font-family: monospace;
      font-weight: 700;
      text-align: center;
      margin: 0 0 8px 0;
      padding: 8px 12px;
      border: 1px solid var(--ring);
      border-radius: 10px;
      background: rgba(0, 0, 0, .2);
    }


    /* --- Numberline (integrated) --- */
    .nl-row {
      display: grid;
      grid-template-columns: 64px 1fr;
      gap: 10px;
      align-items: center;
      margin: 14px 0;
      padding-bottom: 30px;
      animation: fadeSlideUp var(--dur-md) var(--ease-soft) both
    }

    .nl-hourBadge {
      justify-self: end;
      font-size: 13px;
      color: var(--muted);
      background: rgba(255, 255, 255, .04);
      border: 1px solid var(--ring);
      border-radius: 12px;
      padding: 6px 8px;
      letter-spacing: .04em
    }

    .nl-rail {
      position: relative;
      height: 130px;
      border-radius: 12px;
      background: linear-gradient(180deg, rgba(255, 255, 255, .02), rgba(255, 255, 255, 0)), rgba(0, 0, 0, .25);
      border: 1px solid var(--ring);
      padding: 18px 12px 14px;
      overflow: hidden
    }

    .nl-scale {
      position: relative;
      height: 70px;
      margin: 0;
      border-radius: 10px
    }

    .nl-lane {
      position: absolute;
      left: 18px;
      right: 18px;
      top: 0;
      bottom: 0
    }

    .nl-track {
      position: absolute;
      left: 0;
      right: 0;
      top: 50%;
      height: 4px;
      background: rgba(255, 255, 255, .14);
      transform: translateY(-50%);
      border-radius: 999px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, .35), inset 0 0 0 1px rgba(255, 255, 255, .04)
    }

    .nl-ticks {
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0
    }

    .nl-tick {
      position: absolute;
      width: 1px;
      background: var(--tickMinor, rgba(255, 255, 255, 0.35));
      top: 40%;
      height: 28%;
      transform: translateX(-50%);
    }

    .nl-tick.major {
      width: 3px;
      background: var(--tickMajor, rgba(255, 255, 255, 0.85));
      top: 30%;
      height: 40%;
    }

    .nl-label {
      position: absolute;
      top: 0;
      transform: translateX(-50%);
      font-size: 12px;
      color: var(--muted);
      font-variant-numeric: tabular-nums
    }

    .nl-cap {
      position: absolute;
      top: 36px;
      left: 18px;
      right: 18px;
      display: flex;
      justify-content: space-between;
      color: var(--muted);
      font-size: 12px
    }

    .nl-hand {
      position: absolute;
      top: 8px;
      bottom: 8px;
      width: 0;
      transform: translateX(-50%);
      pointer-events: none;
      z-index: 3
    }

    .nl-hand.m::after {
      content: "";
      display: block;
      height: 100%;
      width: 6px;
      border-radius: 3px;
      background: var(--accent)
    }

    .nl-hand::after {
      transform: translateX(-50%);
    }

    .nl-hand.s::after {
      content: "";
      display: block;
      height: 100%;
      width: 4px;
      border-radius: 2px;
      background: var(--handS)
    }

    .nl-hand.s::after {
      margin-left: -0.5px
    }

    .nl-bars {
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 2
    }

    .nl-bar {
      position: absolute;
      top: 50%;
      height: 100%;
      transform: translateY(-50%);
      border-radius: 8px;
      color: #0b1020;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 700;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      backdrop-filter: saturate(120%) blur(.3px);
      border: 1px solid rgba(255, 255, 255, .35);
      box-shadow: 0 6px 16px rgba(0, 0, 0, .35), inset 0 0 0 1px rgba(255, 255, 255, .2);
    }

    .nl-bar-poof-shell {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      pointer-events: none;
      overflow: visible;
      filter: drop-shadow(0 8px 18px rgba(0, 0, 0, 0.35));
    }

    .nl-poof-dot {
      position: absolute;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--poof-color, #7dd3fc);
      opacity: 0;
      animation: nlPoofDot 0.52s ease-out forwards;
    }

    @keyframes nlPoofDot {
      0% {
        transform: translate(0, 0) scale(0.6);
        opacity: 0.9;
      }

      60% {
        opacity: 1;
      }

      100% {
        transform: translate(var(--tx, 0px), var(--ty, 0px)) scale(0.1);
        opacity: 0;
      }
    }

    @keyframes nlBarPoof {
      0% {
        transform: translateY(-50%) scale(1);
        opacity: 1;
        filter: none;
      }

      30% {
        transform: translateY(-50%) scale(1.08);
        opacity: 1;
      }

      60% {
        transform: translateY(-50%) scale(1.02);
        opacity: 0.9;
      }

      100% {
        transform: translateY(-50%) scale(0.2);
        opacity: 0;
        filter: blur(3px);
      }
    }

    .nl-bar-poof {
      animation: nlBarPoof 0.45s cubic-bezier(0.2, 0.8, 0.25, 1.05) both;
    }

    @keyframes nlBarDrop {
      0% {
        transform: translateY(-180%) scaleY(1.12);
        opacity: 0;
      }

      45% {
        transform: translateY(-40%) scaleY(0.94);
        opacity: 1;
      }

      72% {
        transform: translateY(-58%) scaleY(1.06);
        opacity: 1;
      }

      100% {
        transform: translateY(-50%) scaleY(1);
        opacity: 1;
      }
    }

    .nl-bar-drop {
      animation: nlBarDrop 0.82s cubic-bezier(0.2, 0.9, 0.18, 1) var(--nl-drop-delay, 0ms) both;
    }

    .nl-direct-guide {
      position: absolute;
      top: 8px;
      bottom: 8px;
      border-radius: 12px;
      background: linear-gradient(90deg, rgba(77, 163, 255, .2), rgba(77, 163, 255, .45));
      border: 1px dashed rgba(77, 163, 255, .85);
      box-shadow: 0 12px 24px rgba(0, 0, 0, .35), inset 0 0 0 1px rgba(255, 255, 255, .12);
      opacity: 0;
      pointer-events: none;
      transition: opacity .12s ease;
    }

    .nl-direct-guide.show {
      opacity: 1;
    }


    .btn.small {
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 6px;
      background: var(--ring);
      color: var(--muted);
      border: 1px solid rgba(255, 255, 255, .15);
      cursor: pointer
    }

    /* === Timer HUD (no bars/gauges) === */
    .hud-pill {
      display: inline-block;
      padding: 6px 10px;
      border-radius: 8px;
      background: var(--ring);
      color: var(--muted);
      border: 1px solid rgba(255, 255, 255, .15);
      font-size: 14px;
      letter-spacing: .02em;
      user-select: none;
      cursor: pointer;
      font-variant-numeric: tabular-nums;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.06);
    }

    .hud-pill.strong {
      color: var(--fg);
      background: rgba(77, 163, 255, 0.12);
      border-color: rgba(77, 163, 255, 0.35);
    }

    .hud-pill.warn {
      color: #eab308;
      border-color: rgba(234, 179, 8, .35);
    }

    .hud-pill.danger {
      color: #f97316;
      border-color: rgba(249, 115, 22, .35);
    }

    .hud-note {
      font-size: 12px;
      color: var(--muted);
      margin-left: 6px
    }


    /* Planner ETA position tweak: a bit higher than numberline */
    #plEta.nl-eta {
      bottom: -8px;
    }


    /* === Horror Theme (Upgraded) === */
    .theme-horror {
      --bg: #09090b;
      --face: #111114;
      --ring: rgba(255, 255, 255, 0.06);
      --muted: #e5e5ea;
      --accent: #c1121f;
      --handH: #fafafa;
      --handM: #ff3b3b;
      --handS: #ff3b3b;
      --tickMinor: rgba(255, 255, 255, 0.18);
      --tickMajor: rgba(255, 255, 255, 0.92);
    }

    .theme-horror .clock-wrap {
      position: relative;
      overflow: visible;
    }

    .theme-horror #clock {
      filter: drop-shadow(0 4px 18px rgba(193, 18, 31, .35));
    }

    /* Aura: slow rotating radial glow */
    .theme-horror .h-aura {
      position: absolute;
      inset: -12% -12% -12% -12%;
      border-radius: 50%;
      background: conic-gradient(from 0deg, rgba(193, 18, 31, .12), transparent 35%, rgba(255, 255, 255, .06) 50%, transparent 65%, rgba(193, 18, 31, .12));
      animation: aura-rot 18s linear infinite, aura-flicker 2.6s ease-in-out infinite;
      filter: blur(18px);
      pointer-events: none;
    }

    @keyframes aura-rot {
      to {
        transform: rotate(360deg);
      }
    }

    @keyframes aura-flicker {

      0%,
      100% {
        opacity: .35
      }

      45% {
        opacity: .6
      }

      55% {
        opacity: .25
      }
    }

    /* Fog layers: slow parallax drift */
    .theme-horror .h-fog {
      position: absolute;
      inset: -8% -8% -8% -8%;
      pointer-events: none;
      background: radial-gradient(60% 60% at 40% 50%, rgba(255, 255, 255, .035), transparent 60%),
        radial-gradient(50% 50% at 70% 60%, rgba(255, 255, 255, .03), transparent 65%),
        radial-gradient(70% 70% at 30% 40%, rgba(255, 255, 255, .04), transparent 70%);
      filter: blur(16px);
      opacity: .55;
    }

    .theme-horror .h-fog.f1 {
      animation: fog-drift-1 40s linear infinite;
    }

    .theme-horror .h-fog.f2 {
      animation: fog-drift-2 55s linear infinite;
      opacity: .35;
      filter: blur(22px);
    }

    @keyframes fog-drift-1 {
      0% {
        transform: translate3d(-2%, 0, 0)
      }

      50% {
        transform: translate3d(2%, 1%, 0)
      }

      100% {
        transform: translate3d(-2%, 0, 0)
      }
    }

    @keyframes fog-drift-2 {
      0% {
        transform: translate3d(1%, 0, 0)
      }

      50% {
        transform: translate3d(-3%, -1%, 0)
      }

      100% {
        transform: translate3d(1%, 0, 0)
      }
    }

    /* Vignette & scanlines */
    .theme-horror .h-vignette {
      position: absolute;
      inset: -10% -10% -10% -10%;
      pointer-events: none;
      background: radial-gradient(60% 60% at 50% 50%, transparent 55%, rgba(0, 0, 0, .35) 85%, rgba(0, 0, 0, .55));
      mix-blend-mode: multiply;
      animation: vignette-pulse 6s ease-in-out infinite;
    }

    @keyframes vignette-pulse {

      0%,
      100% {
        opacity: .85
      }

      50% {
        opacity: .7
      }
    }

    .theme-horror .h-scan {
      position: absolute;
      inset: 0;
      pointer-events: none;
      background: repeating-linear-gradient(180deg, rgba(255, 255, 255, .03), rgba(255, 255, 255, .03) 1px, transparent 2px, transparent 4px);
      opacity: .18;
      animation: scan-flicker 3.5s linear infinite;
    }

    @keyframes scan-flicker {

      0%,
      100% {
        opacity: .14
      }

      40% {
        opacity: .22
      }

      55% {
        opacity: .1
      }
    }

    /* Subtle hand heartbeat (minute & second hands) */
    .theme-horror #hands {
      transform-origin: 250px 250px;
      animation: hand-breath 5.2s ease-in-out infinite;
    }

    @keyframes hand-breath {

      0%,
      100% {
        transform: scale(1)
      }

      50% {
        transform: scale(1.01)
      }
    }

    /* Planner top complete button */
    #pageCompleteBtn {
      position: relative;
      top: 0;
      left: auto;
      transform: none;
      z-index: 5;
    }

    /* Unify design with numberline button */
    .btn.small {
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 6px;
      background: var(--ring);
      color: var(--muted);
      border: 1px solid rgba(255, 255, 255, .15);
      cursor: pointer
    }

    /* === Horror Theme === */
    .theme-horror {
      --bg: #0b0b0d;
      --face: #121216;
      --ring: rgba(255, 255, 255, 0.08);
      --muted: #d0cfd4;
      --accent: #c1121f;
      --handH: #fafafa;
      --handM: #ff3b3b;
      --handS: #ff3b3b;
      --tickMinor: rgba(255, 255, 255, 0.15);
      --tickMajor: rgba(255, 255, 255, 0.9);
    }

    .theme-horror .clock-wrap {
      position: relative;
      overflow: visible;
    }

    .theme-horror #clock {
      filter: drop-shadow(0 2px 8px rgba(193, 18, 31, .5));
    }

    .theme-horror .bleed {
      position: absolute;
      left: 50%;
      top: -8px;
      width: 6px;
      height: 18px;
      background: #c1121f;
      border-radius: 3px;
      transform: translateX(-50%);
      animation: drip 2.2s infinite ease-in;
      box-shadow: 0 0 8px rgba(193, 18, 31, .6);
    }

    @keyframes drip {
      0% {
        transform: translate(-50%, 0) scaleY(0.6);
      }

      70% {
        transform: translate(-50%, 20px) scaleY(1);
      }

      100% {
        transform: translate(-50%, 0) scaleY(0.6);
      }
    }

    .theme-horror .pulse {
      position: absolute;
      inset: auto 0 0 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(193, 18, 31, .65), transparent);
      animation: pulse 1.8s infinite ease-in-out;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: .2
      }

      50% {
        opacity: 1
      }
    }


    .nl-eta {
      position: absolute;
      left: 50%;
      bottom: -24px;
      transform: translateX(-50%);
      padding: 4px 14px;
      border-radius: 999px;
      background: rgba(0, 0, 0, .35);
      color: var(--muted);
      font-size: 16px;
      font-weight: 700;
      line-height: 1;
      backdrop-filter: blur(6px);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, .08);
      pointer-events: none
    }

    .nl-fullscreen {
      position: fixed;
      inset: 0;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 24px
    }

    .nl-fullscreen .nl-row {
      width: min(1400px, 95vw)
    }

    .nl-row {
      padding-bottom: 30px
    }

    .nl-fs-close {
      position: fixed;
      top: 16px;
      right: 16px;
      background: var(--ring);
      border: 1px solid rgba(255, 255, 255, .1);
      color: var(--muted);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 14px
    }

    .nl-digital-toggle {
      display: inline-flex;
      gap: 6px;
      flex-wrap: wrap
    }

    .nl-digital-toggle .btn.active {
      background: var(--accent);
      color: #fff
    }

    .nl-digital-row,
    .nl-digital-inline {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%
    }

    .nl-digital-row {
      padding: 18px;
      margin: 10px 0;
      border-radius: 16px;
      border: 1px solid var(--ring);
      background: rgba(255, 255, 255, .04);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, .08)
    }

    .nl-digital-inline {
      margin: -6px auto 6px;
      padding: 0 12px;
      width: 100%;
      max-width: 520px
    }

    .nl-digital-face {
      display: flex;
      align-items: flex-end;
      gap: 10px;
      font-family: 'SFMono-Regular', 'Roboto Mono', monospace;
      font-weight: 700;
      color: var(--fg);
      padding: 14px 28px;
      border-radius: 18px;
      background: linear-gradient(135deg, rgba(77, 163, 255, .25), rgba(123, 92, 255, .15));
      box-shadow: 0 14px 26px rgba(0, 0, 0, .35), inset 0 1px 0 rgba(255, 255, 255, .4)
    }

    .nl-digital-inline .nl-digital-face {
      padding: 10px 20px;
      border-radius: 14px;
      box-shadow: 0 10px 20px rgba(0, 0, 0, .28), inset 0 1px 0 rgba(255, 255, 255, .35)
    }

    .nl-digital-time {
      font-size: 48px;
      letter-spacing: 0.12em
    }

    .nl-digital-inline .nl-digital-time {
      font-size: 34px
    }

    .nl-digital-sec {
      font-size: 20px;
      opacity: .85
    }

    @media (max-width:640px) {
      .nl-digital-time {
        font-size: 38px
      }

      .nl-digital-inline .nl-digital-time {
        font-size: 30px
      }
    }

    .nl-planner-clock-wrap {
      margin: -8px 0 32px;
      padding: 0;
      border: none;
      background: transparent;
      box-shadow: none;
    }

    .nl-planner-clock-host {
      display: flex;
      justify-content: center;
      align-items: center;
      pointer-events: none;
      overflow: visible;
    }

    .nl-planner-clock-host .clock-wrap {
      margin: 0;
      transform: translateY(-28px) scale(1.24);
      transform-origin: top center;
      pointer-events: none;
    }

    .nl-planner-clock-host .clock-wrap svg {
      max-width: 620px;
    }

    .nl-planner-clock-host #hint,
    .nl-planner-clock-host #plEta,
    .nl-planner-clock-host .hud-pill,
    .nl-planner-clock-host #plannerDirectLabel {
      display: none !important;
    }

    @media (max-width:640px) {
      .nl-planner-clock-host .clock-wrap {
        transform: translateY(-14px) scale(.95);
        margin: 0;
      }
    }

    .btn.ghost.active {
      background: var(--accent);
      color: #fff;
      border-color: transparent
    }

    .quick-dialog-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(5, 8, 12, .75);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 4000;
      padding: 12px;
      animation: fadeBackdrop var(--dur-md) var(--ease-soft) both
    }

    .quick-dialog-card {
      background: var(--face);
      color: var(--fg);
      border: 1px solid var(--ring);
      border-radius: 18px;
      min-width: 280px;
      max-width: min(420px, 92vw);
      padding: 22px;
      box-shadow: 0 30px 60px rgba(0, 0, 0, .55);
      animation: popCard var(--dur-sm) var(--ease-emph) both
    }

    .quick-dialog-card h3 {
      margin: 0 0 12px 0;
      font-size: 18px
    }

    .quick-dialog-card label {
      display: block;
      font-size: 12px;
      color: var(--muted);
      margin-top: 12px
    }

    .quick-dialog-card input[type="text"],
    .quick-dialog-card input[type="datetime-local"],
    .quick-dialog-card input[type="color"] {
      width: 100%;
      margin-top: 4px;
      padding: 8px;
      border-radius: 10px;
      border: 1px solid var(--ring);
      background: rgba(0, 0, 0, .15);
      color: var(--fg)
    }

    .quick-dialog-card input[type="color"] {
      height: 42px;
      padding: 4px
    }

    .quick-dialog-actions {
      display: flex;
      gap: 10px;
      margin-top: 18px
    }

    .quick-dialog-actions button {
      flex: 1
    }

    .btn.small:hover {
      filter: brightness(1.1)
    }

    .btn.small.danger {
      background: #5b1e1e;
      color: #fff;
      border-color: #9e2a2a
    }

    /* Unify planner complete button with numberline style */
    #pageCompleteBtn.btn.small {
      background: var(--ring);
      color: var(--muted);
      border: 1px solid rgba(255, 255, 255, .35);
      box-shadow: 0 6px 16px rgba(0, 0, 0, .35), inset 0 0 0 1px rgba(255, 255, 255, .2);
      backdrop-filter: saturate(140%) blur(6px);
      -webkit-backdrop-filter: saturate(140%) blur(6px);
    }

    /* === Horror Theme === */
    .theme-horror {
      --bg: #0b0b0d;
      --face: #121216;
      --ring: rgba(255, 255, 255, 0.08);
      --muted: #d0cfd4;
      --accent: #c1121f;
      --handH: #fafafa;
      --handM: #ff3b3b;
      --handS: #ff3b3b;
      --tickMinor: rgba(255, 255, 255, 0.15);
      --tickMajor: rgba(255, 255, 255, 0.9);
    }

    .theme-horror .clock-wrap {
      position: relative;
      overflow: visible;
    }

    .theme-horror #clock {
      filter: drop-shadow(0 2px 8px rgba(193, 18, 31, .5));
    }

    .theme-horror .bleed {
      position: absolute;
      left: 50%;
      top: -8px;
      width: 6px;
      height: 18px;
      background: #c1121f;
      border-radius: 3px;
      transform: translateX(-50%);
      animation: drip 2.2s infinite ease-in;
      box-shadow: 0 0 8px rgba(193, 18, 31, .6);
    }

    @keyframes drip {
      0% {
        transform: translate(-50%, 0) scaleY(0.6);
      }

      70% {
        transform: translate(-50%, 20px) scaleY(1);
      }

      100% {
        transform: translate(-50%, 0) scaleY(0.6);
      }
    }

    .theme-horror .pulse {
      position: absolute;
      inset: auto 0 0 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(193, 18, 31, .65), transparent);
      animation: pulse 1.8s infinite ease-in-out;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: .2
      }

      50% {
        opacity: 1
      }
    }


    .nl-eta {
      position: absolute;
      left: 50%;
      bottom: -24px;
      transform: translateX(-50%);
      padding: 4px 14px;
      border-radius: 999px;
      background: rgba(0, 0, 0, .35);
      color: var(--muted);
      font-size: 16px;
      font-weight: 700;
      line-height: 1;
      backdrop-filter: blur(6px);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, .08);
      pointer-events: none
    }

    .nl-fullscreen {
      position: fixed;
      inset: 0;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 24px
    }

    .nl-fullscreen .nl-row {
      width: min(1400px, 95vw)
    }

    .nl-row {
      padding-bottom: 30px
    }

    .nl-fs-close {
      position: fixed;
      top: 16px;
      right: 16px;
      background: var(--ring);
      border: 1px solid rgba(255, 255, 255, .1);
      color: var(--muted);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 14px
    }



    /* === Overall Study Indicators === */
    .overall-study {
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      margin: 8px 0 4px 0;
      padding: 14px 14px 12px;
      /* 少し下げる */
      border: 1px solid var(--ring);
      border-radius: 12px;
      background: rgba(0, 0, 0, .25);
      font-weight: 700;
      font-family: monospace;
      font-size: 16px;
      line-height: 1.2;
    }

    .overall-study #osiRemain,
    .overall-study #osiEnd {
      color: var(--accent);
      font-size: inherit;
      transform: translateY(2px);
    }

    .overall-study #osiEnd {
      color: var(--fg);
    }

    .nl-overall {
      position: absolute;
      right: 10px;
      top: 14px;
      /* 少し下げる */
      padding: 14px 16px 12px;
      border: 1px solid var(--ring);
      border-radius: 12px;
      background: rgba(0, 0, 0, .35);
      font-weight: 800;
      font-size: clamp(18px, 2vw, 28px);
      line-height: 1.1;
      pointer-events: auto;
      z-index: 5;
    }

    .nl-overall div,
    .nl-overall small {
      transform: translateY(1px)
    }

    .nl-overall small {
      display: block;
      color: var(--muted);
      font-weight: 600;
      margin-top: 2px;
      font-size: clamp(13px, 1.4vw, 18px)
    }


    /* Inline overall indicator next to per-event ETA in numberline */
    .nl-overall-inline {
      position: absolute;
      bottom: -24px;
      /* align with nl-eta */
      left: calc(50% + 120px);
      /* a bit to the right of centered eta */
      transform: translateX(0);
      font-size: clamp(14px, 1.8vw, 22px);
      font-weight: 700;
      background: rgba(0, 0, 0, .28);
      border: 1px solid var(--ring);
      border-radius: 8px;
      padding: 3px 6px;
      color: var(--fg);
      pointer-events: auto;
      z-index: 6;
      font-family: monospace;
    }
  </style>
  <style data-planner-style="1" media="not all">
    .nl-bars {
      padding: 0;
      border: 0;
      box-sizing: border-box;
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 2;
    }

    .btn.small {
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 6px;
      background: var(--ring);
      color: var(--muted);
      border: 1px solid rgba(255, 255, 255, .15);
      cursor: pointer
    }

    /* === Horror Theme === */
    .theme-horror {
      --bg: #0b0b0d;
      --face: #121216;
      --ring: rgba(255, 255, 255, 0.08);
      --muted: #d0cfd4;
      --accent: #c1121f;
      --handH: #fafafa;
      --handM: #ff3b3b;
      --handS: #ff3b3b;
      --tickMinor: rgba(255, 255, 255, 0.15);
      --tickMajor: rgba(255, 255, 255, 0.9);
    }

    .theme-horror .clock-wrap {
      position: relative;
      overflow: visible;
    }

    .theme-horror #clock {
      filter: drop-shadow(0 2px 8px rgba(193, 18, 31, .5));
    }

    .theme-horror .bleed {
      position: absolute;
      left: 50%;
      top: -8px;
      width: 6px;
      height: 18px;
      background: #c1121f;
      border-radius: 3px;
      transform: translateX(-50%);
      animation: drip 2.2s infinite ease-in;
      box-shadow: 0 0 8px rgba(193, 18, 31, .6);
    }

    @keyframes drip {
      0% {
        transform: translate(-50%, 0) scaleY(0.6);
      }

      70% {
        transform: translate(-50%, 20px) scaleY(1);
      }

      100% {
        transform: translate(-50%, 0) scaleY(0.6);
      }
    }

    .theme-horror .pulse {
      position: absolute;
      inset: auto 0 0 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(193, 18, 31, .65), transparent);
      animation: pulse 1.8s infinite ease-in-out;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: .2
      }

      50% {
        opacity: 1
      }
    }


    .nl-eta {
      position: absolute;
      left: 50%;
      bottom: -24px;
      transform: translateX(-50%);
      padding: 4px 14px;
      border-radius: 999px;
      background: rgba(0, 0, 0, .35);
      color: var(--muted);
      font-size: 16px;
      font-weight: 700;
      line-height: 1;
      backdrop-filter: blur(6px);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, .08);
      pointer-events: none
    }

    .nl-fullscreen {
      position: fixed;
      inset: 0;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 24px
    }

    .nl-fullscreen .nl-row {
      width: min(1400px, 95vw)
    }

    .nl-row {
      padding-bottom: 30px
    }

    .nl-fs-close {
      position: fixed;
      top: 16px;
      right: 16px;
      background: var(--ring);
      border: 1px solid rgba(255, 255, 255, .1);
      color: var(--muted);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 14px
    }

    .btn.small:hover {
      filter: brightness(1.1)
    }

    .btn.small.danger {
      background: #5b1e1e;
      color: #fff;
      border-color: #9e2a2a
    }

    /* Planner top complete button */
    #pageCompleteBtn {
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 50;
    }

    /* Unify design with numberline button */
    .btn.small {
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 6px;
      background: var(--ring);
      color: var(--muted);
      border: 1px solid rgba(255, 255, 255, .15);
      cursor: pointer
    }

    /* === Horror Theme === */
    .theme-horror {
      --bg: #0b0b0d;
      --face: #121216;
      --ring: rgba(255, 255, 255, 0.08);
      --muted: #d0cfd4;
      --accent: #c1121f;
      --handH: #fafafa;
      --handM: #ff3b3b;
      --handS: #ff3b3b;
      --tickMinor: rgba(255, 255, 255, 0.15);
      --tickMajor: rgba(255, 255, 255, 0.9);
    }

    .theme-horror .clock-wrap {
      position: relative;
      overflow: visible;
    }

    .theme-horror #clock {
      filter: drop-shadow(0 2px 8px rgba(193, 18, 31, .5));
    }

    .theme-horror .bleed {
      position: absolute;
      left: 50%;
      top: -8px;
      width: 6px;
      height: 18px;
      background: #c1121f;
      border-radius: 3px;
      transform: translateX(-50%);
      animation: drip 2.2s infinite ease-in;
      box-shadow: 0 0 8px rgba(193, 18, 31, .6);
    }

    @keyframes drip {
      0% {
        transform: translate(-50%, 0) scaleY(0.6);
      }

      70% {
        transform: translate(-50%, 20px) scaleY(1);
      }

      100% {
        transform: translate(-50%, 0) scaleY(0.6);
      }
    }

    .theme-horror .pulse {
      position: absolute;
      inset: auto 0 0 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(193, 18, 31, .65), transparent);
      animation: pulse 1.8s infinite ease-in-out;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: .2
      }

      50% {
        opacity: 1
      }
    }


    .nl-eta {
      position: absolute;
      left: 50%;
      bottom: -24px;
      transform: translateX(-50%);
      padding: 4px 14px;
      border-radius: 999px;
      background: rgba(0, 0, 0, .35);
      color: var(--muted);
      font-size: 16px;
      font-weight: 700;
      line-height: 1;
      backdrop-filter: blur(6px);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, .08);
      pointer-events: none
    }

    .nl-fullscreen {
      position: fixed;
      inset: 0;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 24px
    }

    .nl-fullscreen .nl-row {
      width: min(1400px, 95vw)
    }

    .nl-row {
      padding-bottom: 30px
    }

    .nl-fs-close {
      position: fixed;
      top: 16px;
      right: 16px;
      background: var(--ring);
      border: 1px solid rgba(255, 255, 255, .1);
      color: var(--muted);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 14px
    }

    .btn.small:hover {
      filter: brightness(1.1)
    }

    .btn.small.danger {
      background: #5b1e1e;
      color: #fff;
      border-color: #9e2a2a
    }

    /* Unify planner complete button with numberline style */
    #pageCompleteBtn.btn.small {
      background: var(--ring);
      color: var(--muted);
      border: 1px solid rgba(255, 255, 255, .35);
      box-shadow: 0 6px 16px rgba(0, 0, 0, .35), inset 0 0 0 1px rgba(255, 255, 255, .2);
      backdrop-filter: saturate(140%) blur(6px);
      -webkit-backdrop-filter: saturate(140%) blur(6px);
    }

    /* === Horror Theme === */
    .theme-horror {
      --bg: #0b0b0d;
      --face: #121216;
      --ring: rgba(255, 255, 255, 0.08);
      --muted: #d0cfd4;
      --accent: #c1121f;
      --handH: #fafafa;
      --handM: #ff3b3b;
      --handS: #ff3b3b;
      --tickMinor: rgba(255, 255, 255, 0.15);
      --tickMajor: rgba(255, 255, 255, 0.9);
    }

    .theme-horror .clock-wrap {
      position: relative;
      overflow: visible;
    }

    .theme-horror #clock {
      filter: drop-shadow(0 2px 8px rgba(193, 18, 31, .5));
    }

    .theme-horror .bleed {
      position: absolute;
      left: 50%;
      top: -8px;
      width: 6px;
      height: 18px;
      background: #c1121f;
      border-radius: 3px;
      transform: translateX(-50%);
      animation: drip 2.2s infinite ease-in;
      box-shadow: 0 0 8px rgba(193, 18, 31, .6);
    }

    @keyframes drip {
      0% {
        transform: translate(-50%, 0) scaleY(0.6);
      }

      70% {
        transform: translate(-50%, 20px) scaleY(1);
      }

      100% {
        transform: translate(-50%, 0) scaleY(0.6);
      }
    }

    .theme-horror .pulse {
      position: absolute;
      inset: auto 0 0 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(193, 18, 31, .65), transparent);
      animation: pulse 1.8s infinite ease-in-out;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: .2
      }

      50% {
        opacity: 1
      }
    }


    .nl-eta {
      position: absolute;
      left: 50%;
      bottom: -24px;
      transform: translateX(-50%);
      padding: 4px 14px;
      border-radius: 999px;
      background: rgba(0, 0, 0, .35);
      color: var(--muted);
      font-size: 16px;
      font-weight: 700;
      line-height: 1;
      backdrop-filter: blur(6px);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, .08);
      pointer-events: none
    }

    .nl-fullscreen {
      position: fixed;
      inset: 0;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 24px
    }

    .nl-fullscreen .nl-row {
      width: min(1400px, 95vw)
    }

    .nl-row {
      padding-bottom: 30px
    }

    .nl-fs-close {
      position: fixed;
      top: 16px;
      right: 16px;
      background: var(--ring);
      border: 1px solid rgba(255, 255, 255, .1);
      color: var(--muted);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 14px
    }
  </style>
  <style data-planner-style="1" media="not all">
    .nl-tick,
    .nl-label {
      transform: translateX(-50%);
    }

    .nl-hand {
      transform: translateX(-50%);
    }

    .btn.small {
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 6px;
      background: var(--ring);
      color: var(--muted);
      border: 1px solid rgba(255, 255, 255, .15);
      cursor: pointer
    }

    /* === Horror Theme === */
    .theme-horror {
      --bg: #0b0b0d;
      --face: #121216;
      --ring: rgba(255, 255, 255, 0.08);
      --muted: #d0cfd4;
      --accent: #c1121f;
      --handH: #fafafa;
      --handM: #ff3b3b;
      --handS: #ff3b3b;
      --tickMinor: rgba(255, 255, 255, 0.15);
      --tickMajor: rgba(255, 255, 255, 0.9);
    }

    .theme-horror .clock-wrap {
      position: relative;
      overflow: visible;
    }

    .theme-horror #clock {
      filter: drop-shadow(0 2px 8px rgba(193, 18, 31, .5));
    }

    .theme-horror .bleed {
      position: absolute;
      left: 50%;
      top: -8px;
      width: 6px;
      height: 18px;
      background: #c1121f;
      border-radius: 3px;
      transform: translateX(-50%);
      animation: drip 2.2s infinite ease-in;
      box-shadow: 0 0 8px rgba(193, 18, 31, .6);
    }

    @keyframes drip {
      0% {
        transform: translate(-50%, 0) scaleY(0.6);
      }

      70% {
        transform: translate(-50%, 20px) scaleY(1);
      }

      100% {
        transform: translate(-50%, 0) scaleY(0.6);
      }
    }

    .theme-horror .pulse {
      position: absolute;
      inset: auto 0 0 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(193, 18, 31, .65), transparent);
      animation: pulse 1.8s infinite ease-in-out;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: .2
      }

      50% {
        opacity: 1
      }
    }


    .nl-eta {
      position: absolute;
      left: 50%;
      bottom: -24px;
      transform: translateX(-50%);
      padding: 4px 14px;
      border-radius: 999px;
      background: rgba(0, 0, 0, .35);
      color: var(--muted);
      font-size: 16px;
      font-weight: 700;
      line-height: 1;
      backdrop-filter: blur(6px);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, .08);
      pointer-events: none
    }

    .nl-fullscreen {
      position: fixed;
      inset: 0;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 24px
    }

    .nl-fullscreen .nl-row {
      width: min(1400px, 95vw)
    }

    .nl-row {
      padding-bottom: 30px
    }

    .nl-fs-close {
      position: fixed;
      top: 16px;
      right: 16px;
      background: var(--ring);
      border: 1px solid rgba(255, 255, 255, .1);
      color: var(--muted);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 14px
    }

    .btn.small:hover {
      filter: brightness(1.1)
    }

    .btn.small.danger {
      background: #5b1e1e;
      color: #fff;
      border-color: #9e2a2a
    }

    /* Planner top complete button */
    #pageCompleteBtn {
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 50;
    }

    /* Unify design with numberline button */
    .btn.small {
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 6px;
      background: var(--ring);
      color: var(--muted);
      border: 1px solid rgba(255, 255, 255, .15);
      cursor: pointer
    }

    /* === Horror Theme === */
    .theme-horror {
      --bg: #0b0b0d;
      --face: #121216;
      --ring: rgba(255, 255, 255, 0.08);
      --muted: #d0cfd4;
      --accent: #c1121f;
      --handH: #fafafa;
      --handM: #ff3b3b;
      --handS: #ff3b3b;
      --tickMinor: rgba(255, 255, 255, 0.15);
      --tickMajor: rgba(255, 255, 255, 0.9);
    }

    .theme-horror .clock-wrap {
      position: relative;
      overflow: visible;
    }

    .theme-horror #clock {
      filter: drop-shadow(0 2px 8px rgba(193, 18, 31, .5));
    }

    .theme-horror .bleed {
      position: absolute;
      left: 50%;
      top: -8px;
      width: 6px;
      height: 18px;
      background: #c1121f;
      border-radius: 3px;
      transform: translateX(-50%);
      animation: drip 2.2s infinite ease-in;
      box-shadow: 0 0 8px rgba(193, 18, 31, .6);
    }

    @keyframes drip {
      0% {
        transform: translate(-50%, 0) scaleY(0.6);
      }

      70% {
        transform: translate(-50%, 20px) scaleY(1);
      }

      100% {
        transform: translate(-50%, 0) scaleY(0.6);
      }
    }

    .theme-horror .pulse {
      position: absolute;
      inset: auto 0 0 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(193, 18, 31, .65), transparent);
      animation: pulse 1.8s infinite ease-in-out;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: .2
      }

      50% {
        opacity: 1
      }
    }


    .nl-eta {
      position: absolute;
      left: 50%;
      bottom: -24px;
      transform: translateX(-50%);
      padding: 4px 14px;
      border-radius: 999px;
      background: rgba(0, 0, 0, .35);
      color: var(--muted);
      font-size: 16px;
      font-weight: 700;
      line-height: 1;
      backdrop-filter: blur(6px);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, .08);
      pointer-events: none
    }

    .nl-fullscreen {
      position: fixed;
      inset: 0;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 24px
    }

    .nl-fullscreen .nl-row {
      width: min(1400px, 95vw)
    }

    .nl-row {
      padding-bottom: 30px
    }

    .nl-fs-close {
      position: fixed;
      top: 16px;
      right: 16px;
      background: var(--ring);
      border: 1px solid rgba(255, 255, 255, .1);
      color: var(--muted);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 14px
    }

    .btn.small:hover {
      filter: brightness(1.1)
    }

    .btn.small.danger {
      background: #5b1e1e;
      color: #fff;
      border-color: #9e2a2a
    }

    /* Unify planner complete button with numberline style */
    #pageCompleteBtn.btn.small {
      background: var(--ring);
      color: var(--muted);
      border: 1px solid rgba(255, 255, 255, .35);
      box-shadow: 0 6px 16px rgba(0, 0, 0, .35), inset 0 0 0 1px rgba(255, 255, 255, .2);
      backdrop-filter: saturate(140%) blur(6px);
      -webkit-backdrop-filter: saturate(140%) blur(6px);
    }

    /* === Horror Theme === */
    .theme-horror {
      --bg: #0b0b0d;
      --face: #121216;
      --ring: rgba(255, 255, 255, 0.08);
      --muted: #d0cfd4;
      --accent: #c1121f;
      --handH: #fafafa;
      --handM: #ff3b3b;
      --handS: #ff3b3b;
      --tickMinor: rgba(255, 255, 255, 0.15);
      --tickMajor: rgba(255, 255, 255, 0.9);
    }

    .theme-horror .clock-wrap {
      position: relative;
      overflow: visible;
    }

    .theme-horror #clock {
      filter: drop-shadow(0 2px 8px rgba(193, 18, 31, .5));
    }

    .theme-horror .bleed {
      position: absolute;
      left: 50%;
      top: -8px;
      width: 6px;
      height: 18px;
      background: #c1121f;
      border-radius: 3px;
      transform: translateX(-50%);
      animation: drip 2.2s infinite ease-in;
      box-shadow: 0 0 8px rgba(193, 18, 31, .6);
    }

    @keyframes drip {
      0% {
        transform: translate(-50%, 0) scaleY(0.6);
      }

      70% {
        transform: translate(-50%, 20px) scaleY(1);
      }

      100% {
        transform: translate(-50%, 0) scaleY(0.6);
      }
    }

    .theme-horror .pulse {
      position: absolute;
      inset: auto 0 0 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(193, 18, 31, .65), transparent);
      animation: pulse 1.8s infinite ease-in-out;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: .2
      }

      50% {
        opacity: 1
      }
    }


    .nl-eta {
      position: absolute;
      left: 50%;
      bottom: -24px;
      transform: translateX(-50%);
      padding: 4px 14px;
      border-radius: 999px;
      background: rgba(0, 0, 0, .35);
      color: var(--muted);
      font-size: 16px;
      font-weight: 700;
      line-height: 1;
      backdrop-filter: blur(6px);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, .08);
      pointer-events: none
    }

    .nl-fullscreen {
      position: fixed;
      inset: 0;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 24px
    }

    .nl-fullscreen .nl-row {
      width: min(1400px, 95vw)
    }

    .nl-row {
      padding-bottom: 30px
    }

    .nl-fs-close {
      position: fixed;
      top: 16px;
      right: 16px;
      background: var(--ring);
      border: 1px solid rgba(255, 255, 255, .1);
      color: var(--muted);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 14px
    }
  </style>
  <style data-planner-style="1" media="not all">
    /* nl-bar override */
    .nl-bar {
      height: 22px;
      position: absolute;
      top: 56%;
      transform: translateY(-50%);
      border-radius: 6px;
    }

    .btn.small {
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 6px;
      background: var(--ring);
      color: var(--muted);
      border: 1px solid rgba(255, 255, 255, .15);
      cursor: pointer
    }

    /* === Horror Theme === */
    .theme-horror {
      --bg: #0b0b0d;
      --face: #121216;
      --ring: rgba(255, 255, 255, 0.08);
      --muted: #d0cfd4;
      --accent: #c1121f;
      --handH: #fafafa;
      --handM: #ff3b3b;
      --handS: #ff3b3b;
      --tickMinor: rgba(255, 255, 255, 0.15);
      --tickMajor: rgba(255, 255, 255, 0.9);
    }

    .theme-horror .clock-wrap {
      position: relative;
      overflow: visible;
    }

    .theme-horror #clock {
      filter: drop-shadow(0 2px 8px rgba(193, 18, 31, .5));
    }

    .theme-horror .bleed {
      position: absolute;
      left: 50%;
      top: -8px;
      width: 6px;
      height: 18px;
      background: #c1121f;
      border-radius: 3px;
      transform: translateX(-50%);
      animation: drip 2.2s infinite ease-in;
      box-shadow: 0 0 8px rgba(193, 18, 31, .6);
    }

    @keyframes drip {
      0% {
        transform: translate(-50%, 0) scaleY(0.6);
      }

      70% {
        transform: translate(-50%, 20px) scaleY(1);
      }

      100% {
        transform: translate(-50%, 0) scaleY(0.6);
      }
    }

    .theme-horror .pulse {
      position: absolute;
      inset: auto 0 0 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(193, 18, 31, .65), transparent);
      animation: pulse 1.8s infinite ease-in-out;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: .2
      }

      50% {
        opacity: 1
      }
    }


    .nl-eta {
      position: absolute;
      left: 50%;
      bottom: -24px;
      transform: translateX(-50%);
      padding: 4px 14px;
      border-radius: 999px;
      background: rgba(0, 0, 0, .35);
      color: var(--muted);
      font-size: 16px;
      font-weight: 700;
      line-height: 1;
      backdrop-filter: blur(6px);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, .08);
      pointer-events: none
    }

    .nl-fullscreen {
      position: fixed;
      inset: 0;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 24px
    }

    .nl-fullscreen .nl-row {
      width: min(1400px, 95vw)
    }

    .nl-row {
      padding-bottom: 30px
    }

    .nl-fs-close {
      position: fixed;
      top: 16px;
      right: 16px;
      background: var(--ring);
      border: 1px solid rgba(255, 255, 255, .1);
      color: var(--muted);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 14px
    }

    .btn.small:hover {
      filter: brightness(1.1)
    }

    .btn.small.danger {
      background: #5b1e1e;
      color: #fff;
      border-color: #9e2a2a
    }

    /* Planner top complete button */
    #pageCompleteBtn {
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 50;
    }

    /* Unify design with numberline button */
    .btn.small {
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 6px;
      background: var(--ring);
      color: var(--muted);
      border: 1px solid rgba(255, 255, 255, .15);
      cursor: pointer
    }

    /* === Horror Theme === */
    .theme-horror {
      --bg: #0b0b0d;
      --face: #121216;
      --ring: rgba(255, 255, 255, 0.08);
      --muted: #d0cfd4;
      --accent: #c1121f;
      --handH: #fafafa;
      --handM: #ff3b3b;
      --handS: #ff3b3b;
      --tickMinor: rgba(255, 255, 255, 0.15);
      --tickMajor: rgba(255, 255, 255, 0.9);
    }

    .theme-horror .clock-wrap {
      position: relative;
      overflow: visible;
    }

    .theme-horror #clock {
      filter: drop-shadow(0 2px 8px rgba(193, 18, 31, .5));
    }

    .theme-horror .bleed {
      position: absolute;
      left: 50%;
      top: -8px;
      width: 6px;
      height: 18px;
      background: #c1121f;
      border-radius: 3px;
      transform: translateX(-50%);
      animation: drip 2.2s infinite ease-in;
      box-shadow: 0 0 8px rgba(193, 18, 31, .6);
    }

    @keyframes drip {
      0% {
        transform: translate(-50%, 0) scaleY(0.6);
      }

      70% {
        transform: translate(-50%, 20px) scaleY(1);
      }

      100% {
        transform: translate(-50%, 0) scaleY(0.6);
      }
    }

    .theme-horror .pulse {
      position: absolute;
      inset: auto 0 0 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(193, 18, 31, .65), transparent);
      animation: pulse 1.8s infinite ease-in-out;
    }

    .nl-eta {
      font-family: var(--clock-font);
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: .2
      }

      50% {
        opacity: 1
      }
    }


    .nl-eta {
      position: absolute;
      left: 50%;
      bottom: -24px;
      transform: translateX(-50%);
      padding: 4px 14px;
      border-radius: 999px;
      background: rgba(0, 0, 0, .35);
      color: var(--muted);
      font-size: 16px;
      font-weight: 700;
      line-height: 1;
      backdrop-filter: blur(6px);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, .08);
      pointer-events: none
    }

    .nl-fullscreen {
      position: fixed;
      inset: 0;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 24px
    }

    .nl-fullscreen .nl-row {
      width: min(1400px, 95vw)
    }

    .nl-row {
      padding-bottom: 30px
    }

    .nl-fs-close {
      position: fixed;
      top: 16px;
      right: 16px;
      background: var(--ring);
      border: 1px solid rgba(255, 255, 255, .1);
      color: var(--muted);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 14px
    }

    .btn.small:hover {
      filter: brightness(1.1)
    }

    .btn.small.danger {
      background: #5b1e1e;
      color: #fff;
      border-color: #9e2a2a
    }

    /* Unify planner complete button with numberline style */
    #pageCompleteBtn.btn.small {
      background: var(--ring);
      color: var(--muted);
      border: 1px solid rgba(255, 255, 255, .35);
      box-shadow: 0 6px 16px rgba(0, 0, 0, .35), inset 0 0 0 1px rgba(255, 255, 255, .2);
      backdrop-filter: saturate(140%) blur(6px);
      -webkit-backdrop-filter: saturate(140%) blur(6px);
    }

    /* === Horror Theme === */
    .theme-horror {
      --bg: #0b0b0d;
      --face: #121216;
      --ring: rgba(255, 255, 255, 0.08);
      --muted: #d0cfd4;
      --accent: #c1121f;
      --handH: #fafafa;
      --handM: #ff3b3b;
      --handS: #ff3b3b;
      --tickMinor: rgba(255, 255, 255, 0.15);
      --tickMajor: rgba(255, 255, 255, 0.9);
    }

    .theme-horror .clock-wrap {
      position: relative;
      overflow: visible;
    }

    .theme-horror #clock {
      filter: drop-shadow(0 2px 8px rgba(193, 18, 31, .5));
    }

    .theme-horror .bleed {
      position: absolute;
      left: 50%;
      top: -8px;
      width: 6px;
      height: 18px;
      background: #c1121f;
      border-radius: 3px;
      transform: translateX(-50%);
      animation: drip 2.2s infinite ease-in;
      box-shadow: 0 0 8px rgba(193, 18, 31, .6);
    }

    @keyframes drip {
      0% {
        transform: translate(-50%, 0) scaleY(0.6);
      }

      70% {
        transform: translate(-50%, 20px) scaleY(1);
      }

      100% {
        transform: translate(-50%, 0) scaleY(0.6);
      }
    }

    .theme-horror .pulse {
      position: absolute;
      inset: auto 0 0 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(193, 18, 31, .65), transparent);
      animation: pulse 1.8s infinite ease-in-out;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: .2
      }

      50% {
        opacity: 1
      }
    }


    .nl-eta {
      position: absolute;
      left: 50%;
      bottom: -24px;
      transform: translateX(-50%);
      padding: 4px 14px;
      border-radius: 999px;
      background: rgba(0, 0, 0, .35);
      color: var(--muted);
      font-size: 16px;
      font-weight: 700;
      line-height: 1;
      backdrop-filter: blur(6px);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, .08);
      pointer-events: none
    }

    .nl-fullscreen {
      position: fixed;
      inset: 0;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 24px
    }

    .nl-fullscreen .nl-row {
      width: min(1400px, 95vw)
    }

    .nl-row {
      padding-bottom: 30px
    }

    .nl-fs-close {
      position: fixed;
      top: 16px;
      right: 16px;
      background: var(--ring);
      border: 1px solid rgba(255, 255, 255, .1);
      color: var(--muted);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 14px
    }
  </style>
  <style data-planner-style="1" media="not all">
    /* numberline tick visibility tweaks */
    .nl-scale {
      position: relative;
    }

    .nl-lane {
      position: absolute;
      left: 18px;
      right: 18px;
      top: 0;
      bottom: 0;
    }

    .nl-tick {
      position: absolute;
      width: 1px;
      background: var(--tickMinor, rgba(255, 255, 255, 0.35));
      top: 40%;
      height: 28%;
      transform: translateX(-50%);
    }

    .nl-tick.major {
      width: 3px;
      background: var(--tickMajor, rgba(255, 255, 255, 0.85));
      top: 30%;
      height: 40%;
    }

    .btn.small {
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 6px;
      background: var(--ring);
      color: var(--muted);
      border: 1px solid rgba(255, 255, 255, .15);
      cursor: pointer
    }

    /* === Horror Theme === */
    .theme-horror {
      --bg: #0b0b0d;
      --face: #121216;
      --ring: rgba(255, 255, 255, 0.08);
      --muted: #d0cfd4;
      --accent: #c1121f;
      --handH: #fafafa;
      --handM: #ff3b3b;
      --handS: #ff3b3b;
      --tickMinor: rgba(255, 255, 255, 0.15);
      --tickMajor: rgba(255, 255, 255, 0.9);
    }

    .theme-horror .clock-wrap {
      position: relative;
      overflow: visible;
    }

    .theme-horror #clock {
      filter: drop-shadow(0 2px 8px rgba(193, 18, 31, .5));
    }

    .theme-horror .bleed {
      position: absolute;
      left: 50%;
      top: -8px;
      width: 6px;
      height: 18px;
      background: #c1121f;
      border-radius: 3px;
      transform: translateX(-50%);
      animation: drip 2.2s infinite ease-in;
      box-shadow: 0 0 8px rgba(193, 18, 31, .6);
    }

    @keyframes drip {
      0% {
        transform: translate(-50%, 0) scaleY(0.6);
      }

      70% {
        transform: translate(-50%, 20px) scaleY(1);
      }

      100% {
        transform: translate(-50%, 0) scaleY(0.6);
      }
    }

    .theme-horror .pulse {
      position: absolute;
      inset: auto 0 0 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(193, 18, 31, .65), transparent);
      animation: pulse 1.8s infinite ease-in-out;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: .2
      }

      50% {
        opacity: 1
      }
    }


    .nl-eta {
      position: absolute;
      left: 50%;
      bottom: -24px;
      transform: translateX(-50%);
      padding: 4px 14px;
      border-radius: 999px;
      background: rgba(0, 0, 0, .35);
      color: var(--muted);
      font-size: 16px;
      font-weight: 700;
      line-height: 1;
      backdrop-filter: blur(6px);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, .08);
      pointer-events: none
    }

    .nl-fullscreen {
      position: fixed;
      inset: 0;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 24px
    }

    .nl-fullscreen .nl-row {
      width: min(1400px, 95vw)
    }

    .nl-row {
      padding-bottom: 30px
    }

    .nl-fs-close {
      position: fixed;
      top: 16px;
      right: 16px;
      background: var(--ring);
      border: 1px solid rgba(255, 255, 255, .1);
      color: var(--muted);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 14px
    }

    .btn.small:hover {
      filter: brightness(1.1)
    }

    .btn.small.danger {
      background: #5b1e1e;
      color: #fff;
      border-color: #9e2a2a
    }

    /* Planner top complete button */
    #pageCompleteBtn {
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 50;
    }

    /* Unify design with numberline button */
    .btn.small {
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 6px;
      background: var(--ring);
      color: var(--muted);
      border: 1px solid rgba(255, 255, 255, .15);
      cursor: pointer
    }

    /* === Horror Theme === */
    .theme-horror {
      --bg: #0b0b0d;
      --face: #121216;
      --ring: rgba(255, 255, 255, 0.08);
      --muted: #d0cfd4;
      --accent: #c1121f;
      --handH: #fafafa;
      --handM: #ff3b3b;
      --handS: #ff3b3b;
      --tickMinor: rgba(255, 255, 255, 0.15);
      --tickMajor: rgba(255, 255, 255, 0.9);
    }

    .theme-horror .clock-wrap {
      position: relative;
      overflow: visible;
    }

    .theme-horror #clock {
      filter: drop-shadow(0 2px 8px rgba(193, 18, 31, .5));
    }

    .theme-horror .bleed {
      position: absolute;
      left: 50%;
      top: -8px;
      width: 6px;
      height: 18px;
      background: #c1121f;
      border-radius: 3px;
      transform: translateX(-50%);
      animation: drip 2.2s infinite ease-in;
      box-shadow: 0 0 8px rgba(193, 18, 31, .6);
    }

    @keyframes drip {
      0% {
        transform: translate(-50%, 0) scaleY(0.6);
      }

      70% {
        transform: translate(-50%, 20px) scaleY(1);
      }

      100% {
        transform: translate(-50%, 0) scaleY(0.6);
      }
    }

    .theme-horror .pulse {
      position: absolute;
      inset: auto 0 0 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(193, 18, 31, .65), transparent);
      animation: pulse 1.8s infinite ease-in-out;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: .2
      }

      50% {
        opacity: 1
      }
    }


    .nl-eta {
      position: absolute;
      left: 50%;
      bottom: -24px;
      transform: translateX(-50%);
      padding: 4px 14px;
      border-radius: 999px;
      background: rgba(0, 0, 0, .35);
      color: var(--muted);
      font-size: 16px;
      font-weight: 700;
      line-height: 1;
      backdrop-filter: blur(6px);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, .08);
      pointer-events: none
    }

    .nl-fullscreen {
      position: fixed;
      inset: 0;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 24px
    }

    .nl-fullscreen .nl-row {
      width: min(1400px, 95vw)
    }

    .nl-row {
      padding-bottom: 30px
    }

    .nl-fs-close {
      position: fixed;
      top: 16px;
      right: 16px;
      background: var(--ring);
      border: 1px solid rgba(255, 255, 255, .1);
      color: var(--muted);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 14px
    }

    .btn.small:hover {
      filter: brightness(1.1)
    }

    .btn.small.danger {
      background: #5b1e1e;
      color: #fff;
      border-color: #9e2a2a
    }

    /* Unify planner complete button with numberline style */
    #pageCompleteBtn.btn.small {
      background: var(--ring);
      color: var(--muted);
      border: 1px solid rgba(255, 255, 255, .35);
      box-shadow: 0 6px 16px rgba(0, 0, 0, .35), inset 0 0 0 1px rgba(255, 255, 255, .2);
      backdrop-filter: saturate(140%) blur(6px);
      -webkit-backdrop-filter: saturate(140%) blur(6px);
    }

    /* === Horror Theme === */
    .theme-horror {
      --bg: #0b0b0d;
      --face: #121216;
      --ring: rgba(255, 255, 255, 0.08);
      --muted: #d0cfd4;
      --accent: #c1121f;
      --handH: #fafafa;
      --handM: #ff3b3b;
      --handS: #ff3b3b;
      --tickMinor: rgba(255, 255, 255, 0.15);
      --tickMajor: rgba(255, 255, 255, 0.9);
    }

    .theme-horror .clock-wrap {
      position: relative;
      overflow: visible;
    }

    .theme-horror #clock {
      filter: drop-shadow(0 2px 8px rgba(193, 18, 31, .5));
    }

    .theme-horror .bleed {
      position: absolute;
      left: 50%;
      top: -8px;
      width: 6px;
      height: 18px;
      background: #c1121f;
      border-radius: 3px;
      transform: translateX(-50%);
      animation: drip 2.2s infinite ease-in;
      box-shadow: 0 0 8px rgba(193, 18, 31, .6);
    }

    @keyframes drip {
      0% {
        transform: translate(-50%, 0) scaleY(0.6);
      }

      70% {
        transform: translate(-50%, 20px) scaleY(1);
      }

      100% {
        transform: translate(-50%, 0) scaleY(0.6);
      }
    }

    .theme-horror .pulse {
      position: absolute;
      inset: auto 0 0 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(193, 18, 31, .65), transparent);
      animation: pulse 1.8s infinite ease-in-out;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: .2
      }

      50% {
        opacity: 1
      }
    }


    .nl-eta {
      position: absolute;
      left: 50%;
      bottom: -24px;
      transform: translateX(-50%);
      padding: 4px 14px;
      border-radius: 999px;
      background: rgba(0, 0, 0, .35);
      color: var(--muted);
      font-size: 16px;
      font-weight: 700;
      line-height: 1;
      backdrop-filter: blur(6px);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, .08);
      pointer-events: none
    }

    .nl-fullscreen {
      position: fixed;
      inset: 0;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 24px
    }

    .nl-fullscreen .nl-row {
      width: min(1400px, 95vw)
    }

    .nl-row {
      padding-bottom: 30px
    }

    .nl-fs-close {
      position: fixed;
      top: 16px;
      right: 16px;
      background: var(--ring);
      border: 1px solid rgba(255, 255, 255, .1);
      color: var(--muted);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 14px
    }
  </style>
  <style data-planner-style="1" media="not all">
    /* 仮（Aqua風）テーマ */
    body.kari {
      --bg: radial-gradient(120% 100% at 50% 0%, #eef6ff 0%, #d9ecff 40%, #cfe8ff 60%, #c5e2ff 80%, #badaff 100%);
      --card: rgba(255, 255, 255, 0.65);
      --muted: #366080;
      --tickMinor: rgba(70, 100, 130, 0.35);
      --tickMajor: rgba(40, 80, 120, 0.9);
    }

    body.kari {
      background: var(--bg);
    }

    body.kari .panel {
      background: var(--card);
      backdrop-filter: blur(8px) saturate(140%);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.12), inset 0 1px 0 rgba(255, 255, 255, 0.6);
    }

    body.kari #clock {
      filter: drop-shadow(0 10px 18px rgba(0, 0, 0, 0.15));
    }

    body.kari .badge {
      border: 1px solid rgba(255, 255, 255, 0.6);
    }

    body.kari .tab.active {
      background: linear-gradient(#ffffff, #eaf4ff);
      border: 1px solid rgba(0, 0, 0, 0.08);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.8);
    }

    body.kari .tab {
      background: linear-gradient(#f6fbff, #e8f3ff);
      border: 1px solid rgba(0, 0, 0, 0.06);
    }

    body.kari .nl-bar {
      box-shadow: inset 0 1px 2px rgba(255, 255, 255, 0.85), inset 0 -1px 2px rgba(0, 0, 0, 0.12), 0 6px 14px rgba(0, 0, 0, 0.18);
    }

    .btn.small {
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 6px;
      background: var(--ring);
      color: var(--muted);
      border: 1px solid rgba(255, 255, 255, .15);
      cursor: pointer
    }

    /* === Horror Theme === */
    .theme-horror {
      --bg: #0b0b0d;
      --face: #121216;
      --ring: rgba(255, 255, 255, 0.08);
      --muted: #d0cfd4;
      --accent: #c1121f;
      --handH: #fafafa;
      --handM: #ff3b3b;
      --handS: #ff3b3b;
      --tickMinor: rgba(255, 255, 255, 0.15);
      --tickMajor: rgba(255, 255, 255, 0.9);
    }

    .theme-horror .clock-wrap {
      position: relative;
      overflow: visible;
    }

    .theme-horror #clock {
      filter: drop-shadow(0 2px 8px rgba(193, 18, 31, .5));
    }

    .theme-horror .bleed {
      position: absolute;
      left: 50%;
      top: -8px;
      width: 6px;
      height: 18px;
      background: #c1121f;
      border-radius: 3px;
      transform: translateX(-50%);
      animation: drip 2.2s infinite ease-in;
      box-shadow: 0 0 8px rgba(193, 18, 31, .6);
    }

    @keyframes drip {
      0% {
        transform: translate(-50%, 0) scaleY(0.6);
      }

      70% {
        transform: translate(-50%, 20px) scaleY(1);
      }

      100% {
        transform: translate(-50%, 0) scaleY(0.6);
      }
    }

    .theme-horror .pulse {
      position: absolute;
      inset: auto 0 0 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(193, 18, 31, .65), transparent);
      animation: pulse 1.8s infinite ease-in-out;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: .2
      }

      50% {
        opacity: 1
      }
    }


    .nl-eta {
      position: absolute;
      left: 50%;
      bottom: -24px;
      transform: translateX(-50%);
      padding: 4px 14px;
      border-radius: 999px;
      background: rgba(0, 0, 0, .35);
      color: var(--muted);
      font-size: 16px;
      font-weight: 700;
      line-height: 1;
      backdrop-filter: blur(6px);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, .08);
      pointer-events: none
    }

    .nl-fullscreen {
      position: fixed;
      inset: 0;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 24px
    }

    .nl-fullscreen .nl-row {
      width: min(1400px, 95vw)
    }

    .nl-row {
      padding-bottom: 30px
    }

    .nl-fs-close {
      position: fixed;
      top: 16px;
      right: 16px;
      background: var(--ring);
      border: 1px solid rgba(255, 255, 255, .1);
      color: var(--muted);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 14px
    }

    .btn.small:hover {
      filter: brightness(1.1)
    }

    .btn.small.danger {
      background: #5b1e1e;
      color: #fff;
      border-color: #9e2a2a
    }

    /* Planner top complete button */
    #pageCompleteBtn {
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 50;
    }

    /* Unify design with numberline button */
    .btn.small {
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 6px;
      background: var(--ring);
      color: var(--muted);
      border: 1px solid rgba(255, 255, 255, .15);
      cursor: pointer
    }

    /* === Horror Theme === */
    .theme-horror {
      --bg: #0b0b0d;
      --face: #121216;
      --ring: rgba(255, 255, 255, 0.08);
      --muted: #d0cfd4;
      --accent: #c1121f;
      --handH: #fafafa;
      --handM: #ff3b3b;
      --handS: #ff3b3b;
      --tickMinor: rgba(255, 255, 255, 0.15);
      --tickMajor: rgba(255, 255, 255, 0.9);
    }

    .theme-horror .clock-wrap {
      position: relative;
      overflow: visible;
    }

    .theme-horror #clock {
      filter: drop-shadow(0 2px 8px rgba(193, 18, 31, .5));
    }

    .theme-horror .bleed {
      position: absolute;
      left: 50%;
      top: -8px;
      width: 6px;
      height: 18px;
      background: #c1121f;
      border-radius: 3px;
      transform: translateX(-50%);
      animation: drip 2.2s infinite ease-in;
      box-shadow: 0 0 8px rgba(193, 18, 31, .6);
    }

    @keyframes drip {
      0% {
        transform: translate(-50%, 0) scaleY(0.6);
      }

      70% {
        transform: translate(-50%, 20px) scaleY(1);
      }

      100% {
        transform: translate(-50%, 0) scaleY(0.6);
      }
    }

    .theme-horror .pulse {
      position: absolute;
      inset: auto 0 0 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(193, 18, 31, .65), transparent);
      animation: pulse 1.8s infinite ease-in-out;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: .2
      }

      50% {
        opacity: 1
      }
    }


    .nl-eta {
      position: absolute;
      left: 50%;
      bottom: -24px;
      transform: translateX(-50%);
      padding: 4px 14px;
      border-radius: 999px;
      background: rgba(0, 0, 0, .35);
      color: var(--muted);
      font-size: 16px;
      font-weight: 700;
      line-height: 1;
      backdrop-filter: blur(6px);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, .08);
      pointer-events: none
    }

    .nl-fullscreen {
      position: fixed;
      inset: 0;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 24px
    }

    .nl-fullscreen .nl-row {
      width: min(1400px, 95vw)
    }

    .nl-row {
      padding-bottom: 30px
    }

    .nl-fs-close {
      position: fixed;
      top: 16px;
      right: 16px;
      background: var(--ring);
      border: 1px solid rgba(255, 255, 255, .1);
      color: var(--muted);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 14px
    }

    .btn.small:hover {
      filter: brightness(1.1)
    }

    .btn.small.danger {
      background: #5b1e1e;
      color: #fff;
      border-color: #9e2a2a
    }

    /* Unify planner complete button with numberline style */
    #pageCompleteBtn.btn.small {
      background: var(--ring);
      color: var(--muted);
      border: 1px solid rgba(255, 255, 255, .35);
      box-shadow: 0 6px 16px rgba(0, 0, 0, .35), inset 0 0 0 1px rgba(255, 255, 255, .2);
      backdrop-filter: saturate(140%) blur(6px);
      -webkit-backdrop-filter: saturate(140%) blur(6px);
    }

    /* === Horror Theme === */
    .theme-horror {
      --bg: #0b0b0d;
      --face: #121216;
      --ring: rgba(255, 255, 255, 0.08);
      --muted: #d0cfd4;
      --accent: #c1121f;
      --handH: #fafafa;
      --handM: #ff3b3b;
      --handS: #ff3b3b;
      --tickMinor: rgba(255, 255, 255, 0.15);
      --tickMajor: rgba(255, 255, 255, 0.9);
    }

    .theme-horror .clock-wrap {
      position: relative;
      overflow: visible;
    }

    .theme-horror #clock {
      filter: drop-shadow(0 2px 8px rgba(193, 18, 31, .5));
    }

    .theme-horror .bleed {
      position: absolute;
      left: 50%;
      top: -8px;
      width: 6px;
      height: 18px;
      background: #c1121f;
      border-radius: 3px;
      transform: translateX(-50%);
      animation: drip 2.2s infinite ease-in;
      box-shadow: 0 0 8px rgba(193, 18, 31, .6);
    }

    @keyframes drip {
      0% {
        transform: translate(-50%, 0) scaleY(0.6);
      }

      70% {
        transform: translate(-50%, 20px) scaleY(1);
      }

      100% {
        transform: translate(-50%, 0) scaleY(0.6);
      }
    }

    .theme-horror .pulse {
      position: absolute;
      inset: auto 0 0 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(193, 18, 31, .65), transparent);
      animation: pulse 1.8s infinite ease-in-out;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: .2
      }

      50% {
        opacity: 1
      }
    }


    .nl-eta {
      position: absolute;
      left: 50%;
      bottom: -24px;
      transform: translateX(-50%);
      padding: 4px 14px;
      border-radius: 999px;
      background: rgba(0, 0, 0, .35);
      color: var(--muted);
      font-size: 16px;
      font-weight: 700;
      line-height: 1;
      backdrop-filter: blur(6px);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, .08);
      pointer-events: none
    }

    .nl-fullscreen {
      position: fixed;
      inset: 0;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 24px
    }

    .nl-fullscreen .nl-row {
      width: min(1400px, 95vw)
    }

    .nl-row {
      padding-bottom: 30px
    }

    .nl-fs-close {
      position: fixed;
      top: 16px;
      right: 16px;
      background: var(--ring);
      border: 1px solid rgba(255, 255, 255, .1);
      color: var(--muted);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 14px
    }
  </style>
  <style data-planner-style="1" media="not all">
    /* migrated from テーマ.html */
    @keyframes waterRipple {
      0% {
        background-position: 0 0, 0 0;
      }

      100% {
        background-position: 200% 0, -200% 0;
      }
    }

    @keyframes auroraFlow {
      0% {
        background-position: 0% 50%;
      }

      50% {
        background-position: 100% 50%;
      }

      100% {
        background-position: 0% 50%;
      }
    }

    body.water {
      --bg1: radial-gradient(120% 90% at 50% -10%, rgba(180, 220, 255, 0.9), rgba(120, 180, 255, 0.5), rgba(30, 120, 200, 0.35));
      --bg2: repeating-linear-gradient(to right, rgba(255, 255, 255, 0.15) 0 2px, rgba(0, 0, 0, 0) 2px 6px);
      background-image: var(--bg1), var(--bg2);
      background-size: 200% 100%, 300% 100%;
      animation: waterRipple 18s linear infinite;
    }

    body.water .panel {
      background: rgba(255, 255, 255, 0.6);
      backdrop-filter: blur(10px) saturate(140%);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
    }

    body.aurora {
      background: linear-gradient(120deg, #091540, #102a68, #183a72, #2a628f, #1b998b, #6ed0ff);
      background-size: 400% 400%;
      animation: auroraFlow 22s ease-in-out infinite;
    }

    body.aurora .panel {
      background: rgba(255, 255, 255, 0.5);
      backdrop-filter: blur(12px) saturate(140%);
    }

    .btn.small {
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 6px;
      background: var(--ring);
      color: var(--muted);
      border: 1px solid rgba(255, 255, 255, .15);
      cursor: pointer
    }

    /* === Horror Theme === */
    .theme-horror {
      --bg: #0b0b0d;
      --face: #121216;
      --ring: rgba(255, 255, 255, 0.08);
      --muted: #d0cfd4;
      --accent: #c1121f;
      --handH: #fafafa;
      --handM: #ff3b3b;
      --handS: #ff3b3b;
      --tickMinor: rgba(255, 255, 255, 0.15);
      --tickMajor: rgba(255, 255, 255, 0.9);
    }

    .theme-horror .clock-wrap {
      position: relative;
      overflow: visible;
    }

    .theme-horror #clock {
      filter: drop-shadow(0 2px 8px rgba(193, 18, 31, .5));
    }

    .theme-horror .bleed {
      position: absolute;
      left: 50%;
      top: -8px;
      width: 6px;
      height: 18px;
      background: #c1121f;
      border-radius: 3px;
      transform: translateX(-50%);
      animation: drip 2.2s infinite ease-in;
      box-shadow: 0 0 8px rgba(193, 18, 31, .6);
    }

    @keyframes drip {
      0% {
        transform: translate(-50%, 0) scaleY(0.6);
      }

      70% {
        transform: translate(-50%, 20px) scaleY(1);
      }

      100% {
        transform: translate(-50%, 0) scaleY(0.6);
      }
    }

    .theme-horror .pulse {
      position: absolute;
      inset: auto 0 0 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(193, 18, 31, .65), transparent);
      animation: pulse 1.8s infinite ease-in-out;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: .2
      }

      50% {
        opacity: 1
      }
    }


    .nl-eta {
      position: absolute;
      left: 50%;
      bottom: -24px;
      transform: translateX(-50%);
      padding: 4px 14px;
      border-radius: 999px;
      background: rgba(0, 0, 0, .35);
      color: var(--muted);
      font-size: 16px;
      font-weight: 700;
      line-height: 1;
      backdrop-filter: blur(6px);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, .08);
      pointer-events: none
    }

    .nl-fullscreen {
      position: fixed;
      inset: 0;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 24px
    }

    .nl-fullscreen .nl-row {
      width: min(1400px, 95vw)
    }

    .nl-row {
      padding-bottom: 30px
    }

    .nl-fs-close {
      position: fixed;
      top: 16px;
      right: 16px;
      background: var(--ring);
      border: 1px solid rgba(255, 255, 255, .1);
      color: var(--muted);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 14px
    }

    .btn.small:hover {
      filter: brightness(1.1)
    }

    .btn.small.danger {
      background: #5b1e1e;
      color: #fff;
      border-color: #9e2a2a
    }

    /* Planner top complete button */
    #pageCompleteBtn {
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 50;
    }

    /* Unify design with numberline button */
    .btn.small {
      font-size: 12px;
      padding: 6px 10px;
      border-radius: 6px;
      background: var(--ring);
      color: var(--muted);
      border: 1px solid rgba(255, 255, 255, .15);
      cursor: pointer
    }

    /* === Horror Theme === */
    .theme-horror {
      --bg: #0b0b0d;
      --face: #121216;
      --ring: rgba(255, 255, 255, 0.08);
      --muted: #d0cfd4;
      --accent: #c1121f;
      --handH: #fafafa;
      --handM: #ff3b3b;
      --handS: #ff3b3b;
      --tickMinor: rgba(255, 255, 255, 0.15);
      --tickMajor: rgba(255, 255, 255, 0.9);
    }

    .theme-horror .clock-wrap {
      position: relative;
      overflow: visible;
    }

    .theme-horror #clock {
      filter: drop-shadow(0 2px 8px rgba(193, 18, 31, .5));
    }

    .theme-horror .bleed {
      position: absolute;
      left: 50%;
      top: -8px;
      width: 6px;
      height: 18px;
      background: #c1121f;
      border-radius: 3px;
      transform: translateX(-50%);
      animation: drip 2.2s infinite ease-in;
      box-shadow: 0 0 8px rgba(193, 18, 31, .6);
    }

    @keyframes drip {
      0% {
        transform: translate(-50%, 0) scaleY(0.6);
      }

      70% {
        transform: translate(-50%, 20px) scaleY(1);
      }

      100% {
        transform: translate(-50%, 0) scaleY(0.6);
      }
    }

    .theme-horror .pulse {
      position: absolute;
      inset: auto 0 0 0;
      height: 2px;
      background: linear-gradient(90deg, transparent, rgba(193, 18, 31, .65), transparent);
      animation: pulse 1.8s infinite ease-in-out;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: .2
      }

      50% {
        opacity: 1
      }
    }


    .nl-eta {
      position: absolute;
      left: 50%;
      bottom: -24px;
      transform: translateX(-50%);
      padding: 4px 14px;
      border-radius: 999px;
      background: rgba(0, 0, 0, .35);
      color: var(--muted);
      font-size: 16px;
      font-weight: 700;
      line-height: 1;
      backdrop-filter: blur(6px);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, .08);
      pointer-events: none
    }

    .nl-fullscreen {
      position: fixed;
      inset: 0;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 24px
    }

    .nl-fullscreen .nl-row {
      width: min(1400px, 95vw)
    }

    .nl-row {
      padding-bottom: 30px
    }

    .nl-fs-close {
      position: fixed;
      top: 16px;
      right: 16px;
      background: var(--ring);
      border: 1px solid rgba(255, 255, 255, .1);
      color: var(--muted);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 14px
    }

    .btn.small:hover {
      filter: brightness(1.1)
    }

    .btn.small.danger {
      background: #5b1e1e;
      color: #fff;
      border-color: #9e2a2a
    }

    /* Unify planner complete button with numberline style */
    #pageCompleteBtn.btn.small {
      background: var(--ring);
      color: var(--muted);
      border: 1px solid rgba(255, 255, 255, .35);
      box-shadow: 0 6px 16px rgba(0, 0, 0, .35), inset 0 0 0 1px rgba(255, 255, 255, .2);
      backdrop-filter: saturate(140%) blur(6px);
      -webkit-backdrop-filter: saturate(140%) blur(6px);
    }

    .nl-eta {
      position: absolute;
      left: 50%;
      bottom: -24px;
      transform: translateX(-50%);
      padding: 4px 14px;
      border-radius: 999px;
      background: rgba(0, 0, 0, .35);
      color: var(--muted);
      font-size: 16px;
      font-weight: 700;
      line-height: 1;
      backdrop-filter: blur(6px);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, .08);
      pointer-events: none
    }

    .nl-fullscreen {
      position: fixed;
      inset: 0;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 24px
    }

    .nl-fullscreen .nl-row {
      width: min(1400px, 95vw)
    }

    .nl-row {
      padding-bottom: 30px
    }

    .nl-fs-close {
      position: fixed;
      top: 16px;
      right: 16px;
      background: var(--ring);
      border: 1px solid rgba(255, 255, 255, .1);
      color: var(--muted);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 14px
    }
  </style>
  <style data-planner-style="1" media="not all">
    /* --- injected: place delay counter to the right of remaining time --- */
    .remaining-time-row {
      display: flex;
      align-items: center;
      gap: .5rem;
      flex-wrap: nowrap
    }

    .remaining-time-row .delay-counter {
      font-variant-numeric: tabular-nums;
      opacity: .85
    }

    .remaining-time-row .delay-counter.negative {
      color: inherit
    }

    .remaining-time-row .delay-counter.positive {}

    /* compact on mobile */
    @media (max-width: 540px) {
      .remaining-time-row {
        gap: .35rem
      }
    }
  </style>
  <style data-planner-style="1" media="not all">
    /* upload→変更ボタンUI */
    .sound-file-hidden {
      display: none !important;
    }

    .sound-file-btn {
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid #666;
      background: transparent;
      cursor: pointer;
    }

    .sound-file-btn:hover {
      opacity: .85;
    }
  </style>
  <style data-planner-style="1" media="not all">
    .vibe-card .vibe-row {
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    .vibe-card select,
    .vibe-card input[type="range"] {
      border-radius: 8px;
    }

    .vibe-card .vibe-target,
    .vibe-card .vibe-pattern {
      min-width: 180px;
      padding: 4px 8px;
      background: rgba(255, 255, 255, .06);
      color: var(--fg);
      border: 1px solid var(--ring);
    }

    .vibe-card .vibe-status {
      margin-top: 6px;
    }

    @media (max-width: 720px) {
      .vibe-card .vibe-row {
        align-items: flex-start;
      }
    }
  </style>
  <style data-planner-style="1" media="not all">
    /* Planner hero layout refresh */
    #plannerApp main {
      max-width: 100vw;
      width: 100%;
      padding: 2px 0 6px;
      margin: 0 auto;
      overflow: visible;
    }

    #plannerApp .planner-hero-card {
      padding: 12px 0 0 0;
      background: transparent;
      border: none;
      box-shadow: none;
      overflow: visible;
    }

    #plannerApp .planner-hero {
      display: flex;
      flex-direction: column;
      gap: 4px;
      align-items: stretch;
    }

    #plannerApp .planner-clock-area {
      display: flex;
      flex-direction: column;
      gap: 2px;
      align-items: center;
      min-width: 0;
      align-self: stretch;
      padding-top: 0;
      margin-top: -46px;
      overflow: visible;
    }

    #plannerApp .planner-hero-top {
      width: 100%;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: space-between;
      padding: 8px 10px 4px;
      min-height: 56px;
    }

    #pageCompleteBtn {
      display: none;
    }

    #plannerApp .planner-hero-top #pageCompleteBtn {
      position: static;
      transform: none;
      left: auto;
      top: auto;
      display: none;
      margin-left: auto;
    }

    #plannerApp .planner-hero-top #pageCompleteBtn.btn.small {
      padding: 10px 14px;
      border-radius: 12px;
      margin-top: 4px;
    }

    #plannerApp .planner-clock-area .clock-wrap {
      width: 100%;
      max-width: 100%;
      padding: 0;
      margin: 0 auto;
      border: none;
      box-shadow: none;
    }

    #plannerApp .planner-clock-area .clock-wrap svg {
      width: 100%;
      height: auto;
      max-width: 100%;
      max-height: calc(100vh - 60px);
      aspect-ratio: 1 / 1;
      display: block;
      margin-top: -56px;
    }

    #plannerApp .tab-content[data-content="planner"] {
      overflow: visible;
    }

    #plannerApp .planner-info-stack {
      display: none;
      flex-direction: column;
      gap: 12px;
      min-width: 260px;
      width: 100%;
    }

    #plannerApp .planner-info-stack.active {
      display: flex;
    }

    #plannerApp .planner-hud-grid {
      display: grid;
      gap: 12px;
      grid-template-columns: 1fr;
      align-items: stretch;
    }

    #plannerApp .planner-hud-grid .hud-pill {
      display: none;
      align-items: center;
      justify-content: center;
      width: 100%;
      text-align: center;
      font-size: 22px;
      padding: 18px 20px;
      font-weight: 800;
      line-height: 1.12;
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, .24), inset 0 1px 0 rgba(255, 255, 255, .08);
    }

    #plannerApp .planner-hud-grid #plEta {
      position: static;
      transform: none;
      left: auto;
      right: auto;
      top: auto;
      bottom: auto;
      width: 100%;
      text-align: center;
      padding: 20px 22px;
      font-size: 24px;
      font-weight: 800;
      line-height: 1.08;
      border-radius: 12px;
      background: rgba(0, 0, 0, .32);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, .08), 0 10px 26px rgba(0, 0, 0, .26);
      pointer-events: auto;
    }

    #plannerApp #plEta,
    #plannerApp #plTimerHUD,
    #plannerApp #pomoClockHUD {
      display: none;
    }

    #plannerApp .planner-info-stack .overall-study {
      margin: 0;
      width: 100%;
      justify-content: space-between;
      font-size: clamp(18px, 2.4vw, 26px);
      gap: 16px;
      align-items: center;
      padding: 16px 18px 14px;
    }

    @media (max-width: 640px) {
      #plannerApp .clock-wrap {
        padding: 10px 4px 2px;
      }

      #plannerApp .planner-hero-top {
        gap: 8px;
      }

      #plannerApp .planner-hud-grid .hud-pill,
      #plannerApp .planner-hud-grid #plEta {
        font-size: 15px;
      }
    }

    @media (orientation: landscape) and (min-width: 960px) {
      #plannerApp main {
        max-width: 100vw;
      }

      #plannerApp .planner-hero {
        display: grid;
        grid-template-columns: minmax(780px, 1fr) minmax(260px, 360px);
        gap: 6px;
        align-items: flex-start;
      }

      #plannerApp .planner-clock-area .clock-wrap {
        max-width: 100%;
        padding: 0 6px;
      }

      #plannerApp .planner-info-stack .overall-study {
        font-size: clamp(22px, 2.9vw, 34px);
        line-height: 1.14;
        gap: 12px;
        padding: 18px 18px 16px;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
      }

      #plannerApp .planner-info-stack .overall-study span {
        font-size: inherit;
        line-height: 1.05;
        width: 100%;
        display: block;
      }

      #plannerApp .planner-hud-grid {
        gap: 14px;
      }

      #plannerApp .planner-hud-grid .hud-pill {
        font-size: clamp(24px, 3vw, 40px);
        padding: 22px 24px;
        line-height: 1.1;
      }

      #plannerApp .planner-hud-grid #plEta {
        font-size: clamp(28px, 3.6vw, 48px);
        padding: 24px 26px;
        line-height: 1.08;
      }
    }
  </style>
</head>

<body>
  <div class="topbar">
    <div class="topbar-inner">
      <div class="brand">
        <div class="logo"></div>
        <h1>統合版（電子書籍＋プランナー）</h1>
      </div>
      <div class="tabs" id="tabs">
        <div class="tab active" data-tab="home">ホーム</div>
        <div class="tab" data-tab="library">ライブラリ</div>
        <div class="tab" data-tab="boxes">ボックス</div>
        <div class="tab" data-tab="dictionary">辞書</div>
        <div class="tab" data-tab="settings">設定</div>
        <div class="tab" data-tab="planner">📅 プランナー</div>
      </div>
      <div class="open-tabs" id="openTabs"></div>
      <div class="actions">
        <button class="btn ghost" id="mainModeBtn">メイン</button>
      </div>
    </div>
  </div>
  <div id="topbarRestore"><button class="mini-menu" id="restoreTopbarBtn">通常</button></div>

  <!-- PuddingOS desktop shell -->
  <div id="puddingOsLayer">
    <div class="pudding-desktop">
      <div class="pudding-window" id="puddingMainWindow">
        <div class="pw-titlebar" id="puddingWindowDrag">
          <div class="pw-title" id="puddingWindowTitle">PuddingOS - Workspace</div>
          <div class="pw-controls">
            <button class="pw-btn" id="puddingMinimizeBtn" title="デスクトップにしまう">–</button>
            <button class="pw-btn exit" id="puddingExitBtn" title="PuddingOSを終了">×</button>
          </div>
        </div>
        <div class="pw-body" id="puddingWindowBody"></div>
        <div class="pw-resize" id="puddingWindowResize"></div>
      </div>
      <div class="pudding-dock" id="puddingDock"></div>
    </div>
  </div>

  <div class="layout" id="readerLayout">
    <aside class="panel side" id="sidebar">
      <div class="row" style="align-items:center; gap:8px; margin-bottom:8px;">
        <input id="searchInput" class="input" placeholder="本を検索…" />
      </div>
      <h3>表示・並べ替え</h3>
      <div class="toggle">
        <button class="btn small" data-view="grid">棚ビュー</button>
        <button class="btn small" data-view="list">リスト</button>
        <button class="btn small" data-view="tree">ファイル風</button>
      </div>
      <div class="hr" style="height:1px;background:#1d2738;margin:10px 0"></div>
      <label class="helper">並べ替え</label>
      <select id="sortSelect">
        <option value="-createdAt">新しい順</option>
        <option value="title">タイトルA→Z</option>
        <option value="pages">ページ数多い順</option>
      </select>
      <div class="row" style="gap:8px;margin:10px 0 6px">
        <button class="btn small primary" id="quickMake">+ 本を作成</button>
      </div>
      <div class="hr" style="height:1px;background:#1d2738;margin:10px 0"></div>
      <h3>タグ/ジャンル</h3>
      <div id="tagArea"></div>
      <div class="hr" style="height:1px;background:#1d2738;margin:10px 0"></div>
      <h3>フォルダ</h3>
      <div class="tree" id="folderTree"></div>
      <div class="hr" style="height:1px;background:#1d2738;margin:10px 0"></div>
      <h3>その他</h3>
      <label class="row" style="gap:8px;align-items:center;font-size:13px">
        <input type="checkbox" id="showAnswersToggle" />
        解答も表示
        <span class="muted" id="hiddenAnswersInfo" style="font-size:11px"></span>
      </label>
    </aside>

    <main class="panel" id="main">
      <!-- Home View -->
      <div id="homeView">
        <div class="home-shell">
          <section class="home-hero">
            <div class="home-hero-main">
              <div class="home-kicker">HOME</div>
              <div class="home-header">
                <h1 id="homeGreeting">おはようございます！</h1>
              </div>
              <p id="homeDate" class="home-date"></p>
            </div>
            <div class="home-hero-side">
              <div class="home-lesson-card">
                <div class="home-lesson-header">
                  <h3>🎓 今日の授業</h3>
                  <button class="btn ghost small" id="homeOpenOriginalLesson">編集</button>
                </div>
                <div class="home-lesson-summary">
                  <span class="home-lesson-chip">合計 <strong id="homeLessonTotal">--</strong></span>
                  <span class="home-lesson-chip">完了 <strong id="homeLessonDone">--</strong></span>
                  <span class="home-lesson-chip">残り <strong id="homeLessonRemain">--</strong></span>
                </div>
                <div id="homeLessonTimetable" class="home-lesson-timetable"></div>
              </div>
            </div>
          </section>

          <section class="home-grid">
            <div class="home-card accent">
              <h3>📋 今日のやること</h3>
              <p class="home-sub" style="display:none">カレンダーの予定から抽出しています</p>
              <div id="homeTodayTasks" class="home-task-list"></div>
            </div>

            <div class="home-card">
              <h3>📊 今日の統計</h3>
              <div class="home-stat-grid">
                <div class="home-stat-item">
                  <span class="home-stat-value" id="homeStatCompleted">0</span>
                  <span class="home-stat-label">完了ページ</span>
                </div>
                <div class="home-stat-item">
                  <span class="home-stat-value" id="homeStatRemaining">0</span>
                  <span class="home-stat-label">残りページ</span>
                </div>
                <div class="home-stat-item">
                  <span class="home-stat-value" id="homeStatMinutes">0</span>
                  <span class="home-stat-label">推定時間</span>
                </div>
              </div>
            </div>

            <div class="home-card">
              <div class="home-card-header">
                <h3>🎯 完了ページ</h3>
                <div class="home-completed-controls">
                  <button class="btn ghost small home-review-pill" id="homeReviewToggle" title="復習モード">復</button>
                  <div class="home-completed-date-wrap">
                    <span class="home-completed-date" id="homeCompletedDateLabel" title="タップで日付を選択">--</span>
                    <div class="home-completed-arrows">
                      <button class="btn ghost small home-arrow" id="homeCompletedPrev" title="前の日">◀</button>
                      <button class="btn ghost small home-arrow" id="homeCompletedNext" title="次の日">▶</button>
                    </div>
                  </div>
                  <input id="homeCompletedDateInput" type="date" class="input home-date-input" />
                </div>
              </div>
              <p class="home-sub" style="display:none">直近の完了ログを表示します</p>
              <div id="homeTodayCompleted" class="home-completed-list"></div>
            </div>

            <div class="home-card">
              <h3>📚 最近使った本</h3>
              <p class="home-sub" style="display:none">最後に開いた順に最大5件を表示します</p>
              <div id="homeRecentBooks" class="home-book-list"></div>
            </div>
          </section>

          <section id="homeReview" class="home-review">
            <div class="home-review-header">
              <div class="home-review-title">🔁 復習モード</div>
              <div class="home-review-actions">
                <button class="btn ghost small" id="homeReviewBack">ホームに戻る</button>
              </div>
            </div>
            <div class="home-review-body">
              <div class="home-review-side">
                <div class="home-review-controls">
                  <div class="home-review-row">
                    <label>表示</label>
                    <select id="homeReviewRangeMode" class="input">
                      <option value="all" selected>全て</option>
                      <option value="day">1日</option>
                      <option value="week">週</option>
                      <option value="month">月</option>
                      <option value="range">範囲</option>
                      <option value="recent">直近</option>
                    </select>
                    <label>基準日</label>
                    <input id="homeReviewAnchor" type="date" class="input">
                    <span id="homeReviewRangeWrap">
                      <label>範囲</label>
                      <input id="homeReviewStart" type="date" class="input">
                      <span>〜</span>
                      <input id="homeReviewEnd" type="date" class="input">
                    </span>
                    <span id="homeReviewRecentWrap">
                      <label>直近日数</label>
                      <input id="homeReviewRecentDays" type="number" min="1" max="365" value="7" class="input"
                        style="width:70px">
                      <span>日</span>
                    </span>
                  </div>
                  <div class="home-review-row">
                    <label>対象</label>
                    <select id="homeReviewKind" class="input">
                      <option value="completed" selected>完了ページ</option>
                      <option value="miss">ミス</option>
                    </select>
                    <label>本</label>
                    <select id="homeReviewBookFilter" class="input"></select>
                    <label>並び</label>
                    <select id="homeReviewSort" class="input">
                      <option value="newest" selected>新しい順</option>
                      <option value="oldest">古い順</option>
                    </select>
                  </div>
                  <div class="home-review-row">
                    <label>検索</label>
                    <input id="homeReviewSearch" class="input" placeholder="本名 / P番号 / メモ">
                    <button class="btn ghost small" id="homeReviewSearchClear">クリア</button>
                  </div>
                </div>
                <div class="home-review-summary" id="homeReviewSummary"></div>
                <div class="home-review-panel" id="homeReviewPagePanel">
                  <div class="home-review-panel-head">
                    <div class="home-review-panel-title">📖 ページマップ</div>
                    <button class="btn ghost small" id="homeReviewPageToggle">折りたたみ</button>
                  </div>
                  <div class="home-review-panel-body">
                    <div class="home-review-row">
                      <label>本</label>
                      <select id="homeReviewPageBook" class="input"></select>
                      <label>完了日</label>
                      <input id="homeReviewCompleteDate" type="date" class="input">
                    </div>
                    <div class="home-review-row">
                      <label>ページ</label>
                      <input id="homeReviewCompleteInput" class="input" placeholder="例: 12, 15-20"
                        style="min-width:160px">
                      <button class="btn small" id="homeReviewCompleteAdd">追加</button>
                    </div>
                    <div class="home-review-row">
                      <label>ページ検索</label>
                      <input id="homeReviewPageFilter" class="input" placeholder="例: 10-30 / 42 / 3,5,9"
                        style="min-width:160px">
                      <button class="btn ghost small" id="homeReviewPageFilterClear">クリア</button>
                    </div>
                    <div class="home-review-page-meta" id="homeReviewPageMeta"></div>
                    <div class="home-review-page-grid" id="homeReviewPageGrid"></div>
                  </div>
                </div>
              </div>
              <div class="home-review-main">
                <div id="homeReviewList" class="home-review-list"></div>
              </div>
            </div>
          </section>
        </div>
      </div>

      <div id="libraryView" class="hidden">
        <div id="libraryGrid" class="grid"></div>
        <div id="libraryShelf" class="shelf hidden"></div>
        <div id="libraryList" class="list hidden"></div>
      </div>

      <div id="boxesView" class="hidden" style="padding:10px">
        <div class="toolbar" style="margin-bottom:8px">
          <input id="boxSearch" class="input" placeholder="ボックス/切り取り検索…" style="max-width:260px">
          <select id="boxSort" class="input" style="max-width:180px">
            <option value="-createdAt">新しい順</option>
            <option value="name">名前A→Z</option>
            <option value="-items">件数多い順</option>
            <option value="-weak">苦手が多い順</option>
          </select>
          <label class="row" style="gap:6px"><input id="onlyWeakBox" type="checkbox"> 苦手含むのみ</label>
          <button class="btn small" id="newBoxToolbar">+ 新規ボックス</button>
        </div>
        <div class="grid" id="boxGrid"></div>
        <div id="boxEmpty" class="empty hidden">まだボックスがありません。選択モードで切り取り後、「新規ボックス」を作成してください。</div>
      </div>

      <div id="dictionaryView" class="hidden" style="padding:12px">
        <div class="panel" style="padding:12px;margin-bottom:10px">
          <h3 style="margin:0 0 6px">📚 オフライン辞書（英語/国語/数学/理科/社会：中学生向け）</h3>
          <p class="muted" style="margin:0 0 10px;font-size:12px">科目を選んで用語を検索できます。お気に入りや履歴も保持します。例文・解説も登録可能。</p>
          <div class="row" style="gap:8px;flex-wrap:wrap">
            <select id="dictSubjectSelect" class="input" style="max-width:160px">
              <option value="english">英語</option>
              <option value="kokugo">国語</option>
              <option value="math">数学</option>
              <option value="science">理科</option>
              <option value="social">社会</option>
            </select>
            <input id="dictSearchInput" class="input" placeholder="用語を検索 (例: apple / りんご / 一次方程式 / 光合成 / 三権分立)"
              style="min-width:260px;flex:1">
            <select id="dictModeSelect" class="input" style="max-width:160px">
              <option value="auto">自動判定</option>
              <option value="en">英語で検索</option>
              <option value="ja">日本語で検索</option>
            </select>
            <button class="btn ghost small" id="dictClearBtn">クリア</button>
          </div>
          <div class="row" style="gap:8px;flex-wrap:wrap;margin-top:8px">
            <label class="row" style="gap:6px;align-items:center"><input type="checkbox" id="dictFavoritesOnly">
              お気に入りのみ表示</label>
            <button class="btn ghost small" id="dictHistoryBtn">履歴</button>
          </div>
        </div>
        <div class="grid" style="grid-template-columns:2fr 3fr;gap:12px">
          <div class="panel" style="padding:10px;max-height:70vh;overflow:auto">
            <div class="list" id="dictResultList"></div>
          </div>
          <div class="panel" style="padding:12px;min-height:300px">
            <div id="dictDetailEmpty" class="muted">左の一覧から単語を選ぶと詳細が表示されます。</div>
            <div id="dictDetail" class="hidden">
              <div class="row space" style="align-items:flex-start">
                <div>
                  <h2 id="dictWord" style="margin:0"></h2>
                  <div id="dictPron" class="muted" style="margin:2px 0 6px;font-size:12px"></div>
                  <div class="row" style="gap:6px;align-items:center;flex-wrap:wrap;">
                    <div id="dictPos" class="pill"></div>
                    <div id="dictSubjectBadge" class="pill" style="opacity:.75"></div>
                  </div>
                </div>
                <button class="btn small ghost" id="dictFavBtn">☆ お気に入り</button>
              </div>
              <p id="dictMeaning" style="margin:8px 0;font-weight:600"></p>
              <div id="dictExampleWrap" class="muted" style="font-size:12px"></div>
              <div id="dictExtraWrap" class="muted" style="font-size:12px;margin-top:8px"></div>
            </div>
          </div>
        </div>
        <div class="panel" style="padding:12px;margin-top:10px">
          <h4 style="margin:0 0 6px">テキストから単語をまとめて追加</h4>
          <p class="muted" style="margin:0 0 6px;font-size:12px">
            1行1語。<code>word | 意味(必須) | 読み/よみがな | 品詞 | 例文1 ;; 例文2 | 補足 | 詳細 | 科目</code>
            の順（末尾の科目は省略可、選択した科目が既定で付与）。<code>#</code>始まりの行は無視。</p>
          <div class="row" style="gap:8px;flex-wrap:wrap;margin-bottom:6px">
            <select id="dictImportSubject" class="input" style="max-width:160px">
              <option value="english">英語</option>
              <option value="kokugo">国語</option>
              <option value="math">数学</option>
              <option value="science">理科</option>
              <option value="social">社会</option>
            </select>
            <button class="btn ghost small" id="dictImportBtn">テキストを読み込む</button>
            <input type="file" id="dictImportFile" accept=".txt,text/plain" class="hidden" />
            <span class="tiny muted">例: <code>apple | りんご | アップル | noun | I ate an apple.;; | | | 英語</code></span>
          </div>
          <ul style="margin:0 0 6px 16px;font-size:12px;color:var(--muted,#94a3b8);line-height:1.5">
            <li>国語例: <code>比喩 | たとえを用いた表現方法 | ひゆ | 名詞 | | 「時間は金なり」は代表的な比喩表現 | | 国語</code></li>
            <li>数学例: <code>一次方程式 | ax+b=0 の形の方程式 | いちじほうていしき | 名詞 | | 解の公式や移項を使って解く | | 数学</code></li>
            <li>理科例: <code>光合成 | 植物が光を使って養分を作る反応 | こうごうせい | 名詞 | | 葉緑体で水と二酸化炭素から酸素とデンプンを作る | | 理科</code></li>
            <li>社会例: <code>三権分立 | 立法・行政・司法を分ける仕組み | さんけんぶんりつ | 名詞 | | | 近代国家の権力分立の原則 | 社会</code></li>
          </ul>
          <div class="row" style="gap:8px;flex-wrap:wrap">
            <button class="btn ghost small" id="dictClearCustomBtn">カスタム語彙をすべてリセット</button>
            <button class="btn ghost small" id="dictExportCustomBtn">現行データをテキストに保存</button>
            <button class="btn ghost small" id="dictClearSubjectBtn">選択科目のみリセット</button>
          </div>
        </div>
        <div class="panel" style="padding:12px;margin-top:10px">
          <h4 style="margin:0 0 6px">使い方ガイド</h4>
          <ul style="margin:0 0 4px 16px;font-size:12px;color:var(--muted,#94a3b8);line-height:1.5">
            <li>科目を選ぶと、その科目の用語だけを検索します。</li>
            <li>英語・日本語どちらでも検索できます。部分一致でもOK（数学・理科・社会も同様）。</li>
            <li>一覧から単語をクリックすると詳細（品詞・意味・例文・派生語）が表示されます。</li>
            <li>☆を押すとお気に入り登録。チェックボックスでお気に入りだけ表示できます。</li>
            <li>履歴ボタンで最近見た単語を一覧表示します。</li>
            <li>語彙追加は辞書タブの「テキストを読み込む」からインポートできます（オフラインで増やせます）。</li>
          </ul>
        </div>
      </div>

      <div id="uploadView" class="hidden" style="padding:14px 14px 20px;">
        <div class="row space" style="margin-bottom:10px">
          <h3 style="margin:0">本を作成</h3>
          <div class="muted">プレビュー側でドラッグ＆ドロップで順番変更できます</div>
        </div>
        <div class="split">
          <div class="panel" style="padding:12px">
            <div class="row" style="gap:10px;align-items:center;margin-bottom:8px">
              <input id="bookTitle" class="input" placeholder="タイトル" />
            </div>
            <div class="row" style="gap:8px;margin-bottom:8px">
              <input id="bookTags" class="input" placeholder="タグ（カンマ区切り）" />
            </div>
            <div class="row" style="gap:8px;margin-bottom:8px">
              <input id="bookFolder" class="input" placeholder="フォルダ" />
            </div>
            <div class="row" style="gap:8px;margin-bottom:8px">
              <input type="file" id="imagePicker" accept="image/*" multiple />
              <button class="btn ghost" id="clearImages">クリア</button>
            </div>
            <div id="dropZone" class="list" style="height:220px">ここに画像をドロップ…</div>
            <div class="row space" style="margin-top:8px">
              <div class="muted">サムネをドラッグして順番変更</div>
              <button class="btn primary" id="createBook">保存</button>
            </div>
          </div>
          <div class="panel" style="padding:12px">
            <h3 style="margin:0 0 6px">プレビュー（並べ替え可）</h3>
            <div id="previewArea" class="grid"
              style="grid-template-columns:repeat(auto-fill,minmax(120px,1fr));max-height:420px;overflow:auto"></div>
          </div>
        </div>
      </div>

      <div id="settingsView" class="hidden" style="padding:14px;display:grid;gap:12px">
        <div class="panel" style="padding:12px" id="bookFsPanel">
          <h3>📂 ファイルバックアップ（設定/予定/ToDoなど本以外）</h3>
          <p class="muted" style="margin:0 0 8px">本以外のデータを1ファイルにバックアップ／復元します。書籍データには影響しません。</p>
          <div class="row" style="gap:8px;flex-wrap:wrap;margin-bottom:6px">
            <button class="btn primary small" id="nonBookBackupBtn">💾 本以外をバックアップ</button>
            <button class="btn ghost small" id="nonBookRestoreBtn">📥 本以外を復元</button>
            <input type="file" id="nonBookRestoreFile" accept="application/json" class="hidden" />
          </div>
          <div class="row" style="gap:8px;flex-wrap:wrap;margin-bottom:6px">
            <button class="btn ghost small" id="nonBookFsBackupBtn" disabled>💾 本以外をバックアップ（フォルダ）</button>
            <button class="btn ghost small" id="nonBookFsRestoreBtn" disabled>📥 本以外を復元（フォルダ）</button>
            <button class="btn ghost small" id="nonBookFsManageBtn" disabled>🗂️ 編集</button>
            <span class="tiny muted">※ 本バックアップと同じフォルダ（StudyAppData/settings.json）に保存されます</span>
          </div>
          <div id="nonBookFsStatus" style="margin-top:6px;font-size:11px;display:none">
            <div class="progress-bar"
              style="height:4px;background:rgba(255,255,255,0.1);border-radius:2px;overflow:hidden">
              <div id="nonBookFsProgress"
                style="height:100%;width:0%;background:var(--brand2,#6ee7b7);transition:width 0.2s"></div>
            </div>
            <span id="nonBookFsStatusText" style="opacity:0.7">準備中...</span>
          </div>
          <div class="hr" style="height:1px;background:rgba(255,255,255,0.08);margin:10px 0"></div>
          <h4 style="margin:0 0 6px">📚 本だけファイルバックアップ（Chrome専用）</h4>
          <p class="muted" style="margin:0 0 8px">File System Access APIでフォルダに本だけ保存／復元します。設定や予定は含みません。</p>
          <p class="muted" id="bookFsUnsupportedNotice" style="margin:0 0 8px;color:var(--error,#ef4444);display:none">
            ⚠️ このブラウザではFile System Access APIが使えないため、フォルダバックアップは利用できません。</p>
          <div class="row" style="gap:8px;flex-wrap:wrap;align-items:center">
            <button class="btn ghost small" id="bookFsSelectBtn">📂 フォルダを選択</button>
            <span id="bookFsPath" style="font-size:11px;opacity:0.7">（未設定）</span>
          </div>
          <div class="row" style="gap:8px;flex-wrap:wrap;margin-top:8px">
            <button class="btn ghost small" id="bookFsBackupBtn" disabled>💾 本をバックアップ</button>
            <button class="btn ghost small" id="bookFsRestoreBtn" disabled>📥 本を復元</button>
            <button class="btn ghost small" id="bookFsManageBtn" disabled>🗂️ 編集</button>
          </div>
          <div id="bookFsStatus" style="margin-top:8px;font-size:11px;display:none">
            <div class="progress-bar"
              style="height:4px;background:rgba(255,255,255,0.1);border-radius:2px;overflow:hidden">
              <div id="bookFsProgress"
                style="height:100%;width:0%;background:var(--brand,#4f8cff);transition:width 0.2s"></div>
            </div>
            <span id="bookFsStatusText" style="opacity:0.7">準備中...</span>
          </div>
          <p class="muted" style="font-size:11px;margin-top:8px">※ 既存の本は上書きされます。必要に応じて別フォルダを選んでください。</p>
          <div class="hr" style="height:1px;background:rgba(255,255,255,0.08);margin:10px 0"></div>
          <h4 style="margin:0 0 6px">⬇️ 本だけバックアップ（ダウンロード）</h4>
          <p class="muted" style="margin:0 0 8px">File System Access API非対応ブラウザ向け。本が多い場合は分割して順番に保存します。</p>
          <div class="row" style="gap:8px;flex-wrap:wrap;margin-top:4px">
            <button class="btn ghost small" id="bookDlBackupBtn">⬇️ 本だけをバックアップ</button>
          </div>
          <p class="muted" style="font-size:11px;margin-top:6px">※ 複数ファイルのダウンロードが行われます。</p>
          <div class="hr" style="height:1px;background:rgba(255,255,255,0.08);margin:10px 0"></div>
          <h4 style="margin:0 0 6px">📥 フォルダバックアップを読み込む</h4>
          <p class="muted" style="margin:0 0 8px">File System Access API非対応ブラウザでも、フォルダ選択から本だけ復元できます。</p>
          <div class="row" style="gap:8px;flex-wrap:wrap;margin-top:4px">
            <button class="btn ghost small" id="bookFolderImportBtn">📥 フォルダを選んで復元</button>
            <input type="file" id="bookFolderImportInput" class="hidden" webkitdirectory directory multiple>
          </div>
          <p class="muted" style="font-size:11px;margin-top:6px">※ StudyAppData を含むフォルダを選択してください。</p>
        </div>
        <div class="panel" style="padding:12px">
          <h3>バックアップ</h3>
          <div class="row" style="gap:8px;flex-wrap:wrap;margin-top:8px">
            <button class="btn danger" id="resetAllBtn">全データをリセット</button>
            <button class="btn danger ghost" id="resetLibraryBtn">ライブラリのみリセット</button>
            <button class="btn danger ghost" id="resetBoxesBtn">ボックスのみリセット</button>
          </div>
          <div class="row" style="gap:8px;flex-wrap:wrap;margin-top:8px">
            <button class="btn ghost" id="importBookSingleBtn">本をインポート(1件)</button>
            <input type="file" id="importBookSingleFile" accept="application/json" class="hidden" />
            <button class="btn ghost" id="importBoxSingleBtn">ボックスをインポート(1件)</button>
            <input type="file" id="importBoxSingleFile" accept="application/json" class="hidden" />
          </div>
          <div class="row" style="gap:8px;flex-wrap:wrap;margin-top:8px">
            <button class="btn ghost small" id="rescueBooksBtn">🛠️ 本データを復旧</button>
            <span class="muted" style="font-size:11px">本の一覧が消えた時にIndexedDBから復旧を試みます</span>
          </div>
          <div class="row"
            style="gap:8px;flex-wrap:wrap;margin-top:8px;padding-top:8px;border-top:1px solid rgba(255,255,255,0.08)">
            <button class="btn ghost small" id="exportSettingsOnlyBtn" title="設定・予定・TODO等を書き出し（本とボックスを除く）">📋
              設定のみ書き出し</button>
            <input type="file" id="importSettingsOnlyFile" accept="application/json" class="hidden" />
            <button class="btn ghost small" id="importSettingsOnlyBtn" title="設定・予定・TODO等を読み込み">📋 設定のみ読み込み</button>
          </div>
          <div class="row"
            style="gap:8px;flex-wrap:wrap;margin-top:12px;padding-top:12px;border-top:1px solid rgba(255,255,255,0.1)">
            <button class="btn ghost small" id="backupSettingsBtn" title="設定をIndexedDBにバックアップ">⚙️ 設定を今すぐバックアップ</button>
            <button class="btn ghost small" id="restoreSettingsBtn" title="IndexedDBから設定を復元">📥 設定を復元</button>
          </div>
          <p class="muted" style="font-size:11px;margin-top:4px">💡
            設定は30秒ごとに自動バックアップされます。localStorageが消えた場合は起動時に自動復元されます。</p>
        </div>
        <div class="panel" style="padding:12px">
          <h3>機能</h3>
          <label class="row" style="gap:8px;align-items:center">
            <input type="checkbox" id="boxesTabToggle">
            ボックス機能を表示する（設定からオンにするとタブが出現します）
          </label>
          <p class="muted" style="margin:4px 0 0;font-size:12px;">オフの場合、タブも非表示になり、ボックス一覧は開けません。</p>
        </div>
        <div class="panel" style="padding:12px">
          <h3>クイックメニュー設定</h3>
          <p class="muted">メニューに表示する操作を選択してください。</p>
          <div id="menuActionSettings" class="list" style="max-height:220px;overflow:auto"></div>
        </div>
        <div class="panel" style="padding:12px">
          <h3>パフォーマンス</h3>
          <label class="row" style="gap:8px;align-items:center">
            <input type="checkbox" id="perfModeToggle">
            軽量モードを有効にする
          </label>
          <p class="muted" style="margin:4px 0 0">アニメーションやぼかしを抑え、低スペック環境での負荷を軽減します。</p>
        </div>
        <div class="panel" style="padding:12px" id="debugTimePanel">
          <h3>デバッグ時間</h3>
          <label class="row" style="gap:8px;align-items:center">
            <input type="checkbox" id="debugTimeEnable">
            仮想時間を使う
          </label>
          <div id="debugTimeControls" style="margin-top:8px;display:none">
            <div class="row" style="gap:8px;align-items:center;flex-wrap:wrap">
              <label style="font-size:12px">仮想現在時刻
                <input type="datetime-local" id="debugTimeValue" class="input" style="min-width:200px">
              </label>
              <button class="btn ghost small" id="debugTimeApply">適用</button>
              <button class="btn ghost small" id="debugTimeReset">実時間に戻す</button>
              <button class="btn ghost small" id="debugTimeFill">今の仮想時刻を入力</button>
            </div>
            <div class="row" style="gap:8px;align-items:center;flex-wrap:wrap;margin-top:6px">
              <span class="muted" id="debugTimeStatus" style="font-size:11px">--</span>
            </div>
          </div>
          <p class="muted" style="margin:6px 0 0;font-size:11px">時計・予定・タイマーはこの仮想時間を現在時刻として扱います。</p>
        </div>
        <div class="panel" style="padding:12px">
          <h3>予定バー色（予定ウィンドウ）</h3>
          <div class="row" style="gap:10px;align-items:center;flex-wrap:wrap">
            <label style="font-size:12px">モード
              <select id="todoColorMode" class="input" style="min-width:160px">
                <option value="default">標準</option>
                <option value="custom">カスタム</option>
              </select>
            </label>
            <button class="btn ghost small" id="todoColorReset">標準に戻す</button>
          </div>
          <div id="todoColorCustomWrap" style="margin-top:8px">
            <div class="row" style="gap:8px;align-items:center;flex-wrap:wrap;margin-bottom:6px">
              <button class="btn small" id="todoColorAdd">+ 色を追加</button>
              <span class="muted" style="font-size:12px">色数を増やしてから各色を選べます</span>
            </div>
            <div class="todo-color-grid" id="todoColorGrid"></div>
          </div>
          <p class="muted" style="margin:6px 0 0;font-size:12px">予定ウィンドウで作成する予定の色に反映されます。</p>
        </div>
        <div class="panel" style="padding:12px">
          <h3>休憩（予定ウィンドウ）</h3>
          <div class="row" style="gap:8px;align-items:center;flex-wrap:wrap">
            <label style="font-size:12px">標準の休憩時間
              <input type="number" id="studyBreakDefaultMin" min="1" max="180" style="width:60px">
              分
            </label>
            <button class="btn ghost small" id="studyBreakDefaultReset">標準に戻す</button>
          </div>
          <p class="muted" style="margin:6px 0 0;font-size:12px">予定ウィンドウ内の休憩ボタンに反映されます。</p>
        </div>
        <div class="panel" style="padding:12px">
          <h3>フォント設定</h3>
          <div class="row" style="gap:10px;align-items:center;flex-wrap:wrap">
            <label style="font-size:12px;display:flex;flex-direction:column;gap:4px">
              アプリ全体のフォント
              <div class="row" style="gap:6px">
                <input type="file" id="appFontInput" accept=".ttf,.otf,.woff,.woff2" style="font-size:11px;width:180px">
                <button class="btn ghost small" id="appFontReset">標準に戻す</button>
              </div>
            </label>
          </div>
          <div class="row" style="gap:10px;align-items:center;flex-wrap:wrap;margin-top:12px">
            <label style="font-size:12px;display:flex;flex-direction:column;gap:4px">
              ミス・メッセージのフォント
              <div class="row" style="gap:6px">
                <input type="file" id="missFontInput" accept=".ttf,.otf,.woff,.woff2"
                  style="font-size:11px;width:180px">
                <button class="btn ghost small" id="missFontReset">標準に戻す</button>
              </div>
            </label>
          </div>
          <p class="muted" style="margin:8px 0 0;font-size:12px;">
            フォントファイルをアップロードして適用します。データはブラウザに保存されます（大きいファイルは保存されない場合があります）。</p>
        </div>
        <div class="panel" style="padding:12px">
          <h3>カーソル</h3>
          <label style="font-size:12px">スタイル
            <select id="cursorStyleSelect" class="input" style="min-width:180px">
              <option value="default">標準（OSデフォルト）</option>
              <optgroup label="シンプル">
                <option value="pen">🖊️ ペン</option>
                <option value="marker">🖍️ マーカー</option>
                <option value="cross">✛ クロス</option>
                <option value="reticle">◎ レティクル</option>
                <option value="ring">○ リング</option>
              </optgroup>
              <optgroup label="クール">
                <option value="star">⭐ スター</option>
                <option value="diamond">💎 ダイアモンド</option>
                <option value="blade">🗡️ ブレード</option>
                <option value="laser">🎯 レーザー</option>
              </optgroup>
              <optgroup label="アニメーション付き ✨">
                <option value="neon">💜 ネオン（グロー）</option>
                <option value="portal">🌀 ポータル（回転）</option>
                <option value="flame">🔥 フレイム（揺らぎ）</option>
                <option value="crystal">💠 クリスタル（回転）</option>
              </optgroup>
            </select>
          </label>
          <p class="muted" style="margin:4px 0 0;font-size:12px;">常時適用されます。アニメーション付きカーソルはグロー効果がマウスに追従します。</p>
        </div>
        <div class="panel" style="padding:12px">
          <h3>ドロー</h3>
          <label class="row" style="gap:8px;align-items:center">
            <input type="checkbox" id="tapDrawToggle">
            タップ中だけドローモードにする
          </label>
          <p class="muted" style="margin:4px 0 0;font-size:12px;">
            オンにすると、ドローモードがOFFでもタップ操作中は自動でドローモードに入り、マウス/ペン操作に戻ると解除されます。</p>
        </div>
        <div class="panel" style="padding:12px">
          <h3>ビュー背景</h3>
          <div class="row" style="gap:10px;align-items:center;flex-wrap:wrap">
            <label style="font-size:12px">プリセット
              <select id="stageBgPreset" class="input" style="min-width:160px">
                <option value="default">やわらかホワイト</option>
                <option value="ui-same">UI同</option>
                <option value="ui">UIと同系（ダーク）</option>
                <option value="latte">ラテ</option>
                <option value="mint">ミント</option>
                <option value="dusk">スモーク</option>
                <option value="custom">カスタム</option>
              </select>
            </label>
            <label style="font-size:12px">カスタム色
              <input type="color" id="stageBgColor" value="#f6f7fb"
                style="width:64px;height:36px;padding:0;border:none;background:transparent">
            </label>
            <button class="btn ghost" id="stageBgReset">リセット</button>
          </div>
          <p class="muted" style="margin:4px 0 0">画像外の余白に使われるグラデーションの基準色です。</p>
        </div>
        <div class="panel" style="padding:12px">
          <h3>自動色合い</h3>
          <label class="row" style="gap:8px;align-items:center">
            <input type="checkbox" id="autoToneToggle">
            解答ウィンドウが透明のときに電子書籍の色を自動で変換する
          </label>
          <div class="row" style="gap:10px;align-items:center;flex-wrap:wrap;margin-top:8px">
            <label style="font-size:12px">色変換プリセット
              <select id="autoToneMode" class="input" style="min-width:200px">
                <option value="red">白→黒 / 黒→赤</option>
                <option value="green">白→黒 / 黒→緑</option>
                <option value="paper">白→紙</option>
                <option value="canvas">白→布/クラフト</option>
                <option value="metal">白→鉄/メタル</option>
                <option value="water">白→水面(ゆらぎ)</option>
                <option value="invert">反転</option>
                <option value="custom">カスタム（色変換設定に追従）</option>
                <option value="orig">オリジナル</option>
              </select>
            </label>
          </div>
          <p class="muted" style="margin:6px 0 0;font-size:12px;">透明の解答ウィンドウを開いた瞬間に色合いを切り替え、閉じたら元の設定に戻します。</p>
        </div>
        <div class="panel" style="padding:12px">
          <h3>HPバー</h3>
          <label class="row" style="gap:8px;align-items:center">
            <input type="checkbox" id="hpBarEnable">
            HPバーを表示する（今の予定がある時のみ）
          </label>
          <div class="row" style="gap:10px;align-items:center;flex-wrap:wrap;margin-top:8px">
            <label style="font-size:12px">減少ステップ
              <select id="hpBarStep" class="input" style="min-width:160px">
                <option value="60000">1分ごと</option>
                <option value="30000">30秒ごと</option>
                <option value="10000">10秒ごと</option>
                <option value="5000">5秒ごと</option>
                <option value="1000">1秒ごと</option>
              </select>
            </label>
            <span class="muted" style="font-size:12px">揺れ演出は常に1分おき</span>
          </div>
          <div class="row" style="gap:10px;align-items:center;flex-wrap:wrap;margin-top:6px">
            <label style="font-size:12px">デザイン
              <select id="hpBarDesign" class="input" style="min-width:160px">
                <option value="standard">標準</option>
                <option value="glass">ガラス</option>
                <option value="translucent">半透明</option>
                <option value="muted">背景になじむ</option>
              </select>
            </label>
            <label style="font-size:12px">サイズ
              <select id="hpBarSize" class="input" style="min-width:160px">
                <option value="normal">通常</option>
                <option value="short">高さ小さめ</option>
                <option value="narrow">横幅小さめ</option>
              </select>
            </label>
            <label style="font-size:12px">配置
              <select id="hpBarAlign" class="input" style="min-width:140px">
                <option value="center">中央</option>
                <option value="left">左寄せ</option>
                <option value="right">右寄せ</option>
              </select>
            </label>
            <label style="font-size:12px">揺れバリエーション
              <select id="hpBarShake" class="input" style="min-width:160px">
                <option value="shake-x">横揺れ（標準）</option>
                <option value="shake-tilt">チルト揺れ</option>
                <option value="shake-bounce">バウンド揺れ</option>
                <option value="shake-rumble">ランブル揺れ</option>
                <option value="shake-quake">クエイク揺れ（派手）</option>
              </select>
            </label>
          </div>
        </div>
        <div class="panel" style="padding:12px">
          <h3>ストレージ使用量</h3>
          <div class="row" style="gap:8px;flex-wrap:wrap;align-items:center">
            <button class="btn" id="analyzeStorageBtn">使用量を計測</button>
            <button class="btn ghost" id="optimizeThumbBtn">解像度を下げる</button>
          </div>
          <div class="row" style="gap:10px;align-items:center;margin:8px 0">
            <label style="font-size:12px">対象</label>
            <select id="optimizeBookSelect" class="input" style="min-width:180px">
              <option value="">すべての本</option>
            </select>
            <label style="font-size:12px">解像度 <span id="optimizeScaleVal"></span></label>
            <input id="optimizeScale" type="range" min="0.2" max="1" step="0.05" value="0.6" class="input"
              style="flex:1;max-width:240px" />
          </div>
          <div class="muted" id="optimizePreview" style="margin:4px 0 8px;font-size:12px">解像度を下げる前に計測してください。</div>
          <div class="muted" style="margin:6px 0 10px;font-size:12px">解像度を下げると元データを上書きし復元できません（過去に `_origDataUrl`
            が残っている場合のみ復元ボタンが有効）。容量削減目的でご利用ください。</div>
          <div id="storageStats" class="list" style="max-height:220px;overflow:auto;font-size:12px"></div>
        </div>
        <div class="panel" style="padding:12px">
          <h3>ページめくりアニメーション</h3>
          <p class="muted" style="margin:4px 0 8px">アニメーションは廃止しました（常に「なし」）。</p>
          <select id="pageAnimSelect" class="input" disabled>
            <option value="none">なし（固定）</option>
          </select>
        </div>
        <div class="panel" style="padding:12px">
          <h3>ページめくり速度</h3>
          <p class="muted" style="margin:4px 0 8px">長押し連続送りの速度を調整できます（通常とShiftターボ）。</p>
          <label style="display:block;font-size:12px">通常長押し速度 <span class="muted" id="pageSpeedNormalVal"></span>
            <input id="pageSpeedNormal" type="range" min="2" max="20" step="0.5" class="input" />
          </label>
          <label style="display:block;font-size:12px;margin-top:10px">Shiftターボ速度 <span class="muted"
              id="pageSpeedShiftVal"></span>
            <input id="pageSpeedShift" type="range" min="2" max="20" step="0.5" class="input" />
          </label>
          <button class="btn ghost" id="pageSpeedReset" style="margin-top:10px">標準に戻す</button>
        </div>
        <div class="panel" style="padding:12px">
          <h3>ビューア配置</h3>
          <label class="row" style="gap:8px;align-items:center">
            <input type="checkbox" id="controlsBottomToggle">
            ページ数や解答ボタンなどの上部操作を下部にまとめる
          </label>
          <p class="muted" style="margin:4px 0 0">有効にすると左右のページ送りボタンも下寄りになります。</p>
        </div>
        <div class="panel" style="padding:12px">
          <h3>フライイン時計</h3>
          <div class="row" style="gap:10px;flex-wrap:wrap">
            <label class="row" style="gap:6px;align-items:center">
              <span class="muted" style="font-size:12px">プランナー時計キー</span>
              <input id="flyPlannerKey" class="input" placeholder="例: Shift+P" style="width:160px">
              <button type="button" class="mini-menu" id="flyPlannerKeyCapture">設定</button>
            </label>
            <label class="row" style="gap:6px;align-items:center">
              <span class="muted" style="font-size:12px">出現方向</span>
              <select id="flyPlannerPos" class="input" style="min-width:140px">
                <option value="right">右</option>
                <option value="left">左</option>
                <option value="top">上</option>
                <option value="bottom">下</option>
              </select>
            </label>
          </div>
          <div class="row" style="gap:10px;flex-wrap:wrap;margin-top:6px">
            <label class="row" style="gap:6px;align-items:center">
              <span class="muted" style="font-size:12px">数直線時計キー</span>
              <input id="flyNumberlineKey" class="input" placeholder="例: Shift+N" style="width:160px">
              <button type="button" class="mini-menu" id="flyNumberlineKeyCapture">設定</button>
            </label>
            <label class="row" style="gap:6px;align-items:center">
              <span class="muted" style="font-size:12px">出現方向</span>
              <select id="flyNumberlinePos" class="input" style="min-width:140px">
                <option value="left">左</option>
                <option value="right">右</option>
                <option value="top">上</option>
                <option value="bottom">下</option>
              </select>
            </label>
            <label class="row" style="gap:6px;align-items:center">
              <span class="muted" style="font-size:12px">本数</span>
              <input id="flyNumberlineCount" type="number" min="1" max="12" value="2" class="input" style="width:80px">
            </label>
          </div>
          <p class="muted" style="margin:6px 0 0;font-size:12px">プランナーの時計/数直線を電子書籍上に一時表示。キーでヒュンと出現/退場します。</p>
        </div>
        <div class="panel" style="padding:12px">
          <h3>ビューア時計</h3>
          <div class="row" style="gap:10px;flex-wrap:wrap">
            <label class="row" style="gap:6px;align-items:center">
              <span class="muted" style="font-size:12px">表示</span>
              <input type="checkbox" id="viewerClockVisible" checked>
            </label>
            <label class="row" style="gap:6px;align-items:center">
              <span class="muted" style="font-size:12px">位置</span>
              <select id="viewerClockPosition" class="input" style="min-width:170px">
                <option value="inline-right">右上（ボタン間）</option>
                <option value="top-right">右上</option>
                <option value="top-left">左上</option>
                <option value="bottom-right">右下</option>
                <option value="bottom-left">左下</option>
                <option value="top">上中央</option>
                <option value="bottom">下中央</option>
                <option value="left">左中央</option>
                <option value="right">右中央</option>
              </select>
            </label>
            <label class="row" style="gap:6px;align-items:center">
              <span class="muted" style="font-size:12px">デザイン</span>
              <select id="viewerClockDesign" class="input" style="min-width:180px">
                <option value="bare">テキストのみ</option>
                <option value="minimal">ミニマル</option>
                <option value="glass">ガラス（ぼかし）</option>
                <option value="glass-clear">ガラス（クリア）</option>
                <option value="wood">木製サイン</option>
                <option value="neon">ネオン</option>
                <option value="lcd">LCD</option>
                <option value="ribbon">リボン</option>
                <option value="planner">プランナー</option>
                <option value="numberline">数直線</option>
                <option value="water">ウォーター</option>
              </select>
            </label>
          </div>
          <div class="row" style="gap:10px;flex-wrap:wrap;margin-top:8px">
            <label class="row" style="gap:6px;align-items:center">
              <span class="muted" style="font-size:12px">時間表示</span>
              <select id="viewerClockFormat" class="input" style="min-width:120px">
                <option value="12">12時間（15時→3:00）</option>
                <option value="24">24時間（15:00）</option>
              </select>
            </label>
            <label class="row" style="gap:6px;align-items:center">
              <input type="checkbox" id="viewerClockSeconds" checked>
              <span>秒を表示</span>
            </label>
            <label class="row" style="gap:6px;align-items:center">
              <span class="muted" style="font-size:12px">表示/非表示キー</span>
              <input id="viewerClockToggleKey" class="input" placeholder="例: Shift+C" style="width:160px">
              <button type="button" class="mini-menu" id="viewerClockToggleCapture">設定</button>
            </label>
          </div>
          <div class="row" style="gap:10px;flex-wrap:wrap;margin-top:8px">
            <label class="row" style="gap:6px;align-items:center">
              <span class="muted" style="font-size:12px">文字色</span>
              <input type="color" id="viewerClockTextColor" class="input" value="#000000" style="width:90px">
            </label>
            <label class="row" style="gap:6px;align-items:center">
              <span class="muted" style="font-size:12px">枠色</span>
              <input type="color" id="viewerClockBorderColor" class="input" value="#222222" style="width:90px">
            </label>
          </div>
          <div class="row" style="gap:10px;flex-wrap:wrap;margin-top:8px">
            <label class="row" style="gap:6px;align-items:center">
              <span class="muted" style="font-size:12px">文字サイズ</span>
              <input type="range" id="viewerClockTextScale" min="0.8" max="1.8" step="0.05" class="input"
                style="width:180px">
              <span class="muted" id="viewerClockTextScaleVal" style="min-width:48px;text-align:right"></span>
            </label>
          </div>
          <div class="row" style="gap:10px;flex-wrap:wrap;margin-top:8px">
            <label class="row" style="gap:6px;align-items:center">
              <span class="muted" style="font-size:12px">フォント</span>
              <input type="file" id="viewerClockFontUpload" accept=".ttf,.otf,.woff,.woff2" class="input"
                style="max-width:240px">
              <button class="btn ghost small" id="viewerClockFontReset">標準に戻す</button>
            </label>
            <span class="muted" id="viewerClockFontLabel" style="font-size:12px"></span>
          </div>
          <p class="muted" style="margin:6px 0 0;font-size:12px">配置はステージ外周または右上のボタン列に挿入します。キー割り当てでヒュンッと出現/非表示できます。</p>
        </div>
        <div class="panel" style="padding:12px">
          <h3>キー操作設定</h3>
          <p class="muted">矢印やズームキーの割り当てやスピードを調整できます。</p>
          <p class="muted" style="margin:4px 0 10px;font-size:12px">初期状態ではキーは割り当てていません。必要なものだけ入力してください。</p>
          <div class="grid" style="grid-template-columns:1fr 1fr;gap:8px" id="keyNavSettingsForm">
            <label style="display:block">
              移動量（キー） <span class="muted" id="keyPanStepVal"></span>
              <div class="row" style="gap:8px">
                <input id="keyPanStep" type="range" min="10" max="140" step="5" class="input" />
                <button type="button" class="mini-menu" id="keyPanStepReset">リセット</button>
              </div>
            </label>
            <label style="display:block">
              ズーム倍率（キー） <span class="muted" id="keyZoomStepVal"></span>
              <div class="row" style="gap:8px">
                <input id="keyZoomStep" type="range" min="1.01" max="1.18" step="0.005" class="input" />
                <button type="button" class="mini-menu" id="keyZoomStepReset">リセット</button>
              </div>
            </label>
            <label style="display:block">
              慣性の強さ（移動） <span class="muted" id="keyPanDecayVal"></span>
              <div class="row" style="gap:8px">
                <input id="keyPanDecay" type="range" min="0.9" max="0.999" step="0.001" class="input" />
                <button type="button" class="mini-menu" id="keyPanDecayReset">リセット</button>
              </div>
            </label>
            <label style="display:block">
              慣性の強さ（ズーム） <span class="muted" id="keyZoomDecayVal"></span>
              <div class="row" style="gap:8px">
                <input id="keyZoomDecay" type="range" min="0.9" max="0.999" step="0.001" class="input" />
                <button type="button" class="mini-menu" id="keyZoomDecayReset">リセット</button>
              </div>
            </label>
            <label>長押し間隔(ms)<input id="keyHoldMs" type="number" min="40" step="10" class="input" /></label>
            <label>左キー（カンマ区切り）
              <div class="row" style="gap:6px">
                <input id="keyLeftKeys" class="input" placeholder="例: ArrowLeft, A" />
                <button type="button" class="mini-menu" id="keyLeftCapture">設定</button>
              </div>
            </label>
            <label>右キー（カンマ区切り）
              <div class="row" style="gap:6px">
                <input id="keyRightKeys" class="input" placeholder="例: ArrowRight, D" />
                <button type="button" class="mini-menu" id="keyRightCapture">設定</button>
              </div>
            </label>
            <label>上キー（カンマ区切り）
              <div class="row" style="gap:6px">
                <input id="keyUpKeys" class="input" placeholder="例: W" />
                <button type="button" class="mini-menu" id="keyUpCapture">設定</button>
              </div>
            </label>
            <label>下キー（カンマ区切り）
              <div class="row" style="gap:6px">
                <input id="keyDownKeys" class="input" placeholder="例: ArrowDown, S" />
                <button type="button" class="mini-menu" id="keyDownCapture">設定</button>
              </div>
            </label>
            <label>ズームインキー（カンマ区切り）
              <div class="row" style="gap:6px">
                <input id="keyZoomInKeys" class="input" placeholder="例: E" />
                <button type="button" class="mini-menu" id="keyZoomInCapture">設定</button>
              </div>
            </label>
            <label>ズームアウトキー（カンマ区切り）
              <div class="row" style="gap:6px">
                <input id="keyZoomOutKeys" class="input" placeholder="例: Q" />
                <button type="button" class="mini-menu" id="keyZoomOutCapture">設定</button>
              </div>
            </label>
            <label>次ページキー（カンマ区切り）
              <div class="row" style="gap:6px">
                <input id="keyPageNextKeys" class="input" placeholder="例: ArrowRight" />
                <button type="button" class="mini-menu" id="keyPageNextCapture">設定</button>
              </div>
            </label>
            <label>前ページキー（カンマ区切り）
              <div class="row" style="gap:6px">
                <input id="keyPagePrevKeys" class="input" placeholder="例: ArrowLeft" />
                <button type="button" class="mini-menu" id="keyPagePrevCapture">設定</button>
              </div>
            </label>
            <label>表示リセットキー（カンマ区切り）
              <div class="row" style="gap:6px">
                <input id="keyResetKeys" class="input" placeholder="例: f" />
                <button type="button" class="mini-menu" id="keyResetCapture">設定</button>
              </div>
            </label>
            <label style="grid-column:span 2;display:flex;align-items:center;gap:8px;">
              <input id="resetZoomOnlyToggle" type="checkbox" />
              表示リセット時にズームのみを戻す（移動位置は維持）
            </label>
            <label>解答ウィンドウ（トグル）
              <div class="row" style="gap:6px">
                <input id="keyAnswerToggle" class="input" placeholder="例: K" />
                <button type="button" class="mini-menu" id="keyAnswerToggleCapture">設定</button>
              </div>
            </label>
            <label>予定メニュー（トグル）
              <div class="row" style="gap:6px">
                <input id="keyStudyMenuKeys" class="input" placeholder="例: S" />
                <button type="button" class="mini-menu" id="keyStudyMenuCapture">設定</button>
              </div>
            </label>
            <div id="keyActionExtrasHeader"
              style="grid-column:span 2;display:flex;align-items:center;justify-content:space-between;gap:8px;margin-top:6px">
              <span style="font-weight:600">追加アクション（任意）</span>
              <span class="muted" style="font-size:11px">好きな操作を割り当てできます</span>
            </div>
            <div id="keyActionExtras"
              style="grid-column:span 2;display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:8px">
            </div>
            <label style="grid-column:span 2;display:flex;align-items:center;gap:8px">
              <input id="keyClamp" type="checkbox" /> 電子書籍で画像外に出ない（限界を適用）
            </label>
            <button class="btn ghost" id="keyNavResetDefaults" style="grid-column:span 2">デフォルトに戻す</button>
            <button class="btn primary" id="keyNavSave" style="grid-column:span 2">保存</button>
          </div>
        </div>
      </div>

      <div id="viewerView" class="hidden"></div>
    </main>
  </div>

  <!-- Planner App (Clock Planner) -->
  <div id="plannerApp" class="hidden">
    <svg width="0" height="0" style="position:absolute" aria-hidden="true">
      <filter id="bookToneFilter" color-interpolation-filters="sRGB">
        <feColorMatrix id="bookToneMono" type="matrix"
          values="0.299 0.587 0.114 0 0 0.299 0.587 0.114 0 0 0.299 0.587 0.114 0 0 0 0 0 1 0" />
        <feComponentTransfer color-interpolation-filters="sRGB">
          <feFuncR id="bookToneR" type="linear" slope="1" intercept="0" />
          <feFuncG id="bookToneG" type="linear" slope="1" intercept="0" />
          <feFuncB id="bookToneB" type="linear" slope="1" intercept="0" />
        </feComponentTransfer>
      </filter>
      <filter id="bookTonePaper" x="-5%" y="-5%" width="110%" height="110%" color-interpolation-filters="sRGB">
        <feColorMatrix in="SourceGraphic" type="matrix" values="1 0 0 0 0.02 0 1 0 0 0.01 0 0 1 0 -0.02 0 0 0 1 0"
          result="warmBase" />
        <feTurbulence type="fractalNoise" baseFrequency="0.85" numOctaves="3" seed="2" result="paperNoise" />
        <feColorMatrix in="paperNoise" type="matrix" values="0 0 0 0 0.96 0 0 0 0 0.9 0 0 0 0 0.78 0 0 0 0.16 0"
          result="paperTint" />
        <feComposite in="paperTint" in2="warmBase" operator="in" result="paperOverlay" />
        <feBlend in="warmBase" in2="paperOverlay" mode="multiply" />
      </filter>
      <filter id="bookToneCanvas" x="-6%" y="-6%" width="112%" height="112%" color-interpolation-filters="sRGB">
        <feColorMatrix in="SourceGraphic" type="matrix"
          values="0.98 0 0 0 0.01 0 0.98 0 0 0.01 0 0 0.98 0 0.01 0 0 0 1 0" result="coolBase" />
        <feTurbulence type="fractalNoise" baseFrequency="0.72" numOctaves="4" seed="9" result="fabricNoise" />
        <feColorMatrix in="fabricNoise" type="matrix" values="0 0 0 0 0.9 0 0 0 0 0.92 0 0 0 0 0.95 0 0 0 0.18 0"
          result="fabricTint" />
        <feComposite in="fabricTint" in2="coolBase" operator="in" result="woven" />
        <feBlend in="coolBase" in2="woven" mode="multiply" />
      </filter>
      <filter id="bookToneMetal" x="-5%" y="-5%" width="110%" height="110%" color-interpolation-filters="sRGB">
        <feColorMatrix in="SourceGraphic" type="matrix"
          values="0.33 0.33 0.33 0 0 0.33 0.33 0.33 0 0 0.33 0.33 0.33 0 0 0 0 0 1 0" result="mono" />
        <feComponentTransfer in="mono" result="steel">
          <feFuncR type="linear" slope="0.85" intercept="0.12" />
          <feFuncG type="linear" slope="0.9" intercept="0.14" />
          <feFuncB type="linear" slope="1.05" intercept="0.18" />
        </feComponentTransfer>
        <feTurbulence type="fractalNoise" baseFrequency="0.55" numOctaves="4" seed="6" result="grain" />
        <feColorMatrix in="grain" type="matrix" values="0 0 0 0 0.75 0 0 0 0 0.8 0 0 0 0 0.85 0 0 0 0.24 0"
          result="grainTint" />
        <feComposite in="grainTint" in2="steel" operator="in" result="brushed" />
        <feBlend in="steel" in2="brushed" mode="screen" />
      </filter>
      <filter id="bookToneWater" x="-10%" y="-10%" width="120%" height="120%" color-interpolation-filters="sRGB">
        <feColorMatrix in="SourceGraphic" type="matrix"
          values="0.9 0.04 0.04 0 0 0.08 0.85 0.08 0 0.02 0.08 0.1 0.92 0 0.04 0 0 0 1 0" result="coolBase" />
        <feTurbulence id="bookToneWaterNoise" type="fractalNoise" baseFrequency="0.32" numOctaves="3" seed="3"
          result="ripples">
          <animate attributeName="seed" values="3;12;6;3" dur="18s" repeatCount="indefinite" />
          <animate attributeName="baseFrequency" values="0.32;0.38;0.3;0.32" dur="12s" repeatCount="indefinite" />
        </feTurbulence>
        <feDisplacementMap in="coolBase" in2="ripples" scale="12" xChannelSelector="R" yChannelSelector="G"
          result="wobble" />
        <feColorMatrix in="ripples" type="matrix" values="0 0 0 0 0.6 0 0 0 0 0.82 0 0 0 0 0.95 0 0 0 0.18 0"
          result="foam" />
        <feBlend in="wobble" in2="foam" mode="screen" />
      </filter>
    </svg>
    <header>
      <h1>🕐 Clock Planner v6</h1>
    </header>

    <div class="tabs">
      <button class="tab active" data-tab="planner">🕒 時計</button>
      <button class="tab" data-tab="timer">⏲️ タイマー</button>
      <button class="tab" data-tab="stopwatch">⏱️ ストップウォッチ</button>
      <button class="tab" data-tab="digital">🔢 デジタル</button>
      <button class="tab" data-tab="calendar">📆 カレンダー</button>
      <button class="tab" data-tab="original-lesson">🎓 オリジナル授業</button>
      <button class="tab" data-tab="numberline">📏 数直線</button>
      <button class="tab" data-tab="study">📚 勉強管理</button>
      <button class="tab" data-tab="todo">✅ ToDo</button>
      <button class="tab" data-tab="today">📅 今日</button>
      <button class="tab" data-tab="sound">🔊 サウンド</button>
    </div>

    <main>
      <div class="tab-content active" data-content="planner">
        <div class="card planner-hero-card">
          <div class="planner-hero">
            <div class="planner-clock-area">
              <div class="planner-hero-top">
                <button class="btn small" id="pageCompleteBtn">✅ 完了 0/0</button>
              </div>

              <div class="clock-wrap">
                <svg id="clock" viewBox="0 0 500 500">
                  <defs>
                    <filter id="shadow">
                      <feDropShadow dx="0" dy="2" stdDeviation="2" flood-opacity=".3" />
                    </filter>
                    <linearGradient id="glassGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                      <stop offset="0%" style="stop-color:rgba(255,255,255,.3)" />
                      <stop offset="100%" style="stop-color:rgba(255,255,255,0)" />
                    </linearGradient>
                    <filter id="glow">
                      <feGaussianBlur stdDeviation="4" result="coloredBlur" />
                      <feMerge>
                        <feMergeNode in="coloredBlur" />
                        <feMergeNode in="SourceGraphic" />
                      </feMerge>
                    </filter>
                    <linearGradient id="arcGrad1" x1="0%" y1="0%" x2="100%" y2="0%">
                      <stop offset="0%" id="arcGradStart1" />
                      <stop offset="100%" id="arcGradEnd1" />
                    </linearGradient>
                    <linearGradient id="arcGrad2" x1="0%" y1="0%" x2="100%" y2="100%">
                      <stop offset="0%" id="arcGradStart2" />
                      <stop offset="50%" id="arcGradMid2" />
                      <stop offset="100%" id="arcGradEnd2" />
                    </linearGradient>
                  </defs>
                  <circle cx="250" cy="250" r="235" fill="var(--face)" stroke="var(--ring)" stroke-width="2" />
                  <g id="ticks"></g>
                  <g id="numbers"></g>
                  <g id="arcs"></g>
                  <g id="timerArcs" style="pointer-events:none"></g>
                  <g id="outerArcs1"></g>
                  <g id="outerArcs2"></g>
                  <g id="hands" filter="url(#shadow)">
                    <line id="hHand" x1="250" y1="250" x2="250" y2="110" stroke="var(--handH)" stroke-width="8"
                      stroke-linecap="round" />
                    <line id="mHand" x1="250" y1="250" x2="250" y2="65" stroke="var(--handM)" stroke-width="5"
                      stroke-linecap="round" />
                    <line id="sHand" x1="250" y1="250" x2="250" y2="50" stroke="var(--handS)" stroke-width="3"
                      stroke-linecap="round" />
                  </g>
                  <circle cx="250" cy="250" r="8" fill="var(--handS)" />
                </svg>
                <div id="hint" class="drag-hint"></div>
              </div>
            </div>

            <div class="planner-info-stack" id="plannerInfoStack">
              <!-- ▼ Overall (study) total remain/end; visible only when study auto-generated exists -->
              <div id="overallStudyInfo" class="overall-study" style="display:none">
                <span id="osiRemain">残り --</span>
                <span id="osiEnd">終了 --:--</span>
              </div>
              <div class="planner-hud-grid">
                <div id="plEta" class="nl-eta">--</div>
                <div id="plTimerHUD" class="hud-pill">--</div>
                <div id="pomoClockHUD" class="hud-pill">--</div>
              </div>
            </div>
          </div>
        </div>

        <div class="card">
          <div class="row">
            <label>テーマ</label>
            <select id="theme">


              <option value="water">水（アニメ）</option>
              <option value="aurora">オーロラ（アニメ）</option>

              <option value="kari">仮（Aqua風）</option>
              <option value="theme-minimal" selected>Minimal</option>
              <option value="theme-classic">Classic</option>
              <option value="theme-neon">Neon</option>
              <option value="theme-horror">Horror</option>
              <option value="theme-paper">Paper</option>
              <option value="theme-glass">Glass</option>
              <option value="theme-pudding">Pudding</option>
              <option value="theme-metal">Metal</option>
            </select>
            <label>表示</label>
            <select id="mode">
              <option value="day">12時間</option>
              <option value="hour" selected>60分</option>
            </select>
            <label>針の動き</label>
            <select id="motion">
              <option value="smooth">スムーズ</option>
              <option value="tick" selected>カチカチ</option>
            </select>
            <label>倍速</label>
            <select id="timeScale">
              <option value="1" selected>1x</option>
              <option value="2">2x</option>
              <option value="4">4x</option>
              <option value="8">8x</option>
              <option value="10">10x</option>
              <option value="20">20x</option>
              <option value="40">40x</option>
              <option value="80">80x</option>
              <option value="160">160x</option>
              <option value="320">320x</option>
              <option value="1000">1000x</option>
              <option value="5000">5000x</option>
              <option value="10000">10000x</option>
              <option value="20000">20000x</option>
              <option value="50000">50000x</option>
            </select>

            <label>バー形</label>
            <select id="shape">
              <option value="arc">アーク</option>
              <option value="wedge">くさび</option>
              <option value="bar" selected>帯</option>
              <option value="triangle">三角</option>
            </select>
            <label>バー見た目</label>
            <select id="style">
              <option value="solid" selected>ソリッド</option>
              <option value="glass">ガラス</option>
              <option value="glow">発光</option>
              <option value="metal">メタル</option>
              <option value="gradient">グラデ</option>
              <option value="rainbow">レインボー</option>
            </select>
            <label>時計デザイン</label>
            <select id="clockDesign">
              <option value="classic" selected>Classic</option>
              <option value="minimal">Minimal</option>
              <option value="neon">Neon</option>
              <option value="frost">Frost</option>
              <option value="blueprint">Blueprint</option>
              <option value="highcontrast">High-Contrast</option>
            </select> <span class="tiny"
              style="margin-left:10px;opacity:.8;display:inline-flex;gap:6px;align-items:center"><input type="checkbox"
                id="plShowSeconds"> プランナーの残り秒まで表示</span>

            <label>スナップ</label>
            <select id="snap">
              <option value="1">1分</option>
              <option value="5" selected>5分</option>
              <option value="10">10分</option>
              <option value="15">15分</option>
            </select>
          </div>

          <div class="row">
            <label>針の動き</label>
            <select id="motion">
              <option value="smooth">スムーズ</option>
              <option value="tick" selected>カチカチ</option>
            </select>
            <label>形状</label>
            <select id="shape">
              <option value="arc">アーク</option>
              <option value="wedge">三角</option>
              <option value="bar" selected>バー</option>
              <option value="triangle">中央三角</option>
            </select>
            <label>見た目</label>
            <select id="style">
              <option value="solid">ソリッド</option>
              <option value="glass">ガラス</option>
              <option value="glow">グロー</option>
              <option value="metal">メタル</option>
              <option value="gradient">グラデーション</option>
              <option value="rainbow">レインボー</option>
            </select>
          </div>

          <div class="row">
            <label>開始</label>
            <input id="start" type="time" value="09:00">
            <label>終了</label>
            <input id="end" type="time" value="10:00">
            <input id="label" type="text" placeholder="ラベル" style="flex:1">
            <input id="color" type="color" value="#4da3ff">
            <button id="add">追加</button>
            <button id="plannerDirectToggle" class="ghost">直接モード:OFF</button>
          </div>
          <div class="row" style="gap:8px;flex-wrap:wrap;align-items:center">
            <span class="tiny" style="opacity:.8">＋ 休憩/ミニ授業を即配置</span>
            <button class="btn ghost small" id="quickBreak5">☕ 休憩5分</button>
            <button class="btn ghost small" id="quickBreak15">☕ 休憩15分</button>
            <button class="btn ghost small" id="quickLesson25">🎒 ミニ授業25分</button>
            <span class="tiny" style="color:var(--muted)">時計の現在位置に差し込み</span>
          </div>
          <div class="row" style="align-items:center;gap:10px">
            <label>バー透明度</label>
            <input id="plannerOpacity" type="range" min="0.2" max="1" step="0.05" value="0.9" style="width:160px">
            <span id="plannerOpacityVal" class="tiny" style="color:var(--muted)">0.90</span>
            <label>バー高さ</label>
            <input id="plannerHeight" type="range" min="8" max="80" step="2" value="24" style="width:160px">
            <span id="plannerHeightVal" class="tiny" style="color:var(--muted)">24px</span>
          </div>
          <div class="row" style="align-items:center;gap:10px">
            <label>ゲージデザイン</label>
            <select id="plannerGaugeStyle">
              <option value="standard" selected>通常</option>
              <option value="guide">直接ゲージ風</option>
            </select>
            <span class="tiny" style="opacity:.75">※数直線の直接モード風デザイン</span>
          </div>

          <div class="tiny">💡 タップ→長押しドラッグ→離して確定</div>

          <div style="margin:12px 0; display:flex; gap:8px; flex-wrap:wrap">
            <button id="undo" class="ghost">↶ 元に戻す</button>
            <button id="clear" class="ghost danger">🗑️ 全削除</button>
            <button id="export" class="ghost">💾 保存</button>
            <button id="import" class="ghost">📂 読込</button>
            <input id="file" type="file" accept=".json" style="display:none">
          </div>

          <div class="tiny" style="margin-top:12px">📋 予定一覧</div>
          <div id="list" class="list"></div>
        </div>
      </div>

      <div class="tab-content" data-content="timer">
        <div class="card">
          <div class="row space" style="align-items:flex-end; gap:10px; flex-wrap:wrap">
            <div style="flex:1; min-width:240px">
              <div class="timer-form">
                <div>
                  <label class="tiny" style="display:block;opacity:.8">分</label>
                  <input id="tMinutesInput" class="input" type="number" min="1" max="720" value="25">
                </div>
                <div>
                  <label class="tiny" style="display:block;opacity:.8">配置</label>
                  <select id="tModeSelect" class="input">
                    <option value="outer" selected>外周ゲージ</option>
                    <option value="direct">直接配置</option>
                  </select>
                </div>
                <div>
                  <label class="tiny" style="display:block;opacity:.8">色</label>
                  <input id="tColorInput" class="input" type="color" value="#4da3ff">
                </div>
                <div style="display:flex;align-items:flex-end;gap:6px">
                  <button class="btn primary" id="tAdd" style="width:100%">➕ 追加</button>
                </div>
              </div>
            </div>
            <div class="row" style="gap:8px;align-items:center;flex-wrap:wrap">
              <button class="btn ghost small" id="timerKitchenToggle">🍳 キッチンモード</button>
              <span class="tiny" style="color:var(--muted)">コンパクト表示＋大画面ボタン付き</span>
            </div>
          </div>
          <div class="row" style="margin-top:10px;align-items:center;gap:8px;flex-wrap:wrap">
            <label>終了時刻</label>
            <input id="tUntilTime" type="time" step="60" style="width:120px">
            <label>表示</label>
            <select id="tUntilMode">
              <option value="direct">直接配置</option>
              <option value="outer" selected>外周</option>
            </select>
            <label>色</label>
            <input id="tUntilColor" type="color" value="#4da3ff" style="width:50px">
            <button id="tUntilStart">⏲️ 〜まで開始</button>
            <span class="tiny" style="color:var(--muted)">選んだ時刻まで自動セット</span>
          </div>
          <div id="timerList" class="timer-list"></div>
        </div>
      </div>

      <div class="tab-content" data-content="stopwatch">
        <div class="card">
          <button id="swAdd" style="width:100%">➕ ストップウォッチ追加</button>
          <div id="swList" style="margin-top:16px"></div>
        </div>
      </div>

      <div class="tab-content" data-content="digital">
        <div class="card digital-card">
          <div class="digital-wrap">
            <div id="digitalTime" class="digital-big"></div>
          </div>
        </div>
      </div>

      <div class="tab-content" data-content="calendar">
        <div class="calendar-shell">
          <div class="calendar-main card study-calendar-main">
            <!-- Header with view modes and navigation -->
            <div class="sc-header">
              <div class="sc-nav">
                <button class="btn ghost small" id="scPrev">◀</button>
                <h2 id="scTitle" class="sc-title">2025年12月</h2>
                <button class="btn ghost small" id="scNext">▶</button>
                <button class="btn ghost small" id="scToday">今日</button>
              </div>
              <div class="sc-views">
                <button class="btn ghost small sc-view-btn active" data-view="month">月</button>
                <button class="btn ghost small sc-view-btn" data-view="week">週</button>
                <button class="btn ghost small sc-view-btn" data-view="horizontal">横スクロール</button>
                <button class="btn ghost small sc-view-btn" data-view="agenda">リスト</button>
              </div>
              <div class="sc-options">
                <button class="btn ghost small" id="scUndo" title="元に戻す">↶</button>
                <button class="btn ghost small" id="scRedo" title="やり直す">↷</button>
                <button class="btn ghost small" id="scRefresh" title="更新">🔄</button>
                <div class="sc-width-control hidden" id="scWidthControl" aria-label="横幅調整">
                  <span class="mini-label">横幅</span>
                  <button class="btn ghost small" type="button" id="scWidthDec">−</button>
                  <input type="range" id="scWidthFine" min="90" max="200" step="5" value="120" title="横幅調整">
                  <button class="btn ghost small" type="button" id="scWidthInc">＋</button>
                </div>
              </div>
            </div>

            <div class="sc-layout-bar">
              <div class="sc-slider">
                <label for="scZoomSlider">拡大率</label>
                <input type="range" id="scZoomSlider" min="0.9" max="1.4" step="0.05" value="1">
              </div>
              <div class="sc-slider">
                <label for="scWidthSlider">横スクロール幅</label>
                <input type="range" id="scWidthSlider" min="90" max="180" step="5" value="120">
              </div>
              <div class="sc-slider">
                <label for="scWeekHeightSlider">週ビュー高さ</label>
                <input type="range" id="scWeekHeightSlider" min="1" max="2" step="0.1" value="1.1">
              </div>
              <div class="sc-slider inline">
                <label for="scAsideWidthSlider">右メニュー幅</label>
                <input type="range" id="scAsideWidthSlider" min="320" max="520" step="10" value="400">
              </div>
              <div class="sc-layout-actions">
                <button class="btn ghost small" id="scExpandToggle">拡大表示</button>
                <button class="btn ghost small" id="scFocusToday">今日を開く</button>
              </div>
            </div>

            <!-- Quick Stats from TODO -->
            <div class="sc-stats">
              <div class="sc-stat">
                <span class="sc-stat-value" id="scStatTodo">0</span>
                <span class="sc-stat-label">ToDo数</span>
              </div>
              <div class="sc-stat">
                <span class="sc-stat-value" id="scStatRemain">0</span>
                <span class="sc-stat-label">未完了</span>
              </div>
              <div class="sc-stat">
                <span class="sc-stat-value" id="scStatPages">0</span>
                <span class="sc-stat-label">残りP</span>
              </div>
              <div class="sc-stat">
                <span class="sc-stat-value" id="scStatToday">0</span>
                <span class="sc-stat-label">今日</span>
              </div>
              <div class="sc-stat urgent">
                <span class="sc-stat-value" id="scStatOverdue">0</span>
                <span class="sc-stat-label">期限切れ</span>
              </div>
            </div>

            <!-- Month View -->
            <div id="scMonthView" class="sc-month-view">
              <div class="sc-weekdays" id="scWeekdays"></div>
              <div id="scGrid" class="sc-grid"></div>
            </div>

            <!-- Week View -->
            <div id="scWeekView" class="sc-week-view hidden">
              <div id="scWeekGrid" class="sc-week-grid"></div>
            </div>

            <!-- Horizontal Scroll Timeline View -->
            <div id="scHorizontalView" class="sc-horizontal-view hidden">
              <div id="scHTimeline" class="sc-h-timeline"></div>
            </div>

            <!-- Agenda/List View -->
            <div id="scAgendaView" class="sc-agenda-view hidden">
              <div id="scAgendaList" class="sc-agenda-list"></div>
            </div>
          </div>
          <div class="calendar-resizer" id="calendarResizer" title="幅をドラッグで調整"></div>
          <aside class="calendar-aside">
            <div class="calendar-aside-scroll">
              <!-- Day Detail Panel (shows when clicking a date) -->
              <div id="scDayDetail" class="card sc-day-detail hidden">
                <div class="sc-dd-header">
                  <h3 id="scDDTitle">12月10日（火）</h3>
                  <button class="btn ghost small" id="scDDClose">✕ 閉じる</button>
                </div>

                <!-- Scheduled Tasks for this day -->
                <div class="sc-dd-section">
                  <h4>📋 予定タスク</h4>
                  <div id="scDDTasks" class="sc-dd-tasks"></div>
                </div>

                <!-- Completed Pages on this day -->
                <div class="sc-dd-section">
                  <h4>✅ 完了ページ記録</h4>
                  <div class="row space" style="align-items:center;gap:8px;margin:4px 0;">
                    <div class="tiny" style="color:var(--muted);">スクロール/ドラッグで高さ調整</div>
                    <button class="btn ghost small" id="scCompletedToggle">折りたたみ</button>
                  </div>
                  <div class="sc-completed-wrap" id="scCompletedWrap">
                    <div id="scDDCompleted" class="sc-dd-completed"></div>
                    <div class="sc-completed-resize" id="scCompletedResize" title="ドラッグで高さ変更"></div>
                  </div>
                  <button class="btn small" id="scDDOpenDailyBook">📖 この日のまとめを見る</button>
                </div>

              </div>

              <!-- TODO Scheduling Panel -->
              <div class="card study-calendar-panel">
                <h3 style="margin:0 0 12px">📅 ToDoスケジュール配分</h3>
                <p class="sc-hint">開始日と終了日を決めるだけで残ページを自動配分。配分スタイルはお好みで変更できます。</p>

                <div class="sc-todo-select-area">
                  <label>ToDoを選択</label>
                  <select id="scTodoSelect" class="input">
                    <option value="">-- ToDoを選択 --</option>
                  </select>
                  <button class="btn ghost small" id="scTodoRefresh">更新</button>
                </div>

                <div id="scTodoInfo" class="sc-todo-info hidden">
                  <div class="sc-todo-detail">
                    <span class="sc-todo-title" id="scTodoTitle">-</span>
                    <span class="sc-todo-meta" id="scTodoMeta">残り: 0P / 推定: 0分</span>
                  </div>
                </div>

                <div class="sc-schedule-form">
                  <div class="sc-form-row">
                    <div class="sc-form-group">
                      <label>開始日</label>
                      <input type="date" id="scScheduleStart" class="input">
                    </div>
                    <div class="sc-form-group">
                      <label>終了日/期限</label>
                      <input type="date" id="scScheduleEnd" class="input">
                    </div>
                  </div>
                  <div class="sc-form-row">
                    <div class="sc-form-group">
                      <label>配分スタイル</label>
                      <select id="scDistributeMode" class="input">
                        <option value="even">均等に割り振る</option>
                        <option value="front">前倒しに詰める</option>
                        <option value="back">後ろに詰める</option>
                        <option value="weekdays">平日のみ均等</option>
                      </select>
                    </div>
                  </div>
                  <div class="sc-form-row">
                    <label class="sc-checkbox-label">
                      <input type="checkbox" id="scOverwriteExisting">
                      既存の配分を上書き
                    </label>
                  </div>
                  <div class="sc-form-actions">
                    <button class="btn ghost small" id="scPreviewSchedule">プレビュー</button>
                    <button class="btn small" id="scApplySchedule">配分を適用</button>
                    <button class="btn ghost small" id="scAutoDistribute">残りを自動配分</button>
                  </div>
                </div>

                <!-- Schedule Preview -->
                <div id="scPreviewArea" class="sc-preview-area hidden">
                  <h4>配分プレビュー</h4>
                  <div id="scPreviewList" class="sc-preview-list"></div>
                </div>

                <!-- Settings -->
                <div class="sc-settings-section">
                  <details>
                    <summary>表示設定</summary>
                    <div class="sc-form-group">
                      <label>週の開始曜日</label>
                      <select id="scWeekStart" class="input">
                        <option value="0">日曜日</option>
                        <option value="1" selected>月曜日</option>
                      </select>
                    </div>
                    <div class="sc-form-group">
                      <label class="sc-checkbox-label">
                        <input type="checkbox" id="scShowComplete" checked>
                        完了タスクを表示
                      </label>
                    </div>
                    <div class="sc-form-group">
                      <label class="sc-checkbox-label">
                        <input type="checkbox" id="scHighlightWeekend" checked>
                        土日を色分け
                      </label>
                    </div>
                    <div class="sc-form-group">
                      <label class="sc-checkbox-label">
                        <input type="checkbox" id="scShowProgress" checked>
                        進捗バーを表示
                      </label>
                    </div>
                  </details>
                </div>
              </div>

              <div class="card sc-mini-card">
                <h3 style="margin:0 0 10px">🎒 ミニ授業/休憩ブロック</h3>
                <p class="sc-hint">時間を確保して週の学習時間を見える化。カレンダーに直接入ります。</p>
                <div class="sc-mini-grid">
                  <div>
                    <label class="tiny" style="display:block;opacity:.8">タイトル</label>
                    <input id="scMiniTitle" class="input" value="ミニ授業">
                  </div>
                  <div>
                    <label class="tiny" style="display:block;opacity:.8">日付</label>
                    <input id="scMiniDate" type="date" class="input">
                  </div>
                  <div>
                    <label class="tiny" style="display:block;opacity:.8">開始</label>
                    <input id="scMiniStart" type="time" class="input" step="60" value="09:00">
                  </div>
                  <div>
                    <label class="tiny" style="display:block;opacity:.8">長さ(分)</label>
                    <input id="scMiniDuration" type="number" class="input" min="5" max="360" value="25">
                  </div>
                  <div>
                    <label class="tiny" style="display:block;opacity:.8">繰り返し(週)</label>
                    <input id="scMiniRepeat" type="number" class="input" min="1" max="12" value="1">
                  </div>
                  <div>
                    <label class="tiny" style="display:block;opacity:.8">週の目標(時間)</label>
                    <input id="scMiniWeeklyGoal" type="number" class="input" min="1" max="60" value="10">
                  </div>
                </div>
                <div class="sc-mini-quick">
                  <button class="btn ghost small" id="scMiniBreakQuick">☕ 休憩 10分</button>
                  <button class="btn ghost small" id="scMiniNow">⚡ 今すぐ開始</button>
                  <button class="btn ghost small" id="scMiniFromPage">📖 現在のページから</button>
                </div>
                <div class="sc-mini-actions">
                  <button class="btn" id="scMiniAdd">カレンダーに追加</button>
                </div>
                <div class="sc-mini-grid" style="margin-top:10px">
                  <div class="sc-mini-stat">
                    <span class="label">今週の確保時間</span>
                    <span class="value" id="scMiniWeekTotal">--</span>
                  </div>
                  <div class="sc-mini-stat">
                    <span class="label">残り目標</span>
                    <span class="value" id="scMiniWeekRemain">--</span>
                  </div>
                </div>
                <div class="sc-mini-log" id="scMiniLog"></div>
              </div>
            </div>
          </aside>
        </div>
      </div>

      <div class="tab-content" data-content="original-lesson">
        <div class="card ol-hero">
          <div class="row space" style="align-items:flex-end;gap:16px;flex-wrap:wrap">
            <div>
              <h2 style="margin:0">🎓 オリジナル授業プランナー</h2>
              <p class="muted" style="margin:6px 0 0">横スクロールで先の授業時間を一括確保。範囲指定で長期の学習枠を作れます。</p>
            </div>
            <div class="ol-stat-grid">
              <div class="ol-stat">
                <span class="label">今週</span>
                <span class="value" id="olStatWeek">--</span>
              </div>
              <div class="ol-stat">
                <span class="label">今日</span>
                <span class="value" id="olStatToday">--</span>
              </div>
              <div class="ol-stat">
                <span class="label">今月</span>
                <span class="value" id="olStatMonth">--</span>
              </div>
              <div class="ol-stat">
                <span class="label">合計</span>
                <span class="value" id="olStatTotal">--</span>
              </div>
            </div>
          </div>

          <div class="ol-form-grid">
            <div>
              <label class="tiny" style="display:block;opacity:.8">授業名</label>
              <input id="olTitle" class="input" placeholder="例: 数学 / 英語 / 自習" />
            </div>
            <div>
              <label class="tiny" style="display:block;opacity:.8">期間</label>
              <div class="row" style="gap:6px;align-items:center;flex-wrap:wrap">
                <input id="olRangeStart" type="date" class="input">
                <span class="tiny" style="color:var(--muted)">〜</span>
                <input id="olRangeEnd" type="date" class="input">
              </div>
            </div>
            <div>
              <label class="tiny" style="display:block;opacity:.8">開始</label>
              <input id="olStartTime" type="time" class="input" step="60" value="19:00">
            </div>
            <div>
              <label class="tiny" style="display:block;opacity:.8">終了</label>
              <input id="olEndTime" type="time" class="input" step="60" value="20:00">
            </div>
            <div>
              <label class="tiny" style="display:block;opacity:.8">時間(分)</label>
              <input id="olDuration" type="number" class="input" min="5" max="600" value="60">
            </div>
            <div>
              <label class="tiny" style="display:block;opacity:.8">色</label>
              <input id="olColor" type="color" value="#60a5fa"
                style="width:72px;height:34px;border:none;background:transparent">
            </div>
          </div>

          <div class="ol-clock-panel">
            <div class="ol-clock-header">
              <span class="tiny" style="color:var(--muted)">時計で時間設定（分針を回して調整）</span>
              <button type="button" class="chip-btn" id="olClockSetNow">現在に合わせる</button>
            </div>
            <div class="ol-clock-body">
              <div class="ol-clock-grid">
                <div class="ol-clock-block">
                  <div class="ol-clock-label">開始</div>
                  <div class="ol-clock" role="application" aria-label="開始時間の時計" data-clock-target="start">
                    <svg viewBox="0 0 200 200" aria-hidden="true">
                      <circle cx="100" cy="100" r="86" fill="rgba(15, 23, 42, 0.6)" stroke="rgba(255, 255, 255, 0.08)"
                        stroke-width="2"></circle>
                      <g class="ol-clock-ticks"></g>
                      <g class="ol-clock-numbers"></g>
                      <line class="ol-clock-hand ol-clock-hour-hand" x1="100" y1="100" x2="100" y2="60"></line>
                      <line class="ol-clock-hand ol-clock-minute-hand active" x1="100" y1="100" x2="100" y2="40"></line>
                      <circle cx="100" cy="100" r="4" fill="#38bdf8"></circle>
                    </svg>
                  </div>
                  <div class="ol-clock-readout" data-clock-readout="start">--:--</div>
                </div>
                <div class="ol-clock-block">
                  <div class="ol-clock-label">終了</div>
                  <div class="ol-clock" role="application" aria-label="終了時間の時計" data-clock-target="end">
                    <svg viewBox="0 0 200 200" aria-hidden="true">
                      <circle cx="100" cy="100" r="86" fill="rgba(15, 23, 42, 0.6)" stroke="rgba(255, 255, 255, 0.08)"
                        stroke-width="2"></circle>
                      <g class="ol-clock-ticks"></g>
                      <g class="ol-clock-numbers"></g>
                      <line class="ol-clock-hand ol-clock-hour-hand" x1="100" y1="100" x2="100" y2="60"></line>
                      <line class="ol-clock-hand ol-clock-minute-hand active" x1="100" y1="100" x2="100" y2="40"></line>
                      <circle cx="100" cy="100" r="4" fill="#38bdf8"></circle>
                    </svg>
                  </div>
                  <div class="ol-clock-readout" data-clock-readout="end">--:--</div>
                </div>
              </div>
              <div class="tiny" style="color:var(--muted);margin-top:0">ドラッグで針を回して設定（現在より前は選択不可）</div>
            </div>
          </div>

          <div class="ol-weekdays" id="olWeekdays">
            <button type="button" class="chip-btn" data-day="0">日</button>
            <button type="button" class="chip-btn" data-day="1">月</button>
            <button type="button" class="chip-btn" data-day="2">火</button>
            <button type="button" class="chip-btn" data-day="3">水</button>
            <button type="button" class="chip-btn" data-day="4">木</button>
            <button type="button" class="chip-btn" data-day="5">金</button>
            <button type="button" class="chip-btn" data-day="6">土</button>
          </div>
          <div class="ol-quick-row">
            <button type="button" class="chip-btn" id="olWeekAll">毎日</button>
            <button type="button" class="chip-btn" id="olWeekWeekdays">平日</button>
            <button type="button" class="chip-btn" id="olWeekWeekends">土日</button>
          </div>
          <div class="ol-quick-row" id="olDurationQuick">
            <button type="button" class="chip-btn" data-duration="25">25分</button>
            <button type="button" class="chip-btn" data-duration="45">45分</button>
            <button type="button" class="chip-btn" data-duration="60">60分</button>
            <button type="button" class="chip-btn" data-duration="90">90分</button>
          </div>
          <div class="ol-quick-row">
            <button type="button" class="chip-btn" id="olRangeWeek">今週</button>
            <button type="button" class="chip-btn" id="olRangeMonth">今月</button>
            <button type="button" class="chip-btn" id="olRange30">30日</button>
            <button type="button" class="chip-btn" id="olRange90">90日</button>
          </div>

          <div class="ol-actions">
            <button class="btn" id="olAddRange">範囲に追加</button>
            <button class="btn ghost" id="olAddSelected">選択日に追加</button>
            <button class="btn ghost danger" id="olClearAll">全削除</button>
          </div>
          <div class="tiny" style="color:var(--muted)">💡 日付をクリックすると、その日の授業一覧が右に表示されます。</div>
        </div>

        <div class="ol-layout">
          <div class="card ol-main">
            <div class="ol-timeline-toolbar">
              <div class="row" style="gap:6px;align-items:center;flex-wrap:wrap">
                <button class="btn ghost small" id="olPrevRange">◀</button>
                <button class="btn ghost small" id="olNextRange">▶</button>
                <button class="btn ghost small" id="olToday">今日</button>
                <select id="olFilter" class="input" style="min-width:120px">
                  <option value="all">すべて</option>
                  <option value="active">未完のみ</option>
                  <option value="done">完了のみ</option>
                </select>
              </div>
              <div class="ol-timeline-range">
                <span class="tiny" style="color:var(--muted)">表示期間</span>
                <input id="olViewStart" type="date" class="input">
                <span class="tiny" style="color:var(--muted)">〜</span>
                <input id="olViewEnd" type="date" class="input">
                <button class="btn ghost small" id="olViewSync">範囲と同期</button>
              </div>
            </div>
            <div id="olHorizontalView" class="sc-horizontal-view ol-horizontal">
              <div id="olTimeline" class="sc-h-timeline"></div>
            </div>
          </div>

          <div class="ol-side">
            <div class="card">
              <div class="row space" style="align-items:center;gap:8px;flex-wrap:wrap">
                <h3 style="margin:0" id="olDayTitle">--</h3>
                <span class="tiny" id="olDayTotal" style="color:var(--muted)">--</span>
              </div>
              <div class="ol-day-copy" id="olDayCopy">
                <div class="row" style="gap:6px;align-items:center;flex-wrap:wrap">
                  <span class="tiny" style="color:var(--muted)">コピー先</span>
                  <input id="olCopyTarget" type="date" class="input">
                  <button class="btn ghost small" id="olCopyDay">この日の授業をコピー</button>
                  <button class="btn ghost small" id="olCopyTomorrow">明日へ</button>
                  <button class="btn ghost small" id="olCopyNextWeek">来週同曜日へ</button>
                </div>
                <div class="tiny" style="color:var(--muted);margin-top:4px">授業の「コピー」はこの日付へ複製します</div>
              </div>
              <div id="olDayList" class="ol-day-list"></div>
              <div id="olDayEmpty" class="ol-empty hidden">この日に授業はありません</div>
            </div>
            <div class="card ol-session-card" id="olSessionCard">
              <h3 style="margin:0 0 10px 0">🧠 授業モード</h3>
              <div id="olSessionStatus" class="ol-session-status">--</div>
              <div class="ol-progress">
                <div id="olSessionProgress" class="ol-progress-bar"></div>
              </div>
              <div id="olSessionMeta" class="ol-session-meta"></div>
              <div class="ol-session-actions">
                <button class="btn" id="olSessionStart">開始</button>
                <button class="btn ghost" id="olSessionFinish">完了</button>
                <button class="btn ghost small" id="olSessionExtend">+5分</button>
              </div>
              <div class="tiny" style="color:var(--muted);margin-top:8px">予定/タイマーとは別の専用モードで集中管理します。</div>
            </div>
          </div>
        </div>
      </div>


      <div class="tab-content" data-content="numberline">
        <div class="card">
          <h3 style="margin:0 0 12px 0">📏 数直線ビュー（プランナーと同期）</h3>
          <div class="row">
            <label>表示する時間数</label>
            <select id="nlRowCount">
              <option>1</option>
              <option selected>2</option>
              <option>3</option>
              <option>4</option>
              <option>5</option>
              <option>6</option>
              <option>7</option>
              <option>8</option>
              <option>9</option>
              <option>10</option>
              <option>11</option>
              <option>12</option>
              <option>13</option>
              <option>14</option>
              <option>15</option>
              <option>16</option>
              <option>17</option>
              <option>18</option>
              <option>19</option>
              <option>20</option>
              <option>21</option>
              <option>22</option>
              <option>23</option>
              <option>24</option>
              <option>25</option>
              <option>26</option>
              <option>27</option>
              <option>28</option>
              <option>29</option>
              <option>30</option>
            </select>
            <button id="nlSync" class="ghost">境界に同期（分・秒）</button> <button id="nlFullscreenBtn"
              class="ghost">全画面</button> <label class="tiny"
              style="margin-left:8px;display:inline-flex;gap:6px;align-items:center"><input type="checkbox"
                id="nlShowSeconds"> 残り秒まで表示</label>
            <div class="tiny">※ 先頭行は現在の時。以降は+1時間ずつ。</div>
          </div>
          <div class="row" id="nlDigitalControls" style="align-items:center; gap:6px; flex-wrap:wrap">
            <label style="margin-right:4px">時計表示</label>
            <div class="nl-digital-toggle">
              <button type="button" class="btn ghost" data-nl-digital-mode="off">OFF</button>
              <button type="button" class="btn ghost" data-nl-digital-mode="planner">プランナー時計</button>
              <button type="button" class="btn ghost" data-nl-digital-mode="mode1">切り替え1</button>
              <button type="button" class="btn ghost" data-nl-digital-mode="mode2">切り替え2</button>
            </div>
            <span class="tiny" style="color:var(--muted)">※配置を切り替えても予定は維持されます</span>
          </div>

          <div class="row">
            <input id="nlTitle" type="text" placeholder="予定タイトル" style="flex:1">
            <label>開始</label><input id="nlStart" type="time" step="60" style="width:120px">
            <label>終了</label><input id="nlEnd" type="time" step="60" style="width:120px">
            <label>色</label><input id="nlColor" type="color" value="#7dd3fc" style="width:54px">
            <button id="nlAdd">プランナーに追加</button>
            <button id="nlDirectToggle" class="ghost">直接モード:OFF</button>
            <span id="nlMsg" class="tiny" style="color:#ef4444"></span>
          </div>

          <div id="nlRows"></div>
          <div class="tiny" style="margin-top:12px">📋 予定一覧</div>
          <div id="nlList" class="list"></div>
          <div style="margin-top:8px">
            <div id="nlTimerHUD" class="hud-pill">--</div><span class="hud-note">（タップで一時停止／再開。0分以下はタップで終了）</span>
          </div>
        </div>
      </div>

      <div class="tab-content" data-content="study">
        <div class="card">
          <h3 style="margin:0 0 12px 0">📚 学習進捗管理</h3>
          <div class="row">
            <label>総ページ数</label>
            <input id="studyTotal" type="number" min="1" value="20" style="width:80px">
            <label>1ページあたり(分)</label>
            <input id="studyPerPage" type="number" min="1" value="5" style="width:80px">
            <button id="studyGenerateCount">📖 ページ数で生成</button>
            <button id="studyForceEnd" class="btn small danger">⛔ 強制終了</button>
          </div>
          <div class="row">
            <label>ページ範囲</label>
            <input id="studyPageFrom" type="number" min="1" placeholder="開始" style="width:80px">
            <span>〜</span>
            <input id="studyPageTo" type="number" min="1" placeholder="終了" style="width:80px">
            <button id="studyGenerateRange" class="ghost">📖 範囲から生成</button>
            <span class="tiny" style="color:var(--muted)">※範囲モードでは開始〜終了ページを含めた予定を生成</span>
          </div>
          <div class="study-panel">
            <div class="study-stat">
              <div class="study-stat-label">総ページ数</div>
              <div class="study-stat-value" id="statTotal">20</div>
            </div>
            <div class="study-stat">
              <div class="study-stat-label">残りページ数</div>
              <div class="study-stat-value" id="statRemain">20</div>
            </div>
            <div class="study-stat">
              <div class="study-stat-label">進捗率</div>
              <div class="study-stat-value" id="statProgress">0%</div>
            </div>
            <div class="study-stat">
              <div class="study-stat-label">推定残り時間</div>
              <div class="study-stat-value" id="statTime">100分</div>
            </div>
          </div>
          <div class="tiny" style="margin-top:12px">💡 ページをクリックして完了マーク</div>
        </div>
        <div class="card">
          <h3 style="margin:0 0 12px 0">📊 学習進捗(全ページ)</h3>
          <div id="studyLog" class="page-grid"></div>
        </div>
      </div>

      <div class="tab-content" data-content="todo">
        <div class="row" style="justify-content:flex-start;align-items:center;gap:6px;flex-wrap:wrap;margin-bottom:8px">
          <button class="btn ghost small" id="todoToggleForm">＋ 追加フォーム</button>
        </div>
        <div class="card todo-form todo-card collapsed" id="todoFormCard">
          <div class="row" style="justify-content:space-between;align-items:center;gap:8px;flex-wrap:wrap">
            <h3 style="margin:0">＋ ToDoを素早く追加</h3>
            <div class="row" style="gap:6px;align-items:center">
              <button class="btn ghost small" id="todoFormClose">閉じる</button>
            </div>
          </div>
          <div class="row" style="align-items:center;gap:8px;margin-top:6px">
            <input id="todoTitle" class="input" placeholder="やること / タスク名 (必須)" style="flex:1">
            <input id="todoRange" class="input" placeholder="ページ (例: 12-18 または空欄)" style="flex:1">
            <button class="btn ghost small" id="todoPageOverlayOpen" title="ページ表を開く">ページ表</button>
            <label>1ページ(分)</label><input id="todoPerPage" type="number" min="1" value="5" class="input"
              style="width:80px">
          </div>
          <div class="page-blocks" id="todoPageBlocks"></div>
          <div class="todo-quick">
            <span class="tiny" style="opacity:.8">期限クイック:</span>
            <button class="chip-btn" id="todoDueToday">今日</button>
            <button class="chip-btn" id="todoDueTomorrow">明日</button>
            <button class="chip-btn" id="todoDueWeekend">週末</button>
            <button class="chip-btn" id="todoDueClear">期限なし</button>
            <div class="row" style="gap:6px;align-items:center;">
              <input id="todoDue" type="date" class="input" style="max-width:150px">
              <input id="todoDueTime" type="time" class="input" style="max-width:110px">
            </div>
          </div>
          <div class="row" style="align-items:center;gap:8px;margin-top:4px">
            <label style="min-width:70px">本と紐付け</label>
            <input id="todoBookSearch" class="input" placeholder="タイトル/タグを検索" style="flex:1;min-width:160px">
            <select id="todoBookSelect" class="input" style="min-width:220px">
              <option value="">紐付けなし</option>
            </select>
            <button class="btn ghost small" id="todoBookReload">再読込</button>
          </div>
          <textarea id="todoNote" class="input" placeholder="詳細・メモ（任意）"
            style="margin-top:8px; min-height:56px"></textarea>
          <div class="row" style="justify-content:flex-end;gap:8px;margin-top:8px;flex-wrap:wrap">
            <span class="tiny" id="todoRangeCount" style="color:var(--muted)">0ページ</span>
            <button class="btn ghost small" id="todoResetBtn">クリア</button>
            <button class="btn" id="todoAddBtn">追加</button>
          </div>
        </div>
        <div class="card todo-card">
          <div class="row" style="justify-content:space-between;align-items:center;gap:8px;flex-wrap:wrap">
            <h3 style="margin:0">📋 ToDo一覧</h3>
          </div>
          <div class="todo-toolbar">
            <div class="todo-toolbar-grid">
              <select id="todoFilterStatus" class="input">
                <option value="all">すべて</option>
                <option value="active" selected>未完のみ</option>
                <option value="done">完了のみ</option>
                <option value="due">期限あり</option>
              </select>
              <select id="todoSort" class="input">
                <option value="due">期限が近い順</option>
                <option value="progress">進捗が少ない順</option>
                <option value="time">残り時間順</option>
                <option value="created">作成が新しい順</option>
                <option value="title">タイトル順</option>
              </select>
              <input id="todoSearch" class="input wide" placeholder="タスク/本で検索">
              <label class="row" style="gap:6px;align-items:center;font-size:12px;">
                <input type="checkbox" id="todoProblemOnly"> 問題表表示
              </label>
            </div>
            <div class="todo-toolbar-actions">
              <div class="todo-view-switch">
                <button class="btn ghost small" id="todoViewCards">カード</button>
                <button class="btn ghost small" id="todoViewTable">表</button>
              </div>
              <div class="row" style="gap:6px;flex-wrap:wrap;align-items:center;">
                <button class="btn ghost small" id="todoBulkPlan">未完を予定に追加</button>
                <button class="btn ghost small" id="todoArchiveToggle">📦 アーカイブ</button>
              </div>
            </div>
          </div>
          <div class="todo-summary" id="todoSummary">
            <span><strong>0</strong> 件</span>
            <span>残り <strong>0</strong> ページ</span>
            <span>推定 <strong>0</strong> 分</span>
          </div>
          <div class="tiny" style="color:var(--muted); margin-bottom:6px;">完了したToDoはアーカイブに移動します</div>
          <div id="todoList" class="todo-list"></div>
          <div id="todoArchive" class="todo-list hidden" style="margin-top:10px;"></div>
          <div id="todoTableWrap" style="display:none;overflow:auto;">
            <table class="todo-table">
              <thead>
                <tr>
                  <th>タスク</th>
                  <th>ページ</th>
                  <th>本</th>
                  <th>期限</th>
                  <th>残り時間</th>
                  <th>操作</th>
                </tr>
              </thead>
              <tbody id="todoTableBody"></tbody>
            </table>
          </div>
        </div>
      </div>

      <!-- 今日セッション専用タブ -->
      <div class="tab-content" data-content="today">
        <div class="card"
          style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border: 1px solid rgba(99, 102, 241, 0.3);">
          <div class="row"
            style="justify-content:space-between;align-items:center;margin-bottom:16px;flex-wrap:wrap;gap:12px">
            <div>
              <h2 style="margin:0;font-size:1.5em;display:flex;align-items:center;gap:8px">
                <span style="font-size:1.3em">📅</span> 今日のセッション
              </h2>
              <p id="todaySessionDate" style="margin:4px 0 0;opacity:.7;font-size:14px">--</p>
            </div>
            <div class="row" style="gap:8px">
              <button class="btn" id="todaySessionStartBtn"
                style="background:linear-gradient(135deg, #6366f1, #8b5cf6);font-weight:600">
                ▶ セッション開始
              </button>
              <button class="btn ghost small" id="todaySessionRefreshBtn">更新</button>
            </div>
          </div>

          <div class="home-stat-grid" style="margin-bottom:16px">
            <div class="home-stat-item" style="background:rgba(99, 102, 241, 0.15);border-radius:8px;padding:12px">
              <span class="home-stat-value" id="todaySessionRemainPages" style="color:#a5b4fc">0</span>
              <span class="home-stat-label" style="color:#9ca3af">残りページ</span>
            </div>
            <div class="home-stat-item" style="background:rgba(16, 185, 129, 0.15);border-radius:8px;padding:12px">
              <span class="home-stat-value" id="todaySessionCompletedPages" style="color:#6ee7b7">0</span>
              <span class="home-stat-label" style="color:#9ca3af">完了ページ</span>
            </div>
            <div class="home-stat-item" style="background:rgba(249, 115, 22, 0.15);border-radius:8px;padding:12px">
              <span class="home-stat-value" id="todaySessionEstTime" style="color:#fdba74">0</span>
              <span class="home-stat-label" style="color:#9ca3af">推定残り時間</span>
            </div>
          </div>

          <h3 style="margin:16px 0 8px;font-size:1em;color:#9ca3af">📋 今日のタスク一覧</h3>
          <div id="todaySessionTaskList" class="home-task-list" style="max-height:400px;overflow-y:auto"></div>

          <div id="todaySessionEmpty" class="home-empty" style="display:none;padding:32px;text-align:center">
            <div style="font-size:48px;margin-bottom:12px">🎉</div>
            <div style="font-size:16px;font-weight:600">今日の予定はすべて完了しました！</div>
            <div style="opacity:.7;margin-top:8px">またはまだ予定が配分されていません</div>
          </div>
        </div>

        <div class="card" style="margin-top:12px">
          <h3 style="margin:0 0 12px 0;font-size:1em">💡 使い方</h3>
          <ul style="margin:0;padding-left:20px;color:#9ca3af;font-size:13px;line-height:1.6">
            <li><strong>セッション開始</strong>をクリックすると、今日配分されたページを順番にこなせます</li>
            <li>タスクをクリックすると、そのタスクの本を直接開きます</li>
            <li>ページ完了はビューアの「完了」ボタンまたは時計画面から記録できます</li>
            <li>カレンダーで予定を配分すると、ここに表示されます</li>
          </ul>
        </div>
      </div>

      <div class="tab-content" data-content="sound">
        <div class="card">
          <div class="row" style="justify-content:space-between;align-items:center;">
            <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
              <button class="btn" id="soundEnableBtn">▶️ サウンド有効化</button>
              <button class="btn ghost" id="soundTestAllBtn">全テスト</button>
              <button class="btn ghost" id="soundStopAllBtn">全停止</button>
            </div>
            <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
              <button class="btn" id="soundExportBtn">エクスポート</button>
              <label class="btn"><input id="soundImportInput" type="file" accept="application/json"
                  style="display:none">インポート</label>
            </div>
          </div>
          <div class="tiny">※ ブラウザの制限により、最初に「サウンド有効化」を押してください。以降、自動再生が可能になります。</div>
        </div>
        <div class="card vibe-card">
          <h3 style="margin:0 0 10px 0;font-size:16px;opacity:.85">🎮 コントローラー振動</h3>
          <div class="row vibe-row">
            <button class="btn ghost" id="vibeEnableBtn">🎮 振動: OFF</button>
            <label class="tiny">対象</label>
            <select id="vibeTarget" class="vibe-target"></select>
            <label class="tiny">全体強さ</label>
            <input type="range" id="vibeGlobalStrength" min="0" max="1" step="0.05" value="0.8" style="width:140px">
            <span class="tiny" id="vibeGlobalValue">80%</span>
            <label class="tiny">テスト</label>
            <select id="vibeTestPattern" class="vibe-pattern"></select>
            <button class="btn small" id="vibeTestBtn">テスト</button>
          </div>
          <div class="tiny vibe-status" id="vibeStatus">コントローラー未接続</div>
          <div class="tiny" style="opacity:.7">※ 振動対応のコントローラーとブラウザが必要です。初回は「テスト」などの操作が必要な場合があります。</div>
        </div>
        <div class="card">
          <h3 style="margin:0 0 10px 0;font-size:16px;opacity:.85">イベント別サウンド設定</h3>
          <div id="soundRoot"></div>
        </div>
        <div class="card">
          <h3 style="margin:0 0 10px 0;font-size:16px;opacity:.85">BGM / 環境音（任意）</h3>
          <div class="row" id="bgmRow">
            <input type="file" id="bgmFile" accept="audio/*">
            <label style="font-size:12px;opacity:.8">音量</label>
            <input type="range" id="bgmVol" min="0" max="1" step="0.01" value="0.3" style="width:140px">
            <label style="font-size:12px;opacity:.8">ループ</label>
            <input type="checkbox" id="bgmLoop" checked>
            <button class="btn" id="bgmPlay">再生</button>
            <button class="btn ghost" id="bgmStop">停止</button>
          </div>
        </div>
      </div>

    </main>

    <div class="ol-edit-overlay hidden" id="olEditOverlay">
      <div class="ol-edit-modal card">
        <div class="row space" style="align-items:center;gap:8px;flex-wrap:wrap;">
          <h3 style="margin:0">🎓 授業を編集</h3>
          <button class="btn ghost small" id="olEditClose">閉じる</button>
        </div>
        <div class="ol-edit-grid">
          <div>
            <label class="tiny" style="display:block;opacity:.8">授業名</label>
            <input id="olEditTitle" class="input" placeholder="授業名">
          </div>
          <div>
            <label class="tiny" style="display:block;opacity:.8">日付</label>
            <input id="olEditDate" type="date" class="input">
          </div>
          <div>
            <label class="tiny" style="display:block;opacity:.8">開始</label>
            <input id="olEditStart" type="time" class="input" step="60">
          </div>
          <div>
            <label class="tiny" style="display:block;opacity:.8">終了</label>
            <input id="olEditEnd" type="time" class="input" step="60">
          </div>
          <div>
            <label class="tiny" style="display:block;opacity:.8">時間(分)</label>
            <input id="olEditDuration" type="number" class="input" min="5" max="600">
          </div>
          <div>
            <label class="tiny" style="display:block;opacity:.8">色</label>
            <input id="olEditColor" type="color" value="#60a5fa"
              style="width:72px;height:34px;border:none;background:transparent">
          </div>
        </div>
        <div class="ol-edit-quick">
          <button type="button" class="chip-btn" data-edit-shift="-5" data-edit-target="start">開始 -5分</button>
          <button type="button" class="chip-btn" data-edit-shift="5" data-edit-target="start">開始 +5分</button>
          <button type="button" class="chip-btn" data-edit-shift="-5" data-edit-target="end">終了 -5分</button>
          <button type="button" class="chip-btn" data-edit-shift="5" data-edit-target="end">終了 +5分</button>
          <button type="button" class="chip-btn" data-edit-day="-1">前日へ</button>
          <button type="button" class="chip-btn" data-edit-day="1">翌日へ</button>
          <button type="button" class="chip-btn" id="olEditDuplicate">複製</button>
        </div>
        <label class="row" style="gap:6px;align-items:center;font-size:12px;margin-top:8px;">
          <input type="checkbox" id="olEditApplySeries"> 系列(同グループ)にも反映
        </label>
        <div class="ol-edit-actions">
          <button class="btn ghost small danger" id="olEditDelete">削除</button>
          <button class="btn ghost small" id="olEditCancel">キャンセル</button>
          <button class="btn" id="olEditSave">保存</button>
        </div>
      </div>
    </div>

    <script>
      // Planner integration helpers (style toggle & tab activation)
      (function () {
        const plannerRoot = document.getElementById('plannerApp');
        const headStyles = [...document.querySelectorAll('style[data-planner-style]')];
        const inlineStyles = plannerRoot ? [...plannerRoot.querySelectorAll('style')] : [];
        inlineStyles.forEach(s => { s.setAttribute('data-planner-style', '1'); s.media = 'not all'; });
        const PLANNER_TAB_KEY = 'planner-active-tab';
        let plannerLastTab = (() => { try { return localStorage.getItem(PLANNER_TAB_KEY) || 'planner'; } catch (e) { return 'planner'; } })();
        const setPlannerStylesEnabled = (on = true) => {
          [...headStyles, ...inlineStyles].forEach(node => {
            if (!node) return;
            try { node.media = on ? 'all' : 'all'; } catch (e) { }
          });
        };
        const scrollPlannerTop = () => {
          try {
            plannerRoot?.scrollTo?.({ top: 0 });
            plannerRoot?.querySelector('main')?.scrollTo?.({ top: 0, behavior: 'smooth' });
            window.scrollTo({ top: 0 });
          } catch (_) { }
        };
        function setPlannerTheme(theme) {
          const t = theme || (plannerRoot?.querySelector('#theme')?.value) || 'theme-minimal';
          if (plannerRoot) { plannerRoot.dataset.theme = t; plannerRoot.className = plannerRoot.className.replace(/\btheme-[^\\s]+/g, '').trim(); plannerRoot.classList.add(t); }
        }
        function resetPlannerBody() { }
        function persistPlannerTab(id) {
          if (!id) return;
          plannerLastTab = id;
          try { localStorage.setItem(PLANNER_TAB_KEY, id); } catch (e) { }
        }
        function activatePlannerTab(id) {
          if (!plannerRoot) return;
          const target = plannerRoot.querySelector(`.tab[data-tab=\"${id || plannerLastTab}\"]`);
          if (target) { target.click(); }
          persistPlannerTab(id || plannerLastTab);
        }
        plannerRoot?.addEventListener('click', (e) => {
          const tab = e.target.closest('.tab');
          if (tab?.dataset.tab) { persistPlannerTab(tab.dataset.tab); scrollPlannerTop(); }
        });
        setPlannerStylesEnabled(true);
        window.__plannerStyles = { enable: () => setPlannerStylesEnabled(true), disable: () => setPlannerStylesEnabled(true) };
        window.__setPlannerTheme = setPlannerTheme;
        window.__resetPlannerBody = resetPlannerBody;
        window.__activatePlannerTab = activatePlannerTab;
        window.__plannerLastTab = () => plannerLastTab;
      })();
    </script>

    <script>
      (() => {
        // ================================
        // Numberline-first Data Store
        // ================================
        // 単一の真実 (Single Source of Truth) : NLStore.events (絶対時刻ベース)
        // {id, title, start:number(ms since epoch), end:number(ms), color, kind?}
        const LS_KEY = "nl_events_v1";
        const $ = (id) => document.getElementById(id);
        const plannerRoot = document.getElementById('plannerApp');
        const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
        const NL_DIGITAL_MODE_KEY = 'nl_digital_mode';
        let nlDigitalState = { mode: 'off', displays: [] };
        let nlPlannerMirrorHost = null;
        let nlPlannerMirrorHands = null;
        let nlPlannerMirrorSnapshotRev = 0;
        let nlPlannerMirrorDirty = true;
        let nlLastHour = null;
        let nlRenderDirty = true;
        let nlLastRenderKey = null;
        let nlFastUpdate = false;
        const markNlDirty = () => { nlRenderDirty = true; };
        const plannerCalendarNotify = (reason) => {
          try { window.PlannerCalendar?.refresh?.(reason); } catch (_) { }
          try { window.dispatchEvent(new CustomEvent('planner:nl-updated', { detail: { reason } })); } catch (_) { }
        };

        // ================================
        // IndexedDB Helper for NLStore
        // ================================
        const NLDB = {
          dbName: 'NLStoreDB',
          storeName: 'events',
          version: 1,
          db: null,
          async open() {
            if (this.db) return this.db;
            return new Promise((resolve, reject) => {
              const req = indexedDB.open(this.dbName, this.version);
              req.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains(this.storeName)) {
                  db.createObjectStore(this.storeName, { keyPath: 'id' });
                }
              };
              req.onsuccess = (e) => {
                this.db = e.target.result;
                // Handle version change (when another tab upgrades DB)
                this.db.onversionchange = () => {
                  console.warn('[NLDB] Database version changed, closing connection');
                  this.db.close();
                  this.db = null;
                };
                // Handle unexpected close
                this.db.onclose = () => {
                  console.warn('[NLDB] Database connection closed unexpectedly');
                  this.db = null;
                };
                resolve(this.db);
              };
              req.onerror = () => reject(req.error);
              req.onblocked = () => {
                console.warn('[NLDB] Database open blocked, another connection may be holding it open');
              };
            });
          },
          async loadAll() {
            const db = await this.open();
            return new Promise((resolve, reject) => {
              const tx = db.transaction(this.storeName, 'readonly');
              const store = tx.objectStore(this.storeName);
              const req = store.getAll();
              req.onsuccess = () => resolve(req.result || []);
              req.onerror = () => reject(req.error);
            });
          },
          async saveAll(events) {
            const db = await this.open();
            return new Promise((resolve, reject) => {
              const tx = db.transaction(this.storeName, 'readwrite');
              const store = tx.objectStore(this.storeName);
              // Safer approach: delete only what's not in new events, then put all
              // First get all existing IDs
              const getAllReq = store.getAllKeys();
              getAllReq.onsuccess = () => {
                const existingIds = new Set(getAllReq.result || []);
                const newIds = new Set(events.map(e => e.id));
                // Delete items that are no longer in the list
                existingIds.forEach(id => {
                  if (!newIds.has(id)) {
                    store.delete(id);
                  }
                });
                // Put all current events
                events.forEach(ev => store.put(ev));
              };
              getAllReq.onerror = () => {
                // Fallback: just put all events
                events.forEach(ev => store.put(ev));
              };
              tx.oncomplete = () => resolve();
              tx.onerror = () => reject(tx.error);
            });
          },
          async clear() {
            const db = await this.open();
            return new Promise((resolve, reject) => {
              const tx = db.transaction(this.storeName, 'readwrite');
              const store = tx.objectStore(this.storeName);
              const req = store.clear();
              req.onsuccess = () => resolve();
              req.onerror = () => reject(req.error);
            });
          }
        };

        const NLStore = {
          events: [],
          __rev: 0,
          _saveQueued: false,
          _initialized: false,
          bumpRev() { this.__rev = Date.now(); window.__nlRev = this.__rev; markNlDirty(); },
          compact(aggressive = false) {
            const now = Date.now();
            const cutoff = aggressive ? (now - 7 * 86400000) : (now - 45 * 86400000);
            const beforeCount = this.events.length;

            this.events = this.events.filter(ev => {
              if (!ev || !Number.isFinite(ev.end)) return false;
              if (ev.kind && /bookmark|memo/i.test(ev.kind)) {
                return ev.end >= (now - 180 * 86400000);
              }
              if (ev.todoId) {
                return ev.end >= cutoff;
              }
              return ev.end >= cutoff;
            });

            const maxEvents = aggressive ? 200 : 1000;
            if (this.events.length > maxEvents) {
              this.events.sort((a, b) => b.start - a.start);
              this.events = this.events.slice(0, maxEvents);
              this.events.sort((a, b) => a.start - b.start);
            }

            console.log(`[NLStore.compact] ${aggressive ? 'AGGRESSIVE' : 'normal'}: ${beforeCount} -> ${this.events.length} events`);
          },
          load() {
            // Synchronous load from localStorage for backwards compatibility
            try {
              const raw = localStorage.getItem(LS_KEY);
              this.events = raw ? JSON.parse(raw) : [];
            } catch (e) {
              this.events = [];
            }
            this._normalizeEvents();
            this.bumpRev();

            // Async: also load from IndexedDB and merge
            this._loadFromIDB();
          },
          async _loadFromIDB() {
            try {
              const idbEvents = await NLDB.loadAll();
              if (idbEvents.length > 0 && !this._initialized) {
                // Only merge on initial load, not when already running
                // Merge: prefer IndexedDB data if newer
                const existingIds = new Set(this.events.map(e => e.id));
                idbEvents.forEach(ev => {
                  if (!existingIds.has(ev.id)) {
                    this.events.push(ev);
                  }
                });
                this.events.sort((a, b) => a.start - b.start);
                this.bumpRev();
              }
              // Migrate localStorage data to IndexedDB
              if (this.events.length > 0 && !this._initialized) {
                await NLDB.saveAll(this.events);
                // Clear localStorage to free up space
                try { localStorage.removeItem(LS_KEY); } catch (_) { }
                console.log('[NLStore] Migrated to IndexedDB, cleared localStorage');
              }
              this._initialized = true;
              try { if (typeof StudyUI !== 'undefined' && StudyUI && typeof StudyUI.update === 'function') StudyUI.update(); } catch (_) { }
              try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (_) { }
            } catch (e) {
              console.warn('[NLStore] IndexedDB load failed, using localStorage:', e);
              this._initialized = true;
              try { if (typeof StudyUI !== 'undefined' && StudyUI && typeof StudyUI.update === 'function') StudyUI.update(); } catch (_) { }
              try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (_) { }
            }
          },
          _normalizeEvents() {
            this.events = this.events.map(ev => {
              const start = Number(ev.start) || 0, end = Number(ev.end) || 0;
              const pageNumber = Number.isFinite(ev.pageNumber) ? parseInt(ev.pageNumber, 10) : null;
              return Object.assign({}, ev, {
                id: ev.id || (Date.now() + Math.random()),
                title: (ev.title || "予定").trim(),
                start: Math.max(0, start),
                end: Math.max(Math.max(0, start + 60 * 1000), end),
                color: ev.color || "#4da3ff",
                kind: ev.kind || "normal",
                pageNumber,
                pageKey: ev.pageKey || null,
                todoId: ev.todoId || null
              });
            }).sort((a, b) => a.start - b.start);
          },
          save() {
            this.compact();
            // Queue async save to IndexedDB
            if (!this._saveQueued) {
              this._saveQueued = true;
              setTimeout(() => this._saveAsync(), 100);
            }
            this.bumpRev();
            if (typeof window.__invalidateScheduleCache === 'function') {
              try { window.__invalidateScheduleCache(); } catch (_) { }
            }
            plannerCalendarNotify('nl-save');
          },
          async _saveAsync() {
            this._saveQueued = false;
            try {
              await NLDB.saveAll(this.events);
              console.log('[NLStore] Saved to IndexedDB:', this.events.length, 'events');
            } catch (e) {
              console.error('[NLStore] IndexedDB save failed, falling back to localStorage:', e);
              // Fallback to localStorage
              try {
                this.compact(true);
                localStorage.setItem(LS_KEY, JSON.stringify(this.events));
              } catch (lsErr) {
                console.error('[NLStore] localStorage fallback also failed:', lsErr);
              }
            }
          },
          // Synchronous flush for beforeunload - saves to localStorage immediately
          flushSync() {
            if (this._saveQueued) {
              this._saveQueued = false;
              this.compact(true);
              try {
                localStorage.setItem(LS_KEY, JSON.stringify(this.events));
                console.log('[NLStore] flushSync: Saved', this.events.length, 'events to localStorage');
              } catch (e) {
                console.error('[NLStore] flushSync failed:', e);
              }
            }
          },
          clear() {
            this.events = [];
            NLDB.clear().catch(() => { });
            try { localStorage.removeItem(LS_KEY); } catch (_) { }
            this.bumpRev();
          },
          addAbs(startDate, endDate, title, color, kind) {
            const s = (startDate instanceof Date) ? startDate.getTime() : Number(startDate);
            const e = (endDate instanceof Date) ? endDate.getTime() : Number(endDate);
            if (!isFinite(s) || !isFinite(e)) return null;
            const ev = {
              id: Date.now() + Math.random(),
              title: (title || "予定").trim() || "予定",
              start: Math.min(s, e),
              end: Math.max(s, e),
              color: color || "#4da3ff",
              kind: kind || "normal"
            };
            this.events.push(ev);
            this.events.sort((a, b) => a.start - b.start);
            this.save();
            return ev;
          },
          removeById(id) {
            this.events = this.events.filter(ev => ev.id !== id);
            this.save();
          },
          listBetween(winStart, winEnd) {
            return this.events.filter(ev => ev.end > winStart && ev.start < winEnd);
          }
        };
        NLStore.load();
        // 他スクリプトからも参照できるように公開
        window.NLStore = NLStore;
        // NLStore のIndexedDB読み込みが終わっていないかを簡易判定
        const isNLStoreLoading = () => {
          try {
            return !!(window.NLStore && !NLStore._initialized && (!Array.isArray(NLStore.events) || NLStore.events.length === 0));
          } catch (_) { return false; }
        };

        // 外部から開始できる簡易API: StudyStart(ids)
        window.StudyStart = function (ids) {
          StudyMgr.active = true; StudyMgr.pageIds = ids.slice(); StudyMgr.save(); StudyUI.update(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
          try { scheduleStudyWatchdog(); } catch (e) { }
          if (window.updateOverallStudyUI) updateOverallStudyUI(); setCompleteBtnText(); drawPlanner(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
          try { scheduleStudyWatchdog(); } catch (e) { }

          StudyUI.update(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
          try { scheduleStudyWatchdog(); } catch (e) { }
          setCompleteBtnText(); nlRebuildAll(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
          try { scheduleStudyWatchdog(); } catch (e) { }
        }; if (window.updateOverallStudyUI) updateOverallStudyUI(); if (window.__startOverallTicker) window.__startOverallTicker();


        // ============== 時刻ヘルパ ==============
        function now() { return (window.__getNow ? window.__getNow() : (window.__getNow ? window.__getNow() : new Date())); }
        function pad2(n) { return (n < 10 ? "0" : "") + n; }
        function toHM(d) { return pad2(d.getHours()) + ":" + pad2(d.getMinutes()); }
        function formatDuration(ms) {
          ms = Math.max(0, ms | 0);
          const totalSec = Math.floor(ms / 1000);
          const mm = Math.floor(totalSec / 60);
          const ss = totalSec % 60;
          return `${mm}:${String(ss).padStart(2, '0')}`;
        }
        let clockPulseMs = null;
        function setClockPulseDate(src) {
          if (src == null) return;
          const ms = src instanceof Date ? src.getTime() : Number(src);
          if (!Number.isFinite(ms)) return;
          clockPulseMs = ms;
          window.__clockPulseMs = ms;
          window.__clockPulseDate = new Date(ms);
        }
        function getClockPulseDate() {
          if (clockPulseMs == null) return null;
          return new Date(clockPulseMs);
        }
        function getSyncedNow(opts) {
          const preferPulse = !!(opts && opts.preferPulse);
          if (preferPulse) {
            const pulse = getClockPulseDate();
            if (pulse) return pulse;
          }
          return now();
        }
        window.__setClockPulseDate = setClockPulseDate;
        window.__getClockPulseDate = getClockPulseDate;
        window.__getSyncedNow = getSyncedNow;

        // ============== 既存UIへの最小限バインド ==============
        // 1) プランナー: 円形時計 (hour/day) を NLStore から描画
        // 2) 数直線: NLStore を直接描画（基盤）
        // 3) 追加ボタン類は NLStore へ追加 → 双方向同期不要

        // DOM
        const svg = document.getElementById('clock');
        const plannerClockWrap = document.querySelector('.clock-wrap');
        const ticks = document.getElementById('ticks');
        const numbers = document.getElementById('numbers');
        const arcs = document.getElementById('arcs');
        const outerArcs1 = document.getElementById('outerArcs1');
        const outerArcs2 = document.getElementById('outerArcs2');
        const timerArcs = document.getElementById('timerArcs');
        const hHand = document.getElementById('hHand');
        const mHand = document.getElementById('mHand');
        const sHand = document.getElementById('sHand');
        const PLANNER_OPACITY_KEY = 'planner_bar_opacity';
        const PLANNER_HEIGHT_KEY = 'planner_bar_height';
        const PLANNER_GUIDE_KEY = 'planner_bar_guide';
        function loadPlannerOpacity() {
          try {
            const v = parseFloat(localStorage.getItem(PLANNER_OPACITY_KEY));
            if (isFinite(v)) return Math.max(0.2, Math.min(1, v));
          } catch (e) { }
          return 0.9;
        }
        function savePlannerOpacity(v) {
          try { localStorage.setItem(PLANNER_OPACITY_KEY, String(v)); } catch (e) { }
        }
        function loadPlannerThickness() {
          try {
            const v = parseFloat(localStorage.getItem(PLANNER_HEIGHT_KEY));
            if (isFinite(v)) return Math.max(8, Math.min(80, v));
          } catch (e) { }
          return 24;
        }
        function savePlannerThickness(v) {
          try { localStorage.setItem(PLANNER_HEIGHT_KEY, String(v)); } catch (e) { }
        }
        function loadPlannerGuideStyle() {
          try { return localStorage.getItem(PLANNER_GUIDE_KEY) === 'guide'; } catch (e) { }
          return false;
        }
        function savePlannerGuideStyle(flag) {
          try { localStorage.setItem(PLANNER_GUIDE_KEY, flag ? 'guide' : 'standard'); } catch (e) { }
        }
        const plannerBarStyle = {
          opacity: loadPlannerOpacity(),
          thickness: loadPlannerThickness(),
          guideLook: loadPlannerGuideStyle()
        };

        // 軽量なユーティリティ(SVG)
        function mk(tag) { return document.createElementNS('http://www.w3.org/2000/svg', tag); }
        function pol(r, a) { return { x: 250 + r * Math.cos(a), y: 250 + r * Math.sin(a) }; }
        function rot(el, deg) { if (el) el.setAttribute('transform', `rotate(${deg} 250 250)`); }
        function updatePlannerHandRotation(date, motionValue) {
          if (!date) return;
          const mode = motionValue || (($('motion') && $('motion').value) || 'smooth');
          const smooth = mode === 'smooth';
          const secBase = date.getSeconds();
          const sec = smooth ? (secBase + date.getMilliseconds() / 1000) : secBase;
          const minBase = date.getMinutes();
          const min = smooth ? (minBase + sec / 60) : minBase;
          const hourBase = date.getHours() % 12;
          const hour = smooth ? (hourBase + min / 60) : (hourBase + minBase / 60);
          rot(sHand, sec * 6);
          rot(mHand, min * 6);
          rot(hHand, hour * 30);
        }
        window.__updatePlannerHandRotation = updatePlannerHandRotation;

        function minToAng(min, total) {
          return (min % total) / total * 2 * Math.PI - Math.PI / 2;
        }
        function arcPath(r, a1, a2, strokeWidth = 24) {
          while (a2 < a1) a2 += 2 * Math.PI;
          const large = (a2 - a1) > Math.PI ? 1 : 0;
          const p1 = pol(r, a1), p2 = pol(r, a2);
          return `M ${p1.x} ${p1.y} A ${r} ${r} 0 ${large} 1 ${p2.x} ${p2.y}`;
        }


        // === Planner control bindings & defaults ===
        (function () {
          const KEY = 'planner_prefs_v1';
          function loadPrefs() {
            try { return JSON.parse(localStorage.getItem(KEY) || '{}'); } catch (e) { return {}; }
          }
          function savePrefs(p) { try { localStorage.setItem(KEY, JSON.stringify(p)); } catch (e) { } }
          const els = {
            mode: document.getElementById('mode'),
            motion: document.getElementById('motion'),
            shape: document.getElementById('shape'),
            style: document.getElementById('style'),
            clockDesign: document.getElementById('clockDesign')
          };
          const PROFILE_KEY = 'study-profiles';
          const loadProfiles = () => {
            try { return JSON.parse(localStorage.getItem(PROFILE_KEY) || '{}'); } catch (_) { return {}; }
          };
          const saveProfiles = (obj) => { try { localStorage.setItem(PROFILE_KEY, JSON.stringify(obj || {})); } catch (_) { } };
          const pref = loadPrefs();
          // Apply defaults if not saved
          if (!pref.mode) pref.mode = 'hour';
          if (!pref.motion) pref.motion = 'tick';
          if (!pref.shape) pref.shape = 'bar';
          // Sync UI
          if (els.mode) els.mode.value = pref.mode;
          if (els.motion) els.motion.value = pref.motion;
          if (els.shape) els.shape.value = pref.shape;
          if (els.style && pref.style) els.style.value = pref.style;
          if (els.clockDesign && pref.clockDesign) els.clockDesign.value = pref.clockDesign;
          // Bind changes
          Object.entries(els).forEach(([k, el]) => {
            if (!el) return;
            el.addEventListener('change', () => {
              const p = loadPrefs();
              p[k] = el.value;
              savePrefs(p);
              drawPlanner(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
              try { scheduleStudyWatchdog(); } catch (e) { }

            });
          });
          // initial draw (ensures new defaults take effect)
          drawPlanner(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
          try { scheduleStudyWatchdog(); } catch (e) { }

        })();

        // ============== プランナー描画（NLStore → 相対化） ==============

        // ===== 時計デザイン適用 =====
        function applyClockDesign(design) {
          const root = document.documentElement.style;
          const set = (k, v) => root.setProperty(k, v);
          const theme = design || 'classic';
          if (theme === 'classic') {
            set('--face', '#0b1724'); set('--ring', '#2b4a6a');
            set('--tickMajor', '#9fb5c9'); set('--tickMinor', '#6183a3'); set('--muted', '#b7c7d6');
            set('--handH', '#e0e6ed'); set('--handM', '#9cc3ff'); set('--handS', '#ff6b6b');
          } else if (theme === 'minimal') {
            set('--face', '#101013'); set('--ring', '#282828');
            set('--tickMajor', '#cccccc'); set('--tickMinor', '#4a4a4a'); set('--muted', '#bdbdbd');
            set('--handH', '#eaeaea'); set('--handM', '#eaeaea'); set('--handS', '#eaeaea');
          } else if (theme === 'neon') {
            set('--face', '#05060a'); set('--ring', '#0f172a');
            set('--tickMajor', '#61dafb'); set('--tickMinor', '#22d3ee'); set('--muted', '#a5f3fc');
            set('--handH', '#22d3ee'); set('--handM', '#a78bfa'); set('--handS', '#f472b6');
          } else if (theme === 'frost') {
            set('--face', 'rgba(255,255,255,0.06)'); set('--ring', 'rgba(255,255,255,0.25)');
            set('--tickMajor', 'rgba(255,255,255,0.85)'); set('--tickMinor', 'rgba(255,255,255,0.45)'); set('--muted', 'rgba(255,255,255,0.9)');
            set('--handH', 'rgba(255,255,255,0.95)'); set('--handM', 'rgba(255,255,255,0.95)'); set('--handS', 'rgba(255,255,255,0.95)');
          } else if (theme === 'blueprint') {
            set('--face', '#081a33'); set('--ring', '#93c5fd');
            set('--tickMajor', '#bfdbfe'); set('--tickMinor', '#60a5fa'); set('--muted', '#e0f2fe');
            set('--handH', '#e0f2fe'); set('--handM', '#93c5fd'); set('--handS', '#60a5fa');
          } else if (theme === 'highcontrast') {
            set('--face', '#000'); set('--ring', '#fff');
            set('--tickMajor', '#fff'); set('--tickMinor', '#aaa'); set('--muted', '#fff');
            set('--handH', '#fff'); set('--handM', '#fff'); set('--handS', '#ff3b3b');
          }
          // Optional: add class to SVG
          const svg = document.getElementById('clock');
          if (svg) { svg.setAttribute('data-design', theme); }
        }
        function drawPlanner() {
          const mode = $('mode') ? $('mode').value : 'day';
          const cd = $('clockDesign') ? $('clockDesign').value : 'classic';
          applyClockDesign(cd);
          // 'hour' or 'day'
          // 目盛り
          ticks.innerHTML = ''; numbers.innerHTML = '';
          for (let i = 0; i <= 60; i++) {
            const a = i / 60 * 2 * Math.PI - Math.PI / 2;
            const r1 = i % 5 === 0 ? 205 : 220;
            const r2 = i % 5 === 0 ? 232 : 236;
            const l = mk('line');
            l.setAttribute('x1', pol(r1, a).x); l.setAttribute('y1', pol(r1, a).y);
            l.setAttribute('x2', pol(r2, a).x); l.setAttribute('y2', pol(r2, a).y);
            l.setAttribute('stroke', getComputedStyle(document.documentElement).getPropertyValue(i % 5 === 0 ? '--tickMajor' : '--tickMinor').trim());
            l.setAttribute('stroke-width', i % 5 === 0 ? 2 : 1);
            ticks.appendChild(l);
          }
          if (mode === 'day') {
            for (let i = 1; i <= 12; i++) {
              const a = i / 12 * 2 * Math.PI - Math.PI / 2;
              const p = pol(185, a);
              const t = mk('text');
              t.setAttribute('x', p.x); t.setAttribute('y', p.y);
              t.setAttribute('fill', getComputedStyle(document.documentElement).getPropertyValue('--muted').trim());
              t.setAttribute('font-size', '20'); t.setAttribute('font-weight', '700');
              t.setAttribute('text-anchor', 'middle'); t.setAttribute('dominant-baseline', 'middle');
              t.textContent = i;
              numbers.appendChild(t);
            }
          } else { for (let i = 1; i <= 12; i++) { const a = i / 12 * 2 * Math.PI - Math.PI / 2; const p = pol(185, a); const t = mk('text'); t.setAttribute('x', p.x); t.setAttribute('y', p.y); t.setAttribute('fill', getComputedStyle(document.documentElement).getPropertyValue('--muted').trim()); t.setAttribute('font-size', '20'); t.setAttribute('font-weight', '700'); t.setAttribute('text-anchor', 'middle'); t.setAttribute('dominant-baseline', 'middle'); t.textContent = i; numbers.appendChild(t); } }
          // 針
          const motion = ($('motion') ? $('motion').value : 'smooth');
          const nowD = now();
          updatePlannerHandRotation(nowD, motion);
          hHand.style.opacity = (mode === 'day') ? 1 : 0.2;

          // イベント描画 (絶対→相対)
          arcs.innerHTML = ''; outerArcs1.innerHTML = ''; outerArcs2.innerHTML = '';
          const nowMs = nowD.getTime();
          let winStart, winEnd, totalMin;
          if (mode === 'hour') {
            const base = new Date(nowD); base.setMinutes(0, 0, 0);
            winStart = base.getTime();
            winEnd = winStart + 60 * 60000;
            totalMin = 60;
          } else { // day(12h)
            const half = (nowD.getHours() >= 12 ? 12 : 0);
            const base = new Date(nowD.getFullYear(), nowD.getMonth(), nowD.getDate(), half, 0, 0, 0);
            winStart = base.getTime();
            winEnd = winStart + 12 * 60 * 60000;
            totalMin = 720;
          }

          const defsEl = svg.querySelector('defs');
          const styleSel = $('style') ? $('style').value : 'solid';
          const shapeSel = $('shape') ? $('shape').value : 'arc';
          const guideLook = !!plannerBarStyle.guideLook;
          const thickness = Math.max(8, Math.min(80, plannerBarStyle.thickness || 24));
          const baseRadius = 200;
          const barOuterRadius = baseRadius + thickness / 2;
          const barInnerRadius = Math.max(40, baseRadius - thickness / 2);
          const wedgeOuterRadius = baseRadius + thickness * 0.75;
          const wedgeInnerRadius = Math.max(0, wedgeOuterRadius - Math.max(40, thickness * 1.2));
          const triangleHalfWidth = Math.max(16, thickness * 0.6);
          const triangleLength = 150 + (thickness - 24) * 1.1;

          function hexToRgb(hex) { hex = (hex || '#4da3ff').replace('#', ''); return { r: parseInt(hex.substr(0, 2), 16), g: parseInt(hex.substr(2, 2), 16), b: parseInt(hex.substr(4, 2), 16) }; }
          function rgba({ r, g, b }, a) { return `rgba(${r},${g},${b},${a})`; }
          function shade({ r, g, b }, k) { const f = (v) => Math.round(Math.max(0, Math.min(50000, v * (1 + k)))); return { r: f(r), g: f(g), b: f(b) }; }
          function ensureLinearGrad(id, stops) {
            let g = defsEl.querySelector('#' + id);
            if (!g) {
              g = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
              g.setAttribute('id', id);
              g.setAttribute('x1', '0%'); g.setAttribute('y1', '0%');
              g.setAttribute('x2', '0%'); g.setAttribute('y2', '100%');
              defsEl.appendChild(g);
            }
            while (g.firstChild) g.removeChild(g.firstChild);
            stops.forEach(([off, col, op]) => {
              const s = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
              s.setAttribute('offset', off);
              s.setAttribute('stop-color', col);
              if (op != null) s.setAttribute('stop-opacity', op);
              g.appendChild(s);
            });
            return `url(#${id})`;
          }
          function sectorPath(cx, cy, rOuter, rInner, a1, a2) {
            while (a2 < a1) a2 += Math.PI * 2;
            const large = (a2 - a1) > Math.PI ? 1 : 0;
            const p1o = { x: cx + rOuter * Math.cos(a1), y: cy + rOuter * Math.sin(a1) };
            const p2o = { x: cx + rOuter * Math.cos(a2), y: cy + rOuter * Math.sin(a2) };
            const p1i = { x: cx + rInner * Math.cos(a2), y: cy + rInner * Math.sin(a2) };
            const p2i = { x: cx + rInner * Math.cos(a1), y: cy + rInner * Math.sin(a1) };
            if (rInner <= 0) {
              return `M ${cx} ${cy} L ${p1o.x} ${p1o.y} A ${rOuter} ${rOuter} 0 ${large} 1 ${p2o.x} ${p2o.y} Z`;
            } else {
              return `M ${p1o.x} ${p1o.y} A ${rOuter} ${rOuter} 0 ${large} 1 ${p2o.x} ${p2o.y} L ${p1i.x} ${p1i.y} A ${rInner} ${rInner} 0 ${large} 0 ${p2i.x} ${p2i.y} Z`;
            }
          }
          function drawStyledArc(g, a1, a2, color) {
            const rgb = hexToRgb(color || '#4da3ff');
            const baseOpacity = Math.max(0.2, Math.min(1, plannerBarStyle.opacity || 0.95));
            const baseCol = rgba(rgb, baseOpacity);
            const guideFillAlpha = Math.min(0.65, Math.max(0.15, baseOpacity * 0.8));
            const guideFill = `rgba(${rgb.r},${rgb.g},${rgb.b},${guideFillAlpha})`;
            const guideEdgeCol = `rgba(${shade(rgb, 0.15).r},${shade(rgb, 0.15).g},${shade(rgb, 0.15).b},0.9)`;
            const dashWidth = Math.max(1.5, Math.min(6, thickness * 0.18));
            const guideDash = '12 7';
            if (shapeSel === 'arc') {
              if (guideLook) {
                const track = mk('path');
                track.setAttribute('d', arcPath(baseRadius, a1, a2, thickness));
                track.setAttribute('fill', 'none');
                track.setAttribute('stroke', guideFill);
                track.setAttribute('stroke-width', thickness);
                track.setAttribute('stroke-linecap', 'round');
                track.setAttribute('filter', 'url(#shadow)');
                const dash = mk('path');
                dash.setAttribute('d', arcPath(baseRadius, a1, a2, thickness + 3));
                dash.setAttribute('fill', 'none');
                dash.setAttribute('stroke', guideEdgeCol);
                dash.setAttribute('stroke-width', Math.max(2, Math.min(8, thickness * 0.35)));
                dash.setAttribute('stroke-linecap', 'round');
                dash.setAttribute('stroke-linejoin', 'round');
                dash.setAttribute('stroke-dasharray', guideDash);
                const inner = mk('path');
                inner.setAttribute('d', arcPath(baseRadius, a1, a2, Math.max(2, thickness * 0.45)));
                inner.setAttribute('fill', 'none');
                inner.setAttribute('stroke', 'rgba(255,255,255,0.35)');
                inner.setAttribute('stroke-linecap', 'round');
                inner.setAttribute('stroke-width', Math.max(1, thickness * 0.25));
                g.appendChild(track);
                g.appendChild(dash);
                g.appendChild(inner);
                return;
              }
              const base = mk('path');
              base.setAttribute('d', arcPath(baseRadius, a1, a2, thickness));
              base.setAttribute('fill', 'none');
              base.setAttribute('stroke-linecap', 'round');
              if (styleSel === 'gradient') {
                const gId = 'grad-' + Math.random().toString(36).slice(2);
                const c1 = `rgba(${shade(rgb, 0.25).r},${shade(rgb, 0.25).g},${shade(rgb, 0.25).b},1)`;
                const c2 = baseCol;
                base.setAttribute('stroke', ensureLinearGrad(gId, [['0%', c1, 1], ['100%', c2, 1]]));
              } else if (styleSel === 'rainbow') {
                const gId = 'rainbow-' + Math.random().toString(36).slice(2);
                ensureLinearGrad(gId, [
                  ['0%', '#ff6b6b', 1], ['20%', '#ffd43b', 1], ['40%', '#51cf66', 1],
                  ['60%', '#4dabf7', 1], ['80%', '#845ef7', 1], ['100%', '#f783ac', 1]
                ]);
                base.setAttribute('stroke', `url(#${gId})`);
              } else {
                base.setAttribute('stroke', baseCol);
              }
              base.setAttribute('stroke-width', thickness);
              const outHi = mk('path'); outHi.setAttribute('d', arcPath(baseRadius, a1, a2, thickness + 3)); outHi.setAttribute('fill', 'none'); outHi.setAttribute('stroke', 'rgba(255,255,255,0.22)'); outHi.setAttribute('stroke-linecap', 'round'); outHi.setAttribute('stroke-width', 3);
              const outLo = mk('path'); outLo.setAttribute('d', arcPath(baseRadius, a1, a2, Math.max(2, thickness - 2))); outLo.setAttribute('fill', 'none'); outLo.setAttribute('stroke', 'rgba(0,0,0,0.18)'); outLo.setAttribute('stroke-linecap', 'round'); outLo.setAttribute('stroke-width', 2);
              g.appendChild(outHi);
              g.appendChild(base);
              g.appendChild(outLo);

              if (styleSel === 'glass') {
                const hl = mk('path');
                hl.setAttribute('d', arcPath(baseRadius, a1, a2, Math.max(8, thickness * 0.52)));
                hl.setAttribute('fill', 'none');
                hl.setAttribute('stroke', 'url(#glassGrad)');
                hl.setAttribute('stroke-opacity', '0.9');
                hl.setAttribute('stroke-linecap', 'round');
                hl.setAttribute('stroke-width', Math.max(8, thickness * 0.52));
                g.appendChild(hl);
                const edge = mk('path');
                edge.setAttribute('d', arcPath(baseRadius, a1, a2, thickness + 2));
                edge.setAttribute('fill', 'none');
                edge.setAttribute('stroke', `rgba(${shade(rgb, -0.5).r},${shade(rgb, -0.5).g},${shade(rgb, -0.5).b},0.25)`);
                edge.setAttribute('stroke-linecap', 'round');
                edge.setAttribute('stroke-width', 2);
                g.appendChild(edge);
              }
              if (styleSel === 'metal') {
                const top = mk('path');
                top.setAttribute('d', arcPath(baseRadius, a1, a2, thickness * 0.55));
                top.setAttribute('fill', 'none');
                top.setAttribute('stroke', `rgba(${shade(rgb, 0.35).r},${shade(rgb, 0.35).g},${shade(rgb, 0.35).b},0.9)`);
                top.setAttribute('stroke-linecap', 'round');
                top.setAttribute('stroke-width', thickness * 0.55);
                g.appendChild(top);
                const bot = mk('path');
                bot.setAttribute('d', arcPath(baseRadius, a1, a2, thickness));
                bot.setAttribute('fill', 'none');
                bot.setAttribute('stroke', `rgba(${shade(rgb, -0.25).r},${shade(rgb, -0.25).g},${shade(rgb, -0.25).b},0.9)`);
                bot.setAttribute('stroke-linecap', 'round');
                bot.setAttribute('stroke-width', 2);
                g.appendChild(bot);
              }
              if (styleSel === 'glow') { g.setAttribute('filter', 'url(#glow)'); }
            } else if (shapeSel === 'wedge') {
              const pathD = sectorPath(250, 250, wedgeOuterRadius, guideLook ? wedgeInnerRadius : 0, a1, a2);
              if (guideLook) {
                const fill = mk('path');
                fill.setAttribute('d', pathD);
                fill.setAttribute('fill', guideFill);
                fill.setAttribute('filter', 'url(#shadow)');
                const edge = mk('path');
                edge.setAttribute('d', pathD);
                edge.setAttribute('fill', 'none');
                edge.setAttribute('stroke', guideEdgeCol);
                edge.setAttribute('stroke-width', dashWidth);
                edge.setAttribute('stroke-dasharray', guideDash);
                edge.setAttribute('stroke-linecap', 'round');
                arcs.appendChild(fill);
                arcs.appendChild(edge);
                return;
              }
              const p = mk('path');
              p.setAttribute('d', pathD);
              p.setAttribute('fill', baseCol);
              if (styleSel === 'glass') {
                const gId = 'wglass-' + Math.random().toString(36).slice(2);
                p.setAttribute('fill', ensureLinearGrad(gId, [['0%', 'rgba(255,255,255,0.7)', 1], ['20%', 'rgba(255,255,255,0.35)', 1], ['100%', baseCol, 1]]));
                p.setAttribute('stroke', `rgba(${shade(rgb, -0.4).r},${shade(rgb, -0.4).g},${shade(rgb, -0.4).b},0.3)`);
                p.setAttribute('stroke-width', '1.5');
              } else if (styleSel === 'gradient') {
                const gId = 'wgrad-' + Math.random().toString(36).slice(2);
                const c1 = `rgba(${shade(rgb, 0.25).r},${shade(rgb, 0.25).g},${shade(rgb, 0.25).b},1)`;
                const c2 = baseCol;
                p.setAttribute('fill', ensureLinearGrad(gId, [['0%', c1, 1], ['100%', c2, 1]]));
              } else if (styleSel === 'rainbow') {
                const gId = 'wrain-' + Math.random().toString(36).slice(2);
                p.setAttribute('fill', ensureLinearGrad(gId, [
                  ['0%', '#ff6b6b', 1], ['20%', '#ffd43b', 1], ['40%', '#51cf66', 1],
                  ['60%', '#4dabf7', 1], ['80%', '#845ef7', 1], ['100%', '#f783ac', 1]
                ]));
              } else if (styleSel === 'metal') {
                const gId = 'wmetal-' + Math.random().toString(36).slice(2);
                p.setAttribute('fill', ensureLinearGrad(gId, [
                  ['0%', 'rgba(255,255,255,0.25)', 1], ['20%', baseCol, 1],
                  ['80%', `rgba(${shade(rgb, -0.25).r},${shade(rgb, -0.25).g},${shade(rgb, -0.25).b},0.95)`, 1], ['100%', 'rgba(255,255,255,0.2)', 1]
                ]));
              }
              arcs.appendChild(p);
              if (styleSel === 'glow') { p.setAttribute('filter', 'url(#glow)'); }
            } else if (shapeSel === 'bar') {
              const pathD = sectorPath(250, 250, barOuterRadius, barInnerRadius, a1, a2);
              if (guideLook) {
                const fill = mk('path');
                fill.setAttribute('d', pathD);
                fill.setAttribute('fill', guideFill);
                fill.setAttribute('filter', 'url(#shadow)');
                const edge = mk('path');
                edge.setAttribute('d', pathD);
                edge.setAttribute('fill', 'none');
                edge.setAttribute('stroke', guideEdgeCol);
                edge.setAttribute('stroke-width', dashWidth);
                edge.setAttribute('stroke-dasharray', guideDash);
                edge.setAttribute('stroke-linecap', 'round');
                const inner = mk('path');
                inner.setAttribute('d', pathD);
                inner.setAttribute('fill', 'none');
                inner.setAttribute('stroke', 'rgba(255,255,255,0.25)');
                inner.setAttribute('stroke-width', 1);
                arcs.appendChild(fill);
                arcs.appendChild(edge);
                arcs.appendChild(inner);
                return;
              }
              const p = mk('path');
              p.setAttribute('d', pathD);
              p.setAttribute('fill', baseCol);
              if (styleSel === 'glass') {
                const gId = 'bglass-' + Math.random().toString(36).slice(2);
                p.setAttribute('fill', ensureLinearGrad(gId, [['0%', 'rgba(255,255,255,0.7)', 1], ['20%', 'rgba(255,255,255,0.35)', 1], ['100%', baseCol, 1]]));
                p.setAttribute('stroke', `rgba(${shade(rgb, -0.4).r},${shade(rgb, -0.4).g},${shade(rgb, -0.4).b},0.35)`);
                p.setAttribute('stroke-width', '1.5');
              } else if (styleSel === 'gradient') {
                const gId = 'bgrad-' + Math.random().toString(36).slice(2);
                const c1 = `rgba(${shade(rgb, 0.25).r},${shade(rgb, 0.25).g},${shade(rgb, 0.25).b},1)`;
                const c2 = baseCol;
                p.setAttribute('fill', ensureLinearGrad(gId, [['0%', c1, 1], ['100%', c2, 1]]));
              } else if (styleSel === 'rainbow') {
                const gId = 'brain-' + Math.random().toString(36).slice(2);
                p.setAttribute('fill', ensureLinearGrad(gId, [
                  ['0%', '#ff6b6b', 1], ['20%', '#ffd43b', 1], ['40%', '#51cf66', 1],
                  ['60%', '#4dabf7', 1], ['80%', '#845ef7', 1], ['100%', '#f783ac', 1]
                ]));
              } else if (styleSel === 'metal') {
                const gId = 'bmetal-' + Math.random().toString(36).slice(2);
                p.setAttribute('fill', ensureLinearGrad(gId, [
                  ['0%', 'rgba(255,255,255,0.25)', 1], ['20%', baseCol, 1],
                  ['80%', `rgba(${shade(rgb, -0.25).r},${shade(rgb, -0.25).g},${shade(rgb, -0.25).b},0.95)`, 1], ['100%', 'rgba(255,255,255,0.2)', 1]
                ]));
              }
              arcs.appendChild(p);
              if (styleSel === 'glow') { p.setAttribute('filter', 'url(#glow)'); }
            } else if (shapeSel === 'triangle') {
              const mid = (a1 + a2) / 2;
              const len = triangleLength;
              const base = triangleHalfWidth;
              const tip = { x: 250 + len * Math.cos(mid), y: 250 + len * Math.sin(mid) };
              const left = { x: 250 + base * Math.cos(mid + Math.PI / 2), y: 250 + base * Math.sin(mid + Math.PI / 2) };
              const right = { x: 250 + base * Math.cos(mid - Math.PI / 2), y: 250 + base * Math.sin(mid - Math.PI / 2) };
              const points = `${left.x},${left.y} ${right.x},${right.y} ${tip.x},${tip.y}`;
              if (guideLook) {
                const poly = mk('polygon');
                poly.setAttribute('points', points);
                poly.setAttribute('fill', guideFill);
                poly.setAttribute('filter', 'url(#shadow)');
                const edge = mk('polygon');
                edge.setAttribute('points', points);
                edge.setAttribute('fill', 'none');
                edge.setAttribute('stroke', guideEdgeCol);
                edge.setAttribute('stroke-width', dashWidth);
                edge.setAttribute('stroke-dasharray', guideDash);
                arcs.appendChild(poly);
                arcs.appendChild(edge);
                return;
              }
              const poly = mk('polygon');
              poly.setAttribute('points', points);
              poly.setAttribute('fill', baseCol);
              if (styleSel === 'glass') {
                const gId = 'tglass-' + Math.random().toString(36).slice(2);
                poly.setAttribute('fill', ensureLinearGrad(gId, [['0%', 'rgba(255,255,255,0.8)', 1], ['100%', baseCol, 1]]));
                poly.setAttribute('stroke', `rgba(${shade(rgb, -0.35).r},${shade(rgb, -0.35).g},${shade(rgb, -0.35).b},0.35)`);
                poly.setAttribute('stroke-width', '1.2');
              }
              if (styleSel === 'glow') { poly.setAttribute('filter', 'url(#glow)'); }
              arcs.appendChild(poly);
            }
          }

          const list = NLStore.listBetween(winStart, winEnd);
          list.forEach(ev => {
            if (isBreakEvent(ev) && Number.isFinite(ev.end) && ev.end <= nowMs) return;
            const sMs = Math.max(ev.start, winStart);
            const eMs = Math.min(ev.end, winEnd);
            if (eMs <= sMs) return;
            const relS = (sMs - winStart) / 60000;
            const relE = (eMs - winStart) / 60000;
            const a1 = minToAng(relS, totalMin);
            const a2 = minToAng(relE, totalMin);
            const gArc = mk('g');
            drawStyledArc(gArc, a1, a2, ev.color || '#4da3ff');
            arcs.appendChild(gArc);
          });
          if (outerArcs2) {
            outerArcs2.innerHTML = '';
            let gaugeInfo = null;
            try {
              if (window.OriginalLesson && typeof OriginalLesson.getGaugeInfo === 'function') {
                gaugeInfo = OriginalLesson.getGaugeInfo(nowMs);
              }
            } catch (_) { }
            if (gaugeInfo && gaugeInfo.ratio > 0) {
              const radius = 244;
              const thicknessOuter = Math.max(6, Math.min(14, (plannerBarStyle.thickness || 24) * 0.4));
              const { r, g, b } = hexToRgb(gaugeInfo.color || '#60a5fa');
              const track = mk('circle');
              track.setAttribute('cx', '250');
              track.setAttribute('cy', '250');
              track.setAttribute('r', radius);
              track.setAttribute('fill', 'none');
              track.setAttribute('stroke', `rgba(${r},${g},${b},0.16)`);
              track.setAttribute('stroke-width', thicknessOuter);
              outerArcs2.appendChild(track);
              const circ = 2 * Math.PI * radius;
              const gauge = mk('circle');
              gauge.setAttribute('cx', '250');
              gauge.setAttribute('cy', '250');
              gauge.setAttribute('r', radius);
              gauge.setAttribute('fill', 'none');
              gauge.setAttribute('stroke', `rgba(${r},${g},${b},0.9)`);
              gauge.setAttribute('stroke-width', thicknessOuter);
              gauge.setAttribute('stroke-linecap', 'round');
              gauge.setAttribute('stroke-dasharray', circ);
              gauge.setAttribute('stroke-dashoffset', circ * (1 - gaugeInfo.ratio));
              gauge.setAttribute('transform', 'rotate(-90 250 250)');
              outerArcs2.appendChild(gauge);
            }
          }
          nlPlannerMirrorDirty = true;
        }

        // ============== 数直線描画（基盤） ==============

        // ===== Tick (メモリ) style settings =====
        const nlTickStyle = {
          minorLen: 28, minorThick: 1, minorColor: '#9fb5c9',
          majorLen: 40, majorThick: 3, majorColor: '#285078',
          glow: 6, shadow: 6, shape: 'line'
        };
        function setTickStyleFromUI() {
          const g = id => document.getElementById(id);
          const mLen = g('tickMinorLen'), mTh = g('tickMinorThick'), mCol = g('tickMinorColor');
          const MLen = g('tickMajorLen'), MTh = g('tickMajorThick'), MCol = g('tickMajorColor');
          const gl = g('tickGlow'), sh = g('tickShadow'), shp = g('tickShape');
          if (mLen) { nlTickStyle.minorLen = parseInt(mLen.value) || 28; const v = g('tickMinorLenVal'); if (v) v.textContent = nlTickStyle.minorLen + '%'; }
          if (mTh) { nlTickStyle.minorThick = parseInt(mTh.value) || 1; const v = g('tickMinorThickVal'); if (v) v.textContent = nlTickStyle.minorThick + 'px'; }
          if (mCol) { nlTickStyle.minorColor = mCol.value || '#9fb5c9'; }
          if (MLen) { nlTickStyle.majorLen = parseInt(MLen.value) || 40; const v = g('tickMajorLenVal'); if (v) v.textContent = nlTickStyle.majorLen + '%'; }
          if (MTh) { nlTickStyle.majorThick = parseInt(MTh.value) || 3; const v = g('tickMajorThickVal'); if (v) v.textContent = nlTickStyle.majorThick + 'px'; }
          if (MCol) { nlTickStyle.majorColor = MCol.value || '#285078'; }
          if (gl) { nlTickStyle.glow = parseInt(gl.value) || 0; const v = g('tickGlowVal'); if (v) v.textContent = nlTickStyle.glow; }
          if (sh) { nlTickStyle.shadow = parseInt(sh.value) || 0; const v = g('tickShadowVal'); if (v) v.textContent = nlTickStyle.shadow; }
          if (shp) { nlTickStyle.shape = shp.value; }
        }
        function applyTickStyleToRow(row) {
          const laneBounds = row.querySelector('.nl-lane')?.getBoundingClientRect();
          const laneHeight = laneBounds ? laneBounds.height : 100;
          const pxToPercent = laneHeight ? (100 / laneHeight) : 0;
          const ticksWrap = row.querySelector('.nl-ticks');
          if (!ticksWrap) return;
          // minor
          ticksWrap.querySelectorAll('.nl-tick').forEach(el => {
            const isMajor = el.classList.contains('major');
            const len = (isMajor ? nlTickStyle.majorLen : nlTickStyle.minorLen);
            const thick = (isMajor ? nlTickStyle.majorThick : nlTickStyle.minorThick);
            const color = (isMajor ? nlTickStyle.majorColor : nlTickStyle.minorColor);
            // baseline around center: make top so that it crosses center line and extends upward
            const center = 50;
            const top = center - (len * 0.55); // slightly more above to keep readable when bars are below
            el.style.top = top + '%';
            el.style.height = len + '%';
            el.style.width = thick + 'px';
            el.style.background = color;
            // effects
            const glow = nlTickStyle.glow;
            const shadow = nlTickStyle.shadow;
            const glowCol = color + (color.length === 7 ? '80' : '');
            el.style.filter = `drop-shadow(0 0 ${glow}px ${color})`;
            el.style.boxShadow = shadow > 0 ? `0 1px ${shadow}px rgba(0,0,0,0.35)` : 'none';
            // shape
            el.style.borderRadius = '0';
            el.style.transform = 'translateX(-50%)';
            el.style.clipPath = 'none';
            if (nlTickStyle.shape === 'rounded') {
              el.style.borderRadius = (thick / 2) + 'px';
            } else if (nlTickStyle.shape === 'diamond') {
              // make it a square rotated 45deg; set width=height in px domain via CSS variable
              el.style.height = (thick * 2) + 'px';
              el.style.width = (thick * 2) + 'px';
              el.style.top = (center - (thick * 2) * pxToPercent / 2) + '%';
              el.style.background = color;
              el.style.transform = 'translateX(-50%) rotate(45deg)';
            } else if (nlTickStyle.shape === 'dot') {
              const size = Math.max(4, thick * 3);
              el.style.height = size + 'px';
              el.style.width = size + 'px';
              el.style.top = (center - size * pxToPercent / 2) + '%';
              el.style.borderRadius = '999px';
            }
          });
        }
        function applyTickStyleAll() {
          document.querySelectorAll('.nl-row').forEach(row => applyTickStyleToRow(row));
        }

        // バー見た目設定（グローバル）
        const nlBarStyle = { opacity: 0.8, theme: 'gradient', shape: 'rect', height: 30, guide: false };
        function setBarStyleFromUI() {
          const o = document.getElementById('nlOpacity');
          const t = document.getElementById('nlTheme');
          const s = document.getElementById('nlShape');
          const h = document.getElementById('nlBarHeight');
          const g = document.getElementById('nlGaugeStyle');
          if (o) { nlBarStyle.opacity = Math.max(0.2, Math.min(1, parseFloat(o.value) || 0.8)); const v = document.getElementById('nlOpacityVal'); if (v) v.textContent = nlBarStyle.opacity.toFixed(2); }
          if (t) { nlBarStyle.theme = t.value; }
          if (s) { nlBarStyle.shape = s.value; }
          if (h) {
            const hv = Math.max(12, Math.min(120, parseFloat(h.value) || nlBarStyle.height || 30));
            nlBarStyle.height = hv;
            const hvLabel = document.getElementById('nlHeightVal');
            if (hvLabel) hvLabel.textContent = Math.round(hv) + 'px';
          }
          if (g) { nlBarStyle.guide = (g.value === 'guide'); }
          markNlDirty();
        }
        function hexToRgb(hex) { hex = (hex || '#7dd3fc').replace('#', ''); return { r: parseInt(hex.substr(0, 2), 16), g: parseInt(hex.substr(2, 2), 16), b: parseInt(hex.substr(4, 2), 16) }; }
        function applyBarStyle(el, color) {
          const { r, g, b } = hexToRgb(color || '#7dd3fc');
          const a = Math.max(0.2, Math.min(1, nlBarStyle.opacity || 0.8));
          const base = `rgba(${r},${g},${b},${a})`;
          const light = `rgba(255,255,255,${Math.min(0.65, a * 0.8)})`;
          const dark = `rgba(0,0,0,${Math.min(0.35, (1 - a) * 0.8 + 0.15)})`;
          const heightPx = Math.max(12, Math.min(120, nlBarStyle.height || 30));
          el.style.backdropFilter = '';
          el.style.border = 'none';
          el.style.boxShadow = 'none';
          el.style.background = base;
          el.style.outline = 'none';
          el.style.filter = 'none';
          el.style.color = '#0b1020';
          el.style.textShadow = 'none';
          el.style.height = heightPx + 'px';
          el.style.lineHeight = heightPx + 'px';
          el.style.top = '50%';
          el.style.transform = 'translateY(-50%)';
          if (nlBarStyle.guide) {
            const fillA = Math.min(0.65, Math.max(0.2, a * 0.9));
            el.style.background = `linear-gradient(90deg, rgba(${r},${g},${b},${fillA * 0.6}) 0%, rgba(${r},${g},${b},${fillA}) 100%)`;
            el.style.border = `1.6px dashed rgba(${r},${g},${b},0.85)`;
            el.style.boxShadow = '0 12px 24px rgba(0,0,0,0.35), inset 0 0 0 1px rgba(255,255,255,0.18)';
            el.style.backdropFilter = 'saturate(130%)';
            el.style.borderRadius = Math.max(12, heightPx / 2) + 'px';
            el.style.color = '#f8fbff';
            el.style.textShadow = '0 1px 2px rgba(0,0,0,0.35)';
            return;
          }
          switch (nlBarStyle.theme) {
            case 'glass':
              el.style.background = `linear-gradient(180deg, ${light} 0%, rgba(255,255,255,0.35) 15%, ${base} 55%, rgba(0,0,0,0.18) 100%)`;
              el.style.backdropFilter = 'saturate(140%) blur(6px)';
              el.style.border = '1px solid rgba(255,255,255,0.4)';
              el.style.boxShadow = 'inset 0 1px 2px rgba(255,255,255,0.8), inset 0 -1px 2px rgba(0,0,0,0.15), 0 4px 10px rgba(0,0,0,0.25)';
              break;
            case 'metal':
              el.style.background = `linear-gradient(90deg, rgba(255,255,255,${Math.min(0.20, a)}) 0%, ${base} 12%, rgba(0,0,0,${Math.min(0.18, 1 - a)}) 50%, ${base} 88%, rgba(255,255,255,${Math.min(0.20, a)}) 100%)`;
              el.style.boxShadow = 'inset 0 1px 0 rgba(255,255,255,0.3), inset 0 -1px 0 rgba(0,0,0,0.25), 0 2px 8px rgba(0,0,0,0.25)';
              el.style.border = '1px solid rgba(255,255,255,0.25)';
              break;
            case 'gradient':
              {
                const gradStart = `rgba(${r},${g},${b},${Math.min(1, a + 0.1)})`;
                const gradEnd = `rgba(${r},${g},${b},${Math.max(0.25, a - 0.12)})`;
                const outline = `rgba(${Math.min(255, r + 40)},${Math.min(255, g + 40)},${Math.min(255, b + 40)},${Math.min(0.9, a + 0.35)})`;
                el.style.background = `linear-gradient(90deg, ${gradStart} 0%, ${gradEnd} 100%)`;
                el.style.border = `1px solid ${outline}`;
                el.style.boxShadow = '0 6px 16px rgba(0,0,0,0.28), inset 0 1px 0 rgba(255,255,255,0.22), inset 0 0 0 1px rgba(255,255,255,0.12)';
              }
              break;
            case 'neon':
              el.style.background = base;
              el.style.boxShadow = `0 0 12px rgba(${r},${g},${b},${Math.min(0.9, a)}), 0 0 24px rgba(${r},${g},${b},${Math.min(0.6, a)})`;
              el.style.color = '#0f172a';
              break;
            case 'outline':
              el.style.background = 'transparent';
              el.style.border = `2px solid ${base}`;
              break;
            case 'solid':
            default:
              el.style.background = base;
              el.style.boxShadow = '0 2px 6px rgba(0,0,0,0.15)';
              break;
          }
          switch (nlBarStyle.shape) {
            case 'rect':
              el.style.borderRadius = '4px';
              break;
            case 'underline':
              el.style.borderRadius = '3px';
              el.style.height = '8px';
              el.style.lineHeight = '8px';
              el.style.top = '60%';
              break;
            case 'bevel':
              el.style.borderRadius = '10px 4px 10px 4px';
              break;
            case 'pill':
            default:
              el.style.borderRadius = Math.max(8, heightPx / 2) + 'px';
              break;
          }
        }
        function nlLoadDigitalMode() {
          try {
            const val = localStorage.getItem(NL_DIGITAL_MODE_KEY) || 'off';
            return (val === 'mode1' || val === 'mode2' || val === 'planner' || val === 'off') ? val : 'off';
          } catch (e) { return 'off'; }
        }
        function nlSaveDigitalMode(v) { try { localStorage.setItem(NL_DIGITAL_MODE_KEY, v); } catch (e) { } }
        nlDigitalState.mode = nlLoadDigitalMode();
        function nlApplyDigitalModeButtons() {
          document.querySelectorAll('[data-nl-digital-mode]').forEach(btn => {
            btn.classList.toggle('active', (btn.dataset.nlDigitalMode || 'off') === nlDigitalState.mode);
          });
        }
        function nlSetDigitalMode(mode) {
          const next = mode || 'off';
          if (nlDigitalState.mode === next) {
            nlApplyDigitalModeButtons();
            return;
          }
          nlDigitalState.mode = next;
          nlSaveDigitalMode(next);
          nlApplyDigitalModeButtons();
          markNlDirty();
          try { nlRebuildAll(true); } catch (_) { }
        }
        function nlRegisterDigitalDisplay(entry) {
          nlDigitalState.displays.push(entry);
        }
        function nlCreateDigitalBlock(mode) {
          const wrap = document.createElement('div');
          wrap.className = mode === 'mode1' ? 'nl-digital-row' : 'nl-digital-inline';
          const face = document.createElement('div');
          face.className = 'nl-digital-face';
          const time = document.createElement('span'); time.className = 'nl-digital-time'; time.textContent = '--:--';
          const sec = document.createElement('span'); sec.className = 'nl-digital-sec'; sec.textContent = '--';
          face.appendChild(time); face.appendChild(sec);
          wrap.appendChild(face);
          nlRegisterDigitalDisplay({ time, sec });
          nlUpdateDigitalDisplays(Date.now());
          return wrap;
        }
        function nlMirrorPlannerClock(nowD, forceRebuild = false) {
          if (!nlPlannerMirrorHost) {
            nlStopPlannerClockMirror();
            return;
          }
          if (!nlPlannerMirrorHost.isConnected) {
            return;
          }
          if (!plannerClockWrap) return;
          const rev = NLStore?.__rev || window.__nlRev || 0;
          const needRebuild = forceRebuild || nlPlannerMirrorDirty || !nlPlannerMirrorHands || nlPlannerMirrorSnapshotRev !== rev || !nlPlannerMirrorHost.firstChild;
          if (needRebuild) {
            const clone = plannerClockWrap.cloneNode(true);
            clone.classList.add('nl-planner-clock-clone');
            const hint = clone.querySelector('#hint');
            if (hint && hint.parentNode) hint.remove();
            nlPlannerMirrorHost.innerHTML = '';
            nlPlannerMirrorHost.appendChild(clone);
            nlPlannerMirrorHands = {
              h: clone.querySelector('#hHand'),
              m: clone.querySelector('#mHand'),
              s: clone.querySelector('#sHand')
            };
            nlPlannerMirrorSnapshotRev = rev;
            nlPlannerMirrorDirty = false;
          }
          const target = nowD || (window.__getNow ? window.__getNow() : new Date());
          const motionVal = (document.getElementById('motion')?.value) || 'smooth';
          const smooth = motionVal === 'smooth';
          const secBase = target.getSeconds();
          const sec = smooth ? (secBase + target.getMilliseconds() / 1000) : secBase;
          const minBase = target.getMinutes();
          const min = smooth ? (minBase + sec / 60) : minBase;
          const hourBase = target.getHours() % 12;
          const hour = smooth ? (hourBase + min / 60) : (hourBase + minBase / 60);
          const rot = (el, deg) => { if (el) el.setAttribute('transform', `rotate(${deg} 250 250)`); };
          rot(nlPlannerMirrorHands?.s, sec * 6);
          rot(nlPlannerMirrorHands?.m, min * 6);
          rot(nlPlannerMirrorHands?.h, hour * 30);
        }
        function nlStopPlannerClockMirror() {
          if (nlPlannerMirrorHost) {
            nlPlannerMirrorHost.innerHTML = '';
            nlPlannerMirrorHost = null;
            nlPlannerMirrorHands = null;
            nlPlannerMirrorSnapshotRev = 0;
          }
        }
        function nlStartPlannerClockMirror(host) {
          nlStopPlannerClockMirror();
          if (!host) return;
          nlPlannerMirrorHost = host;
          nlPlannerMirrorDirty = true;
          nlMirrorPlannerClock(new Date(), true);
        }
        function nlCreatePlannerClockBlock() {
          const wrap = document.createElement('div');
          wrap.className = 'nl-planner-clock-wrap';
          const host = document.createElement('div');
          host.className = 'nl-planner-clock-host';
          wrap.appendChild(host);
          nlStartPlannerClockMirror(host);
          return wrap;
        }
        function nlUpdateDigitalDisplays(nowMs) {
          const d = new Date(nowMs || Date.now());
          const hh = pad2(d.getHours());
          const mm = pad2(d.getMinutes());
          const ss = pad2(d.getSeconds());
          nlDigitalState.displays.forEach(entry => {
            if (entry.time) entry.time.textContent = `${hh}:${mm}`;
            if (entry.sec) entry.sec.textContent = ss;
          });
        }
        function bindNLDigitalControls() {
          const buttons = document.querySelectorAll('[data-nl-digital-mode]');
          if (!buttons.length) return;
          buttons.forEach(btn => {
            btn.addEventListener('click', () => {
              nlSetDigitalMode(btn.dataset.nlDigitalMode || 'off');
            });
          });
          nlApplyDigitalModeButtons();
        }
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', bindNLDigitalControls);
        } else {
          bindNLDigitalControls();
        }
        if (nlDigitalState.mode && nlDigitalState.mode !== 'off') {
          setTimeout(() => { try { nlRebuildAll(); } catch (_) { }; }, 0);
        }
        function initPlannerOpacityControl() {
          const slider = document.getElementById('plannerOpacity');
          const val = document.getElementById('plannerOpacityVal');
          if (!slider) return;
          const setVal = (v) => {
            const clamped = Math.max(0.2, Math.min(1, v || plannerBarStyle.opacity || 0.9));
            plannerBarStyle.opacity = clamped;
            if (val) val.textContent = clamped.toFixed(2);
            savePlannerOpacity(clamped);
            drawPlanner();
          };
          slider.value = String(plannerBarStyle.opacity);
          if (val) val.textContent = Number(plannerBarStyle.opacity).toFixed(2);
          slider.addEventListener('input', () => { setVal(parseFloat(slider.value) || plannerBarStyle.opacity); });
        }
        function initPlannerHeightControl() {
          const slider = document.getElementById('plannerHeight');
          const val = document.getElementById('plannerHeightVal');
          if (!slider) return;
          const clamp = (v) => Math.max(8, Math.min(80, isFinite(v) ? v : (plannerBarStyle.thickness || 24)));
          const setVal = (raw) => {
            const clamped = clamp(raw);
            plannerBarStyle.thickness = clamped;
            if (val) val.textContent = Math.round(clamped) + 'px';
            savePlannerThickness(clamped);
            drawPlanner();
          };
          const initVal = clamp(plannerBarStyle.thickness);
          slider.value = String(initVal);
          if (val) val.textContent = Math.round(initVal) + 'px';
          slider.addEventListener('input', () => { setVal(parseFloat(slider.value)); });
        }
        function initPlannerGaugeStyleControl() {
          const select = document.getElementById('plannerGaugeStyle');
          if (!select) return;
          const apply = (value) => {
            const isGuide = value === 'guide';
            plannerBarStyle.guideLook = isGuide;
            savePlannerGuideStyle(isGuide);
            drawPlanner();
          };
          select.value = plannerBarStyle.guideLook ? 'guide' : 'standard';
          select.addEventListener('change', () => apply(select.value));
        }

        function nlPad(n) { return (n < 10 ? '0' : '') + n; }
        function nlHexToRgba(hex, a) {
          if (!hex) return `rgba(125,211,252,${a})`;
          const m = hex.replace('#', '');
          const r = parseInt(m.substring(0, 2), 16);
          const g = parseInt(m.substring(2, 4), 16);
          const b = parseInt(m.substring(4, 6), 16);
          return `rgba(${r},${g},${b},${a})`;
        }
        function nlRebuildAll(force = false) {
          const cont = $('nlRows');
          nlStopPlannerClockMirror();
          if (!cont) return;
          const count = parseInt(($('nlRowCount') || { value: 2 }).value, 10);
          const nowD = (window.__getNow ? window.__getNow() : (window.__getNow ? window.__getNow() : new Date()));
          const digitalMode = nlDigitalState.mode || 'off';
          const rev = window.__nlRev || NLStore.__rev || 0;
          const key = `${rev}-${digitalMode}-${count}-${nowD.getFullYear()}-${nowD.getMonth()}-${nowD.getDate()}-${nowD.getHours()}`;
          const sameKey = key === nlLastRenderKey;
          if (!force && !nlRenderDirty && sameKey) return;
          nlLastRenderKey = key;
          nlRenderDirty = false;
          cont.innerHTML = '';
          clearNlDragPreview();
          nlDigitalState.displays = [];
          let digitalPlaced = false;
          const base = new Date(nowD.getFullYear(), nowD.getMonth(), nowD.getDate(), nowD.getHours(), 0, 0, 0);
          for (let i = 0; i < count; i++) {
            const slotStart = new Date(base.getTime() + i * 60 * 60000);
            nlBuildRow(slotStart, i === 0);
            if (!digitalPlaced && digitalMode !== 'off' && i === 0) {
              if (digitalMode === 'planner') {
                cont.appendChild(nlCreatePlannerClockBlock());
              } else {
                cont.appendChild(nlCreateDigitalBlock(digitalMode));
              }
              digitalPlaced = true;
            }
          }
          applyTickStyleAll();

          // === Responsive: keep bars & hands aligned on resize ===
          (function () {
            const root = document.getElementById('nlRows');
            if (!root || typeof ResizeObserver === 'undefined') return;
            const ro = new ResizeObserver(() => {
              const nowD = (window.__getNow ? window.__getNow() : (window.__getNow ? window.__getNow() : new Date()));
              document.querySelectorAll('.nl-row').forEach(row => {
                // re-render bars
                nlRenderBarsForHour(row);
                // update hands if current
                const isCurrent = row.classList.contains('current');
                const sHand = row.querySelector('.nl-hand.s');
                const mHand = row.querySelector('.nl-hand.m');
                if (isCurrent) {
                  if (sHand) sHand.style.left = (nowD.getSeconds() / 60 * 100) + '%';
                  if (mHand) mHand.style.left = (nowD.getMinutes() / 60 * 100) + '%';
                }
              });
              nlUpdateETA && nlUpdateETA();
            });
            ro.observe(root);
          })();


          // === ETA seconds toggle ===
          const NL_SEC_KEY = "nl_eta_show_seconds";
          function nlLoadShowSeconds() { try { return localStorage.getItem(NL_SEC_KEY) === '1'; } catch (e) { return false; } }
          function nlSaveShowSeconds(v) { try { localStorage.setItem(NL_SEC_KEY, v ? '1' : '0'); } catch (e) { } }
          (function () {
            const cb = document.getElementById('nlShowSeconds');
            if (cb) { cb.checked = nlLoadShowSeconds(); cb.onchange = () => nlSaveShowSeconds(cb.checked); }
          })();


          // ===== Fullscreen handling =====
          function nlEnterFullscreen() {
            const cont = document.createElement('div'); cont.className = 'nl-fullscreen'; cont.id = 'nlFS';
            const close = document.createElement('button'); close.className = 'nl-fs-close'; close.textContent = '閉じる';
            close.onclick = () => {
              const fs = document.getElementById('nlFS'); if (fs) fs.remove(); nlRebuildAll(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
              try { scheduleStudyWatchdog(); } catch (e) { }
            };
            cont.appendChild(close);
            document.body.appendChild(cont);
            // Build a fresh current-hour row inside fullscreen
            const nowD = (window.__getNow ? window.__getNow() : (window.__getNow ? window.__getNow() : new Date()));
            const base = new Date(nowD.getFullYear(), nowD.getMonth(), nowD.getDate(), nowD.getHours(), 0, 0, 0);
            const row = nlBuildRow(base, true);
            cont.appendChild(row);
          }
          (function () { const btn = document.getElementById('nlFullscreenBtn'); if (btn) btn.onclick = nlEnterFullscreen; })();

        }
        function nlBuildRow(startDate, isCurrent) {
          const wrap = $('nlRows'); if (!wrap) return;
          const row = document.createElement('div'); row.className = 'nl-row';
          if (isCurrent) { row.classList.add('current'); }
          row.dataset.startTs = startDate.getTime();
          const hour = startDate.getHours();
          const badge = document.createElement('div'); badge.className = 'nl-hourBadge'; badge.textContent = `${hour}時`;
          const rail = document.createElement('div'); rail.className = 'nl-rail';
          const scale = document.createElement('div'); scale.className = 'nl-scale';
          const lane = document.createElement('div'); lane.className = 'nl-lane';
          const track = document.createElement('div'); track.className = 'nl-track';
          const ticks = document.createElement('div'); ticks.className = 'nl-ticks';
          for (let i = 0; i <= 60; i++) {
            const t = document.createElement('div'); t.className = 'nl-tick' + (i % 5 === 0 ? ' major' : ''); ticks.appendChild(t);
            if (i % 5 === 0) { const lab = document.createElement('div'); lab.className = 'nl-label'; lab.textContent = i; ticks.appendChild(lab); }
          }
          const mHand = document.createElement('div'); mHand.className = 'nl-hand m';
          const sHand = document.createElement('div'); sHand.className = 'nl-hand s';
          const bars = document.createElement('div'); bars.className = 'nl-bars';
          const cap = document.createElement('div'); cap.className = 'nl-cap'; cap.innerHTML = '<span>0</span><span></span>';

          lane.appendChild(track);
          lane.appendChild(ticks);
          lane.appendChild(bars);
          lane.appendChild(mHand);
          lane.appendChild(sHand);
          scale.appendChild(lane);
          rail.appendChild(scale);
          rail.appendChild(cap);
          row.appendChild(badge); row.appendChild(rail);
          wrap.appendChild(row);

          // レイアウト
          const rect = scale.getBoundingClientRect(); const w = rect.width || 600;
          // 0〜60（61本）: %配置
          ticks.querySelectorAll('.nl-tick').forEach((el, idx) => { el.style.left = (idx / 60 * 100) + '%'; });
          ticks.querySelectorAll('.nl-label').forEach((el, idx) => { el.style.left = ((idx * 5) / 60 * 100) + '%'; });
          // 針
          // bars layer width = scale width (to align coordinate origins)
          // responsive: width via left/right; no fixed px width
          const eta = document.createElement('div'); eta.className = 'nl-eta'; eta.textContent = '--';
          lane.appendChild(eta);
          const nowD = (window.__getNow ? window.__getNow() : (window.__getNow ? window.__getNow() : new Date()));
          const min = isCurrent ? nowD.getMinutes() : 0;
          const sec = isCurrent ? nowD.getSeconds() : 0;
          mHand.style.left = (min / 60 * 100) + '%'; sHand.style.left = (sec / 60 * 100) + '%';
          // バー
          nlRenderBarsForHour(row);
          return row;
        }
        function nlPosForMinute(row, minute) {
          const rect = row.querySelector('.nl-lane')?.getBoundingClientRect();
          if (!rect) return 0;
          return (minute / 60) * (rect.width || 600);
        }
        function nlRenderBarsForHour(row) {
          const barsEl = row.querySelector('.nl-bars'); barsEl.innerHTML = '';
          const startTs = Number(row.dataset.startTs || 0);
          const hourStart = new Date(startTs);
          const hourEnd = new Date(startTs + 60 * 60000);
          const nowMs = (window.__getNow ? window.__getNow() : new Date()).getTime();
          const list = NLStore.listBetween(hourStart.getTime(), hourEnd.getTime());
          list.forEach(ev => {
            if (isBreakEvent(ev) && Number.isFinite(ev.end) && ev.end <= nowMs) return;
            const os = new Date(Math.max(ev.start, hourStart.getTime()));
            const oe = new Date(Math.min(ev.end, hourEnd.getTime()));
            if (oe <= os) return;
            const startMin = (os - hourStart) / 60000;
            const endMin = (oe - hourStart) / 60000;
            const leftPct = (clamp(startMin, 0, 60) / 60) * 100;
            const rightPct = (clamp(endMin, 0, 60) / 60) * 100;
            const widthPct = Math.max(0.5, rightPct - leftPct);
            const bar = document.createElement('div'); bar.className = 'nl-bar';
            bar.dataset.evId = ev.id;
            bar.style.left = leftPct + '%';
            bar.style.width = widthPct + '%';
            bar.style.zIndex = '1';
            bar.style.background = nlHexToRgba(ev.color || '#7dd3fc', 0.68);
            bar.style.borderColor = nlHexToRgba('#ffffff', 0.35);
            bar.title = `${ev.title}（${pad2(os.getHours())}:${pad2(os.getMinutes())}〜${pad2(oe.getHours())}:${pad2(oe.getMinutes())}）`;
            bar.textContent = ev.title;
            barsEl.appendChild(bar);
            applyBarStyle(bar, ev.color || '#7dd3fc');
          });
        }
        const isNumberlineActive = () => {
          const root = document.getElementById('nlRows');
          const tab = root?.closest?.('.tab-content');
          return !!(tab && tab.classList.contains('active'));
        };
        function nlStepMinute() {
          if (!isNumberlineActive()) return;
          const nowD = (window.__getNow ? window.__getNow() : (window.__getNow ? window.__getNow() : new Date()));
          document.querySelectorAll('.nl-row').forEach((row, i) => {
            if (i === 0) {
              const mHand = row.querySelector('.nl-hand.m');
              const sHand = row.querySelector('.nl-hand.s');
              mHand.style.left = (nowD.getMinutes() / 60 * 100) + '%';
              sHand.style.left = (nowD.getSeconds() / 60 * 100) + '%';
            }
            nlRenderBarsForHour(row);
          });
        }
        let nlTimersStarted = false;
        let nlAlignTimer = null;
        let nlMinuteTimer = null;
        let nlSecondTimer = null;
        let nlHourTimer = null;
        function nlStartTimers() {
          if (nlTimersStarted) return;
          nlTimersStarted = true;
          // 分境界に同期
          const alignMin = () => {
            const n = (window.__getNow ? window.__getNow() : (window.__getNow ? window.__getNow() : new Date())); const ms = (60 - n.getSeconds()) * 1000 - n.getMilliseconds();
            if (nlAlignTimer) clearTimeout(nlAlignTimer);
            nlAlignTimer = setTimeout(() => {
              nlStepMinute();
              if (nlMinuteTimer) clearInterval(nlMinuteTimer);
              nlMinuteTimer = setInterval(() => { if (isNumberlineActive()) nlStepMinute(); }, 60000);
            }, ms);
          };
          alignMin();
          // 1秒針更新
          nlSecondTimer = setInterval(() => {
            if (!isNumberlineActive()) return;
            const rows = Array.from(document.querySelectorAll('.nl-row'));
            rows.forEach(r => { r.__nlStack = 0; r.__nlOuterStack = 0; });
            if (!rows.length) return;
            const nowD = (window.__getNow ? window.__getNow() : (window.__getNow ? window.__getNow() : new Date()));
            rows.forEach(row => {
              const isCurrent = row.classList.contains('current') || (() => {
                const ts = parseInt(row.dataset.startTs || '0', 10);
                const d = new Date(ts);
                return d.getHours() === nowD.getHours() && d.getDate() === nowD.getDate() && d.getMonth() === nowD.getMonth() && d.getFullYear() === nowD.getFullYear();
              })();
              const sHand = row.querySelector('.nl-hand.s');
              const mHand = row.querySelector('.nl-hand.m');
              if (isCurrent) {
                if (sHand) sHand.style.left = (nowD.getSeconds() / 60 * 100) + '%';
                if (mHand) mHand.style.left = (nowD.getMinutes() / 60 * 100) + '%';
              } else {
                if (sHand) sHand.style.left = '0%';
                if (mHand) mHand.style.left = '0%';
              }
            });
          }, 1000);
          // 時の境目で行を再生成
          nlHourTimer = setInterval(() => {
            if (!isNumberlineActive()) return;
            const n = (window.__getNow ? window.__getNow() : (window.__getNow ? window.__getNow() : new Date()));
            if (n.getMinutes() === 0 && n.getSeconds() < 2) {
              nlRebuildAll(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
              try { scheduleStudyWatchdog(); } catch (e) { }
            }
          }, 1000);
        }




        function nlUpdateETA(secondAligned) {
          const now = secondAligned ? (Date.now() - (Date.now() % 1000)) : Date.now();
          const showSec = (function () { try { return localStorage.getItem('nl_eta_show_seconds') === '1'; } catch (e) { return false; } })();
          document.querySelectorAll('.nl-row').forEach(row => {
            const hourStart = parseInt(row.dataset.startTs || '0', 10);
            const hourEnd = hourStart + 60 * 60000;
            const etaEl = row.querySelector('.nl-eta'); if (!etaEl) return;
            const evs = (NLStore.events || []).filter(ev => ev.start < ev.end && ev.start < hourEnd && ev.end > hourStart);
            let remainMs = null, curTitle = null;
            for (const ev of evs) {
              if (now >= ev.start && now < ev.end) { remainMs = Math.max(0, ev.end - now); curTitle = (ev.title || '予定').toString(); break; }
            }
            if (remainMs === null) { etaEl.style.display = 'none'; }
            else {
              etaEl.style.display = 'block';
              if (showSec) {
                const totalSec = Math.max(0, Math.floor(remainMs / 1000));
                const mm = Math.floor(totalSec / 60);
                const ss = totalSec % 60;
                const ssPad = String(ss).padStart(2, '0');
                etaEl.textContent = mm > 0 ? `${curTitle} (${mm}分${ssPad}秒)` : `${curTitle} (${ssPad}秒)`;
              } else {
                const mins = Math.max(0, Math.ceil(remainMs / 60000));
                etaEl.textContent = `${curTitle} (${mins}分)`;
              }
            }
          });
        }
        // ============== 入力 → NLStore 追加 ==============
        function nlAddFromInputs() {
          const title = ($('nlTitle') || { value: '' }).value.trim() || "予定";
          const sVal = ($('nlStart') || { value: '' }).value;
          const eVal = ($('nlEnd') || { value: '' }).value;
          const color = ($('nlColor') || { value: '#7dd3fc' }).value;
          const msg = $('nlMsg'); if (msg) msg.textContent = '';
          if (!sVal || !eVal) { if (msg) msg.textContent = '開始と終了を入力してください。'; return; }
          const nowD = (window.__getNow ? window.__getNow() : (window.__getNow ? window.__getNow() : new Date()));
          const [sh, sm] = sVal.split(':').map(Number);
          const [eh, em] = eVal.split(':').map(Number);
          let s = new Date(nowD.getFullYear(), nowD.getMonth(), nowD.getDate(), sh, sm || 0, 0, 0);
          let e = new Date(nowD.getFullYear(), nowD.getMonth(), nowD.getDate(), eh, em || 0, 0, 0);
          if (e <= s) { e = new Date(e.getTime() + 24 * 60 * 60000); } // 翌日跨ぎに対応
          NLStore.addAbs(s, e, title, color, "normal");
          NLStore.save();
          // 再描画
          drawPlanner(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
          try { scheduleStudyWatchdog(); } catch (e) { }

          nlRebuildAll(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
          try { scheduleStudyWatchdog(); } catch (e) { }

          // 予定一覧も更新
          renderList();
          try { scheduleStudyWatchdog(); } catch (e) { }

        }

        // ============== 既存「追加」UIも NLStore に接続 ==============
        function addEventFromPlannerInputs() {
          const mode = $('mode') ? $('mode').value : 'day';
          const s = $('start').value.split(':').map(Number);
          const e = $('end').value.split(':').map(Number);
          const label = ($('label') || { value: '' }).value.trim() || '予定';
          const color = ($('color') || { value: '#4da3ff' }).value;
          if (s.length < 2 || e.length < 2) { alert('時間を入力'); return; }
          const nowD = (window.__getNow ? window.__getNow() : (window.__getNow ? window.__getNow() : new Date()));
          let start, end;
          if (mode === 'hour') {
            // 現在の時間をベースに「分」だけ反映
            const base = new Date(nowD.getFullYear(), nowD.getMonth(), nowD.getDate(), nowD.getHours(), 0, 0, 0);
            start = new Date(base.getTime() + (s[1] % 60) * 60000);
            end = new Date(base.getTime() + (e[1] % 60) * 60000);
            if (end <= start) { end = new Date(end.getTime() + 60 * 60000); }
          } else {
            // 12時間面: 時分をそのまま絶対化（現在の半日ブロックに投影）
            const half = (nowD.getHours() >= 12 ? 12 : 0);
            start = new Date(nowD.getFullYear(), nowD.getMonth(), nowD.getDate(), half + (s[0] % 12), s[1] % 60, 0, 0);
            end = new Date(nowD.getFullYear(), nowD.getMonth(), nowD.getDate(), half + (e[0] % 12), e[1] % 60, 0, 0);
            if (end <= start) { end = new Date(end.getTime() + 12 * 60 * 60000); }
          }
          NLStore.addAbs(start, end, label, color, "normal");
          NLStore.save();
          ($('label') || {}).value = '';
          drawPlanner(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
          try { scheduleStudyWatchdog(); } catch (e) { }

          nlRebuildAll(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
          try { scheduleStudyWatchdog(); } catch (e) { }

          renderList();
          try { scheduleStudyWatchdog(); } catch (e) { }

        }

        function addQuickBlock(durationMin, kind = 'lesson', titleOverride) {
          const nowD = (window.__getNow ? window.__getNow() : (window.__getNow ? window.__getNow() : new Date()));
          const start = nowD;
          const end = new Date(nowD.getTime() + Math.max(1, durationMin) * 60000);
          const title = titleOverride || (kind === 'break' ? '休憩' : 'ミニ授業');
          const color = kind === 'break' ? '#f97316' : '#7dd3fc';
          const ev = NLStore.addAbs(start, end, title, color, kind);
          drawPlanner && drawPlanner();
          nlRebuildAll && nlRebuildAll();
          try { PlannerCalendar && PlannerCalendar.refresh && PlannerCalendar.refresh(); } catch (_) { }
          try { showToast && showToast(`${title} を追加しました`, 'ok'); } catch (_) { }
          return ev;
        }

        // ============== 予定一覧（削除だけ提供） ==============
        const LIST_ORDER_FALLBACK = 1e12;
        const listDrag = { id: null, container: null };
        function sortEventsForList(list) {
          const arr = list.slice();
          arr.sort((a, b) => {
            const ao = typeof a.orderIndex === 'number' ? a.orderIndex : LIST_ORDER_FALLBACK;
            const bo = typeof b.orderIndex === 'number' ? b.orderIndex : LIST_ORDER_FALLBACK;
            if (ao !== bo) return ao - bo;
            return (a.start || 0) - (b.start || 0);
          });
          return arr;
        }
        function ensurePlaceholder(container) {
          if (container.__placeholder) return container.__placeholder;
          const ph = document.createElement('div');
          ph.className = 'item placeholder';
          ph.dataset.placeholder = '1';
          const line = document.createElement('div');
          line.className = 'placeholder-line';
          ph.appendChild(line);
          container.__placeholder = ph;
          return ph;
        }
        function clearPlaceholder(container) {
          const ph = container?.__placeholder;
          if (ph && ph.parentElement) ph.parentElement.removeChild(ph);
        }
        function finalizeReorder(container) {
          const dragId = listDrag.id;
          const ph = container?.__placeholder;
          listDrag.id = null;
          listDrag.container = null;
          if (!dragId || !container) { clearPlaceholder(container); return; }
          const ids = [];
          container.querySelectorAll('.item').forEach(el => {
            if (el.dataset.placeholder === '1') {
              ids.push(dragId);
              return;
            }
            const id = el.dataset.id;
            if (!id) return;
            if (id !== dragId) ids.push(id);
          });
          // 落とし先が見つからなかった場合は末尾へ
          if (!ids.includes(dragId)) ids.push(dragId);
          const map = new Map(NLStore.events.map(ev => [ev.id, ev]));
          ids.forEach((id, idx) => {
            const ev = map.get(id);
            if (ev) ev.orderIndex = idx;
          });
          // 安全に再並べ替え
          NLStore.events = sortEventsForList(NLStore.events);
          NLStore.save();
          clearPlaceholder(container);
          renderList();
          try { drawPlanner(); nlRebuildAll && nlRebuildAll(); PlannerCalendar && PlannerCalendar.refresh && PlannerCalendar.refresh(); } catch (_) { }
        }
        function makeReorderable(div, container, id) {
          if (!div || !container) return;
          div.draggable = true;
          div.dataset.id = id;
          const placeholder = ensurePlaceholder(container);
          div.addEventListener('dragstart', (e) => {
            listDrag.id = id;
            listDrag.container = container;
            div.classList.add('dragging');
            e.dataTransfer?.setData('text/plain', id);
            e.dataTransfer?.setDragImage(div, 10, 10);
          });
          div.addEventListener('dragend', () => {
            div.classList.remove('dragging');
            finalizeReorder(container);
          });
          div.addEventListener('drop', (e) => { e.preventDefault(); finalizeReorder(container); });
          div.addEventListener('dragover', (e) => {
            if (listDrag.container !== container) return;
            e.preventDefault();
            const rect = div.getBoundingClientRect();
            const after = (e.clientY - rect.top) > rect.height / 2;
            if (after) {
              div.insertAdjacentElement('afterend', placeholder);
            } else {
              div.insertAdjacentElement('beforebegin', placeholder);
            }
          });
        }
        function renderList() {
          const containers = [$('list'), $('nlList')].filter(Boolean);
          if (containers.length === 0) return;
          containers.forEach(c => c.innerHTML = '');
          const evs = sortEventsForList(NLStore.events);
          evs.forEach(ev => {
            containers.forEach(cont => cont.appendChild(createListItem(ev, cont)));
          });
        }

        function createListItem(ev, container) {
          const div = document.createElement('div'); div.className = 'item';
          const left = document.createElement('div'); left.style.display = 'flex'; left.style.gap = '8px'; left.style.alignItems = 'center';
          const badge = document.createElement('div'); badge.className = 'badge'; badge.style.background = ev.color;
          const txt = document.createElement('div'); txt.textContent = ev.title;
          left.appendChild(badge); left.appendChild(txt);
          const right = document.createElement('div'); right.style.display = 'flex'; right.style.gap = '8px'; right.style.alignItems = 'center';
          const time = document.createElement('span'); time.className = 'tiny';
          const s = new Date(ev.start), e = new Date(ev.end);
          time.textContent = `${toHM(s)} – ${toHM(e)}`;
          const edit = document.createElement('button'); edit.className = 'ghost'; edit.textContent = '編集';
          edit.style.padding = '4px 8px'; edit.style.fontSize = '12px';
          edit.onclick = () => openEventEditor(ev.id);
          const del = document.createElement('button'); del.className = 'danger'; del.textContent = '削除';
          del.style.padding = '4px 8px'; del.style.fontSize = '12px';
          del.onclick = () => {
            NLStore.removeById(ev.id); renderList();
            try { scheduleStudyWatchdog(); } catch (e) { }
            drawPlanner(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
            try { scheduleStudyWatchdog(); } catch (e) { }
            nlRebuildAll(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
            try { scheduleStudyWatchdog(); } catch (e) { }
          };
          right.appendChild(time); right.appendChild(edit); right.appendChild(del);
          div.appendChild(left); div.appendChild(right);
          makeReorderable(div, container, ev.id);
          return div;
        }

        function openEventEditor(id) {
          const ev = NLStore.events.find(e => e.id === id);
          if (!ev) return;
          openEventDialog({
            heading: '予定を編集',
            title: ev.title,
            color: ev.color || '#4da3ff',
            start: new Date(ev.start),
            end: new Date(ev.end),
            note: `開始 ${formatDateTime(new Date(ev.start))} / 終了 ${formatDateTime(new Date(ev.end))}`,
            onSave: (payload) => {
              ev.title = payload.title;
              ev.color = payload.color;
              ev.start = payload.start.getTime();
              ev.end = payload.end.getTime();
              NLStore.save();
              drawPlanner(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
              try { scheduleStudyWatchdog(); } catch (e) { }
              nlRebuildAll(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
              try { scheduleStudyWatchdog(); } catch (e) { }
              renderList();
            }
          });
        }

        function toLocalInputValue(date) {
          const d = new Date(date);
          if (isNaN(d)) return '';
          const y = d.getFullYear();
          const m = String(d.getMonth() + 1).padStart(2, '0');
          const day = String(d.getDate()).padStart(2, '0');
          const hh = String(d.getHours()).padStart(2, '0');
          const mm = String(d.getMinutes()).padStart(2, '0');
          return `${y}-${m}-${day}T${hh}:${mm}`;
        }

        function fromLocalInputValue(value) {
          if (!value) return null;
          const [date, time] = value.split('T');
          if (!date || !time) return null;
          const [y, mo, d] = date.split('-').map(Number);
          const [hh, mm] = time.split(':').map(Number);
          if ([y, mo, d, hh, mm].some(v => isNaN(v))) return null;
          return new Date(y, (mo || 1) - 1, d || 1, hh || 0, mm || 0, 0, 0);
        }

        function formatDateTime(date) {
          const d = new Date(date);
          if (isNaN(d)) return '--';
          return `${d.getMonth() + 1}/${d.getDate()} ${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
        }

        function openEventDialog(opts) {
          const { heading = '予定を追加', title = '新規予定', color = '#4da3ff', start = new Date(), end = new Date(Date.now() + 1800000), onSave, note = '' } = opts || {};
          const overlay = document.createElement('div'); overlay.className = 'quick-dialog-backdrop';
          const card = document.createElement('div'); card.className = 'quick-dialog-card';
          const titleInput = document.createElement('input'); titleInput.type = 'text'; titleInput.value = title;
          const colorInput = document.createElement('input'); colorInput.type = 'color'; colorInput.value = color || '#4da3ff';
          const startInput = document.createElement('input'); startInput.type = 'datetime-local'; startInput.step = '60'; startInput.value = toLocalInputValue(start);
          const endInput = document.createElement('input'); endInput.type = 'datetime-local'; endInput.step = '60'; endInput.value = toLocalInputValue(end);
          const actionWrap = document.createElement('div'); actionWrap.className = 'quick-dialog-actions';
          const cancelBtn = document.createElement('button'); cancelBtn.className = 'ghost'; cancelBtn.textContent = 'キャンセル';
          const saveBtn = document.createElement('button'); saveBtn.textContent = '保存';
          actionWrap.appendChild(cancelBtn); actionWrap.appendChild(saveBtn);
          card.innerHTML = '';
          const headingEl = document.createElement('h3'); headingEl.textContent = heading;
          card.appendChild(headingEl);
          if (note) {
            const noteEl = document.createElement('div'); noteEl.className = 'tiny'; noteEl.style.marginBottom = '6px'; noteEl.textContent = note;
            card.appendChild(noteEl);
          }
          const titleLabel = document.createElement('label'); titleLabel.textContent = 'タイトル';
          card.appendChild(titleLabel); card.appendChild(titleInput);
          const colorLabel = document.createElement('label'); colorLabel.textContent = 'カラー';
          card.appendChild(colorLabel); card.appendChild(colorInput);
          const startLabel = document.createElement('label'); startLabel.textContent = '開始';
          card.appendChild(startLabel); card.appendChild(startInput);
          const endLabel = document.createElement('label'); endLabel.textContent = '終了';
          card.appendChild(endLabel); card.appendChild(endInput);
          card.appendChild(actionWrap);
          overlay.appendChild(card);
          document.body.appendChild(overlay);

          function close() { overlay.remove(); document.removeEventListener('keydown', onKey); }
          function onKey(e) { if (e.key === 'Escape') { close(); } }
          document.addEventListener('keydown', onKey);
          overlay.addEventListener('click', e => { if (e.target === overlay) close(); });
          cancelBtn.onclick = close;
          saveBtn.onclick = () => {
            const s = fromLocalInputValue(startInput.value);
            const e = fromLocalInputValue(endInput.value);
            if (!s || !e || e <= s) { alert('開始・終了時刻を確認してください。'); return; }
            const payload = {
              title: titleInput.value.trim() || '新規予定',
              color: colorInput.value || '#4da3ff',
              start: s,
              end: e
            };
            if (typeof onSave === 'function') { onSave(payload); }
            close();
          };
        }

        const plannerDirectState = {
          enabled: false,
          dragging: false,
          startMinute: null,
          currentMinute: null,
          pointerId: null,
          overlayGroup: null,
          overlayFill: null,
          overlayEdge: null,
          label: null
        };
        function getPlannerTotalMinutes() { const modeSel = $('mode'); return (modeSel && modeSel.value === 'hour') ? 60 : 720; }
        function getPlannerBaseDate() {
          const nowD = (window.__getNow ? window.__getNow() : new Date());
          const modeSel = $('mode'); const mode = modeSel ? modeSel.value : 'hour';
          if (mode === 'hour') {
            return new Date(nowD.getFullYear(), nowD.getMonth(), nowD.getDate(), nowD.getHours(), 0, 0, 0);
          }
          const half = nowD.getHours() >= 12 ? 12 : 0;
          return new Date(nowD.getFullYear(), nowD.getMonth(), nowD.getDate(), half, 0, 0, 0);
        }
        function plannerMinuteToDate(minute) {
          const base = getPlannerBaseDate();
          return new Date(base.getTime() + minute * 60000);
        }
        function plannerMinuteFromEvent(evt) {
          const svg = document.getElementById('clock'); if (!svg) return null;
          const rect = svg.getBoundingClientRect();
          const cx = rect.left + rect.width / 2;
          const cy = rect.top + rect.height / 2;
          const mx = evt.clientX;
          const my = evt.clientY;
          const angle = Math.atan2(my - cy, mx - cx) + Math.PI / 2;
          let norm = angle;
          if (norm < 0) norm += Math.PI * 2;
          const total = getPlannerTotalMinutes();
          const minute = Math.round(norm / (Math.PI * 2) * total);
          return Math.max(0, Math.min(total, minute));
        }
        function ensurePlannerOverlay() {
          const svgEl = document.getElementById('clock');
          if (!svgEl) return null;
          let group = plannerDirectState.overlayGroup;
          if (group && !group.isConnected) {
            group = null;
            plannerDirectState.overlayGroup = null;
            plannerDirectState.overlayFill = null;
            plannerDirectState.overlayEdge = null;
          }
          if (!group) {
            group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.id = 'plannerDirectGroup';
            const fill = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            fill.classList.add('guide-fill');
            const edge = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            edge.classList.add('guide-edge');
            group.appendChild(fill);
            group.appendChild(edge);
            group.style.opacity = '0';
            const hands = document.getElementById('hands');
            if (hands && hands.parentNode === svgEl) {
              svgEl.insertBefore(group, hands);
            } else {
              svgEl.appendChild(group);
            }
            plannerDirectState.overlayGroup = group;
            plannerDirectState.overlayFill = fill;
            plannerDirectState.overlayEdge = edge;
          }
          return plannerDirectState.overlayGroup;
        }
        function plannerUpdateOverlay() {
          const overlay = ensurePlannerOverlay();
          const fill = plannerDirectState.overlayFill;
          const edge = plannerDirectState.overlayEdge;
          const label = ensurePlannerGuideLabel();
          if (!overlay || !fill || !edge) return;
          if (plannerDirectState.dragging && plannerDirectState.startMinute != null && plannerDirectState.currentMinute != null) {
            const total = getPlannerTotalMinutes();
            let start = plannerDirectState.startMinute;
            let end = plannerDirectState.currentMinute;
            if (end <= start) end += total;
            const angleStart = minToAng(start, total);
            const angleEnd = minToAng(end, total);
            const pathData = sectorPath(250, 250, 228, 188, angleStart, angleEnd);
            fill.setAttribute('d', pathData);
            edge.setAttribute('d', pathData);
            overlay.style.opacity = '1';
            if (label) {
              const startDate = plannerMinuteToDate(startMin % total);
              const endDate = new Date(startDate.getTime() + duration);
              label.textContent = `${toHM(startDate)} – ${toHM(endDate)} / ${Math.round(duration / 60000)}分`;
              label.style.display = 'block';
            }
          } else {
            overlay.style.opacity = '0';
            if (label) label.style.display = 'none';
          }
        }
        function initPlannerDirectMode() {
          const btn = $('plannerDirectToggle');
          const svg = document.getElementById('clock');
          if (!btn || !svg) return;
          const updateBtn = () => { btn.textContent = plannerDirectState.enabled ? '直接モード:ON' : '直接モード:OFF'; btn.classList.toggle('active', plannerDirectState.enabled); };
          btn.addEventListener('click', () => {
            plannerDirectState.enabled = !plannerDirectState.enabled;
            if (!plannerDirectState.enabled) {
              plannerDirectState.dragging = false; plannerUpdateOverlay();
            }
            updateBtn();
          });
          updateBtn();
          svg.addEventListener('pointerdown', (e) => {
            if (!plannerDirectState.enabled) return;
            const minute = plannerMinuteFromEvent(e);
            if (minute === null) return;
            plannerDirectState.dragging = true;
            plannerDirectState.startMinute = minute;
            plannerDirectState.currentMinute = minute;
            plannerDirectState.pointerId = e.pointerId;
            plannerDirectState.dragStartTime = Date.now();
            plannerDirectState.dragTriggerTimer = setTimeout(() => {
              if (plannerDirectState.dragging && plannerDirectState.pointerId === e.pointerId) {
                try { svg.setPointerCapture(e.pointerId); } catch (_) { }
                plannerUpdateOverlay();
              }
            }, 150);
            e.preventDefault();
          });
          const moveHandler = (e) => {
            if (!plannerDirectState.dragging || e.pointerId !== plannerDirectState.pointerId) return;
            const minute = plannerMinuteFromEvent(e);
            if (minute === null) return;
            plannerDirectState.currentMinute = minute;
            plannerUpdateOverlay();
          };
          const endHandler = (e) => {
            if (!plannerDirectState.dragging || e.pointerId !== plannerDirectState.pointerId) return;
            if (plannerDirectState.dragTriggerTimer) {
              clearTimeout(plannerDirectState.dragTriggerTimer);
              plannerDirectState.dragTriggerTimer = null;
            }
            if (plannerDirectState.dragStartTime && Date.now() - plannerDirectState.dragStartTime < 120) {
              plannerDirectState.dragging = false;
              plannerDirectState.startMinute = null;
              plannerDirectState.currentMinute = null;
              return;
            }
            try { svg.releasePointerCapture(e.pointerId); } catch (_) { }
            plannerDirectState.dragging = false;
            const start = plannerDirectState.startMinute;
            const end = plannerDirectState.currentMinute;
            plannerDirectState.startMinute = null;
            plannerDirectState.currentMinute = null;
            plannerUpdateOverlay();
            if (start == null || end == null || Math.abs(end - start) < 1) return;
            const total = getPlannerTotalMinutes();
            let startMin = start;
            let endMin = end;
            if (endMin <= startMin) endMin += total;
            const duration = (endMin - startMin) * 60000;
            const startDate = plannerMinuteToDate(startMin % total);
            const endDate = new Date(startDate.getTime() + duration);
            openEventDialog({
              heading: '時計から予定を追加',
              note: `開始 ${formatDateTime(startDate)} / 終了 ${formatDateTime(endDate)}`,
              start: startDate,
              end: endDate,
              onSave: ({ title, color, start, end }) => {
                NLStore.addAbs(start, end, title, color, "normal");
                NLStore.save();
                drawPlanner(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (err) { }
                try { scheduleStudyWatchdog(); } catch (err) { }
                nlRebuildAll(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (err) { }
                try { scheduleStudyWatchdog(); } catch (err) { }
                renderList();
              }
            });
          };
          svg.addEventListener('pointermove', moveHandler);
          svg.addEventListener('pointerup', endHandler);
          svg.addEventListener('pointerleave', (e) => {
            if (plannerDirectState.dragging) { endHandler(e); }
          });
        }

        const nlDirectState = { enabled: false, dragging: false, startTs: null, currentTs: null, pointerId: null };
        function snapToMinute(ts) { return Math.round(ts / 60000) * 60000; }
        function getNlTimeFromEvent(e) {
          const target = e.target.closest('.nl-row');
          if (!target) return null;
          const lane = target.querySelector('.nl-lane');
          if (!lane) return null;
          const rect = lane.getBoundingClientRect();
          if (rect.width === 0) return null;
          const ratio = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
          const startTs = parseInt(target.dataset.startTs || '0', 10);
          const ts = startTs + ratio * 60 * 60000;
          return { timestamp: snapToMinute(ts), row: target };
        }
        function ensureNlGuide(row) {
          if (!row) return null;
          const lane = row.querySelector('.nl-lane');
          if (!lane) return null;
          let guide = row.__nlGuide;
          if (guide && !guide.isConnected) { guide = null; row.__nlGuide = null; }
          if (!guide) {
            guide = document.createElement('div');
            guide.className = 'nl-direct-guide';
            lane.appendChild(guide);
            row.__nlGuide = guide;
          }
          return guide;
        }
        function clearNlDragPreview() {
          document.querySelectorAll('.nl-direct-guide').forEach(el => el.classList.remove('show'));
        }
        function renderNlDragPreview(startMs, endMs) {
          clearNlDragPreview();
          const min = Math.min(startMs, endMs);
          const max = Math.max(startMs, endMs);
          if (max - min < 60000) return;
          const rows = document.querySelectorAll('.nl-row');
          rows.forEach(row => {
            const startTs = parseInt(row.dataset.startTs || '0', 10);
            const endTs = startTs + 60 * 60000;
            const overlapStart = Math.max(startTs, min);
            const overlapEnd = Math.min(endTs, max);
            if (overlapEnd <= overlapStart) return;
            const guide = ensureNlGuide(row);
            if (!guide) return;
            const startRatio = ((overlapStart - startTs) / 60000) / 60;
            const endRatio = ((overlapEnd - startTs) / 60000) / 60;
            const left = Math.max(0, Math.min(100, startRatio * 100));
            const width = Math.max(1.5, Math.min(100 - left, (endRatio - startRatio) * 100));
            guide.style.left = left + '%';
            guide.style.width = width + '%';
            guide.classList.add('show');
          });
        }
        function initNlDirectMode() {
          const btn = $('nlDirectToggle');
          const rows = $('nlRows');
          if (!btn || !rows) return;
          const updateBtn = () => { btn.textContent = nlDirectState.enabled ? '直接モード:ON' : '直接モード:OFF'; btn.classList.toggle('active', nlDirectState.enabled); };
          btn.addEventListener('click', () => {
            nlDirectState.enabled = !nlDirectState.enabled;
            if (!nlDirectState.enabled) {
              nlDirectState.dragging = false; clearNlDragPreview();
            }
            updateBtn();
          });
          updateBtn();
          rows.addEventListener('pointerdown', (e) => {
            if (!nlDirectState.enabled) return;
            const info = getNlTimeFromEvent(e);
            if (!info) return;
            nlDirectState.dragging = true;
            nlDirectState.startTs = info.timestamp;
            nlDirectState.currentTs = info.timestamp;
            nlDirectState.pointerId = e.pointerId;
            e.target.setPointerCapture(e.pointerId);
            renderNlDragPreview(nlDirectState.startTs, nlDirectState.currentTs);
            e.preventDefault();
          });
          const moveHandler = (e) => {
            if (!nlDirectState.dragging || e.pointerId !== nlDirectState.pointerId) return;
            const info = getNlTimeFromEvent(e);
            if (!info) return;
            nlDirectState.currentTs = info.timestamp;
            renderNlDragPreview(nlDirectState.startTs, nlDirectState.currentTs);
          };
          const endHandler = (e) => {
            if (!nlDirectState.dragging || e.pointerId !== nlDirectState.pointerId) return;
            e.target.releasePointerCapture(e.pointerId);
            const start = nlDirectState.startTs;
            const end = nlDirectState.currentTs;
            nlDirectState.dragging = false;
            nlDirectState.startTs = null;
            nlDirectState.currentTs = null;
            clearNlDragPreview();
            if (start == null || end == null) return;
            if (Math.abs(end - start) < 60000) return;
            const sDate = new Date(Math.min(start, end));
            const eDate = new Date(Math.max(start, end));
            openEventDialog({
              heading: '数直線から予定を追加',
              note: `開始 ${formatDateTime(sDate)} / 終了 ${formatDateTime(eDate)}`,
              start: sDate,
              end: eDate,
              onSave: ({ title, color, start, end }) => {
                NLStore.addAbs(start, end, title, color, "normal");
                NLStore.save();
                drawPlanner(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (err) { }
                try { scheduleStudyWatchdog(); } catch (err) { }
                nlRebuildAll(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (err) { }
                try { scheduleStudyWatchdog(); } catch (err) { }
                renderList();
              }
            });
          };
          rows.addEventListener('pointermove', moveHandler);
          rows.addEventListener('pointerup', endHandler);
          rows.addEventListener('pointerleave', (e) => {
            if (nlDirectState.dragging) { endHandler(e); }
          });
        }

        // ============== 勉強管理（安定版の簡潔ロジック） ==============
        const study = { total: 20, perPage: 5, completed: [], startPage: null, endPage: null };
        function studyPageNumber(idx) {
          if (typeof study.startPage === 'number') {
            return study.startPage + idx;
          }
          return idx + 1;
        }
        const STUDY_BREAK_KEY = 'study-break-default-min';
        const STUDY_BREAK_DEFAULT_MIN = 5;
        const STUDY_BREAK_MIN = 1;
        const STUDY_BREAK_MAX = 180;
        const STUDY_BREAK_COLOR = '#1e40af';
        const STUDY_BREAK_TITLE = '休憩';
        function clampStudyBreakMinutes(v) {
          const n = parseInt(v, 10);
          if (!Number.isFinite(n)) return STUDY_BREAK_DEFAULT_MIN;
          return Math.max(STUDY_BREAK_MIN, Math.min(STUDY_BREAK_MAX, n));
        }
        let studyBreakMinutes = (() => {
          try {
            const raw = localStorage.getItem(STUDY_BREAK_KEY);
            if (raw != null) return clampStudyBreakMinutes(raw);
          } catch (_) { }
          return STUDY_BREAK_DEFAULT_MIN;
        })();
        function getStudyBreakMinutes() {
          return studyBreakMinutes;
        }
        function setStudyBreakMinutes(v) {
          const next = clampStudyBreakMinutes(v);
          studyBreakMinutes = next;
          try { localStorage.setItem(STUDY_BREAK_KEY, String(next)); } catch (_) { }
          const ids = ['studyBreakMinutes', 'studyBreakDefaultMin'];
          ids.forEach(id => {
            const el = document.getElementById(id);
            if (el && String(el.value || '') !== String(next)) el.value = String(next);
          });
          return next;
        }
        function isBreakEvent(ev) {
          return !!(ev && (ev.kind === 'break' || ev.isBreak || ev.break === true));
        }
        try {
          window.__getStudyBreakMinutes = getStudyBreakMinutes;
          window.__setStudyBreakMinutes = setStudyBreakMinutes;
          window.__isBreakEvent = isBreakEvent;
        } catch (_) { }
        function getStudyCounts() {
          try {
            if (typeof StudyMgr !== 'undefined' && StudyMgr && StudyMgr.active) {
              const ids = StudyMgr.pageIds || [];
              const remainKeys = new Set();
              ids.forEach(id => {
                const ev = NLStore.events.find(e => e.id === id);
                if (ev && !isBreakEvent(ev)) { remainKeys.add(ev.pageKey || ev.id); }
              });
              const configuredTotal = (typeof study !== 'undefined' && study && study.total) ? study.total : null;
              const total = configuredTotal != null ? configuredTotal : remainKeys.size;
              const remain = remainKeys.size;
              const done = Math.max(0, total - remain);
              return { done, total };
            }
          } catch (e) { }
          const total = (typeof study !== 'undefined' && study) ? (study.total || 0) : 0;
          const done = (typeof study !== 'undefined' && study) ? (study.completed ? study.completed.length : 0) : 0;
          return { done, total };
        }
        function setCompleteBtnText() {
          var ids = ['pageCompleteBtn', 'nlCompleteBtn'];
          var p = getStudyCounts();
          ids.forEach(function (id) {
            var btn = document.getElementById(id);
            if (btn) { btn.textContent = '📖 ページ完了 ' + p.done + '/' + p.total; }
          });
        }
        function updateStudyStats() {
          if ($('studyTotal')) $('studyTotal').value = study.total;
          if ($('studyPerPage')) $('studyPerPage').value = study.perPage;
          if ($('studyPageFrom')) $('studyPageFrom').value = (typeof study.startPage === 'number' ? study.startPage : '');
          if ($('studyPageTo')) $('studyPageTo').value = (typeof study.endPage === 'number' ? study.endPage : '');
          if ($('statTotal')) {
            let label = String(study.total);
            if (typeof study.startPage === 'number' && typeof study.endPage === 'number') {
              label += ` (${study.startPage}〜${study.endPage})`;
            }
            $('statTotal').textContent = label;
          }
          if ($('statRemain')) $('statRemain').textContent = Math.max(0, study.total - study.completed.length);
          if ($('statProgress')) {
            const p = study.total > 0 ? Math.round(study.completed.length / study.total * 100) : 0;
            $('statProgress').textContent = p + '%';
          }
          if ($('statTime')) {
            const remainTime = Math.max(0, (study.total - study.completed.length) * study.perPage);
            $('statTime').textContent = remainTime + '分';
          }
          const log = $('studyLog'); if (log) {
            log.innerHTML = '';
            for (let i = 0; i < study.total; i++) {
              const item = document.createElement('div'); item.className = 'page-btn';
              const done = study.completed.includes(i);
              if (done) item.classList.add('completed');
              const icon = document.createElement('div'); icon.textContent = done ? '✅' : '⬜'; icon.style.fontSize = '20px'; icon.style.marginBottom = '4px';
              const txt = document.createElement('div'); txt.textContent = `${studyPageNumber(i)}`; txt.style.fontSize = '12px'; txt.style.fontWeight = '600';
              item.appendChild(icon); item.appendChild(txt);
              item.onclick = () => { togglePage(i); };
              log.appendChild(item);
            }
          }
          if ($('pageCompleteBtn')) setCompleteBtnText();
        }
        function togglePage(i) {
          if (study.completed.includes(i)) {
            study.completed = study.completed.filter(x => x !== i);
          } else {
            study.completed.push(i);
          }
          updateStudyStats();
        }
        function generateStudy(mode) {
          const modeKind = mode || 'count';
          // 既存の学習イベントを掃除してから安定配置
          NLStore.events = NLStore.events.filter(ev => ev.kind !== "study");
          let total = parseInt(($('studyTotal') || { value: 20 }).value, 10);
          const per = clamp(parseInt(($('studyPerPage') || { value: 5 }).value, 10) || 5, 1, 360);
          const fromEl = $('studyPageFrom');
          const toEl = $('studyPageTo');
          const fromVal = fromEl && fromEl.value !== '' ? parseInt(fromEl.value, 10) : NaN;
          const toVal = toEl && toEl.value !== '' ? parseInt(toEl.value, 10) : NaN;
          const useRange = (modeKind === 'range') && Number.isFinite(fromVal) && Number.isFinite(toVal) && toVal >= fromVal;
          if (modeKind === 'range' && !useRange) {
            alert('ページ範囲の入力が正しくありません（開始と終了を確認してください）。');
            return;
          }
          if (useRange) {
            total = toVal - fromVal + 1;
            if ($('studyTotal')) $('studyTotal').value = total;
            study.startPage = fromVal;
            study.endPage = toVal;
          } else {
            if (!Number.isFinite(total) || total <= 0) {
              alert('総ページ数を正しく入力してください。');
              return;
            }
            study.startPage = null;
            study.endPage = null;
          }
          study.total = total; study.perPage = per; study.completed = [];
          // 現在から順に、休憩などの考慮なしのシンプル連続割付（安定）
          const palette = ['#4da3ff', '#51cf66', '#ffd43b', '#a78bfa', '#fb7185', '#38bdf8', '#fb923c'];
          let cursor = (window.__getNow ? window.__getNow() : (window.__getNow ? window.__getNow() : new Date())); cursor.setSeconds(0, 0);
          const newIds = [];
          const batchKey = Date.now();
          for (let i = 0; i < total; i++) {
            const start = new Date(cursor.getTime());
            const end = new Date(cursor.getTime() + per * 60000);
            const labelNum = studyPageNumber(i);
            const label = String(labelNum);
            const ev = NLStore.addAbs(start, end, label, palette[i % palette.length], "study");
            if (ev) {
              ev.pageKey = `page-${batchKey}-${i}`;
              ev.pageIndex = i;
              ev.pageNumber = labelNum;
              const currentBookId = (typeof book !== 'undefined' && book?.id) ? book.id : (viewerMemory?.book?.id || null);
              const currentBookTitle = (typeof book !== 'undefined' && book?.title) ? book.title : '';
              if (!ev.bookId && currentBookId) ev.bookId = currentBookId;
              if (!ev.bookTitle && currentBookTitle) ev.bookTitle = currentBookTitle;
            }
            if (ev && ev.id) newIds.push(ev.id);
            cursor = new Date(end.getTime());
          }
          NLStore.save();
          // 勉強管理を有効化し、生成したIDを登録
          if (window.StudyStart) { StudyStart(newIds); } else { if (window.StudyMgr) { StudyMgr.active = true; StudyMgr.pageIds = newIds; try { StudyMgr.delay = {}; } catch (e) { } StudyMgr.save && StudyMgr.save(); } }
          updateStudyStats();
          drawPlanner(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
          try { scheduleStudyWatchdog(); } catch (e) { }

          nlRebuildAll(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
          try { scheduleStudyWatchdog(); } catch (e) { }
          updateOverallStudyUI(); if (window.__startOverallTicker) window.__startOverallTicker();
          notify('📚 学習予定を生成しました（安定版）');
        }
        function notify(msg) {
          const n = document.createElement('div');
          n.className = 'notification'; n.textContent = msg;
          document.body.appendChild(n);
          setTimeout(() => n.remove(), 2500);
        }

        // ============== デジタル時計（そのまま） ==============
        function updateDigital(nowOverride) {
          const d = nowOverride || now();
          const h = d.getHours(), m = pad2(d.getMinutes()), s = pad2(d.getSeconds());
          if ($('digitalTime')) $('digitalTime').textContent = `${h}:${m}:${s}`;
        }
        // Shift Turbo: reduce heavy UI during高速ページ送り
        let __shiftTurbo = false;
        let __pageTurboActive = false;
        document.addEventListener('keydown', (e) => { if (e.key === 'Shift') __shiftTurbo = true; });
        document.addEventListener('keyup', (e) => { if (e.key === 'Shift') __shiftTurbo = false; });

        // ============== イベント: タブ・ボタン結線 ==============

        // ===== 勉強管理（ページ進行／強制終了） =====
        const STUDY_LS_KEY = 'STUDY_MGR';
        const StudyMgr = {
          active: false,
          delay: {},
          pageIds: [], // NLStore上のイベントID配列（順序）
          doneHistory: [], // 完了済みスナップショット
          __intentionalEnd: false, // 意図的に終了したフラグ
          restoreFromDelay(nowMs) {
            try {
              if (!this.active || !Array.isArray(this.pageIds) || !this.pageIds.length) return;
              const ts = Number.isFinite(nowMs) ? nowMs : (typeof studyNowMs === 'function' ? studyNowMs() : Date.now());
              const eventsSrc = (NLStore && Array.isArray(NLStore.events)) ? NLStore.events : [];
              const ids = this.pageIds.slice();
              const events = ids.map(id => eventsSrc.find(e => e && e.id === id)).filter(Boolean);
              if (!events.length) return;
              let cursor = Math.floor(ts / 60000) * 60000;
              events.forEach(ev => {
                const info = this.delay?.[ev.id] || {};
                const baseDur = Math.max(60000, info.baseDurationMs ?? (info.baseEnd ? info.baseEnd - ev.start : ev.end - ev.start));
                const times = Math.max(0, Number.isFinite(info.times) ? info.times : 0);
                const dur = baseDur + times * 60000;
                ev.start = cursor;
                ev.end = cursor + dur;
                cursor = ev.end;
              });
              NLStore.save();
            } catch (_) { }
          },
          pruneDelay() {
            if (!this.delay) return;
            const live = new Set(this.pageIds || []);
            Object.keys(this.delay).forEach(id => {
              if (!live.has(id)) { try { delete this.delay[id]; } catch (_) { } }
            });
          },
          load() {
            try {
              const o = JSON.parse(localStorage.getItem(STUDY_LS_KEY) || '{}');
              this.active = !!o.active;
              this.pageIds = Array.isArray(o.pageIds) ? o.pageIds : [];
              this.delay = (o.delay && typeof o.delay === 'object') ? o.delay : {};
              this.doneHistory = Array.isArray(o.doneHistory) ? o.doneHistory : [];
              this.__intentionalEnd = !!o.__intentionalEnd; // 永続化から復元
            } catch (e) { this.active = false; this.pageIds = []; this.doneHistory = []; this.__intentionalEnd = false; }
            this.pruneDelay();
            // リロード後に study 用イベントが残っている場合は自動復帰（意図的終了は除外）
            if (!this.__intentionalEnd && (!this.active || !this.pageIds.length)) {
              const studyIds = (Array.isArray(NLStore?.events) ? NLStore.events.filter(ev => ev && (ev.kind === 'study' || (typeof ev.pageKey === 'string' && ev.pageKey.startsWith('todo-')))).map(ev => ev.id) : []);
              if (studyIds.length) {
                // 開始時刻順に並べて復元
                const sorted = studyIds
                  .map(id => NLStore.events.find(e => e && e.id === id))
                  .filter(Boolean)
                  .sort((a, b) => (a.start || 0) - (b.start || 0))
                  .map(ev => ev.id);
                this.pageIds = sorted;
                this.active = true;
                this.pruneDelay();
                try { this.save(); } catch (_) { }
              }
            }
            // 延長状態を保持したまま時刻ベースで再構成（studyNowMsが未定義ならDate.nowを使用）
            const nlLoading = (typeof isNLStoreLoading === 'function') ? isNLStoreLoading() : false;
            if (this.active && Array.isArray(this.pageIds) && this.pageIds.length && !nlLoading) {
              const ts = (typeof studyNowMs === 'function') ? studyNowMs() : Date.now();
              this.restoreFromDelay(ts);
            }
          },
          save() {
            localStorage.setItem(STUDY_LS_KEY, JSON.stringify({
              active: this.active,
              pageIds: this.pageIds,
              delay: this.delay,
              doneHistory: this.doneHistory || [],
              __intentionalEnd: this.__intentionalEnd // 永続化に保存
            }));
          },
          isStudyEvent(ev) { return ev && this.pageIds.includes(ev.id); },
          currentAndNext(nowMs) {
            // 現在進行中ページ and その次のページindex
            const ids = Array.isArray(this.pageIds) ? this.pageIds : [];
            const eventsSrc = (NLStore && Array.isArray(NLStore.events)) ? NLStore.events : [];
            const nlLoading = (typeof isNLStoreLoading === 'function') ? isNLStoreLoading() : false;
            if (nlLoading && eventsSrc.length === 0 && ids.length > 0) {
              return { events: [], curIdx: -1, nextIdx: -1 };
            }
            const events = ids.map(id => eventsSrc.find(e => e && e.id === id)).filter(Boolean);
            if (events.length !== ids.length) {
              this.pageIds = events.map(ev => ev.id);
              if (events.length === 0) { this.active = false; }
              try { this.save && this.save(); } catch (_) { }
            }
            if (events.length === 0) { return { events: [], curIdx: -1, nextIdx: -1 }; }
            let curIdx = -1;
            for (let i = 0; i < events.length; i++) {
              const ev = events[i];
              if (ev.start <= nowMs && nowMs < ev.end) { curIdx = i; break; }
              if (nowMs <= ev.start) { curIdx = i - 1; break; }
            }
            if (curIdx === -1 && events.length > 0 && nowMs < events[0].start) { curIdx = -1; }

            // 追加: すべて過去に流れてしまった場合は最後のページを対象にする
            if (curIdx === -1 && events.length > 0 && nowMs >= events[events.length - 1].end) { curIdx = events.length - 1; }
            return { events, curIdx, nextIdx: Math.min(curIdx + 1, events.length - 1) };

          },
          /** 自動延長: ページ完了が押されず終了を迎えたら1分ずつ延長し、後続も1分スライド */
          autoExtendIfNeeded(nowMs) {
            if (!this.active) {
              // 意図的に終了した場合は自動復元しない
              if (this.__intentionalEnd) return;
              const reviveIds = (Array.isArray(NLStore?.events) ? NLStore.events.filter(ev => ev && ev.kind === 'study').map(ev => ev.id) : []);
              if (reviveIds.length) {
                this.active = true;
                this.pageIds = reviveIds;
                this.pruneDelay();
                try { this.save && this.save(); } catch (_) { }
              } else {
                return;
              }
            }
            const ctx = this.currentAndNext(nowMs);
            if (!ctx || ctx.curIdx < 0) return;
            const ev = ctx.events[ctx.curIdx];
            if (!ev) return;
            if (isBreakEvent(ev)) return;
            // 初期化
            if (!this.delay) this.delay = {};
            const st = this.delay[ev.id] || { next: null, times: 0 };
            // baseEnd が抜けている旧データを補正（times分だけ巻き戻す）
            if (!('baseEnd' in st)) {
              st.baseEnd = Math.max(ev.start, ev.end - Math.max(0, st.times || 0) * 60000);
              st.baseDurationMs = Math.max(60000, st.baseEnd - ev.start);
            } else if (!('baseDurationMs' in st)) {
              st.baseDurationMs = Math.max(60000, st.baseEnd - ev.start);
            }
            // 終了に達していなければ何もしない
            if (nowMs < ev.end) { return; }
            const firstExtend = st.times === 0;
            if (firstExtend) {
              try { window.SoundMgr && SoundMgr.trigger("study.extend.start"); } catch (e) { }
            }
            // まだ1回も設定されていない or 次の延長タイミングを超えたら延長
            while (st.next === null || nowMs >= st.next) {
              const shift = 60000; // 1分
              ev.end += shift; try { window.SoundMgr && SoundMgr.trigger("study.extend.tick"); } catch (e) { }
              // 後続の学習イベントを連鎖スライド
              for (let i = ctx.curIdx + 1; i < ctx.events.length; i++) {
                const e2 = ctx.events[i];
                if (!e2) continue;
                e2.start += shift; e2.end += shift;
              }
              st.times += 1;
              st.next = (st.next === null ? nowMs : st.next) + shift;
            }
            this.delay[ev.id] = st;
            NLStore.save();
            try {
              drawPlanner(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
              try { scheduleStudyWatchdog(); } catch (e) { }
            } catch (e) { }
            try {
              nlRebuildAll(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
              try { scheduleStudyWatchdog(); } catch (e) { }
            } catch (e) { }
            try {
              StudyUI.update(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
              try { scheduleStudyWatchdog(); } catch (e) { }
            } catch (e) { }
            try { this.save && this.save(); } catch (_) { }
          },
          completePageNow() {
            if (!this.active) return;
            const nowMs = Date.now();
            const findEvent = (id) => NLStore.events.find(e => e.id === id);
            const endedIds = this.pageIds.filter(id => { const ev = findEvent(id); return ev && ev.end <= nowMs; });
            let currentId = null;
            for (const id of this.pageIds) {
              const ev = findEvent(id);
              if (ev && ev.start <= nowMs && nowMs < ev.end) { currentId = id; break; }
            }
            const animateIds = Array.from(new Set([...endedIds, currentId].filter(Boolean)));
            const animateBarsPoof = () => {
              if (!animateIds.length) return;
              document.querySelectorAll('.nl-bar').forEach(bar => {
                if (animateIds.includes(bar.dataset.evId)) {
                  bar.classList.add('nl-bar-poof');
                  makeBarPoof(bar);
                }
              });
            };
            const animateDrop = () => {
              requestAnimationFrame(() => {
                const bars = Array.from(document.querySelectorAll('.nl-bar'));
                bars.forEach((bar, idx) => {
                  bar.classList.add('nl-bar-drop');
                  bar.style.setProperty('--nl-drop-delay', `${idx * 18}ms`);
                  setTimeout(() => bar.classList.remove('nl-bar-drop'), 1100);
                });
              });
            };

            const doComplete = () => {
              const pushHistory = (ev) => {
                if (!ev) return;
                const snap = {
                  id: ev.id,
                  title: ev.title,
                  start: ev.start,
                  end: ev.end,
                  color: ev.color,
                  pageNumber: ev.pageNumber,
                  todoId: ev.todoId,
                  kind: ev.kind || 'study'
                };
                this.doneHistory = [snap, ...(Array.isArray(this.doneHistory) ? this.doneHistory : [])].slice(0, 120);
              };
              // 0) 現時点までに完了したページをすべて削除（履歴も消す）
              let keptIds = [];
              for (const id of this.pageIds) {
                const ev = NLStore.events.find(e => e.id === id);
                if (!ev) continue;
                if (ev.end <= nowMs) {
                  // 完了済み → 履歴へ残しつつ削除
                  try { pushHistory(ev); if (window.TodoUI && TodoUI.completeFromEvent) TodoUI.completeFromEvent(ev); } catch (_) { }
                  try { if (ev.bookId && Number.isFinite(ev.pageNumber)) window.__clearPageProgress?.(ev.bookId, ev.pageNumber); } catch (_) { }
                  NLStore.events = NLStore.events.filter(e => e.id !== id);
                  try { if (this.delay) delete this.delay[id]; } catch (_) { }
                } else {
                  keptIds.push(id);
                }
              }
              this.pageIds = keptIds;
              // 1) 進行中ページを特定し、押した瞬間に「完了」として削除する
              let curIdx = -1;
              for (let i = 0; i < this.pageIds.length; i++) {
                const ev = NLStore.events.find(e => e.id === this.pageIds[i]);
                if (ev && ev.start <= nowMs && nowMs < ev.end) { curIdx = i; break; }
              }
              if (curIdx >= 0) {
                const curId = this.pageIds[curIdx];
                try {
                  const watcher = window.__studySoundWatcher;
                  if (watcher && typeof watcher.markManualComplete === 'function') {
                    watcher.markManualComplete(curId);
                  } else if (window.SoundMgr && SoundMgr.trigger) {
                    SoundMgr.trigger('study.session.done');
                  }
                } catch (_) { }
                const ev = NLStore.events.find(e => e.id === curId);
                try { if (ev) { pushHistory(ev); if (window.TodoUI && TodoUI.completeFromEvent) TodoUI.completeFromEvent(ev); } } catch (_) { }
                try { if (ev?.bookId && Number.isFinite(ev.pageNumber)) window.__clearPageProgress?.(ev.bookId, ev.pageNumber); } catch (_) { }
                NLStore.events = NLStore.events.filter(e => e.id !== curId);
                try { delete this.delay[curId]; } catch (e) { }
                this.pageIds.splice(curIdx, 1);
              }
              this.pruneDelay();
              // 2) 残りを now から順に詰める
              let t = Math.floor(nowMs / 60000) * 60000;
              for (const id of this.pageIds) {
                const ev = NLStore.events.find(e => e.id === id);
                if (!ev) continue;
                const durRaw = Math.max(60000, ev.end - ev.start);
                const dur = Math.max(60000, Math.round(durRaw / 60000) * 60000);
                ev.start = t; ev.end = t + dur; t = ev.end;
              }
              if (this.pageIds.length === 0) { this.active = false; }
              NLStore.save();
              try { const x = ['plannerDelayBadge', 'nlDelayBadge', 'plDelayInline', 'nlDelayInline']; x.forEach(id => { const el = document.getElementById(id); if (el) el.remove(); }); } catch (e) { }
              drawPlanner(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
              try { scheduleStudyWatchdog(); } catch (e) { }
              nlRebuildAll(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
              try { scheduleStudyWatchdog(); } catch (e) { }

              StudyUI.update(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
              try { scheduleStudyWatchdog(); } catch (e) { }

              setCompleteBtnText();
              try { StudyActionMenu && StudyActionMenu.refresh && StudyActionMenu.refresh(); } catch (_) { }
              try { ReaderHpBar && ReaderHpBar.update && ReaderHpBar.update(studyNowMs()); } catch (_) { }
              try { StudyHpOverlay && StudyHpOverlay.update && StudyHpOverlay.update(studyNowMs()); } catch (_) { }
              this.save();
              animateDrop();
              try {
                refreshPlannerFlyClock();
                renderNumberlineFly();
                drawTimerArcs();
                nlRenderTimerOverlays && nlRenderTimerOverlays();
              } catch (_) { }
            };

            if (animateIds.length) {
              animateBarsPoof();
              setTimeout(doComplete, 520);
            } else {
              doComplete();
            }
          },
          forceEnd(opts = {}) {
            // 関連イベント削除・状態クリア
            const isStudyEv = (ev) => {
              if (!ev) return false;
              if (this.pageIds.includes(ev.id)) return true;
              // Fix: Do not blindly delete all 'study' events. Only delete current session items.
              // if (ev.kind === 'study') return true; 
              if (this.pageIds.includes(ev.id)) return true;
              // Fix: Do not blindly delete all 'study' events. Only delete current session items.
              // if (ev.kind === 'study') return true; 
              if (ev.todoId && this.pageIds.includes(ev.id)) return true;
              if (typeof ev.pageKey === 'string' && ev.pageKey.startsWith('todo-')) return true;
              return false;
            };
            const before = NLStore.events.length;
            NLStore.events = NLStore.events.filter(ev => !isStudyEv(ev));
            NLStore.save();
            // Mark as intentionally ended to prevent auto-recovery
            if (!opts.keepIntentional) this.__intentionalEnd = true;
            this.active = false; this.pageIds = []; this.delay = {}; this.doneHistory = []; this.save();
            try { ReaderHpBar && ReaderHpBar.hide && ReaderHpBar.hide(); } catch (_) { }
            try { startStudyHardWatch(); } catch (_) { }
            drawPlanner(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
            try { scheduleStudyWatchdog(); } catch (e) { }
            nlRebuildAll(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
            try { scheduleStudyWatchdog(); } catch (e) { }

            StudyUI.update(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
            try { scheduleStudyWatchdog(); } catch (e) { }

            setCompleteBtnText();
            try { StudyActionMenu && StudyActionMenu.refresh && StudyActionMenu.refresh(); } catch (_) { }
            const silentToast = !!opts.silentToast;
            if (!silentToast && typeof showToast === 'function') {
              showToast(before === NLStore.events.length ? 'リセット対象の予定はありません' : '予定を全てリセットしました', 'info');
            }
          }
        };
        StudyMgr.load();
        // window経由の参照が多いので公開しておく
        window.StudyMgr = StudyMgr;

        const hasActiveStudySchedule = () => {
          if (!StudyMgr || !StudyMgr.active) return false;
          const hasIds = Array.isArray(StudyMgr.pageIds) && StudyMgr.pageIds.length > 0;
          if (!hasIds) return false;
          const hasEvents = Array.isArray(NLStore?.events) && NLStore.events.some(ev => StudyMgr.pageIds?.includes(ev.id));
          const nlLoading = (typeof isNLStoreLoading === 'function') ? isNLStoreLoading() : false;
          if (!hasEvents && !nlLoading) return false;
          return true;
        };
        const completeCurrentBookPage = () => {
          const mem = (typeof viewerMemory !== 'undefined') ? viewerMemory : null;
          const currentBook = mem?.book?.ref || null;
          const pageIndex = Number.isFinite(mem?.book?.page) ? mem.book.page : null;
          if (!currentBook || mem?.book?.closed) return false;
          if (!Array.isArray(currentBook.pages) || !Number.isFinite(pageIndex)) return false;
          const pageMeta = currentBook.pages[pageIndex];
          if (!pageMeta) return false;
          const realPage = (() => {
            if (Array.isArray(currentBook.pageNumberMap)) {
              const mapped = currentBook.pageNumberMap[pageIndex];
              if (Number.isFinite(mapped)) return mapped;
            }
            const base = Number.isFinite(currentBook.firstPageNumber)
              ? currentBook.firstPageNumber
              : parseInt(currentBook.firstPageNumber || '1', 10) || 1;
            return base + pageIndex;
          })();
          if (!Number.isFinite(realPage)) return false;
          const sourceBookId = pageMeta?._sourceBookId || currentBook.id;
          const sourceTitle = pageMeta?._sourceTitle || currentBook.title || '本';
          const todos = (typeof TodoStore !== 'undefined' && TodoStore && typeof TodoStore.all === 'function')
            ? TodoStore.all()
            : (window.TodoStore?.all?.() || []);
          let didTodoUpdate = false;
          if (Array.isArray(todos) && todos.length) {
            const bookId = sourceBookId != null ? String(sourceBookId) : '';
            const bookTitle = sourceTitle ? String(sourceTitle) : '';
            todos.forEach(todo => {
              if (!todo || !Array.isArray(todo.pages)) return;
              const todoBookId = todo.bookId != null ? String(todo.bookId) : '';
              const matchesBook = (todoBookId && bookId && todoBookId === bookId)
                || (!todoBookId && todo.bookTitle && bookTitle && todo.bookTitle === bookTitle);
              if (!matchesBook) return;
              const pageList = todo.pages.map(p => parseInt(p, 10)).filter(Number.isFinite);
              if (!pageList.includes(realPage)) return;
              const doneSet = new Set((todo.completedPages || []).map(p => parseInt(p, 10)).filter(Number.isFinite));
              if (!doneSet.has(realPage)) {
                try { TodoStore.togglePage(todo.id, realPage); didTodoUpdate = true; } catch (_) { }
              }
            });
          }
          if (didTodoUpdate && window.TodoUI?.render) {
            try { TodoUI.render(); } catch (_) { }
          }
          const stDoneEl = document.getElementById('stDone');
          let appliedByCheckbox = false;
          if (stDoneEl && !currentBook._ephemeral && !stDoneEl.checked) {
            stDoneEl.checked = true;
            try { stDoneEl.onchange?.(); appliedByCheckbox = true; } catch (_) { appliedByCheckbox = false; }
          }
          if (!appliedByCheckbox && !currentBook._ephemeral) {
            const state = pageMeta.state || (pageMeta.state = { fav: false, weak: false, done: false, extra: [] });
            if (!Array.isArray(state.extra)) state.extra = [];
            if (!state.done) {
              state.done = true;
              try { Book?.put?.(currentBook); } catch (_) { }
            }
          }
          const needsRecord = !appliedByCheckbox;
          if (needsRecord && window.StudyCalendar?.recordCompletion) {
            try { StudyCalendar.recordCompletion(sourceBookId, realPage, sourceTitle); } catch (_) { }
          }
          if (needsRecord && typeof window.__clearPageProgress === 'function') {
            try { window.__clearPageProgress(sourceBookId, realPage); } catch (_) { }
          }
          return true;
        };
        const handlePlannerCompleteClick = () => {
          if (hasActiveStudySchedule()) {
            StudyMgr.completePageNow();
            return;
          }
          completeCurrentBookPage();
        };

        // ===== UI層（表示/非表示と文言更新） =====
        const StudyUI = {
          ensureButtons() {
            // 既存の planner 用ボタン（#pageCompleteBtn）を流用
            const pc = document.getElementById('pageCompleteBtn');
            if (pc && !pc.dataset.bound) { pc.dataset.bound = '1'; pc.onclick = () => handlePlannerCompleteClick(); }
            // 数直線パネルの下に専用ボタンを用意
            if (!document.getElementById('studyCtlNL')) {
              const rows = document.getElementById('nlRows');
              if (rows) {
                const bar = document.createElement('div');
                bar.id = 'studyCtlNL';
                bar.style.display = 'none';
                bar.style.margin = '8px 0 4px 80px';
                bar.style.display = 'flex'; bar.style.gap = '8px'; bar.style.alignItems = 'center';
                bar.innerHTML = `
            <button id=\"nlCompleteBtn\" class=\"btn small\">📖 ページ完了 0/0</button>
            
          `;
                rows.parentNode.insertBefore(bar, rows);
                document.getElementById('nlCompleteBtn').onclick = () => handlePlannerCompleteClick();

              }
            }
            // プランナー上にも小さな強制終了ボタンを追加（既存完了ボタンの横）
          },
          update() {
            this.ensureButtons();
            if (StudyMgr.active) {
              const hasIds = Array.isArray(StudyMgr.pageIds) && StudyMgr.pageIds.length > 0;
              const hasEvents = Array.isArray(NLStore?.events) && NLStore.events.some(ev => StudyMgr.pageIds?.includes(ev.id));
              const nlLoading = (typeof isNLStoreLoading === 'function') ? isNLStoreLoading() : false;
              if (!hasIds || (!hasEvents && !nlLoading)) {
                StudyMgr.active = false;
                try { StudyMgr.delay = {}; StudyMgr.pruneDelay(); StudyMgr.save && StudyMgr.save(); } catch (_) { }
                StudyMgr.save && StudyMgr.save();
              }
            }
            const pc = document.getElementById('pageCompleteBtn');
            const pForce = document.getElementById('plannerForceBtn');
            const nlBar = document.getElementById('studyCtlNL');
            if (StudyMgr.active) {
              if (pc) { pc.style.display = 'inline-flex'; }
              if (pForce) { pForce.style.display = 'inline-flex'; }
              if (nlBar) { nlBar.style.display = 'flex'; }
              // 進捗表示 (x/y)
              const total = StudyMgr.pageIds.length;
              let done = 0; const nowMs = Date.now();
              for (const id of StudyMgr.pageIds) {
                const ev = NLStore.events.find(e => e.id === id);
                if (ev && ev.end <= nowMs) done++;
              }
              setCompleteBtnText();
            } else {
              if (pc) { pc.style.display = 'inline-flex'; }
              if (pForce) { pForce.style.display = 'none'; }
              if (nlBar) { nlBar.style.display = 'none'; }
              setCompleteBtnText();
            }
          }
        };
        // ===== ToDo リスト（プランナー内） - IndexedDB版 =====
        // TodoDB: IndexedDB helper for todos
        const TodoDB = {
          dbName: 'TodoStoreDB',
          storeName: 'todos',
          archivedStoreName: 'archived',
          version: 1,
          db: null,
          async open() {
            if (this.db) return this.db;
            return new Promise((resolve, reject) => {
              const req = indexedDB.open(this.dbName, this.version);
              req.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains(this.storeName)) {
                  db.createObjectStore(this.storeName, { keyPath: 'id' });
                }
                if (!db.objectStoreNames.contains(this.archivedStoreName)) {
                  db.createObjectStore(this.archivedStoreName, { keyPath: 'id' });
                }
              };
              req.onsuccess = (e) => {
                this.db = e.target.result;
                // Handle version change (when another tab upgrades DB)
                this.db.onversionchange = () => {
                  console.warn('[TodoDB] Database version changed, closing connection');
                  this.db.close();
                  this.db = null;
                };
                // Handle unexpected close
                this.db.onclose = () => {
                  console.warn('[TodoDB] Database connection closed unexpectedly');
                  this.db = null;
                };
                resolve(this.db);
              };
              req.onerror = () => reject(req.error);
              req.onblocked = () => {
                console.warn('[TodoDB] Database open blocked, another connection may be holding it open');
              };
            });
          },
          async loadAll() {
            try {
              const db = await this.open();
              return new Promise((resolve, reject) => {
                const tx = db.transaction(this.storeName, 'readonly');
                const store = tx.objectStore(this.storeName);
                const req = store.getAll();
                req.onsuccess = () => resolve(req.result || []);
                req.onerror = () => reject(req.error);
              });
            } catch (e) { return []; }
          },
          async loadArchived() {
            try {
              const db = await this.open();
              return new Promise((resolve, reject) => {
                const tx = db.transaction(this.archivedStoreName, 'readonly');
                const store = tx.objectStore(this.archivedStoreName);
                const req = store.getAll();
                req.onsuccess = () => resolve(req.result || []);
                req.onerror = () => reject(req.error);
              });
            } catch (e) { return []; }
          },
          async saveAll(todos) {
            try {
              const db = await this.open();
              return new Promise((resolve, reject) => {
                const tx = db.transaction(this.storeName, 'readwrite');
                const store = tx.objectStore(this.storeName);
                // Safer approach: delete only what's not in new todos, then put all
                const getAllReq = store.getAllKeys();
                getAllReq.onsuccess = () => {
                  const existingIds = new Set(getAllReq.result || []);
                  const newIds = new Set(todos.map(t => t.id));
                  existingIds.forEach(id => {
                    if (!newIds.has(id)) {
                      store.delete(id);
                    }
                  });
                  todos.forEach(t => store.put(t));
                };
                getAllReq.onerror = () => {
                  todos.forEach(t => store.put(t));
                };
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
              });
            } catch (e) { console.error('[TodoDB] saveAll failed:', e); }
          },
          async saveArchived(todos) {
            try {
              const db = await this.open();
              return new Promise((resolve, reject) => {
                const tx = db.transaction(this.archivedStoreName, 'readwrite');
                const store = tx.objectStore(this.archivedStoreName);
                // Safer approach: delete only what's not in new archived todos
                const getAllReq = store.getAllKeys();
                getAllReq.onsuccess = () => {
                  const existingIds = new Set(getAllReq.result || []);
                  const newIds = new Set(todos.map(t => t.id));
                  existingIds.forEach(id => {
                    if (!newIds.has(id)) {
                      store.delete(id);
                    }
                  });
                  todos.forEach(t => store.put(t));
                };
                getAllReq.onerror = () => {
                  todos.forEach(t => store.put(t));
                };
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
              });
            } catch (e) { console.error('[TodoDB] saveArchived failed:', e); }
          },
          async clear() {
            try {
              const db = await this.open();
              await new Promise((resolve, reject) => {
                const tx = db.transaction([this.storeName, this.archivedStoreName], 'readwrite');
                tx.objectStore(this.storeName).clear();
                tx.objectStore(this.archivedStoreName).clear();
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
              });
            } catch (e) { console.error('[TodoDB] clear failed:', e); }
          }
        };

        const TodoStore = (function () {
          const KEY = 'planner_todos_v1';
          let list = [];
          let archived = [];
          let _initialized = false;
          let _saveQueued = false;

          function normalize(item) {
            if (!item) return null;
            const pagesRaw = Array.isArray(item.pages) ? item.pages : [];
            const pages = pagesRaw.map(n => parseInt(n, 10)).filter(n => Number.isFinite(n) && n > 0);
            const uniqPages = Array.from(new Set(pages)).sort((a, b) => a - b);
            const donePagesRaw = Array.isArray(item.completedPages) ? item.completedPages : [];
            const donePages = Array.from(new Set(donePagesRaw.map(n => parseInt(n, 10)).filter(n => uniqPages.includes(n))));
            const autoDone = uniqPages.length > 0 && donePages.length >= uniqPages.length;
            return {
              id: item.id || ('todo-' + Date.now().toString(36) + '-' + Math.random().toString(16).slice(2)),
              title: (item.title || '無題タスク').trim(),
              kind: item.kind || 'problem',
              due: item.due || '',
              dueTime: item.dueTime || '',
              perPage: Math.max(1, parseInt(item.perPage, 10) || 5),
              note: item.note || '',
              bookId: item.bookId || '',
              bookTitle: item.bookTitle || '',
              pages: uniqPages,
              completedPages: donePages,
              createdAt: Number(item.createdAt) || Date.now(),
              done: !!item.done || autoDone,
              archived: !!item.archived,
              autoPlanMode: item.autoPlanMode || 'remaining',
              autoPageSource: item.autoPageSource || 'remaining',
              autoPlanAnchor: Number.isFinite(parseInt(item.autoPlanAnchor, 10)) ? parseInt(item.autoPlanAnchor, 10) : null,
              autoReplanOnVisit: !!item.autoReplanOnVisit,
              autoReplanStrategy: item.autoReplanStrategy || (item.autoPlanMode ? item.autoPlanMode : 'from-current')
            };
          }

          // Synchronous load from localStorage (initial/fallback)
          function loadFromLocalStorage() {
            try {
              const raw = localStorage.getItem(KEY);
              const arr = raw ? JSON.parse(raw) : [];
              if (Array.isArray(arr)) { list = arr.map(normalize).filter(Boolean); }
            } catch (e) { list = []; }
            try {
              const rawArch = localStorage.getItem(KEY + '_archived');
              const arrArch = rawArch ? JSON.parse(rawArch) : [];
              archived = Array.isArray(arrArch) ? arrArch.map(normalize).filter(Boolean) : [];
            } catch (e) { archived = []; }
          }

          // Async load from IndexedDB and merge/migrate
          async function loadFromIDB() {
            try {
              const [idbTodos, idbArchived] = await Promise.all([
                TodoDB.loadAll(),
                TodoDB.loadArchived()
              ]);

              if (!_initialized) {
                // Merge: prefer IndexedDB if it has data
                if (idbTodos.length > 0) {
                  const existingIds = new Set(list.map(t => t.id));
                  idbTodos.forEach(t => {
                    const norm = normalize(t);
                    if (norm && !existingIds.has(norm.id)) {
                      list.push(norm);
                    }
                  });
                }
                if (idbArchived.length > 0) {
                  const existingIds = new Set(archived.map(t => t.id));
                  idbArchived.forEach(t => {
                    const norm = normalize(t);
                    if (norm && !existingIds.has(norm.id)) {
                      archived.push(norm);
                    }
                  });
                }

                // Migrate localStorage data to IndexedDB
                if (list.length > 0 || archived.length > 0) {
                  await Promise.all([
                    TodoDB.saveAll(list),
                    TodoDB.saveArchived(archived)
                  ]);
                  // Clear localStorage to free up space
                  try {
                    localStorage.removeItem(KEY);
                    localStorage.removeItem(KEY + '_archived');
                    console.log('[TodoStore] Migrated to IndexedDB, cleared localStorage');
                  } catch (_) { }
                }
              }
              _initialized = true;
              try { window.dispatchEvent(new CustomEvent('todo:updated', { detail: { active: list.length, archived: archived.length } })); } catch (_) { }
            } catch (e) {
              console.warn('[TodoStore] IndexedDB load failed, using localStorage:', e);
              _initialized = true;
            }
          }

          function notifyTodoChange() {
            try { window.dispatchEvent(new CustomEvent('todo:updated', { detail: { active: list.length, archived: archived.length } })); } catch (_) { }
          }

          function save() {
            // Queue async save to IndexedDB
            if (!_saveQueued) {
              _saveQueued = true;
              setTimeout(() => saveAsync(), 100);
            }
          }

          async function saveAsync() {
            _saveQueued = false;
            try {
              await Promise.all([
                TodoDB.saveAll(list),
                TodoDB.saveArchived(archived)
              ]);
              console.log('[TodoStore] Saved to IndexedDB:', list.length, 'todos,', archived.length, 'archived');
              notifyTodoChange();
            } catch (e) {
              console.error('[TodoStore] IndexedDB save failed, falling back to localStorage:', e);
              // Fallback to localStorage
              try {
                localStorage.setItem(KEY, JSON.stringify(list));
                localStorage.setItem(KEY + '_archived', JSON.stringify(archived));
              } catch (lsErr) {
                console.error('[TodoStore] localStorage fallback also failed:', lsErr);
              }
              notifyTodoChange();
            }
          }

          // Synchronous flush for beforeunload
          function flushSync() {
            if (_saveQueued) {
              _saveQueued = false;
              try {
                localStorage.setItem(KEY, JSON.stringify(list));
                localStorage.setItem(KEY + '_archived', JSON.stringify(archived));
                console.log('[TodoStore] flushSync: Saved', list.length, 'todos,', archived.length, 'archived');
              } catch (e) {
                console.error('[TodoStore] flushSync failed:', e);
              }
            }
          }

          // Initial load (sync from localStorage, then async from IDB)
          loadFromLocalStorage();
          const readyPromise = loadFromIDB().then(() => { notifyTodoChange(); }).catch(() => { });

          return {
            ready() { return readyPromise; },
            all() { return list.slice(); },
            archived() { return archived.slice(); },
            upsert(item) {
              const norm = normalize(item);
              if (!norm) return null;
              const idx = list.findIndex(t => t.id === norm.id);
              if (idx >= 0) list[idx] = norm; else list.push(norm);
              save(); return norm;
            },
            update(id, patch) {
              const idx = list.findIndex(t => t.id === id);
              if (idx < 0) return null;
              const merged = Object.assign({}, list[idx], patch || {});
              list[idx] = normalize(merged);
              save(); return list[idx];
            },
            remove(id) {
              list = list.filter(t => t.id !== id);
              save();
            },
            archive(id) {
              const idx = list.findIndex(t => t.id === id);
              if (idx < 0) return;
              const item = list.splice(idx, 1)[0];
              archived.unshift(Object.assign({}, item, { archived: true }));
              save();
            },
            restore(id) {
              const idx = archived.findIndex(t => t.id === id);
              if (idx < 0) return null;
              const item = archived.splice(idx, 1)[0];
              let restored = Object.assign({}, item, { archived: false, done: false, completedPages: [] });
              restored = normalize(restored);
              list.unshift(restored);
              save();
              return restored;
            },
            purgeArchived(id) {
              if (id) { archived = archived.filter(t => t.id !== id); }
              else { archived = []; }
              save();
            },
            togglePage(id, page) {
              const todo = list.find(t => t.id === id);
              if (!todo) return null;
              const p = parseInt(page, 10);
              if (!Number.isFinite(p)) return todo;
              const has = todo.completedPages.includes(p);
              if (has) {
                todo.completedPages = todo.completedPages.filter(x => x !== p);
                todo.done = false;
              } else {
                todo.completedPages = [...todo.completedPages, p];
                if (todo.pages.length && todo.completedPages.length >= todo.pages.length) { todo.done = true; }
                // Record completion to StudyCalendar
                if (window.StudyCalendar?.recordCompletion) {
                  window.StudyCalendar.recordCompletion(todo.bookId, p, todo.bookTitle || todo.title);
                }
                try { window.StudyCalendar?.onTodoPageCompleted?.(todo.id, p); } catch (e) { console.warn('StudyCalendar sync failed', e); }
              }
              save(); return todo;
            },
            async importAll(activeList = [], archivedList = []) {
              list = (Array.isArray(activeList) ? activeList : []).map(normalize).filter(Boolean).map(t => Object.assign({}, t, { archived: false }));
              archived = (Array.isArray(archivedList) ? archivedList : []).map(normalize).filter(Boolean).map(t => Object.assign({}, t, { archived: true }));
              _initialized = true;
              _saveQueued = false;
              try {
                await TodoDB.saveAll(list);
                await TodoDB.saveArchived(archived);
              } catch (e) {
                console.warn('[TodoStore] importAll save failed, falling back to localStorage:', e);
                try {
                  localStorage.setItem(KEY, JSON.stringify(list));
                  localStorage.setItem(KEY + '_archived', JSON.stringify(archived));
                } catch (lsErr) {
                  console.error('[TodoStore] importAll localStorage fallback failed:', lsErr);
                }
              }
              return { active: list.length, archived: archived.length };
            },
            clear() {
              list = [];
              archived = [];
              TodoDB.clear().catch(() => { });
              try { localStorage.removeItem(KEY); localStorage.removeItem(KEY + '_archived'); } catch (_) { }
            },
            flushSync
          };
        })();
        // 他のモジュール（予定シート等）から参照できるよう公開
        window.TodoStore = TodoStore;

        const TodoUI = (function () {
          const VIEW_KEY = 'planner_todo_view';
          const SORT_KEY = 'planner_todo_sort';
          const FILTER_KEY = 'planner_todo_filter';
          let pageSelection = new Set();
          let selectionContext = 'form'; // form | edit
          let selectionBackup = null;
          let overlayPageMax = 1000;
          let overlayDrag = { sheet: null, start: null };
          let dragSelect = { active: false, todoId: null, mode: 'add' };
          let state = {
            view: loadPref(VIEW_KEY, 'cards'),
            sort: loadPref(SORT_KEY, 'due'),
            filterStatus: loadPref(FILTER_KEY, 'active'),
            filterKind: 'all',
            problemOnly: false,
            formVisible: false,
            pageOpen: new Set()
          };
          let bookCache = [];
          let lastRangePages = [];
          let showArchive = false;
          const waitForViewerReady = async (attempts = 8) => {
            for (let i = 0; i < attempts; i++) {
              await new Promise(res => setTimeout(res, i === 0 ? 16 : 80));
              if (document.getElementById('jumpInput')) return true;
            }
            return false;
          };
          function loadPref(key, fallback) {
            try { const v = localStorage.getItem(key); return v !== null ? v : fallback; } catch (_) { return fallback; }
          }
          function savePref(key, val) { try { localStorage.setItem(key, val); } catch (_) { } }
          function parsePages(str) {
            if (!str) return [];
            const parts = str.split(/[,、\s]+/).filter(Boolean);
            const pages = [];
            parts.forEach(seg => {
              const m = seg.split(/[-〜~]/).map(s => s.trim()).filter(Boolean);
              if (m.length === 1) {
                const n = parseInt(m[0], 10);
                if (Number.isFinite(n) && n > 0) pages.push(n);
              } else if (m.length >= 2) {
                const a = parseInt(m[0], 10), b = parseInt(m[1], 10);
                if (Number.isFinite(a) && Number.isFinite(b)) {
                  const start = Math.min(a, b), end = Math.max(a, b);
                  for (let i = start; i <= end; i++) pages.push(i);
                }
              }
            });
            return Array.from(new Set(pages)).sort((a, b) => a - b);
          }
          function setPageSelection(pages, opts = {}) {
            const arr = Array.isArray(pages) ? pages.slice() : [];
            pageSelection = new Set(arr.filter(n => Number.isFinite(n) && n > 0));
            const list = Array.from(pageSelection).sort((a, b) => a - b);
            const input = selectionContext === 'edit' ? $('todoEditRange') : $('todoRange');
            const label = selectionContext === 'edit' ? $('todoEditRangeCount') : $('todoRangeCount');
            if (input && !opts.preserveInput) {
              input.dataset.silent = '1';
              input.value = list.join(',');
              input.dataset.silent = '0';
            }
            updateRangePreview(label, input, list);
            renderPageBlocks();
            renderPageOverlay();
          }
          function syncSelectionFromInput(input) {
            if (!input || input.dataset.silent === '1') return;
            const parsed = parsePages(input.value);
            setPageSelection(parsed, { preserveInput: true });
          }
          function updateRangePreview(labelRef, inputRef, overridePages) {
            const label = labelRef || $('todoRangeCount');
            const input = inputRef || $('todoRange');
            if (!label) return;
            const pages = Array.isArray(overridePages) ? overridePages : parsePages(input?.value || '');
            lastRangePages = pages;
            label.textContent = `${pages.length}ページ`;
          }
          function renderPageBlocks() {
            const host = selectionContext === 'edit' ? $('todoEditPageBlocks') : $('todoPageBlocks');
            if (!host) return;
            const selected = pageSelection;
            const blocks = [];
            const baseCount = 120;
            for (let i = 1; i <= baseCount; i++) {
              const cls = ['page-block'];
              if (selected.has(i)) cls.push('selected');
              blocks.push(`<button class="${cls.join(' ')}" data-page="${i}">p${i}</button>`);
            }
            host.innerHTML = blocks.join('');
          }
          function renderPageOverlay() {
            const wrap = $('todoPageOverlayGrid');
            if (!wrap) return;
            const selected = pageSelection;
            const frag = [];
            const limit = Math.min(overlayPageMax, 1000);
            for (let i = 1; i <= limit; i++) {
              const cls = ['page-block'];
              if (selected.has(i)) cls.push('selected');
              frag.push(`<button class="${cls.join(' ')}" data-page="${i}">p${i}</button>`);
            }
            wrap.innerHTML = frag.join('');
          }
          function extendOverlayPages() {
            overlayPageMax = Math.min(overlayPageMax + 300, 1000);
            renderPageOverlay();
          }
          function togglePageSelection(page) {
            if (!Number.isFinite(page) || page <= 0) return;
            if (pageSelection.has(page)) pageSelection.delete(page);
            else pageSelection.add(page);
            const list = Array.from(pageSelection).sort((a, b) => a - b);
            const input = selectionContext === 'edit' ? $('todoEditRange') : $('todoRange');
            if (input) {
              input.dataset.silent = '1';
              input.value = list.join(',');
              input.dataset.silent = '0';
            }
            const label = selectionContext === 'edit' ? $('todoEditRangeCount') : $('todoEditRangeCount');
            updateRangePreview(label, input, list);
            renderPageBlocks();
            renderPageOverlay();
          }
          function clearForm() {
            if ($('todoTitle')) $('todoTitle').value = '';
            if ($('todoRange')) $('todoRange').value = '';
            if ($('todoNote')) $('todoNote').value = '';
            if ($('todoDue')) {
              const d = new Date();
              $('todoDue').value = d.toISOString().slice(0, 10);
            }
            if ($('todoDueTime')) $('todoDueTime').value = '';
            if ($('todoBookSearch')) $('todoBookSearch').value = '';
            if ($('todoBookSelect')) $('todoBookSelect').value = '';
            pageSelection = new Set();
            updateRangePreview();
            renderPageBlocks();
            renderPageOverlay();
          }
          function setFormVisible(v) {
            state.formVisible = !!v;
            const card = $('todoFormCard');
            if (card) {
              card.classList.toggle('collapsed', !state.formVisible);
            }
            const toggleBtn = $('todoToggleForm');
            if (toggleBtn) {
              toggleBtn.textContent = state.formVisible ? '− フォームを隠す' : '＋ 追加フォーム';
            }
            if (state.formVisible) {
              selectionContext = 'form';
              const due = $('todoDue');
              if (due && !due.value) {
                const d = new Date();
                due.value = d.toISOString().slice(0, 10);
              }
              const time = $('todoDueTime');
              if (time && !time.value) { time.value = ''; }
              renderPageBlocks();
            }
          }
          function quickDue(days) {
            const input = $('todoDue'); if (!input) return;
            const d = new Date();
            d.setDate(d.getDate() + days);
            input.value = d.toISOString().slice(0, 10);
          }
          function quickDueWeekend() {
            const input = $('todoDue'); if (!input) return;
            const d = new Date();
            const day = d.getDay();
            const add = (day === 0) ? 0 : (6 - day); // 土曜基準
            d.setDate(d.getDate() + add);
            input.value = d.toISOString().slice(0, 10);
          }
          function formatDate(due, time) {
            if (!due) return '期限なし';
            const t = (time || '').trim();
            return t ? `${due} ${t}` : due;
          }
          function formatDueRemain(todo) {
            if (!todo || !todo.due) return '';
            const targetBase = Date.parse(todo.due);
            const time = (todo.dueTime || '').trim();
            let target = targetBase;
            if (time && Number.isFinite(targetBase)) {
              const [hh, mm] = time.split(':').map(x => parseInt(x, 10));
              if (Number.isFinite(hh)) {
                const d = new Date(targetBase);
                d.setHours(hh || 0, Number.isFinite(mm) ? mm : 0, 0, 0);
                target = d.getTime();
              }
            }
            if (!Number.isFinite(target)) return '';
            const now = Date.now();
            const diff = target - now;
            const sign = diff >= 0 ? '' : '-';
            const ms = Math.abs(diff);
            const days = Math.floor(ms / 86400000);
            const hours = Math.floor((ms % 86400000) / 3600000);
            if (days > 0) return `${sign}${days}日${hours}時間`;
            const mins = Math.floor((ms % 3600000) / 60000);
            if (hours > 0) return `${sign}${hours}時間${mins}分`;
            return `${sign}${mins}分`;
          }
          function isDone(todo) {
            if (!todo) return false;
            if (todo.done) return true;
            if (todo.pages && todo.pages.length) {
              return todo.completedPages.length >= todo.pages.length;
            }
            return false;
          }
          function remainingPages(todo) {
            if (!todo || !Array.isArray(todo.pages)) return [];
            const doneSet = new Set(todo.completedPages || []);
            return todo.pages.filter(p => !doneSet.has(p));
          }
          function estimateMinutes(todo) {
            const per = Math.max(1, parseInt(todo.perPage, 10) || 5);
            return remainingPages(todo).length * per;
          }
          function badge(text) { return `<span class="todo-badge">${text}</span>`; }
          function applyFilters(list) {
            let out = list.slice();
            const q = ($('todoSearch') || { value: '' }).value.trim().toLowerCase();
            out = out.filter(t => {
              if (state.filterKind === 'problem' && (!t.pages || !t.pages.length)) return false;
              if (state.filterKind === 'review' && t.kind !== 'review') return false;
              if (state.filterKind === 'general' && t.kind !== 'general') return false;
              const done = isDone(t);
              if (state.filterStatus === 'active' && done) return false;
              if (state.filterStatus === 'done' && !done) return false;
              if (state.filterStatus === 'due' && !t.due) return false;
              if (state.problemOnly && (!t.pages || !t.pages.length)) return false;
              if (!q) return true;
              return (t.title || '').toLowerCase().includes(q) || (t.bookTitle || '').toLowerCase().includes(q);
            });
            out.sort((a, b) => {
              const doneA = isDone(a), doneB = isDone(b);
              if (doneA !== doneB) return doneA ? 1 : -1;
              switch (state.sort) {
                case 'progress': {
                  const ra = remainingPages(a).length, rb = remainingPages(b).length;
                  return ra === rb ? (a.title || '').localeCompare(b.title || '') : ra - rb;
                }
                case 'time': {
                  const ta = estimateMinutes(a), tb = estimateMinutes(b);
                  return ta === tb ? (a.title || '').localeCompare(b.title || '') : ta - tb;
                }
                case 'created': return (b.createdAt || 0) - (a.createdAt || 0);
                case 'title': return (a.title || '').localeCompare(b.title || '');
                default: {
                  const da = a.due || '', db = b.due || '';
                  if (da && db) return da.localeCompare(db);
                  if (da) return -1;
                  if (db) return 1;
                  return (a.title || '').localeCompare(b.title || '');
                }
              }
            });
            return out;
          }
          function renderSummary(list) {
            const wrap = $('todoSummary'); if (!wrap) return;
            const total = list.length;
            let pages = 0, mins = 0;
            list.forEach(t => {
              pages += remainingPages(t).length;
              mins += estimateMinutes(t);
            });
            wrap.innerHTML = `<span><strong>${total}</strong> 件</span><span>残り <strong>${pages}</strong> ページ</span><span>推定 <strong>${mins}</strong> 分</span>`;
          }
          function renderCards(list) {
            const host = $('todoList'); const tableWrap = $('todoTableWrap');
            if (host) {
              host.style.display = 'block';
              host.classList.add('cards');
            }
            if (tableWrap) tableWrap.style.display = 'none';
            if (!host) return;
            if (!list.length) { host.innerHTML = '<div class="tiny" style="opacity:.8">まだToDoがありません。ページ範囲を入れて追加してください。</div>'; return; }
            const html = list.map(todo => {
              const done = isDone(todo);
              const remain = remainingPages(todo);
              const total = todo.pages?.length || 0;
              const progress = total > 0 ? Math.min(100, Math.round((todo.completedPages.length / total) * 100)) : (done ? 100 : 0);
              const eta = estimateMinutes(todo);
              const dueRemain = formatDueRemain(todo);
              const chips = (todo.pages || []).slice(0, 120).map(p => {
                const c = todo.completedPages.includes(p);
                return `<span class="todo-chip ${c ? 'done' : ''}" data-todo-page="${p}" data-todo-id="${todo.id}">p${p}</span>`;
              }).join('') || '<span class="tiny" style="color:var(--muted)">ページなし</span>';
              const badges = [
                badge(todo.kind === 'problem' ? '問題タスク' : todo.kind === 'review' ? '読書/復習' : 'その他'),
                todo.due ? badge(`期限 ${formatDate(todo.due, todo.dueTime)}`) : badge('期限なし'),
                todo.bookTitle ? badge(`本: ${escapeHTML(todo.bookTitle)}`) : badge('本の紐付けなし')
              ].join(' ');
              const expanded = state.pageOpen instanceof Set && state.pageOpen.has(todo.id);
              return `<div class="todo-entry compact" data-todo="${todo.id}">
          <div class="todo-head">
            <div>
              <div class="todo-title">${escapeHTML(todo.title || '無題タスク')}</div>
              <div class="todo-meta">${badges}</div>
              ${todo.note ? `<div class="tiny" style="margin-top:6px;white-space:pre-wrap;opacity:.85">${escapeHTML(todo.note)}</div>` : ''}
            </div>
            <div class="todo-actions">
              <button class="btn small ghost" data-todo-action="open-first" data-todo-id="${todo.id}">本で開く</button>
              <button class="btn small ghost" data-todo-action="plan" data-todo-id="${todo.id}">予定を作成</button>
              <button class="btn small ghost" data-todo-action="edit" data-todo-id="${todo.id}">編集</button>
              <button class="btn small ${done ? '' : 'ghost'}" data-todo-action="done" data-todo-id="${todo.id}">${done ? '完了済み' : '完了にする'}</button>
              <button class="btn small ghost danger" data-todo-action="delete" data-todo-id="${todo.id}">削除</button>
            </div>
          </div>
          <div class="todo-progress"><div class="bar" style="width:${progress}%"></div></div>
          <div class="todo-meta"><span>${remain.length}/${todo.pages?.length || 0} ページ残り</span><span>推定 ${eta}分</span>${dueRemain ? `<span class="todo-chip-date">残り ${dueRemain}</span>` : ''}</div>
          <div class="row" style="gap:6px;align-items:center;flex-wrap:wrap">
            <button class="btn ghost small" data-todo-action="toggle-pages" data-todo-id="${todo.id}" aria-expanded="${expanded ? 'true' : 'false'}">${expanded ? 'ページ一覧を隠す' : 'ページ一覧を表示'}</button>
            <span class="tiny" style="color:var(--muted);">${todo.pages?.length || 0}ページ</span>
          </div>
          <div class="todo-pages ${expanded ? '' : 'collapsed'}">${chips}</div>
          <div class="tiny" style="color:var(--muted)">ページ番号をクリックすると完了マーク（本が紐付いていれば「本で開く」で自動ジャンプ）</div>
        </div>`;
            }).join('');
            host.innerHTML = html;
          }
          function renderArchive(list) {
            const host = $('todoArchive');
            if (!host) return;
            host.classList.toggle('hidden', !showArchive);
            if (!showArchive) return;
            if (!list.length) { host.innerHTML = '<div class="tiny" style="opacity:.8">アーカイブは空です</div>'; return; }
            host.innerHTML = list.map(todo => {
              const pages = (todo.pages || []).slice(0, 40).map(p => `<span class="todo-chip${todo.completedPages?.includes(p) ? ' done' : ''}">p${p}</span>`).join('');
              return `<div class="todo-entry" data-archived="${todo.id}">
          <div class="todo-head">
            <div>
              <div class="todo-title">${escapeHTML(todo.title || '無題タスク')}</div>
              <div class="todo-meta">${badge('アーカイブ')}</div>
            </div>
            <div class="todo-actions">
              <button class="btn small ghost" data-arch-action="restore" data-id="${todo.id}">復元</button>
              <button class="btn small ghost danger" data-arch-action="purge" data-id="${todo.id}">完全削除</button>
            </div>
          </div>
          <div class="todo-pages">${pages || '<span class="tiny" style="color:var(--muted)">ページなし</span>'}</div>
        </div>`;
            }).join('');
          }
          function renderTable(list) {
            const host = $('todoList'); const tableWrap = $('todoTableWrap'); const body = $('todoTableBody');
            if (host) { host.style.display = 'none'; host.classList.remove('cards'); }
            if (tableWrap) tableWrap.style.display = 'block';
            if (!body) return;
            const rows = [];
            list.forEach(todo => {
              if (!todo.pages || !todo.pages.length) return;
              todo.pages.forEach(p => {
                rows.push({ todo, page: p, done: isDone(todo) || todo.completedPages.includes(p) });
              });
            });
            rows.sort((a, b) => {
              if (a.todo.due && b.todo.due && a.todo.due !== b.todo.due) return a.todo.due.localeCompare(b.todo.due);
              if (a.todo.title !== b.todo.title) return a.todo.title.localeCompare(b.todo.title);
              return a.page - b.page;
            });
            if (!rows.length) {
              body.innerHTML = '<tr><td colspan="6" class="tiny" style="opacity:.8">問題タスクがありません</td></tr>';
              return;
            }
            body.innerHTML = rows.map(r => {
              const eta = Math.max(1, parseInt(r.todo.perPage, 10) || 5);
              const dueRemain = formatDueRemain(r.todo);
              return `<tr class="${r.done ? 'done' : ''}" data-todo="${r.todo.id}" data-page="${r.page}">
          <td>${escapeHTML(r.todo.title || '無題')}</td>
          <td>p${r.page}</td>
          <td>${escapeHTML(r.todo.bookTitle || '-')}</td>
          <td>${r.todo.due ? formatDate(r.todo.due, r.todo.dueTime) : '-'}${dueRemain ? `<br><span class="tiny" style="color:var(--muted)">残り ${dueRemain}</span>` : ''}</td>
          <td>${eta}分</td>
          <td>
            <button class="btn small ghost" data-todo-action="toggle-page" data-todo-id="${r.todo.id}" data-page="${r.page}">${r.done ? '戻す' : '完了'}</button>
            <button class="btn small" data-todo-action="open-page" data-todo-id="${r.todo.id}" data-page="${r.page}">開く</button>
          </td>
        </tr>`;
            }).join('');
          }
          function render() {
            if (!bookCache.length && window.Book && Book.listMeta) { loadBooks(); }
            const all = TodoStore.all();
            // 自動で完了済みをアーカイブへ
            all.filter(t => isDone(t) && !t.archived).forEach(t => TodoStore.archive(t.id));
            const activeAll = TodoStore.all();
            const archived = TodoStore.archived();
            const filtered = applyFilters(activeAll);
            renderSummary(filtered);
            if (state.view === 'table') {
              renderTable(filtered);
            } else {
              renderCards(filtered);
            }
            renderArchive(archived);
          }
          function addTodo() {
            const title = ($('todoTitle') || { value: '' }).value.trim() || '無題タスク';
            const kind = 'problem';
            const due = ($('todoDue') || { value: '' }).value;
            const dueTime = ($('todoDueTime') || { value: '' }).value;
            const per = Math.max(1, parseInt(($('todoPerPage') || { value: 5 }).value, 10) || 5);
            const note = ($('todoNote') || { value: '' }).value.trim();
            const bookSel = $('todoBookSelect');
            const bookId = bookSel ? bookSel.value : '';
            const bookTitle = bookId
              ? (bookCache.find(b => b.id === bookId)?.title || (bookSel?.selectedOptions?.[0]?.textContent || ''))
              : '';
            const pagesInput = ($('todoRange') || { value: '' }).value;
            let pages = parsePages(pagesInput);
            if (!pages.length && pageSelection.size) { pages = Array.from(pageSelection).sort((a, b) => a - b); }
            const todo = {
              title, kind, due, dueTime, perPage: per, note, bookId, bookTitle, pages, completedPages: [], createdAt: Date.now(), done: false
            };
            TodoStore.upsert(todo);
            clearForm();
            setFormVisible(false);
            render();
          }
          async function openBookAt(todo, page) {
            if (!todo || !todo.bookId) {
              alert('先に本を紐付けてください');
              return;
            }
            try {
              if (typeof showTab === 'function') showTab('library', { preserveOpenTab: true });
              const book = await (window.Book && Book.get ? Book.get(todo.bookId) : Promise.resolve(null));
              if (!book) { alert('本が見つかりません'); return; }
              if (typeof mountBookViewer === 'function') {
                const res = mountBookViewer(book);
                if (res && typeof res.then === 'function') { await res; }
              }
              const targetPage = Number.isFinite(page) ? page : (remainingPages(todo)[0] || todo.pages?.[0] || 1);
              // Wait longer for viewer to be ready (up to 2 seconds)
              for (let attempt = 0; attempt < 20; attempt++) {
                await new Promise(res => setTimeout(res, 100));
                const input = document.getElementById('jumpInput');
                const btn = document.getElementById('jumpGo');
                if (input && btn) {
                  input.value = String(targetPage);
                  // Small delay to ensure value is set
                  await new Promise(res => setTimeout(res, 50));
                  btn.click();
                  return;
                }
              }
              console.warn('[openBookAt] jumpInput/jumpGo not found after waiting');
            } catch (e) { console.error('[openBookAt] Error:', e); }
          }
          function toggleDone(id) {
            const current = TodoStore.all().find(t => t.id === id);
            if (!current) return;
            const done = !isDone(current);
            const newCompleted = done ? (current.pages || []) : [];
            TodoStore.update(id, { done, completedPages: newCompleted });
            render();
          }
          function updateTodoBookLinks(todoId, bookId, bookTitle) {
            const title = bookTitle || '';
            const mappedId = bookId || null;
            if (window.NLStore && Array.isArray(NLStore.events)) {
              let touched = false;
              NLStore.events.forEach(ev => {
                if (ev && ev.todoId === todoId) {
                  ev.bookId = mappedId;
                  ev.bookTitle = title;
                  touched = true;
                }
              });
              if (touched && typeof NLStore.save === 'function') NLStore.save();
            }
            try { if (typeof invalidateScheduleCache === 'function') invalidateScheduleCache(); } catch (_) { }
            try {
              if (typeof loadPausedList === 'function' && typeof savePausedList === 'function') {
                const paused = loadPausedList();
                let changed = false;
                paused.forEach(ent => {
                  (ent.events || []).forEach(ev => {
                    if (ev && ev.todoId === todoId) {
                      ev.bookId = mappedId;
                      ev.bookTitle = title;
                      changed = true;
                    }
                  });
                });
                if (changed) savePausedList(paused);
              }
            } catch (_) { }
          }
          function openTodoEdit(id) {
            const todo = TodoStore.all().find(t => t.id === id);
            if (!todo) return;
            selectionBackup = { context: selectionContext, pages: Array.from(pageSelection) };
            selectionContext = 'edit';
            const setVal = (id, val) => { const el = $(id); if (el) el.value = val || ''; };
            setVal('todoEditTitle', todo.title || '');
            setVal('todoEditRange', (todo.pages || []).join(','));
            setVal('todoEditPer', todo.perPage || 5);
            setVal('todoEditDue', todo.due || '');
            setVal('todoEditDueTime', todo.dueTime || '');
            setVal('todoEditNote', todo.note || '');
            setVal('todoEditBookSearch', '');
            fillBookSelect('', 'todoEditBookSelect', todo.bookId || '');
            setPageSelection(todo.pages || []);
            const lbl = $('todoEditRangeCount'); if (lbl) lbl.textContent = `${(todo.pages || []).length}ページ`;
            const ov = $('todoEditOverlay'); if (ov) ov.classList.add('open');
            ov?.focus?.();
            window.__todoEditingId = id;
            renderPageBlocks();
            renderPageOverlay();
          }
          function closeTodoEdit() {
            window.__todoEditingId = null;
            const ov = $('todoEditOverlay'); if (ov) ov.classList.remove('open');
            selectionContext = 'form';
            if (selectionBackup) {
              setPageSelection(selectionBackup.pages || []);
              selectionBackup = null;
            }
            renderPageBlocks();
            renderPageOverlay();
          }
          function saveTodoEdit() {
            const id = window.__todoEditingId;
            if (!id) return;
            const todo = TodoStore.all().find(t => t.id === id);
            if (!todo) return;
            const title = ($('todoEditTitle') || { value: todo.title }).value.trim() || todo.title || '無題タスク';
            const rangeInput = $('todoEditRange');
            const per = Math.max(1, parseInt(($('todoEditPer') || { value: todo.perPage || 5 }).value, 10) || todo.perPage || 5);
            const due = ($('todoEditDue') || { value: todo.due || '' }).value;
            const dueTime = ($('todoEditDueTime') || { value: todo.dueTime || '' }).value;
            const note = ($('todoEditNote') || { value: todo.note || '' }).value;
            const bookSel = $('todoEditBookSelect');
            const bookId = bookSel ? bookSel.value : (todo.bookId || '');
            const bookTitle = bookId
              ? (bookCache.find(b => b.id === bookId)?.title || (bookSel?.selectedOptions?.[0]?.textContent || todo.bookTitle || ''))
              : (todo.bookTitle || '');
            let pages = parsePages(rangeInput?.value || '');
            if (!pages.length && pageSelection.size) { pages = Array.from(pageSelection).sort((a, b) => a - b); }
            const doneSet = new Set((todo.completedPages || []).filter(p => pages.includes(p)));
            const updated = TodoStore.update(id, {
              title, perPage: per, due, dueTime, note,
              bookId, bookTitle,
              pages,
              completedPages: Array.from(doneSet),
              done: pages.length > 0 && doneSet.size >= pages.length
            });
            if (updated) {
              updateTodoBookLinks(updated.id, updated.bookId, updated.bookTitle);
            }
            render();
            closeTodoEdit();
            if (updated && typeof showToast === 'function') showToast('ToDoを更新しました', 'success');
          }
          function handleAction(action, id, page) {
            if (!id) return;
            if (action === 'delete') { TodoStore.remove(id); render(); return; }
            if (action === 'edit-archive') { showArchive = true; render(); return; }
            if (action === 'done') { toggleDone(id); return; }
            if (action === 'plan') { planTodo(id); return; }
            if (action === 'open-first') { const todo = TodoStore.all().find(t => t.id === id); if (todo) openBookAt(todo); return; }
            if (action === 'open-page') { const todo = TodoStore.all().find(t => t.id === id); if (todo) openBookAt(todo, page); return; }
            if (action === 'edit') { openTodoEdit(id); return; }
            if (action === 'toggle-page') { TodoStore.togglePage(id, page); render(); return; }
            if (action === 'toggle-pages') {
              if (!(state.pageOpen instanceof Set)) state.pageOpen = new Set();
              if (state.pageOpen.has(id)) state.pageOpen.delete(id); else state.pageOpen.add(id);
              render();
              return;
            }
          }
          function bindListEvents() {
            const host = $('todoList'); const table = $('todoTableWrap');
            const handler = (e) => {
              const chip = e.target.closest('[data-todo-page]');
              if (chip) {
                const pid = chip.dataset.todoId; const page = parseInt(chip.dataset.todoPage, 10);
                TodoStore.togglePage(pid, page); render(); return;
              }
              const actBtn = e.target.closest('[data-todo-action]');
              if (actBtn) {
                const act = actBtn.dataset.todoAction;
                const pid = actBtn.dataset.todoId;
                const page = parseInt(actBtn.dataset.page, 10);
                handleAction(act, pid, page);
              }
            };
            host?.addEventListener('click', handler);
            table?.addEventListener('click', handler);
          }
          async function planTodo(id) {
            const todo = TodoStore.all().find(t => t.id === id);
            if (!todo) return;
            const targets = remainingPages(todo);
            if (!targets.length) {
              alert('未完了のページがありません');
              return;
            }
            createSchedule(targets, todo);
          }
          async function planBulk() {
            const todos = applyFilters(TodoStore.all()).filter(t => t.pages && t.pages.length);
            const pages = [];
            todos.forEach(t => { remainingPages(t).forEach(p => pages.push({ todo: t, page: p })); });
            if (!pages.length) { alert('未完の問題ページがありません'); return; }
            // flatten pages in order of due then title then page
            pages.sort((a, b) => {
              if (a.todo.due && b.todo.due && a.todo.due !== b.todo.due) return a.todo.due.localeCompare(b.todo.due);
              if (a.todo.title !== b.todo.title) return a.todo.title.localeCompare(b.todo.title);
              return a.page - b.page;
            });
            const justPages = pages.map(p => p.page);
            createSchedule(justPages, null);
          }
          function createSchedule(pages, todo) {
            if (!pages || !pages.length) return;
            const per = Math.max(1, parseInt(todo?.perPage, 10) || parseInt(($('todoPerPage') || { value: 5 }).value, 10) || 5);

            // Fix: Start after the last study event if it exists and is in the future
            let startTime = (window.__getNow ? window.__getNow() : new Date()).getTime();
            if (window.NLStore && Array.isArray(NLStore.events)) {
              const studyEvents = NLStore.events.filter(e => e.kind === 'study');
              if (studyEvents.length > 0) {
                const lastEnd = Math.max(...studyEvents.map(e => e.end));
                if (lastEnd > startTime) {
                  startTime = lastEnd;
                }
              }
            }
            // Align to minute boundary
            let cursor = new Date(Math.floor(startTime / 60000) * 60000);

            // Toast if far in future
            const nowMs = Date.now();
            if (cursor.getTime() - nowMs > 12 * 60 * 60000) {
              try { if (typeof showToast === 'function') showToast('予定を直近の明き時間（12時間以上先）に追加しました', 'info'); } catch (_) { }
            }

            const newIds = [];
            pages.forEach((pg, idx) => {
              const start = new Date(cursor.getTime());
              const end = new Date(cursor.getTime() + per * 60000);
              const ev = NLStore.addAbs(start, end, `${todo?.title || 'ToDo'} p${pg}`, pickColor(idx, todo?.id), 'study');
              if (ev) {
                ev.pageKey = `todo-${todo?.id || 'bulk'}-${pg}`;
                ev.pageNumber = pg;
                ev.todoId = todo?.id || null;
                ev.bookId = todo?.bookId || null;
                ev.bookTitle = todo?.bookTitle || '';
                newIds.push(ev.id);
              }
              cursor = new Date(end.getTime());
            });
            if (window.StudyMgr) {
              const merged = Array.isArray(StudyMgr.pageIds) ? StudyMgr.pageIds.slice() : [];
              newIds.forEach(id => { if (!merged.includes(id)) merged.push(id); });
              StudyMgr.active = true;
              StudyMgr.pageIds = merged;
              StudyMgr.save && StudyMgr.save();
              StudyUI.update && StudyUI.update();
            }
            setCompleteBtnText();
            NLStore.save();
            if (typeof window.__invalidateScheduleCache === 'function') window.__invalidateScheduleCache();
            queuePlannerRefresh();
            try { notify && notify('ToDoから勉強予定を追加しました'); } catch (_) { }
            render();
          }
          function completeFromEvent(ev) {
            if (!ev) return;
            const todoId = ev.todoId || (ev.pageKey && ev.pageKey.startsWith('todo-') ? ev.pageKey.split('-')[1] : null);
            const page = ev.pageNumber || (() => {
              const m = (ev.pageKey || '').match(/-(\d+)$/); if (m) return parseInt(m[1], 10);
              const m2 = (ev.title || '').match(/p(\d+)/i); if (m2) return parseInt(m2[1], 10);
              return null;
            })();
            if (todoId && Number.isFinite(page)) {
              TodoStore.togglePage(todoId, page);
              if (typeof window.__invalidateScheduleCache === 'function') window.__invalidateScheduleCache();
              render();
            }
          }
          async function loadBooks(force) {
            if (!window.Book || !Book.listMeta) return;
            if (!bookCache.length || force) {
              try {
                bookCache = await Book.listMeta();
              } catch (e) { bookCache = []; }
            }
            fillBookSelect(($('todoBookSearch') || { value: '' }).value, 'todoBookSelect');
            fillBookSelect(($('todoEditBookSearch') || { value: '' }).value, 'todoEditBookSelect');
          }
          function fillBookSelect(filterText, targetId = 'todoBookSelect', currentId) {
            const sel = $(targetId); if (!sel) return;
            const term = (filterText || '').toLowerCase();
            const cur = currentId ?? sel.value;
            sel.innerHTML = '<option value=\"\">紐付けなし</option>';
            const hiddenAnswers = collectHiddenAnswerIds(bookCache || []);
            bookCache.filter(b => {
              if (hiddenAnswers.has(b.id)) return false;
              const tgt = ((b.title || '') + ' ' + (Array.isArray(b.tags) ? b.tags.join(' ') : '')).toLowerCase();
              return !term || tgt.includes(term);
            }).slice(0, 120).forEach(b => {
              const opt = document.createElement('option');
              opt.value = b.id;
              const pagesLabel = (typeof pageCountOf === 'function') ? pageCountOf(b) : (b.pageCount || '?');
              opt.textContent = `${b.title || '無題'} (${pagesLabel}p)`;
              sel.appendChild(opt);
            });
            // Keep the current value even if it is filtered out
            if (cur && !Array.from(sel.options).some(o => o.value === cur)) {
              const found = (bookCache || []).find(b => b.id === cur);
              const opt = document.createElement('option');
              opt.value = cur;
              opt.textContent = found ? `${found.title || '無題'} (リンク中)` : `ID: ${cur}`;
              sel.appendChild(opt);
            }
            if (cur) sel.value = cur;
          }
          function bindForm() {
            $('todoAddBtn')?.addEventListener('click', addTodo);
            $('todoResetBtn')?.addEventListener('click', clearForm);
            $('todoRange')?.addEventListener('input', (e) => { updateRangePreview(undefined, e.target); syncSelectionFromInput(e.target); });
            $('todoRangePreview')?.addEventListener('click', updateRangePreview);
            $('todoBookSearch')?.addEventListener('input', (e) => fillBookSelect(e.target.value));
            $('todoBookReload')?.addEventListener('click', () => loadBooks(true));
            $('todoEditBookSearch')?.addEventListener('input', (e) => fillBookSelect(e.target.value, 'todoEditBookSelect'));
            $('todoEditBookReload')?.addEventListener('click', () => loadBooks(true));
            $('todoToggleForm')?.addEventListener('click', () => setFormVisible(!state.formVisible));
            $('todoFormClose')?.addEventListener('click', () => setFormVisible(false));
            $('todoDueToday')?.addEventListener('click', () => quickDue(0));
            $('todoDueTomorrow')?.addEventListener('click', () => quickDue(1));
            $('todoDueWeekend')?.addEventListener('click', quickDueWeekend);
            $('todoDueClear')?.addEventListener('click', () => { const d = $('todoDue'); if (d) d.value = ''; const t = $('todoDueTime'); if (t) t.value = ''; });
            $('todoFilterStatus')?.addEventListener('change', (e) => { state.filterStatus = e.target.value; savePref(FILTER_KEY, state.filterStatus); render(); });
            $('todoFilterKind')?.addEventListener('change', (e) => { state.filterKind = e.target.value; render(); });
            $('todoSort')?.addEventListener('change', (e) => { state.sort = e.target.value; savePref(SORT_KEY, state.sort); render(); });
            $('todoSearch')?.addEventListener('input', () => render());
            $('todoProblemOnly')?.addEventListener('change', (e) => { state.problemOnly = e.target.checked; if (e.target.checked) state.view = 'table'; render(); });
            $('todoViewCards')?.addEventListener('click', () => { state.view = 'cards'; savePref(VIEW_KEY, state.view); render(); });
            $('todoViewTable')?.addEventListener('click', () => { state.view = 'table'; savePref(VIEW_KEY, state.view); render(); });
            $('todoBulkPlan')?.addEventListener('click', planBulk);
            $('todoArchiveToggle')?.addEventListener('click', () => { showArchive = !showArchive; render(); });
            $('todoArchive')?.addEventListener('click', (e) => {
              const btn = e.target.closest('[data-arch-action]');
              if (!btn) return;
              const id = btn.dataset.id;
              if (btn.dataset.archAction === 'restore') {
                const restored = TodoStore.restore(id);
                render();
                if (restored && typeof showToast === 'function') showToast('復元しました', 'success');
              }
              if (btn.dataset.archAction === 'purge') { TodoStore.purgeArchived(id); render(); }
            });
            // グローバル委譲で後置のDOMにも対応
            document.addEventListener('click', (e) => {
              const id = (el) => el && el.id;
              const tgt = e.target;
              if (id(tgt) === 'todoPageOverlayOpen' || tgt.closest?.('#todoPageOverlayOpen')) {
                selectionContext = 'form';
                const maxSel = Math.max(0, ...Array.from(pageSelection || []));
                overlayPageMax = Math.min(1000, Math.max(300, maxSel + 100));
                renderPageOverlay();
                $('todoPageOverlay')?.classList.add('open');
                return;
              }
              if (id(tgt) === 'todoPageOverlayClose' || tgt.closest?.('#todoPageOverlayClose')) {
                $('todoPageOverlay')?.classList.remove('open'); return;
              }
              if (id(tgt) === 'todoEditClose' || tgt.closest?.('#todoEditClose')) { closeTodoEdit(); return; }
              if (id(tgt) === 'todoEditSave' || tgt.closest?.('#todoEditSave')) { saveTodoEdit(); return; }
            });
            const blockHandler = (ctx) => (e) => {
              const btn = e.target.closest('.page-block');
              if (!btn) return;
              const page = parseInt(btn.dataset.page || '', 10);
              const todoId = ctx === 'edit' ? (window.__todoEditingId || '') : (btn.closest('.study-todo-mini')?.dataset?.todo || '');
              selectionContext = ctx;
              if (todoId) {
                const schedMap = buildScheduledMap();
                const scheduledSet = (schedMap.live || schedMap).get(todoId) || new Set();
                const doneSet = new Set((todoList().find(t => t.id === todoId)?.completedPages) || []);
                if (scheduledSet.has(page)) {
                  unscheduleTodoPage(todoId, page);
                } else if (!doneSet.has(page)) {
                  const todo = todoList().find(t => t.id === todoId);
                  scheduleTodoPages(todo, [page], { silent: true });
                }
                render(false);
              }
              togglePageSelection(page);
            };
            $('todoPageBlocks')?.addEventListener('click', blockHandler('form'));
            $('todoPageOverlayGrid')?.addEventListener('click', (e) => blockHandler(selectionContext)(e));
            $('todoPageOverlayGrid')?.addEventListener('scroll', (e) => {
              const el = e.target;
              if (el.scrollTop + el.clientHeight >= el.scrollHeight - 80) { extendOverlayPages(); }
            });
            $('todoEditPageBlocks')?.addEventListener('click', blockHandler('edit'));
            $('todoEditRange')?.addEventListener('input', (e) => { selectionContext = 'edit'; syncSelectionFromInput(e.target); });
            if ($('todoFilterStatus')) $('todoFilterStatus').value = state.filterStatus;
            if ($('todoFilterKind')) $('todoFilterKind').value = state.filterKind;
            if ($('todoSort')) $('todoSort').value = state.sort;
            if ($('todoProblemOnly')) $('todoProblemOnly').checked = !!state.problemOnly;
            renderPageBlocks();
            renderPageOverlay();
            updateRangePreview();
            syncSelectionFromInput($('todoRange'));
            setFormVisible(false);
          }
          function init() {
            bindForm();
            bindListEvents();
            render();
            loadBooks();
          }
          return {
            init,
            render,
            planTodo,
            completeFromEvent,
            openForm: () => setFormVisible(true),
            closeForm: () => setFormVisible(false),
            createSchedule,
            remainingPages,
            parsePages
          };
        })();
        window.TodoUI = TodoUI;

        // ===== Planner Calendar (月/アジェンダ + ToDo連携) =====
        const PlannerCalendar = (function () {
          const DAY = 86400000;
          const wk = ['日', '月', '火', '水', '木', '金', '土'];
          const state = {
            base: startOfMonth(new Date()),
            selected: startOfDay(new Date()),
            view: 'month',
            filter: 'all',
            selectedTodo: '',
            planMode: 'remaining',
            pageSource: 'remaining',
            replaceExisting: true
          };
          let lastVisited = null;
          const autoHistory = new Map();
          const $$ = (id) => plannerRoot?.querySelector(`#${id}`) || document.getElementById(id);
          const pad2 = (n) => String(n).padStart(2, '0');
          function startOfDay(d) {
            const dt = (d instanceof Date) ? new Date(d) : new Date(d || Date.now());
            dt.setHours(0, 0, 0, 0);
            return dt;
          }
          function startOfMonth(d) {
            const dt = startOfDay(d);
            dt.setDate(1);
            return dt;
          }
          function addMonths(d, delta) {
            const dt = new Date(d.getTime());
            dt.setMonth(dt.getMonth() + delta);
            return dt;
          }
          function formatMonth(d) { return `${d.getFullYear()}年 ${d.getMonth() + 1}月`; }
          function formatDay(d) { return `${d.getMonth() + 1}/${d.getDate()} (${wk[d.getDay()]})`; }
          function toHM(date) { return `${pad2(date.getHours())}:${pad2(date.getMinutes())}`; }
          function classifyEvent(ev) {
            if (!ev) return 'other';
            if (ev.todoId) return 'todo';
            if (ev.kind === 'study') return 'study';
            if (ev.kind && /timer|pomo/i.test(ev.kind)) return 'timer';
            if (ev.pageKey || ev.pageNumber != null) return 'book';
            return ev.kind || 'other';
          }
          function matchesFilter(ev) {
            const kind = classifyEvent(ev);
            switch (state.filter) {
              case 'todo': return kind === 'todo' || kind === 'study';
              case 'study': return kind === 'study';
              case 'timer': return kind === 'timer';
              case 'book': return kind === 'book';
              default: return true;
            }
          }
          function eventsForDay(ms) {
            const dayStart = (ms instanceof Date ? startOfDay(ms).getTime() : (typeof ms === 'number' ? ms : startOfDay(new Date()).getTime()));
            const dayEnd = dayStart + DAY;
            return (NLStore?.events || []).filter(ev => ev && ev.end > dayStart && ev.start < dayEnd && matchesFilter(ev));
          }
          function currentTodo() {
            const id = state.selectedTodo || $$('calTodoSelect')?.value || '';
            if (!id) return null;
            return (TodoStore?.all?.() || []).find(t => t.id === id) || null;
          }
          function parsePagesLocal(str) {
            if (typeof TodoUI?.parsePages === 'function') return TodoUI.parsePages(str);
            if (!str) return [];
            const parts = str.split(/[,、\s]+/).filter(Boolean);
            const pages = [];
            parts.forEach(seg => {
              const range = seg.split(/[-〜~]/).map(s => s.trim()).filter(Boolean);
              if (range.length === 1) {
                const n = parseInt(range[0], 10); if (Number.isFinite(n)) pages.push(n);
              } else if (range.length >= 2) {
                const a = parseInt(range[0], 10), b = parseInt(range[1], 10);
                if (Number.isFinite(a) && Number.isFinite(b)) {
                  const s = Math.min(a, b), e = Math.max(a, b);
                  for (let i = s; i <= e; i++) pages.push(i);
                }
              }
            });
            return Array.from(new Set(pages)).sort((a, b) => a - b);
          }
          function buildPagesFromTodo(todo, opts = {}) {
            const mode = opts.mode || todo.autoPlanMode || state.planMode || 'remaining';
            const pageSource = opts.pageSource || todo.autoPageSource || state.pageSource || 'remaining';
            const anchor = Number.isFinite(opts.anchorPage) ? opts.anchorPage : (Number.isFinite(todo.autoPlanAnchor) ? todo.autoPlanAnchor : null);
            const manualPages = parsePagesLocal(opts.manualInput || '');
            const ordered = Array.isArray(todo.pages) ? todo.pages.slice() : [];
            const doneSet = new Set(todo.completedPages || []);
            const remaining = (typeof TodoUI?.remainingPages === 'function') ? TodoUI.remainingPages(todo) : ordered.filter(p => !doneSet.has(p));
            if (pageSource === 'manual' && manualPages.length) { return manualPages; }
            if (pageSource === 'current' && Number.isFinite(anchor)) {
              if (mode === 'single-current') return [anchor];
              if (mode === 'from-current') {
                const orderedRemain = ordered.filter(p => !doneSet.has(p));
                const idx = orderedRemain.indexOf(anchor);
                if (idx >= 0) {
                  return orderedRemain.slice(idx).concat(orderedRemain.slice(0, idx));
                }
              }
            }
            switch (mode) {
              case 'single-current':
                if (Number.isFinite(anchor)) return [anchor];
                return remaining.slice(0, 1);
              case 'from-current': {
                const orderedRemain = ordered.filter(p => !doneSet.has(p));
                if (Number.isFinite(anchor)) {
                  const idx = orderedRemain.indexOf(anchor);
                  if (idx >= 0) return orderedRemain.slice(idx).concat(orderedRemain.slice(0, idx));
                }
                return orderedRemain.length ? orderedRemain : remaining;
              }
              case 'all':
                return ordered;
              default:
                return remaining;
            }
          }
          function clearTodoEvents(todoId) {
            if (!todoId || !NLStore?.events) return;
            const before = NLStore.events.length;
            NLStore.events = NLStore.events.filter(ev => ev.todoId !== todoId);
            if (before !== NLStore.events.length) {
              NLStore.save();
            }
          }
          function replanTodo(todoId, opts = {}) {
            const todo = (TodoStore?.all?.() || []).find(t => t.id === todoId);
            if (!todo) return 0;
            const beforeCount = Array.isArray(NLStore?.events) ? NLStore.events.length : 0;
            const pages = buildPagesFromTodo(todo, {
              mode: opts.mode,
              pageSource: opts.pageSource,
              anchorPage: opts.anchorPage,
              manualInput: opts.manualInput
            }).filter(n => Number.isFinite(n));
            if (!pages.length) {
              try { showToast && showToast('生成できるページがありません', 'error'); } catch (_) { }
              return 0;
            }
            if (opts.replaceExisting !== false) clearTodoEvents(todo.id);
            if (TodoUI?.createSchedule) {
              TodoUI.createSchedule(pages, todo);
            } else {
              const per = Math.max(1, parseInt(todo.perPage, 10) || 5);
              let cursor = new Date(); cursor.setSeconds(0, 0);
              pages.forEach((pg, idx) => {
                const start = new Date(cursor.getTime());
                const end = new Date(cursor.getTime() + per * 60000);
                const ev = NLStore.addAbs(start, end, `${todo.title || 'ToDo'} p${pg}`, pickColor(idx, todo.id), 'study');
                if (ev) {
                  ev.pageKey = `todo-${todo.id}-${pg}`;
                  ev.pageNumber = pg;
                  ev.todoId = todo.id;
                  ev.bookId = todo.bookId || null;
                  ev.bookTitle = todo.bookTitle || '';
                }
                cursor = new Date(end.getTime());
              });
              NLStore.save();
            }
            if (typeof window.__invalidateScheduleCache === 'function') window.__invalidateScheduleCache();
            plannerCalendarNotify('todo-replan');
            renderMonth(); renderDayDetail(); renderAgenda(); renderSmart();
            const afterCount = Array.isArray(NLStore?.events) ? NLStore.events.length : beforeCount;
            return Math.max(0, afterCount - beforeCount);
          }
          function planFromUI() {
            const todo = currentTodo();
            if (!todo) {
              try { showToast && showToast('ToDoを選択してください', 'error'); } catch (_) { }
              return;
            }
            state.planMode = ($$('calPlanMode')?.value) || state.planMode;
            state.pageSource = ($$('calPageSource')?.value) || state.pageSource;
            state.replaceExisting = $$('calReplaceExisting') ? $$('calReplaceExisting').checked : state.replaceExisting;
            const anchorInput = ($$('calPageAnchor')?.value || '').trim();
            const anchorPage = Number.isFinite(parseInt(anchorInput, 10)) ? parseInt(anchorInput, 10) : (lastVisited?.page || todo.autoPlanAnchor || null);
            const added = replanTodo(todo.id, {
              mode: state.planMode,
              pageSource: state.pageSource,
              anchorPage,
              manualInput: anchorInput,
              replaceExisting: state.replaceExisting
            });
            saveTodoAuto(todo.id);
            if (added > 0) {
              try { showToast && showToast(`予定を${added}件生成しました`, 'success'); } catch (_) { }
            } else if (added === 0) {
              try { showToast && showToast('追加できる予定が見つかりません', 'info'); } catch (_) { }
            }
          }
          function saveTodoAuto(todoId) {
            const todo = (TodoStore?.all?.() || []).find(t => t.id === todoId);
            if (!todo) return;
            const patch = {
              autoPlanMode: state.planMode,
              autoPageSource: state.pageSource,
              autoPlanAnchor: Number.isFinite(parseInt(($$('calPageAnchor')?.value || ''), 10)) ? parseInt($$('calPageAnchor').value, 10) : todo.autoPlanAnchor,
              autoReplanOnVisit: !!($$('calAutoToggle')?.checked),
              autoReplanStrategy: ($$('calAutoStrategy')?.value) || todo.autoReplanStrategy
            };
            TodoStore.update(todo.id, patch);
          }
          function renderMonth() {
            const grid = $$('calGrid');
            const label = $$('calMonthLabel');
            if (label) label.textContent = formatMonth(state.base);
            if (!grid) return;
            if (state.view === 'agenda') { grid.classList.add('hidden'); return; }
            grid.classList.remove('hidden');
            grid.innerHTML = '';
            const base = startOfMonth(state.base);
            const startOffset = base.getDay();
            const firstShown = new Date(base);
            firstShown.setDate(firstShown.getDate() - startOffset);
            const todayMs = startOfDay(new Date()).getTime();
            for (let i = 0; i < 42; i++) {
              const d = new Date(firstShown);
              d.setDate(firstShown.getDate() + i);
              const dayMs = startOfDay(d).getTime();
              const cell = document.createElement('div');
              cell.className = 'cal-day';
              if (d.getMonth() !== base.getMonth()) cell.classList.add('muted');
              if (dayMs === todayMs) cell.classList.add('today');
              if (dayMs === state.selected.getTime()) cell.classList.add('active');
              const head = document.createElement('div'); head.className = 'cal-day-head';
              const ds = document.createElement('span'); ds.className = 'cal-date'; ds.textContent = d.getDate();
              const wkSpan = document.createElement('span'); wkSpan.className = 'cal-week'; wkSpan.textContent = wk[d.getDay()];
              head.appendChild(ds); head.appendChild(wkSpan); cell.appendChild(head);
              const evWrap = document.createElement('div'); evWrap.className = 'cal-day-events';
              const evs = eventsForDay(dayMs).sort((a, b) => a.start - b.start);
              evs.slice(0, 3).forEach(ev => {
                const chip = document.createElement('div');
                chip.className = 'cal-event-chip';
                chip.textContent = `${toHM(new Date(ev.start))} ${ev.title || '予定'}`;
                if (ev.color) chip.style.borderColor = ev.color;
                evWrap.appendChild(chip);
              });
              if (evs.length > 3) {
                const more = document.createElement('div'); more.className = 'cal-more'; more.textContent = `+${evs.length - 3}`;
                evWrap.appendChild(more);
              }
              cell.appendChild(evWrap);
              cell.onclick = () => { state.selected = startOfDay(d); renderDayDetail(); renderAgenda(); renderMonth(); };
              grid.appendChild(cell);
            }
          }
          function renderDayDetail() {
            const title = $$('calDayTitle');
            const meta = $$('calDayMeta');
            const list = $$('calDayList');
            const date = state.selected || startOfDay(new Date());
            const evs = eventsForDay(date.getTime()).sort((a, b) => a.start - b.start);
            if (title) title.textContent = formatDay(date);
            if (meta) meta.textContent = `${evs.length} 件の予定`;
            if (!list) return;
            list.innerHTML = '';
            if (!evs.length) {
              const empty = document.createElement('div'); empty.className = 'cal-note'; empty.textContent = '予定なし';
              list.appendChild(empty); return;
            }
            evs.forEach(ev => {
              const row = document.createElement('div'); row.className = 'cal-day-row';
              row.style.borderLeftColor = ev.color || 'var(--brand)';
              const time = document.createElement('div'); time.className = 'cal-time'; time.textContent = `${toHM(new Date(ev.start))} - ${toHM(new Date(ev.end))}`;
              const titleEl = document.createElement('div'); titleEl.className = 'cal-title'; titleEl.textContent = ev.title || '予定';
              const metaEl = document.createElement('div'); metaEl.className = 'cal-meta';
              const parts = [];
              const kind = classifyEvent(ev);
              if (kind === 'todo') parts.push('ToDo連携');
              if (kind === 'study') parts.push('勉強');
              if (kind === 'book' && ev.pageNumber) parts.push(`p${ev.pageNumber}`);
              metaEl.textContent = parts.join(' / ');
              row.appendChild(time); row.appendChild(titleEl); row.appendChild(metaEl);
              list.appendChild(row);
            });
          }
          function renderAgenda() {
            const agenda = $$('calAgenda');
            if (!agenda) return;
            agenda.classList.toggle('hidden', state.view !== 'agenda');
            if (state.view !== 'agenda') { agenda.innerHTML = ''; return; }
            agenda.innerHTML = '';
            const start = state.selected ? state.selected.getTime() : startOfDay(new Date()).getTime();
            for (let i = 0; i < 14; i++) {
              const d = new Date(start + i * DAY);
              const evs = eventsForDay(d.getTime()).sort((a, b) => a.start - b.start);
              const row = document.createElement('div'); row.className = 'cal-agenda-row';
              const date = document.createElement('div'); date.className = 'cal-agenda-date'; date.textContent = formatDay(d);
              const body = document.createElement('div'); body.className = 'cal-agenda-body';
              if (!evs.length) {
                const t = document.createElement('span'); t.className = 'cal-note'; t.textContent = '予定なし';
                body.appendChild(t);
              } else {
                evs.forEach(ev => {
                  const chip = document.createElement('div'); chip.className = 'cal-agenda-chip';
                  chip.textContent = `${toHM(new Date(ev.start))} ${ev.title || '予定'}`;
                  chip.style.borderColor = ev.color || '#2f4361';
                  body.appendChild(chip);
                });
              }
              row.appendChild(date); row.appendChild(body);
              agenda.appendChild(row);
            }
          }
          function renderSmart() {
            const lv = $$('calLastVisited');
            if (lv) { lv.textContent = lastVisited ? `開いているページ: ${(lastVisited.bookTitle || '本')} p${lastVisited.page}` : '開いているページ: 未取得'; }
            const sel = $$('calTodoSelect');
            const todos = TodoStore?.all?.() || [];
            if (sel) {
              const prev = state.selectedTodo || sel.value;
              sel.innerHTML = '<option value=\"\">ToDoを選択…</option>';
              todos.forEach(t => {
                const opt = document.createElement('option');
                opt.value = t.id;
                opt.textContent = `${t.title || '無題'}${t.bookTitle ? ` / ${t.bookTitle}` : ''}`;
                sel.appendChild(opt);
              });
              sel.value = prev && todos.some(t => t.id === prev) ? prev : (todos[0]?.id || '');
              state.selectedTodo = sel.value || '';
            }
            if ($$('calPlanMode')) $$('calPlanMode').value = state.planMode;
            if ($$('calPageSource')) $$('calPageSource').value = state.pageSource;
            if ($$('calReplaceExisting')) $$('calReplaceExisting').checked = state.replaceExisting;
            const todo = currentTodo();
            if (todo) {
              state.planMode = todo.autoPlanMode || state.planMode;
              state.pageSource = todo.autoPageSource || state.pageSource;
              if ($$('calPlanMode')) $$('calPlanMode').value = state.planMode;
              if ($$('calPageSource')) $$('calPageSource').value = state.pageSource;
              if ($$('calAutoToggle')) $$('calAutoToggle').checked = !!todo.autoReplanOnVisit;
              if ($$('calAutoStrategy')) $$('calAutoStrategy').value = todo.autoReplanStrategy || 'from-current';
            }
          }
          function onPageVisit(meta) {
            if (meta) { lastVisited = meta; }
            if ($$('calPageAnchor') && meta?.page) { $$('calPageAnchor').value = meta.page; }
            renderSmart();
            if (!meta?.bookId) return;
            const todos = (TodoStore?.all?.() || []).filter(t => t.bookId === meta.bookId && t.autoReplanOnVisit);
            todos.forEach(todo => {
              const pages = Array.isArray(todo.pages) ? todo.pages : [];
              if (!pages.includes(meta.page)) return;
              const last = autoHistory.get(todo.id);
              if (last && last.page === meta.page && (Date.now() - last.ts) < 8000) return;
              autoHistory.set(todo.id, { page: meta.page, ts: Date.now() });
              const mode = todo.autoReplanStrategy || todo.autoPlanMode || 'from-current';
              replanTodo(todo.id, { mode, pageSource: 'current', anchorPage: meta.page, replaceExisting: true });
            });
          }
          function bind() {
            $$('calPrev')?.addEventListener('click', () => { state.base = addMonths(state.base, -1); renderMonth(); });
            $$('calNext')?.addEventListener('click', () => { state.base = addMonths(state.base, 1); renderMonth(); });
            $$('calToday')?.addEventListener('click', () => {
              state.base = startOfMonth(new Date());
              state.selected = startOfDay(new Date());
              refresh();
            });
            $$('calViewMonth')?.addEventListener('click', () => { state.view = 'month'; refresh(); });
            $$('calViewAgenda')?.addEventListener('click', () => { state.view = 'agenda'; refresh(); });
            $$('calFilter')?.addEventListener('change', (e) => { state.filter = e.target.value; refresh(); });
            $$('calTodoSelect')?.addEventListener('change', (e) => { state.selectedTodo = e.target.value || ''; renderSmart(); });
            $$('calPlanMode')?.addEventListener('change', (e) => { state.planMode = e.target.value; });
            $$('calPageSource')?.addEventListener('change', (e) => { state.pageSource = e.target.value; });
            $$('calReplaceExisting')?.addEventListener('change', (e) => { state.replaceExisting = e.target.checked; });
            $$('calPlanGenerate')?.addEventListener('click', planFromUI);
            $$('calUseCurrentPage')?.addEventListener('click', () => {
              if (lastVisited?.page && $$('calPageAnchor')) $$('calPageAnchor').value = lastVisited.page;
              planFromUI();
            });
            $$('calAutoToggle')?.addEventListener('change', () => { const todo = currentTodo(); if (todo) saveTodoAuto(todo.id); });
            $$('calAutoStrategy')?.addEventListener('change', () => { const todo = currentTodo(); if (todo) saveTodoAuto(todo.id); });
            $$('calJumpPlanner')?.addEventListener('click', () => { try { __activatePlannerTab?.('planner'); } catch (_) { } });
            $$('calJumpNL')?.addEventListener('click', () => { try { __activatePlannerTab?.('numberline'); nlRebuildAll && nlRebuildAll(); } catch (_) { } });
            $$('calRefreshBtn')?.addEventListener('click', () => { refresh(); try { drawPlanner && drawPlanner(); nlRebuildAll && nlRebuildAll(); } catch (_) { } });
            window.addEventListener('planner:nl-updated', () => refresh());
          }
          function refresh() {
            if (state.view === 'agenda') {
              $$('calGrid')?.classList.add('hidden');
            } else {
              $$('calGrid')?.classList.remove('hidden');
            }
            renderMonth();
            renderDayDetail();
            renderAgenda();
            renderSmart();
          }
          return { init() { bind(); refresh(); }, refresh, onPageVisit, replanTodo, lastVisit: () => lastVisited };
        })();
        window.PlannerCalendar = PlannerCalendar;

        // ========== Study Calendar (TODO連携カレンダー) ==========
        const StudyCalendar = (function () {
          const SETTINGS_KEY = 'sc-settings';
          const SCHEDULE_KEY = 'sc-schedules';
          const SCHEDULE_MEM_KEY = 'sc-schedule-memory';
          const MINI_LOG_KEY = 'sc-mini-log';

          // State
          let currentDate = new Date();
          let currentView = 'month';
          let weekStart = 1; // 0=Sunday, 1=Monday
          let schedules = {}; // { todoId: { [dateStr]: pages[] } }
          let scheduleCompletedMemory = {}; // { todoId: { [dateStr]: completedPages[] } }
          let miniLog = [];
          let todosReady = false;
          const ScheduleDB = {
            dbName: 'StudyCalendarDB',
            storeName: 'kv',
            version: 1,
            db: null,
            async open() {
              if (this.db) return this.db;
              return new Promise((resolve, reject) => {
                const req = indexedDB.open(this.dbName);
                req.onupgradeneeded = (e) => {
                  const db = e.target.result;
                  if (!db.objectStoreNames.contains(this.storeName)) {
                    db.createObjectStore(this.storeName, { keyPath: 'key' });
                  }
                };
                req.onsuccess = (e) => { this.db = e.target.result; resolve(this.db); };
                req.onerror = () => reject(req.error);
              });
            },
            async get(key) {
              try {
                const db = await this.open();
                return await new Promise((resolve, reject) => {
                  const tx = db.transaction(this.storeName, 'readonly');
                  const store = tx.objectStore(this.storeName);
                  const req = store.get(key);
                  req.onsuccess = () => resolve(req.result || null);
                  req.onerror = () => reject(req.error);
                });
              } catch (_) { return null; }
            },
            async set(key, value) {
              try {
                const db = await this.open();
                await new Promise((resolve, reject) => {
                  const tx = db.transaction(this.storeName, 'readwrite');
                  const store = tx.objectStore(this.storeName);
                  store.put({ key, value, updated: Date.now() });
                  tx.oncomplete = () => resolve();
                  tx.onerror = () => reject(tx.error);
                });
              } catch (_) { }
            }
          };
          const DEFAULT_SETTINGS = {
            showComplete: true,
            highlightWeekend: true,
            showProgress: true,
            weekStart: 1,
            zoom: 1,
            hWidth: 120,
            weekHeight: 1.1,
            asideWidth: 400,
            immersive: false
          };
          const H_PAST_DAYS = 365;
          const H_FUTURE_DAYS = 365;
          const COMPLETED_HEIGHT_KEY = 'sc-completed-height';
          const COMPLETED_COLLAPSED_KEY = 'sc-completed-collapsed';
          let completedHeight = 200;
          let completedCollapsed = false;
          let settings = { ...DEFAULT_SETTINGS };
          let hScrollLeft = null;
          let hScrollBound = false;
          const undoStack = [];
          const redoStack = [];
          const UNDO_LIMIT = 60;
          let historyApplying = false;

          // Load/Save
          function loadSettings() {
            try {
              const saved = localStorage.getItem(SETTINGS_KEY);
              if (saved) settings = { ...settings, ...JSON.parse(saved) };
              settings.zoom = clamp(Number(settings.zoom) || DEFAULT_SETTINGS.zoom, 0.9, 1.4);
              settings.hWidth = clamp(Number(settings.hWidth) || DEFAULT_SETTINGS.hWidth, 90, 200);
              settings.weekHeight = clamp(Number(settings.weekHeight) || DEFAULT_SETTINGS.weekHeight, 1, 2);
              settings.asideWidth = clamp(Number(settings.asideWidth) || DEFAULT_SETTINGS.asideWidth, 300, 520);
              const sch = localStorage.getItem(SCHEDULE_KEY);
              if (sch) schedules = JSON.parse(sch);
              const mem = localStorage.getItem(SCHEDULE_MEM_KEY);
              if (mem) scheduleCompletedMemory = JSON.parse(mem);
              try {
                const hRaw = localStorage.getItem(COMPLETED_HEIGHT_KEY);
                if (hRaw) completedHeight = clamp(parseInt(hRaw, 10) || completedHeight, 140, 520);
                const cRaw = localStorage.getItem(COMPLETED_COLLAPSED_KEY);
                completedCollapsed = cRaw === '1';
              } catch (_) { }
            } catch (e) { }
            // 非同期のバックアップ復元（localStorageが空でもIndexedDBに残っていれば採用）
            (async () => {
              try {
                const rec = await ScheduleDB.get('schedules');
                const backup = rec?.value || rec?.data || null;
                if (backup && Object.keys(schedules || {}).length === 0) {
                  schedules = backup;
                  saveSettings();
                  render();
                }
                const memRec = await ScheduleDB.get('schedules-memory');
                const memBackup = memRec?.value || memRec?.data || null;
                if (memBackup && Object.keys(scheduleCompletedMemory || {}).length === 0) {
                  scheduleCompletedMemory = memBackup;
                  saveSettings();
                }
              } catch (_) { }
            })();
          }

          function saveSettings() {
            try {
              localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
              localStorage.setItem(SCHEDULE_KEY, JSON.stringify(schedules));
              localStorage.setItem(SCHEDULE_MEM_KEY, JSON.stringify(scheduleCompletedMemory));
              ScheduleDB.set('schedules', schedules);
              ScheduleDB.set('schedules-memory', scheduleCompletedMemory);
            } catch (e) { }
          }

          function cloneSchedules(src) {
            try { return JSON.parse(JSON.stringify(src || {})); } catch (_) { return {}; }
          }

          function snapshotState() {
            return {
              schedules: cloneSchedules(schedules),
              scheduleCompletedMemory: cloneSchedules(scheduleCompletedMemory),
              selectedDate: selectedDate ? formatDate(selectedDate) : null,
              currentDate: currentDate ? formatDate(currentDate) : null,
              currentView,
              todosDue: (window.TodoStore && typeof window.TodoStore.all === 'function')
                ? window.TodoStore.all().map(t => ({ id: t.id, due: t.due || '', dueTime: t.dueTime || '' }))
                : null
            };
          }

          function updateUndoButtons() {
            const undoBtn = $('scUndo');
            const redoBtn = $('scRedo');
            if (undoBtn) undoBtn.disabled = undoStack.length === 0;
            if (redoBtn) redoBtn.disabled = redoStack.length === 0;
          }

          function pushUndo() {
            if (historyApplying) return;
            undoStack.push(snapshotState());
            if (undoStack.length > UNDO_LIMIT) undoStack.shift();
            redoStack.length = 0;
            updateUndoButtons();
          }

          function restoreSnapshot(snap) {
            schedules = cloneSchedules(snap?.schedules || {});
            scheduleCompletedMemory = cloneSchedules(snap?.scheduleCompletedMemory || {});
            if (snap?.currentDate) currentDate = parseDate(snap.currentDate);
            if (snap?.selectedDate) {
              selectedDate = parseDate(snap.selectedDate);
            } else {
              selectedDate = null;
            }
            if (snap?.currentView) currentView = snap.currentView;
            if (Array.isArray(snap?.todosDue) && window.TodoStore && typeof window.TodoStore.update === 'function') {
              const all = window.TodoStore.all ? window.TodoStore.all() : [];
              snap.todosDue.forEach((rec) => {
                const cur = all.find(t => t.id === rec.id);
                if (!cur) return;
                const nextDue = rec.due || '';
                const nextTime = rec.dueTime || '';
                if ((cur.due || '') !== nextDue || (cur.dueTime || '') !== nextTime) {
                  window.TodoStore.update(cur.id, { due: nextDue, dueTime: nextTime });
                }
              });
            }
            saveSettings();
            render();
          }

          function undoAction() {
            if (!undoStack.length) return;
            historyApplying = true;
            redoStack.push(snapshotState());
            const prev = undoStack.pop();
            restoreSnapshot(prev);
            historyApplying = false;
            updateUndoButtons();
          }

          function redoAction() {
            if (!redoStack.length) return;
            historyApplying = true;
            undoStack.push(snapshotState());
            const next = redoStack.pop();
            restoreSnapshot(next);
            historyApplying = false;
            updateUndoButtons();
          }

          function loadMiniLog() {
            try {
              const raw = localStorage.getItem(MINI_LOG_KEY);
              const parsed = raw ? JSON.parse(raw) : [];
              miniLog = Array.isArray(parsed) ? parsed : [];
            } catch (e) {
              miniLog = [];
            }
          }

          function saveMiniLog() {
            try {
              const trimmed = miniLog.slice(-60);
              localStorage.setItem(MINI_LOG_KEY, JSON.stringify(trimmed));
            } catch (e) { }
          }

          // Utility
          function $(id) { return document.getElementById(id); }
          function formatDate(d) {
            const y = d.getFullYear();
            const m = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${y}-${m}-${day}`; // local timezone基準の日付
          }
          function parseDate(str) { return new Date(str + 'T00:00:00'); }
          function isSameDay(d1, d2) { return formatDate(d1) === formatDate(d2); }
          function isWeekend(d) { const day = d.getDay(); return day === 0 || day === 6; }
          const DAY_NAMES = ['日', '月', '火', '水', '木', '金', '土'];
          function combineDateTime(dateStr, timeStr) {
            if (!dateStr) return null;
            const base = parseDate(dateStr);
            if (!(base instanceof Date) || isNaN(base)) return null;
            const [hh, mm] = (timeStr || '00:00').split(':').map(Number);
            base.setHours(Number.isFinite(hh) ? hh : 0, Number.isFinite(mm) ? mm : 0, 0, 0);
            return base;
          }
          function formatMinutes(min) {
            const m = Math.max(0, Math.round(min || 0));
            const h = Math.floor(m / 60);
            const rest = m % 60;
            if (h <= 0) return `${m}分`;
            return `${h}時間${rest ? ` ${rest}分` : ''}`;
          }
          const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

          function applyLayoutSettings() {
            const root = document.getElementById('plannerApp');
            if (!root) return;
            settings.zoom = clamp(Number(settings.zoom) || DEFAULT_SETTINGS.zoom, 0.9, 1.4);
            settings.hWidth = clamp(Number(settings.hWidth) || DEFAULT_SETTINGS.hWidth, 90, 200);
            settings.weekHeight = clamp(Number(settings.weekHeight) || DEFAULT_SETTINGS.weekHeight, 1, 2);
            settings.asideWidth = clamp(Number(settings.asideWidth) || DEFAULT_SETTINGS.asideWidth, 300, 520);
            root.style.setProperty('--sc-zoom', settings.zoom);
            root.style.setProperty('--sc-h-width', `${settings.hWidth}px`);
            root.style.setProperty('--sc-week-height', settings.weekHeight);
            root.style.setProperty('--sc-aside-width', `${settings.asideWidth}px`);
            const shell = root.querySelector('.calendar-shell');
            if (shell) shell.classList.toggle('immersive', !!settings.immersive);
            const updateVal = (id, val) => { const el = $(id); if (el && typeof val !== 'undefined') el.value = val; };
            updateVal('scZoomSlider', settings.zoom);
            updateVal('scWidthSlider', settings.hWidth);
            updateVal('scWeekHeightSlider', settings.weekHeight);
            updateVal('scAsideWidthSlider', settings.asideWidth);
            updateVal('scWeekStart', settings.weekStart ?? weekStart);
            updateVal('scWidthFine', settings.hWidth);
            const toggleBtn = $('scExpandToggle');
            if (toggleBtn) toggleBtn.textContent = settings.immersive ? '右メニュー表示' : '拡大表示';
          }

          function setupResizer() {
            const resizer = document.getElementById('calendarResizer');
            const shell = document.querySelector('#plannerApp .calendar-shell');
            const aside = document.querySelector('#plannerApp .calendar-aside');
            if (!resizer || !shell || !aside) return;
            let dragging = false;
            let startX = 0;
            let startWidth = 0;
            const onMove = (e) => {
              if (!dragging) return;
              const delta = e.clientX - startX;
              const newWidth = clamp(startWidth - delta, 300, 520);
              settings.asideWidth = newWidth;
              applyLayoutSettings();
              saveSettings();
              e.preventDefault();
            };
            const stop = (e) => {
              if (!dragging) return;
              dragging = false;
              document.body.classList.remove('resizing-calendar');
              if (e?.pointerId != null) resizer.releasePointerCapture(e.pointerId);
            };
            resizer.addEventListener('pointerdown', (e) => {
              dragging = true;
              startX = e.clientX;
              startWidth = aside.getBoundingClientRect().width;
              document.body.classList.add('resizing-calendar');
              resizer.setPointerCapture(e.pointerId);
              e.preventDefault();
            });
            resizer.addEventListener('pointermove', onMove);
            resizer.addEventListener('pointerup', stop);
            window.addEventListener('pointermove', onMove);
            window.addEventListener('pointerup', stop);
            window.addEventListener('pointercancel', stop);
          }

          function setupPanelToggles() {
            const cards = document.querySelectorAll('#plannerApp .calendar-aside .card');
            cards.forEach(card => {
              if (card.querySelector('.panel-toggle')) return;
              if (card.id === 'scDayDetail') return; // 日付詳細は常に表示
              const btn = document.createElement('button');
              btn.type = 'button';
              btn.className = 'panel-toggle';
              const title = (card.querySelector('h3, h4')?.textContent || 'パネル').trim();
              const syncLabel = () => {
                const isCollapsed = card.classList.contains('collapsed');
                btn.textContent = isCollapsed ? '開く' : '閉じる';
                btn.title = `${title}を${isCollapsed ? '開く' : '閉じる'}`;
              };
              btn.addEventListener('click', (e) => {
                e.stopPropagation();
                card.classList.toggle('collapsed');
                syncLabel();
              });
              syncLabel();
              card.appendChild(btn);
            });
          }

          // Get all TODOs
          function getTodos() {
            if (window.TodoStore && typeof window.TodoStore.all === 'function') {
              return window.TodoStore.all();
            }
            return [];
          }

          // Get scheduled tasks for a date
          function getTasksForDate(date) {
            const dateStr = formatDate(date);
            const result = [];
            const todos = getTodos();

            // Check schedules
            for (const [todoId, dateMap] of Object.entries(schedules)) {
              if (dateMap[dateStr]) {
                const todo = todos.find(t => t.id === todoId);
                if (todo) {
                  result.push({
                    type: 'scheduled',
                    todoId,
                    todo,
                    pages: dateMap[dateStr],
                    date: dateStr
                  });
                }
              }
            }

            // Check todos with due dates
            todos.forEach(todo => {
              if (todo.due && formatDate(new Date(todo.due)) === dateStr) {
                result.push({
                  type: 'due',
                  todoId: todo.id,
                  todo,
                  date: dateStr
                });
              }
            });

            // Planner mini lessons / breaks (time付き)
            try {
              if (window.NLStore && Array.isArray(NLStore.events)) {
                const dayStart = new Date(date); dayStart.setHours(0, 0, 0, 0);
                const dayEnd = new Date(dayStart); dayEnd.setDate(dayStart.getDate() + 1);
                NLStore.events.forEach(ev => {
                  if (!ev || !(ev.kind === 'lesson' || ev.kind === 'break')) return;
                  if (ev.start < dayEnd.getTime() && ev.end > dayStart.getTime()) {
                    const durMin = Math.max(1, Math.round((ev.end - ev.start) / 60000));
                    result.push({
                      type: ev.kind === 'break' ? 'break' : 'lesson',
                      plannerEvent: true,
                      todoId: ev.id,
                      todo: {
                        id: ev.id,
                        title: ev.title || (ev.kind === 'break' ? '休憩' : 'ミニ授業'),
                        done: false,
                        color: ev.color || (ev.kind === 'break' ? '#f97316' : '#7dd3fc')
                      },
                      duration: durMin,
                      date: dateStr
                    });
                  }
                });
              }
            } catch (e) { }

            return result;
          }

          const sortTasksByPriority = (tasks) => {
            const weight = (t) => {
              if (!t) return 99;
              if (t.type === 'due') return 0;
              if (t.type === 'scheduled') return 1;
              if (t.type === 'break') return 2;
              if (t.type === 'lesson') return 3;
              return 5;
            };
            return [...tasks].sort((a, b) => weight(a) - weight(b));
          };

          const normalizePage = (v) => {
            const n = typeof v === 'string' ? parseInt(v, 10) : Number(v);
            return Number.isFinite(n) ? n : null;
          };
          const getScheduleMapForDate = (dateStr) => {
            const map = new Map();
            if (!dateStr) return map;
            const key = String(dateStr);
            Object.entries(schedules || {}).forEach(([todoId, dateMap]) => {
              const pages = (dateMap && dateMap[key]) || [];
              const nums = (Array.isArray(pages) ? pages : []).map(normalizePage).filter(Number.isFinite);
              if (nums.length) map.set(String(todoId), new Set(nums));
            });
            return map;
          };
          const remainingUniquePages = (todo) => {
            if (!todo || !Array.isArray(todo.pages)) return [];
            const done = new Set((todo.completedPages || []).map(normalizePage).filter(Number.isFinite));
            const uniq = [];
            todo.pages.map(normalizePage).filter(Number.isFinite).forEach(p => {
              if (!done.has(p) && !uniq.includes(p)) uniq.push(p);
            });
            return uniq;
          };

          const getTodoCompletedSet = (todo) => {
            const set = new Set((todo?.completedPages || []).map(normalizePage).filter(Number.isFinite));
            return set;
          };

          const rememberCompletedPages = (todoId, dateStr, pages) => {
            if (!todoId || !dateStr) return;
            const list = (Array.isArray(pages) ? pages : []).map(normalizePage).filter(Number.isFinite);
            if (!list.length) return;
            if (!scheduleCompletedMemory[todoId]) scheduleCompletedMemory[todoId] = {};
            const existing = new Set((scheduleCompletedMemory[todoId][dateStr] || []).map(normalizePage).filter(Number.isFinite));
            let changed = false;
            list.forEach(p => { if (!existing.has(p)) { existing.add(p); changed = true; } });
            if (changed) {
              scheduleCompletedMemory[todoId][dateStr] = Array.from(existing);
              saveSettings();
            }
          };

          const getScheduleMemorySet = (todoId, dateStr) => {
            return new Set((scheduleCompletedMemory?.[todoId]?.[dateStr] || []).map(normalizePage).filter(Number.isFinite));
          };

          function pruneScheduleForTodo(todo, _extraPage = null) {
            // Keep scheduled pages even after completion for progress review; only clean invalid entries.
            if (!todo || !schedules[todo.id]) return false;
            const validPages = new Set((todo.pages || []).map(normalizePage).filter(Number.isFinite));
            let changed = false;
            const dateMap = schedules[todo.id];
            Object.keys(dateMap).forEach(dateStr => {
              const pages = Array.isArray(dateMap[dateStr]) ? dateMap[dateStr] : [];
              const cleaned = pages.map(normalizePage).filter(p => Number.isFinite(p) && validPages.has(p));
              const unique = Array.from(new Set(cleaned));
              if (unique.length !== pages.length) changed = true;
              if (unique.length) {
                dateMap[dateStr] = unique;
              } else {
                delete dateMap[dateStr];
                changed = true;
              }
            });
            if (!Object.keys(dateMap).length) {
              delete schedules[todo.id];
              changed = true;
            }
            return changed;
          }

          function purgeMissingTodos(todos) {
            let changed = false;
            Object.keys(schedules).forEach(id => {
              if (!todos.find(t => t.id === id)) {
                delete schedules[id];
                if (scheduleCompletedMemory[id]) delete scheduleCompletedMemory[id];
                changed = true;
              }
            });
            return changed;
          }

          function syncSchedulesWithTodos() {
            const todos = getTodos();
            if (!Array.isArray(todos) || todos.length === 0) {
              if (!todosReady) return false; // Todo読み込み前はスキップ
              const hadSchedules = Object.keys(schedules || {}).length > 0;
              if (hadSchedules) {
                schedules = {};
                saveSettings();
              }
              return hadSchedules;
            }
            todosReady = true;
            let changed = purgeMissingTodos(todos);
            todos.forEach(todo => {
              if (pruneScheduleForTodo(todo)) changed = true;
            });
            if (changed) saveSettings();
            return changed;
          }

          function onTodoPageCompleted(todoId, page) {
            const todos = getTodos();
            const todo = todos.find(t => t.id === todoId);
            if (!todo) return false;
            const changed = pruneScheduleForTodo(todo, page);
            if (changed) { saveSettings(); render(); }
            return changed;
          }

          // Calculate stats
          function updateStats() {
            const todos = getTodos();
            const today = formatDate(new Date());
            let totalTodo = todos.length;
            let incomplete = 0;
            let totalPages = 0;
            let todayCount = 0;
            let overdue = 0;

            todos.forEach(todo => {
              const isComplete = todo.done || (todo.pages && todo.completedPages?.length === todo.pages.length);
              if (!isComplete) {
                incomplete++;
                const remaining = (todo.pages?.length || 0) - (todo.completedPages?.length || 0);
                totalPages += remaining;
              }
              if (todo.due) {
                const dueDate = formatDate(new Date(todo.due));
                if (dueDate < today && !isComplete) overdue++;
              }
            });

            // Today's tasks
            const todayTasks = getTasksForDate(new Date());
            todayCount = todayTasks.length;

            $('scStatTodo').textContent = totalTodo;
            $('scStatRemain').textContent = incomplete;
            $('scStatPages').textContent = totalPages;
            $('scStatToday').textContent = todayCount;
            $('scStatOverdue').textContent = overdue;
          }

          function calcWeekMinutes(anchorDate) {
            const base = anchorDate ? new Date(anchorDate) : new Date();
            base.setHours(0, 0, 0, 0);
            const offset = (base.getDay() - weekStart + 7) % 7;
            const start = new Date(base);
            start.setDate(base.getDate() - offset);
            const end = new Date(start);
            end.setDate(start.getDate() + 7);
            let minutes = 0;
            if (window.NLStore && Array.isArray(NLStore.events)) {
              NLStore.events.forEach(ev => {
                if (!ev || !(ev.kind === 'lesson' || ev.kind === 'study')) return;
                const overlap = Math.min(ev.end, end.getTime()) - Math.max(ev.start, start.getTime());
                if (overlap > 0) minutes += overlap / 60000;
              });
            }
            if (Array.isArray(miniLog) && miniLog.length) {
              miniLog.forEach(rec => {
                if (!rec || !rec.date) return;
                const d = parseDate(rec.date);
                if (d >= start && d < end) {
                  minutes += Math.max(0, Number(rec.duration) || 0);
                }
              });
            }
            return { start, end, minutes };
          }

          function updateMiniSummary(anchorDate) {
            const anchor = typeof anchorDate === 'string' ? parseDate(anchorDate) : anchorDate;
            const { minutes } = calcWeekMinutes(anchor || new Date());
            const totalEl = $('scMiniWeekTotal');
            const remainEl = $('scMiniWeekRemain');
            const goalMin = Math.max(0, parseInt($('scMiniWeeklyGoal')?.value || '0', 10) * 60);
            if (totalEl) totalEl.textContent = formatMinutes(minutes);
            if (remainEl) remainEl.textContent = goalMin ? formatMinutes(Math.max(0, goalMin - minutes)) : '--';
          }

          function renderMiniLog() {
            const host = $('scMiniLog');
            if (!host) return;
            if (!miniLog.length) {
              host.innerHTML = '<div class="sc-hint">ミニ授業の履歴はまだありません</div>';
              return;
            }
            const recent = [...miniLog].slice(-6).reverse();
            host.innerHTML = '';
            recent.forEach(item => {
              const row = document.createElement('div');
              row.className = 'sc-mini-log-row';
              const kindLabel = item.kind || '記録';
              const durLabel = Number(item.duration) ? `${item.duration}分` : '--分';
              row.innerHTML = `<div class="title">${item.title || 'ミニ授業'}</div><div class="meta">${item.date} / ${durLabel} / ${kindLabel}</div>`;
              host.appendChild(row);
            });
          }

          // Render weekday headers
          function renderWeekdays() {
            const container = $('scWeekdays');
            if (!container) return;
            container.innerHTML = '';

            for (let i = 0; i < 7; i++) {
              const dayIdx = (i + weekStart) % 7;
              const div = document.createElement('div');
              div.className = 'sc-weekday';
              if (settings.highlightWeekend && (dayIdx === 0 || dayIdx === 6)) {
                div.classList.add('weekend');
              }
              div.textContent = DAY_NAMES[dayIdx];
              container.appendChild(div);
            }
          }

          // Render month view
          function renderMonth() {
            const grid = $('scGrid');
            const title = $('scTitle');
            if (!grid) return;

            const year = currentDate.getFullYear();
            const month = currentDate.getMonth();
            title.textContent = `${year}年${month + 1}月`;

            // First day of month
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);

            // Start from the week start
            let startOffset = (firstDay.getDay() - weekStart + 7) % 7;
            const startDate = new Date(firstDay);
            startDate.setDate(startDate.getDate() - startOffset);

            const today = new Date();
            today.setHours(0, 0, 0, 0);

            grid.innerHTML = '';

            // Generate 6 weeks (42 days)
            for (let i = 0; i < 42; i++) {
              const d = new Date(startDate);
              d.setDate(startDate.getDate() + i);

              const cell = document.createElement('div');
              cell.className = 'sc-day';
              const dateStr = formatDate(d);
              cell.dataset.date = dateStr;

              if (d.getMonth() !== month) cell.classList.add('other-month');
              if (isSameDay(d, today)) cell.classList.add('today');
              if (settings.highlightWeekend && isWeekend(d)) cell.classList.add('weekend');

              // Date number
              const num = document.createElement('div');
              num.className = 'sc-day-num';
              num.textContent = d.getDate();
              cell.appendChild(num);

              // Tasks
              const tasks = sortTasksByPriority(getTasksForDate(d));
              const tasksDiv = document.createElement('div');
              tasksDiv.className = 'sc-day-tasks';

              tasks.forEach(task => {
                const chip = createTaskChip(task, dateStr, 'month');
                if (task.todo.done) chip.classList.add('done');
                tasksDiv.appendChild(chip);
              });

              cell.appendChild(tasksDiv);
              grid.appendChild(cell);
            }
          }

          // Render week view
          function renderWeek() {
            const grid = $('scWeekGrid');
            const title = $('scTitle');
            if (!grid) return;

            const today = new Date();
            today.setHours(0, 0, 0, 0);

            // Find start of week
            const dayOfWeek = (currentDate.getDay() - weekStart + 7) % 7;
            const startOfWeek = new Date(currentDate);
            startOfWeek.setDate(currentDate.getDate() - dayOfWeek);

            const endOfWeek = new Date(startOfWeek);
            endOfWeek.setDate(startOfWeek.getDate() + 6);

            title.textContent = `${startOfWeek.getMonth() + 1}/${startOfWeek.getDate()} - ${endOfWeek.getMonth() + 1}/${endOfWeek.getDate()}`;

            grid.innerHTML = '';

            for (let i = 0; i < 7; i++) {
              const d = new Date(startOfWeek);
              d.setDate(startOfWeek.getDate() + i);

              const dayDiv = document.createElement('div');
              dayDiv.className = 'sc-week-day';
              const dateStr = formatDate(d);
              dayDiv.dataset.date = dateStr;
              if (isSameDay(d, today)) dayDiv.classList.add('today');
              if (settings.highlightWeekend && isWeekend(d)) dayDiv.classList.add('weekend');
              if (selectedDate && isSameDay(d, selectedDate)) dayDiv.classList.add('selected');

              const header = document.createElement('div');
              header.className = 'sc-week-day-header';
              header.innerHTML = `
                <div class="sc-week-day-name">${DAY_NAMES[d.getDay()]}</div>
                <div class="sc-week-day-num">${d.getDate()}</div>
              `;
              dayDiv.appendChild(header);

              const tasks = sortTasksByPriority(getTasksForDate(d));
              const tasksDiv = document.createElement('div');
              tasksDiv.className = 'sc-h-day-tasks';

              tasks.forEach(task => {
                const chip = createTaskChip(task, dateStr, 'week');
                if (task.todo.done) chip.classList.add('done');
                tasksDiv.appendChild(chip);
              });

              dayDiv.appendChild(tasksDiv);
              dayDiv.onclick = () => showDayDetail(d);
              grid.appendChild(dayDiv);
            }
          }

          // Render horizontal timeline
          function renderHorizontal() {
            const timeline = $('scHTimeline');
            const title = $('scTitle');
            const PAST_DAYS = H_PAST_DAYS;
            const FUTURE_DAYS = H_FUTURE_DAYS;
            const dayCount = PAST_DAYS + FUTURE_DAYS + 1;
            if (!timeline) return;

            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const start = new Date(today);
            start.setDate(today.getDate() - PAST_DAYS);
            const end = new Date(start);
            end.setDate(start.getDate() + Math.max(dayCount - 1, 0));
            const fmt = (d) => `${d.getMonth() + 1}/${d.getDate()}`;

            title.textContent = `横スクロール (${fmt(start)}〜${fmt(end)})`;

            timeline.innerHTML = '';

            let todayEl = null;
            for (let i = 0; i < dayCount; i++) {
              const d = new Date(start);
              d.setDate(start.getDate() + i);

              const dayDiv = document.createElement('div');
              dayDiv.className = 'sc-h-day';
              const dateStr = formatDate(d);
              dayDiv.dataset.date = dateStr;
              if (isSameDay(d, today)) {
                dayDiv.classList.add('today');
                todayEl = dayDiv;
              }
              if (settings.highlightWeekend && isWeekend(d)) dayDiv.classList.add('weekend');
              if (selectedDate && isSameDay(d, selectedDate)) dayDiv.classList.add('selected');

              const header = document.createElement('div');
              header.className = 'sc-h-day-header';
              header.innerHTML = `
                <div class="sc-h-day-date">${d.getMonth() + 1}/${d.getDate()}</div>
                <div class="sc-h-day-name">${DAY_NAMES[d.getDay()]}</div>
              `;
              dayDiv.appendChild(header);

              const tasks = sortTasksByPriority(getTasksForDate(d));
              const tasksDiv = document.createElement('div');
              tasksDiv.className = 'sc-h-day-tasks';

              tasks.forEach(task => {
                const chip = createTaskChip(task, dateStr, 'horizontal');
                if (task.todo.done) chip.classList.add('done');
                tasksDiv.appendChild(chip);
              });

              dayDiv.appendChild(tasksDiv);
              dayDiv.onclick = () => showDayDetail(d);
              timeline.appendChild(dayDiv);
            }

            const host = $('scHorizontalView');
            if (host) {
              if (!hScrollBound) {
                host.addEventListener('scroll', () => { hScrollLeft = host.scrollLeft; }, { passive: true });
                hScrollBound = true;
              }
              requestAnimationFrame(() => {
                if (hScrollLeft !== null) {
                  host.scrollLeft = hScrollLeft;
                } else if (todayEl) {
                  host.scrollLeft = Math.max(0, todayEl.offsetLeft - 16);
                  hScrollLeft = host.scrollLeft;
                }
              });
            }
          }

          // Render agenda view
          function renderAgenda() {
            const list = $('scAgendaList');
            if (!list) return;

            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const title = $('scTitle');
            title.textContent = 'タスクリスト';

            // Collect all scheduled dates
            const dateMap = new Map();

            // Add next 60 days
            for (let i = 0; i < 60; i++) {
              const d = new Date(today);
              d.setDate(today.getDate() + i);
              const tasks = getTasksForDate(d);
              if (tasks.length > 0) {
                dateMap.set(formatDate(d), { date: d, tasks });
              }
            }

            list.innerHTML = '';

            if (dateMap.size === 0) {
              list.innerHTML = '<div class="sc-agenda-empty">予定されたタスクはありません</div>';
              return;
            }

            // Sort by date
            const sorted = Array.from(dateMap.entries()).sort((a, b) => a[0].localeCompare(b[0]));

            sorted.forEach(([dateStr, data]) => {
              const item = document.createElement('div');
              item.className = 'sc-agenda-item';

              const dateDiv = document.createElement('div');
              dateDiv.className = 'sc-agenda-date';
              dateDiv.innerHTML = `
                <div class="sc-agenda-date-num">${data.date.getDate()}</div>
                <div class="sc-agenda-date-day">${data.date.getMonth() + 1}月 ${DAY_NAMES[data.date.getDay()]}</div>
              `;
              item.appendChild(dateDiv);

              const tasksDiv = document.createElement('div');
              tasksDiv.className = 'sc-agenda-tasks';

              data.tasks.forEach(task => {
                const taskEl = document.createElement('div');
                taskEl.className = 'sc-agenda-task';
                if (task.todo.done) taskEl.classList.add('done');
                if (task.type === 'break') taskEl.classList.add('break');

                let text = task.todo.title || 'タスク';
                if (task.pages?.length) text += ` (${task.pages.length}P)`;
                if (task.duration) text += ` (${task.duration}分)`;
                taskEl.textContent = text;
                tasksDiv.appendChild(taskEl);
              });

              item.appendChild(tasksDiv);
              list.appendChild(item);
            });
          }

          // Switch view
          function switchView(view) {
            currentView = view;

            // Update buttons
            document.querySelectorAll('.sc-view-btn').forEach(btn => {
              btn.classList.toggle('active', btn.dataset.view === view);
            });

            // Show/hide views
            $('scMonthView')?.classList.toggle('hidden', view !== 'month');
            $('scWeekView')?.classList.toggle('hidden', view !== 'week');
            $('scHorizontalView')?.classList.toggle('hidden', view !== 'horizontal');
            $('scAgendaView')?.classList.toggle('hidden', view !== 'agenda');

            // Compact layout bar visibility
            const widthBar = $('scWidthControl');
            if (widthBar) widthBar.classList.toggle('hidden', view !== 'horizontal');

            render();
          }

          // Render current view
          function render() {
            applyLayoutSettings();
            syncSchedulesWithTodos();
            updateStats();
            renderWeekdays();

            switch (currentView) {
              case 'month': renderMonth(); break;
              case 'week': renderWeek(); break;
              case 'horizontal': renderHorizontal(); break;
              case 'agenda': renderAgenda(); break;
            }
            enhanceCalendarCells();
            updateMiniSummary();
            if (selectedDate) showDayDetail(selectedDate);
            refreshChipInfo();
            updateUndoButtons();
          }

          function recordMiniSession(entry) {
            miniLog.push({ ...entry, created: Date.now() });
            if (miniLog.length > 80) miniLog = miniLog.slice(-80);
            saveMiniLog();
            renderMiniLog();
          }

          function createMiniBlock(opts = {}) {
            const hasPlanner = window.NLStore && typeof NLStore.addAbs === 'function';
            const today = formatDate(new Date());
            const dateStr = opts.date || $('scMiniDate')?.value || today;
            const startStr = opts.start || $('scMiniStart')?.value || '09:00';
            const duration = Math.max(5, parseInt(opts.duration || $('scMiniDuration')?.value || '25', 10));
            const repeat = Math.max(1, parseInt(opts.repeat || $('scMiniRepeat')?.value || '1', 10));
            const kind = opts.kind || (opts.isBreak ? 'break' : 'lesson');
            const baseTitle = kind === 'break' ? '休憩' : 'ミニ授業';
            const title = (opts.title || $('scMiniTitle')?.value || baseTitle).trim() || baseTitle;
            const base = combineDateTime(dateStr, startStr);
            if (!base || isNaN(base)) { alert('日付・開始時刻を確認してください'); return; }
            const color = kind === 'break' ? '#f97316' : '#7dd3fc';
            for (let i = 0; i < repeat; i++) {
              const s = new Date(base);
              s.setDate(base.getDate() + i * 7);
              const e = new Date(s.getTime() + duration * 60000);
              if (hasPlanner) {
                const ev = NLStore.addAbs(s, e, title, color, kind === 'break' ? 'break' : 'lesson');
                if (opts.pageInfo && ev) {
                  ev.pageNumber = opts.pageInfo.page;
                  ev.bookId = opts.pageInfo.bookId;
                  NLStore.save();
                }
              }
              recordMiniSession({ title, date: formatDate(s), duration, kind: kind === 'break' ? '休憩' : '授業' });
            }
            if (hasPlanner) {
              try { drawPlanner && drawPlanner(); } catch (_) { }
              try { nlRebuildAll && nlRebuildAll(); } catch (_) { }
              try { PlannerCalendar && PlannerCalendar.refresh && PlannerCalendar.refresh(); } catch (_) { }
            }
            updateMiniSummary(base);
            try { showToast && showToast(hasPlanner ? '予定を追加しました' : '履歴に保存しました', 'ok'); } catch (_) { }
          }

          function initMiniUI() {
            const today = new Date();
            if ($('scMiniDate') && !$('scMiniDate').value) $('scMiniDate').value = formatDate(today);
            const hm = `${String(today.getHours()).padStart(2, '0')}:${String(today.getMinutes()).padStart(2, '0')}`;
            if ($('scMiniStart') && !$('scMiniStart').value) $('scMiniStart').value = hm;
            updateMiniSummary(today);
          }

          // Navigate
          function navigate(direction) {
            if (currentView === 'month') {
              currentDate.setMonth(currentDate.getMonth() + direction);
            } else if (currentView === 'week') {
              currentDate.setDate(currentDate.getDate() + (direction * 7));
            }
            selectedDate = new Date(currentDate);
            render();
          }

          function goToToday() {
            currentDate = new Date();
            selectedDate = new Date(currentDate);
            render();
            showDayDetail(currentDate);
          }

          // Populate TODO select
          function populateTodoSelect() {
            const select = $('scTodoSelect');
            if (!select) return;

            const todos = getTodos().filter(t => !t.done);
            select.innerHTML = '<option value="">-- ToDoを選択 --</option>';

            todos.forEach(todo => {
              const opt = document.createElement('option');
              opt.value = todo.id;
              const remaining = (todo.pages?.length || 0) - (todo.completedPages?.length || 0);
              opt.textContent = `${todo.title || '無題'} (残${remaining}P)`;
              select.appendChild(opt);
            });
          }

          // Show selected TODO info
          function showTodoInfo(todoId) {
            const infoDiv = $('scTodoInfo');
            if (!todoId) {
              infoDiv?.classList.add('hidden');
              return;
            }

            const todo = getTodos().find(t => t.id === todoId);
            if (!todo) {
              infoDiv?.classList.add('hidden');
              return;
            }

            const remaining = remainingUniquePages(todo).length;
            const perPage = todo.perPage || 5;
            const estMin = remaining * perPage;

            $('scTodoTitle').textContent = todo.title || '無題';
            $('scTodoMeta').textContent = `残り: ${remaining}P / 推定: ${estMin}分`;
            infoDiv?.classList.remove('hidden');

            // Set defaults
            const today = new Date();
            $('scScheduleStart').value = formatDate(today);

            if (todo.due) {
              $('scScheduleEnd').value = formatDate(new Date(todo.due));
            } else {
              const nextWeek = new Date(today);
              nextWeek.setDate(today.getDate() + 7);
              $('scScheduleEnd').value = formatDate(nextWeek);
            }
          }

          // Generate schedule preview
          function generatePreview() {
            const todoId = $('scTodoSelect')?.value;
            if (!todoId) {
              alert('ToDoを選択してください');
              return null;
            }

            const todo = getTodos().find(t => t.id === todoId);
            if (!todo) return null;

            const startDate = parseDate($('scScheduleStart')?.value);
            const endDate = parseDate($('scScheduleEnd')?.value);
            const mode = $('scDistributeMode')?.value || 'even';
            const skipWeekend = mode === 'weekdays';

            if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
              alert('日付を正しく入力してください');
              return null;
            }
            if (endDate < startDate) {
              alert('終了日が開始日より前です');
              return null;
            }

            // Get remaining pages
            const remainingPages = remainingUniquePages(todo);

            if (remainingPages.length === 0) {
              alert('残りページがありません');
              return null;
            }

            // Generate available dates
            const dates = [];
            let d = new Date(startDate);
            while (d <= endDate) {
              if (!skipWeekend || !isWeekend(d)) {
                dates.push(formatDate(d));
              }
              d.setDate(d.getDate() + 1);
            }

            if (dates.length === 0) {
              alert('選択可能な日付がありません');
              return null;
            }

            // Distribute pages
            const distribution = {};
            let pageIndex = 0;

            const pack = (targetDates) => {
              const chunk = Math.ceil(remainingPages.length / targetDates.length);
              targetDates.forEach(dateStr => {
                const slice = remainingPages.slice(pageIndex, pageIndex + chunk);
                if (slice.length) {
                  distribution[dateStr] = slice;
                  pageIndex += slice.length;
                }
              });
            };
            if (mode === 'front') {
              dates.forEach(dateStr => {
                if (pageIndex >= remainingPages.length) return;
                const slice = remainingPages.slice(pageIndex, pageIndex + 1);
                if (slice.length) {
                  distribution[dateStr] = slice;
                  pageIndex += slice.length;
                }
              });
              if (pageIndex < remainingPages.length) {
                const remainingDates = dates.slice(0, Math.max(1, dates.length - 1));
                while (pageIndex < remainingPages.length) {
                  remainingDates.forEach(dateStr => {
                    if (pageIndex >= remainingPages.length) return;
                    const page = remainingPages[pageIndex];
                    if (!distribution[dateStr]) distribution[dateStr] = [];
                    distribution[dateStr].push(page);
                    pageIndex++;
                  });
                }
              }
            } else if (mode === 'back') {
              const reversed = [...dates].reverse();
              pack(reversed);
            } else {
              pack(dates);
            }

            return { todoId, distribution };
          }

          function showPreview() {
            const result = generatePreview();
            if (!result) return;

            const previewArea = $('scPreviewArea');
            const previewList = $('scPreviewList');
            if (!previewArea || !previewList) return;

            previewList.innerHTML = '';

            const sortedDates = Object.keys(result.distribution).sort();
            let totalPages = 0;
            sortedDates.forEach(dateStr => {
              const pages = result.distribution[dateStr];
              const item = document.createElement('div');
              item.className = 'sc-preview-item';
              const d = parseDate(dateStr);
              item.textContent = `${d.getMonth() + 1}/${d.getDate()} (${DAY_NAMES[d.getDay()]}): ${pages.length}P`;
              previewList.appendChild(item);
              totalPages += pages.length;
            });
            if (!sortedDates.length) {
              previewList.innerHTML = '<div class="sc-hint">配分先がありません</div>';
            } else {
              const total = document.createElement('div');
              total.className = 'sc-hint';
              total.textContent = `合計 ${totalPages} ページを配分します`;
              previewList.appendChild(total);
            }

            previewArea.classList.remove('hidden');
          }

          function applySchedule() {
            const result = generatePreview();
            if (!result) return;
            const totalAssigned = Object.values(result.distribution || {}).reduce((acc, arr) => acc + (arr?.length || 0), 0);
            if (!totalAssigned) { alert('配分できるページがありません'); return; }

            const overwrite = $('scOverwriteExisting')?.checked;

            pushUndo();
            if (overwrite) {
              schedules[result.todoId] = result.distribution;
            } else {
              if (!schedules[result.todoId]) schedules[result.todoId] = {};
              Object.assign(schedules[result.todoId], result.distribution);
            }

            saveSettings();
            $('scPreviewArea')?.classList.add('hidden');
            render();

            try { showToast && showToast(`スケジュールを適用しました（${totalAssigned}P）`, 'ok'); } catch (e) { }
          }

          function autoDistribute() {
            const todoId = $('scTodoSelect')?.value;
            if (!todoId) { alert('ToDoを選択してください'); return; }
            const todo = getTodos().find(t => t.id === todoId);
            const remaining = remainingUniquePages(todo);
            if (!remaining.length) { alert('残りページがありません'); return; }
            // If end date before start, fix it
            const startEl = $('scScheduleStart');
            const endEl = $('scScheduleEnd');
            if (startEl && endEl) {
              const s = parseDate(startEl.value);
              const e = parseDate(endEl.value);
              if (e < s) endEl.value = startEl.value;
            }
            const result = generatePreview();
            if (!result || !Object.keys(result.distribution).length) { alert('配分先が見つかりません'); return; }
            applySchedule();
          }

          // Event bindings
          function bind() {
            // View buttons
            document.querySelectorAll('.sc-view-btn').forEach(btn => {
              btn.addEventListener('click', () => switchView(btn.dataset.view));
            });

            // Navigation
            $('scPrev')?.addEventListener('click', () => navigate(-1));
            $('scNext')?.addEventListener('click', () => navigate(1));
            $('scToday')?.addEventListener('click', goToToday);
            $('scRefresh')?.addEventListener('click', () => { populateTodoSelect(); render(); });
            $('scUndo')?.addEventListener('click', undoAction);
            $('scRedo')?.addEventListener('click', redoAction);

            // TODO selection
            $('scTodoSelect')?.addEventListener('change', (e) => showTodoInfo(e.target.value));
            $('scTodoRefresh')?.addEventListener('click', populateTodoSelect);

            // Schedule
            $('scPreviewSchedule')?.addEventListener('click', showPreview);
            $('scApplySchedule')?.addEventListener('click', applySchedule);
            $('scAutoDistribute')?.addEventListener('click', autoDistribute);

            // Settings
            $('scWeekStart')?.addEventListener('change', (e) => {
              weekStart = parseInt(e.target.value, 10);
              settings.weekStart = weekStart;
              saveSettings();
              render();
            });
            const tweakWidth = (delta) => {
              settings.hWidth = clamp((Number(settings.hWidth) || 120) + delta, 90, 200);
              applyLayoutSettings();
              saveSettings();
              render();
            };
            $('scWidthFine')?.addEventListener('input', (e) => {
              settings.hWidth = clamp(parseInt(e.target.value, 10) || 120, 90, 200);
              applyLayoutSettings();
              saveSettings();
              render();
            });
            $('scWidthDec')?.addEventListener('click', () => tweakWidth(-5));
            $('scWidthInc')?.addEventListener('click', () => tweakWidth(5));

            const shell = document.querySelector('#plannerApp .calendar-shell');
            if (shell) {
              shell.addEventListener('wheel', (e) => {
                if (currentView !== 'horizontal' || !e.ctrlKey) return;
                e.preventDefault();
                const delta = e.deltaY > 0 ? 5 : -5;
                tweakWidth(delta);
              }, { passive: false });
            }
            $('scShowComplete')?.addEventListener('change', (e) => {
              settings.showComplete = e.target.checked;
              saveSettings();
              render();
            });
            $('scHighlightWeekend')?.addEventListener('change', (e) => {
              settings.highlightWeekend = e.target.checked;
              saveSettings();
              render();
            });
            $('scShowProgress')?.addEventListener('change', (e) => {
              settings.showProgress = e.target.checked;
              saveSettings();
              render();
            });
            $('scZoomSlider')?.addEventListener('input', (e) => {
              settings.zoom = parseFloat(e.target.value) || 1;
              applyLayoutSettings();
              saveSettings();
              render();
            });
            $('scWidthSlider')?.addEventListener('input', (e) => {
              settings.hWidth = parseInt(e.target.value, 10) || 120;
              applyLayoutSettings();
              saveSettings();
            });
            $('scWeekHeightSlider')?.addEventListener('input', (e) => {
              settings.weekHeight = parseFloat(e.target.value) || 1.1;
              applyLayoutSettings();
              saveSettings();
              render();
            });
            $('scAsideWidthSlider')?.addEventListener('input', (e) => {
              settings.asideWidth = parseInt(e.target.value, 10) || 400;
              applyLayoutSettings();
              saveSettings();
            });
            $('scExpandToggle')?.addEventListener('click', () => {
              settings.immersive = !settings.immersive;
              applyLayoutSettings();
              saveSettings();
            });
            $('scFocusToday')?.addEventListener('click', () => { goToToday(); showDayDetail(new Date()); });

            // Mini lesson / break creators
            const pad2 = (n) => String(n).padStart(2, '0');
            const startNowOpts = () => {
              const now = new Date();
              return { date: formatDate(now), start: `${pad2(now.getHours())}:${pad2(now.getMinutes())}` };
            };
            $('scMiniAdd')?.addEventListener('click', () => createMiniBlock());
            $('scMiniBreakQuick')?.addEventListener('click', () => {
              const base = startNowOpts();
              createMiniBlock({ kind: 'break', duration: 10, date: $('scMiniDate')?.value || base.date, start: $('scMiniStart')?.value || base.start, title: '休憩' });
            });
            $('scMiniNow')?.addEventListener('click', () => {
              const base = startNowOpts();
              createMiniBlock({ date: base.date, start: base.start });
            });
            $('scMiniFromPage')?.addEventListener('click', () => {
              const meta = (window.PlannerCalendar && typeof PlannerCalendar.lastVisit === 'function') ? PlannerCalendar.lastVisit() : null;
              const base = startNowOpts();
              const title = meta ? `今すぐ: ${(meta.bookTitle || '本')} p${meta.page || ''}` : '今すぐミニ授業';
              createMiniBlock({ date: base.date, start: base.start, title, pageInfo: meta ? { bookId: meta.bookId, page: meta.page } : null });
            });
            $('scMiniWeeklyGoal')?.addEventListener('input', () => updateMiniSummary());
            $('scMiniDate')?.addEventListener('change', () => updateMiniSummary($('scMiniDate')?.value));

            document.addEventListener('keydown', (e) => {
              const tab = document.querySelector('#plannerApp .tab-content[data-content="calendar"]');
              if (!tab || !tab.classList.contains('active')) return;
              if (!(e.ctrlKey || e.metaKey)) return;
              const target = e.target;
              const isEditable = target && (
                target.tagName === 'INPUT' ||
                target.tagName === 'TEXTAREA' ||
                target.tagName === 'SELECT' ||
                target.isContentEditable
              );
              if (isEditable) return;
              const key = (e.key || '').toLowerCase();
              if (key === 'z' && !e.shiftKey) {
                undoAction();
                e.preventDefault();
              } else if ((key === 'z' && e.shiftKey) || key === 'y') {
                redoAction();
                e.preventDefault();
              }
            });
          }

          // Initialize
          function init() {
            loadSettings();
            loadCompleted();
            loadMiniLog();
            weekStart = Number(settings.weekStart ?? 1) || 1;
            settings.weekStart = weekStart;
            applyLayoutSettings();
            setupResizer();
            syncSchedulesWithTodos();
            bind();
            populateTodoSelect();
            render();
            showDayDetail(currentDate);
            renderMiniLog();
          }

          // ========== Day Detail & Completed Pages ==========
          const COMPLETED_KEY = 'sc-completed';
          let completedRecords = {}; // { dateStr: [{ bookId, page, title, timestamp }] }
          let selectedDate = null;
          let selectedPages = [];
          let completedPruneWarned = false;
          let completedIdbLoaded = false;
          let completedIdbLoading = false;

          function buildCompletedSnapshot(records) {
            const out = {};
            if (!records || typeof records !== 'object') return out;
            Object.entries(records).forEach(([date, list]) => {
              if (Array.isArray(list) && list.length) out[date] = list.slice();
            });
            return out;
          }

          function loadCompleted() {
            let local = null;
            try {
              const data = localStorage.getItem(COMPLETED_KEY);
              if (data) local = JSON.parse(data);
            } catch (e) { }
            if (local && typeof local === 'object') {
              const localCount = (typeof countCompletedRecords === 'function') ? countCompletedRecords(local) : 0;
              const currentCount = (typeof countCompletedRecords === 'function') ? countCompletedRecords(completedRecords) : 0;
              if (localCount >= currentCount) completedRecords = local;
            }
            if (completedIdbLoaded || completedIdbLoading) return;
            completedIdbLoading = true;
            (async () => {
              try {
                const rec = await ScheduleDB.get('completed');
                const backup = rec?.value || rec?.data || null;
                if (backup && typeof backup === 'object') {
                  const backupCount = (typeof countCompletedRecords === 'function') ? countCompletedRecords(backup) : 0;
                  const currentCount = (typeof countCompletedRecords === 'function') ? countCompletedRecords(completedRecords) : 0;
                  if (backupCount > currentCount) {
                    completedRecords = backup;
                    saveCompleted();
                    try { render(); } catch (_) { }
                    try { if (selectedDate) showDayDetail(selectedDate); } catch (_) { }
                    try { if (typeof renderHomeView === 'function') renderHomeView(true); } catch (_) { }
                  } else if (currentCount > backupCount) {
                    ScheduleDB.set('completed', completedRecords);
                  }
                } else {
                  const currentCount = (typeof countCompletedRecords === 'function') ? countCompletedRecords(completedRecords) : 0;
                  if (currentCount > 0) ScheduleDB.set('completed', completedRecords);
                }
              } catch (_) { }
              completedIdbLoaded = true;
              completedIdbLoading = false;
            })();
          }

          const isQuotaError = (err) => {
            if (!err) return false;
            const name = String(err.name || '');
            const msg = String(err.message || '').toLowerCase();
            return err.code === 22
              || name === 'QuotaExceededError'
              || name === 'NS_ERROR_DOM_QUOTA_REACHED'
              || msg.includes('quota');
          };
          const trySaveCompleted = (records) => {
            try {
              localStorage.setItem(COMPLETED_KEY, JSON.stringify(records));
              return { ok: true };
            } catch (e) {
              return { ok: false, error: e };
            }
          };
          function saveCompleted(opts = {}) {
            const keepDate = opts.keepDate ? String(opts.keepDate) : '';
            let pruned = false;
            const localSnapshot = buildCompletedSnapshot(completedRecords);
            let attempt = trySaveCompleted(localSnapshot);
            if (!attempt.ok && !isQuotaError(attempt.error)) {
              ScheduleDB.set('completed', completedRecords);
              return { ok: false, pruned: false, error: attempt.error };
            }
            if (attempt.ok) {
              ScheduleDB.set('completed', completedRecords);
              return { ok: true, pruned: false };
            }
            // If storage quota is exceeded, prune old completed records and retry.
            Object.keys(localSnapshot || {}).forEach(date => {
              const list = localSnapshot[date];
              if (!Array.isArray(list) || !list.length) {
                delete localSnapshot[date];
                pruned = true;
              }
            });
            attempt = trySaveCompleted(localSnapshot);
            if (attempt.ok) {
              ScheduleDB.set('completed', completedRecords);
              return { ok: true, pruned };
            }
            const dates = Object.keys(localSnapshot || {}).sort();
            for (const date of dates) {
              if (keepDate && date === keepDate) continue;
              delete localSnapshot[date];
              pruned = true;
              attempt = trySaveCompleted(localSnapshot);
              if (attempt.ok) {
                ScheduleDB.set('completed', completedRecords);
                return { ok: true, pruned };
              }
            }
            if (keepDate && Array.isArray(localSnapshot[keepDate]) && localSnapshot[keepDate].length > 200) {
              localSnapshot[keepDate].sort((a, b) => (a?.timestamp || 0) - (b?.timestamp || 0));
              localSnapshot[keepDate] = localSnapshot[keepDate].slice(-200);
              pruned = true;
              attempt = trySaveCompleted(localSnapshot);
              if (attempt.ok) {
                ScheduleDB.set('completed', completedRecords);
                return { ok: true, pruned };
              }
            }
            ScheduleDB.set('completed', completedRecords);
            return { ok: false, pruned, error: attempt.error };
          }

          // Record page completion (called from TODO system)
          function recordCompletion(bookId, page, title, dateOverride) {
            loadCompleted();
            let dateStr = formatDate(new Date());
            if (dateOverride) {
              const raw = String(dateOverride || '').trim();
              const parsed = parseDate(raw);
              if (parsed instanceof Date && !isNaN(parsed)) {
                const today = parseDate(formatDate(new Date()));
                const clamped = parsed > today ? today : parsed;
                dateStr = formatDate(clamped);
              }
            }
            if (!completedRecords[dateStr]) completedRecords[dateStr] = [];
            const pageNum = normalizePage(page);
            const exists = completedRecords[dateStr].some(r => {
              const recPage = normalizePage(r.page);
              const pageMatch = pageNum != null
                ? recPage === pageNum
                : String(r.page || '') === String(page || '');
              if (!pageMatch) return false;
              const recBook = r.bookId != null ? String(r.bookId).trim() : '';
              const newBook = bookId != null ? String(bookId).trim() : '';
              if (!recBook || !newBook) return true;
              return recBook === newBook;
            });
            if (!exists) {
              completedRecords[dateStr].push({ bookId, page: pageNum ?? page, title, timestamp: Date.now() });
              const saved = saveCompleted({ keepDate: dateStr });
              if (!saved.ok) {
                showToast && showToast('完了記録の保存に失敗しました。ストレージ容量を確認してください。', 'error');
                loadCompleted();
              } else if (saved.pruned && !completedPruneWarned) {
                completedPruneWarned = true;
                showToast && showToast('完了記録が多いため表示用の履歴を整理しました。', 'info');
              }
            }
            if (pageNum !== null && bookId) {
              const todos = getTodos().filter(t => t.bookId === bookId);
              let changed = false;
              todos.forEach(todo => { if (pruneScheduleForTodo(todo, pageNum)) changed = true; });
              if (changed) { saveSettings(); }
              // 再描画して完了表示を即時反映
              try { render(); } catch (_) { }
            }
            try { if (typeof window.__clearPageProgress === 'function') window.__clearPageProgress(bookId, pageNum ?? page); } catch (_) { }
          }

          function getBookCompletedPageSet(bookId) {
            const set = new Set();
            if (!bookId) return set;
            Object.values(completedRecords || {}).forEach(list => {
              (Array.isArray(list) ? list : []).forEach(rec => {
                if (String(rec.bookId || '') === String(bookId || '')) {
                  const num = normalizePage(rec.page);
                  if (Number.isFinite(num)) set.add(num);
                }
              });
            });
            return set;
          }

          function getCompletedForDate(dateStr) {
            loadCompleted();
            return completedRecords[dateStr] || [];
          }
          function getCompletedSnapshot() {
            loadCompleted();
            return buildCompletedSnapshot(completedRecords);
          }
          function removeCompletedForDate(dateStr, bookId, page, ts) {
            loadCompleted(); // ensure latest data from storage
            if (!dateStr) return false;
            const list = completedRecords[dateStr];
            if (!Array.isArray(list) || !list.length) return false;
            const pageNum = normalizePage(page);
            const tsNum = Number(ts);
            const hasTs = Number.isFinite(tsNum);
            let removed = false;
            completedRecords[dateStr] = list.filter((rec) => {
              if (removed) return true;
              const sameBook = bookId ? String(rec?.bookId || '') === String(bookId || '') : true;
              const recPage = normalizePage(rec?.page);
              const matchPage = pageNum === null
                ? true
                : (recPage !== null && recPage === pageNum) || String(rec?.page || '') === String(page || '');
              const matchTs = hasTs && Number(rec?.timestamp) === tsNum;
              if (matchTs || (sameBook && matchPage)) {
                removed = true;
                return false;
              }
              return true;
            });
            if (!removed && hasTs) {
              const idx = completedRecords[dateStr].findIndex(rec => Number(rec?.timestamp) === tsNum);
              if (idx >= 0) {
                completedRecords[dateStr].splice(idx, 1);
                removed = true;
              }
            }
            // 追加フォールバック: ページ指定があっても削除できなかった場合、同じ本の最初の記録を削除
            if (!removed && completedRecords[dateStr].length && String(bookId || '')) {
              const idx = completedRecords[dateStr].findIndex(rec => String(rec?.bookId || '') === String(bookId));
              if (idx >= 0) {
                completedRecords[dateStr].splice(idx, 1);
                removed = true;
              }
            }
            if (completedRecords[dateStr].length === 0) delete completedRecords[dateStr];
            if (removed) {
              const saved = saveCompleted({ keepDate: dateStr });
              if (!saved.ok) {
                loadCompleted();
                return false;
              }
            }
            return removed;
          }

          function applyCompletedHeight() {
            const wrap = $('scCompletedWrap');
            if (!wrap) return;
            wrap.style.height = completedCollapsed ? '0px' : `${completedHeight}px`;
            wrap.classList.toggle('collapsed', completedCollapsed);
            const toggle = $('scCompletedToggle');
            if (toggle) toggle.textContent = completedCollapsed ? '展開' : '折りたたみ';
          }

          function setupCompletedResizer() {
            const wrap = $('scCompletedWrap');
            const handle = $('scCompletedResize');
            const toggle = $('scCompletedToggle');
            if (!wrap || !handle) return;
            let resizing = false;
            let startY = 0;
            let startH = completedHeight;
            const onMove = (e) => {
              if (!resizing || completedCollapsed) return;
              const delta = e.clientY - startY;
              completedHeight = clamp(startH + delta, 140, 520);
              wrap.style.height = `${completedHeight}px`;
              try { localStorage.setItem(COMPLETED_HEIGHT_KEY, String(completedHeight)); } catch (_) { }
              e.preventDefault();
            };
            const stop = () => { resizing = false; document.body.classList.remove('resizing-calendar'); };
            handle.addEventListener('pointerdown', (e) => {
              if (completedCollapsed) return;
              resizing = true;
              startY = e.clientY;
              startH = wrap.getBoundingClientRect().height;
              document.body.classList.add('resizing-calendar');
              e.preventDefault();
            });
            window.addEventListener('pointermove', onMove);
            window.addEventListener('pointerup', stop);
            window.addEventListener('pointercancel', stop);
            if (toggle) {
              toggle.addEventListener('click', () => {
                completedCollapsed = !completedCollapsed;
                try { localStorage.setItem(COMPLETED_COLLAPSED_KEY, completedCollapsed ? '1' : '0'); } catch (_) { }
                applyCompletedHeight();
              });
            }
            applyCompletedHeight();
          }

          // Show day detail panel
          function showDayDetail(date) {
            selectedDate = date;
            const dateStr = formatDate(date);
            const panel = $('scDayDetail');
            if (!panel) return;
            const wasHidden = panel.classList.contains('hidden');
            panel.classList.remove('hidden');
            const asideScroll = document.querySelector('.calendar-aside-scroll');
            if (asideScroll && wasHidden) { asideScroll.scrollTo({ top: 0, behavior: 'smooth' }); }
            document.querySelectorAll('.sc-day.selected, .sc-week-day.selected, .sc-h-day.selected').forEach(el => el.classList.remove('selected'));
            document.querySelectorAll(`[data-date="${dateStr}"]`).forEach(el => el.classList.add('selected'));
            applyCompletedHeight();

            $('scDDTitle').textContent = `${date.getMonth() + 1}月${date.getDate()}日（${DAY_NAMES[date.getDay()]}）`;

            // Render scheduled tasks
            const tasksDiv = $('scDDTasks');
            tasksDiv.innerHTML = '';
            const tasks = sortTasksByPriority(getTasksForDate(date));

            if (tasks.length === 0) {
              tasksDiv.innerHTML = '<div class="home-empty">予定なし</div>';
            } else {
              tasks.forEach(task => {
                const item = document.createElement('div');
                item.className = 'sc-dd-task-item';
                const isPlanner = !!task.plannerEvent;
                item.draggable = !isPlanner;
                item.dataset.todoId = task.todoId;
                item.dataset.date = dateStr;
                const metaLabel = task.duration ? `${task.duration}分` : `${task.pages?.length || 0}P`;
                const badge = task.type === 'scheduled' ? '配分' : task.type === 'due' ? '期限' : task.type === 'break' ? '休憩' : '予定';
                const actions = isPlanner
                  ? `<button class="sc-dd-task-btn" data-action="jump">プランナー</button>`
                  : `<button class="sc-dd-task-btn" data-action="open">開く</button><button class="sc-dd-task-btn delete" data-action="delete">削除</button>`;
                item.innerHTML = `
                  <span class="sc-dd-task-title">${task.todo.title || 'タスク'}</span>
                  <span class="sc-dd-task-pages">${badge} / ${metaLabel}</span>
                  <div class="sc-dd-task-actions">${actions}</div>
                `;
                if (isPlanner) {
                  item.classList.add('planner');
                  const jump = item.querySelector('[data-action="jump"]');
                  if (jump) jump.onclick = () => { showTab('planner'); try { __activatePlannerTab?.('planner'); } catch (_) { } };
                  item.ondragstart = null;
                } else {
                  item.querySelector('[data-action="open"]').onclick = () => openTodoBook(task.todoId);
                  item.querySelector('[data-action="delete"]').onclick = () => removeTaskFromDate(task.todoId, dateStr);
                  item.ondragstart = (e) => { e.dataTransfer.setData('text/plain', JSON.stringify({ todoId: task.todoId, fromDate: dateStr })); };
                }
                tasksDiv.appendChild(item);
              });
            }

            // Render completed pages
            const completedDiv = $('scDDCompleted');
            completedDiv.innerHTML = '';
            const completed = getCompletedForDate(dateStr);

            if (completed.length === 0) {
              completedDiv.innerHTML = '<div class="home-empty">完了記録なし</div>';
            } else {
              completed.forEach(rec => {
                const item = document.createElement('div');
                item.className = 'sc-dd-completed-item';
                item.innerHTML = `<span>${rec.title || '本'} P.${rec.page}</span>`;
                item.onclick = () => openCompletedViewer(rec.bookId, { date: dateStr, page: rec.page, bookId: rec.bookId });
                completedDiv.appendChild(item);
              });
            }

            // Populate TODO select for adding
            populateDDTodoSelect();
            panel.classList.remove('hidden');
          }

          function hideDayDetail() {
            $('scDayDetail')?.classList.add('hidden');
            selectedDate = null;
            document.querySelectorAll('.sc-day.selected, .sc-week-day.selected, .sc-h-day.selected').forEach(el => el.classList.remove('selected'));
          }

          let chipInfoState = { todoId: '', date: '' };

          const pageSelection = { todoId: null, set: new Set(), lastIndex: null };
          const chipInfoOriginalOrders = {};
          const chipInfoDrag = { todoId: null, date: null, el: null, changed: false };

          function clearPageSelection() {
            pageSelection.set.clear();
            pageSelection.lastIndex = null;
          }

          function getChipOrderKey(todoId, dateStr) {
            return `${String(todoId || '')}::${String(dateStr || '')}`;
          }

          function rememberChipOriginalOrder(todoId, dateStr, pages) {
            const key = getChipOrderKey(todoId, dateStr);
            if (!chipInfoOriginalOrders[key]) {
              chipInfoOriginalOrders[key] = Array.isArray(pages) ? pages.slice() : [];
            }
          }

          function setChipOriginalOrder(todoId, dateStr, pages) {
            const key = getChipOrderKey(todoId, dateStr);
            chipInfoOriginalOrders[key] = Array.isArray(pages) ? pages.slice() : [];
          }

          function setSchedulePageOrder(todoId, dateStr, pages) {
            if (!todoId || !dateStr) return;
            const list = (Array.isArray(pages) ? pages : []).map(normalizePage).filter(Number.isFinite);
            if (!list.length) return;
            const existing = (schedules[todoId]?.[dateStr] || []).map(normalizePage).filter(Number.isFinite);
            const same = existing.length === list.length && existing.every((v, i) => v === list[i]);
            if (!same) pushUndo();
            if (!schedules[todoId]) schedules[todoId] = {};
            schedules[todoId][dateStr] = list;
            saveSettings();
          }

          function collectPagesFromContainer(container) {
            if (!container) return [];
            const list = [];
            container.querySelectorAll('.sc-dd-page-btn').forEach(btn => {
              const p = normalizePage(btn.dataset.page);
              if (Number.isFinite(p)) list.push(p);
            });
            return list;
          }

          function shouldClearSelectionOnClick(todoId, dateStr) {
            if (pageSelection.todoId !== todoId || pageSelection.set.size === 0) return false;
            if (!selectedDate) return true;
            if (!dateStr) return true;
            return isSameDay(selectedDate, new Date(dateStr));
          }

          function renderChipInfoContent(info, payload) {
            if (!info || !payload) return;
            const { todoId, date, pages, todo } = payload;
            ensureSelectionTodo(todoId);
            info.dataset.todoId = todoId || '';
            info.dataset.date = date || '';
            info.querySelector('#scChipInfoTitle').textContent = todo?.title || '配分';
            chipInfoState = { todoId: info.dataset.todoId, date: info.dataset.date };
            rememberChipOriginalOrder(todoId, date, (pages || []).map(normalizePage).filter(Number.isFinite));

            const pagesArea = info.querySelector('#scChipInfoPages');
            pagesArea.innerHTML = '';
            const pageWrap = document.createElement('div');
            pageWrap.style.display = 'grid';
            pageWrap.style.gridTemplateColumns = 'repeat(auto-fill,minmax(40px,1fr))';
            pageWrap.style.gap = '6px';
            pageWrap.style.maxHeight = '160px';
            pageWrap.style.overflow = 'auto';
            pageWrap.dataset.todoId = todoId || '';
            pageWrap.dataset.date = date || '';
            const memorySet = getScheduleMemorySet(todoId, date || '');
            const list = Array.from(new Set([...(pages && pages.length ? pages : []), ...memorySet]));
            if (!list.length) list.push('?');
            const completedSet = new Set((todo?.completedPages || []).map(normalizePage).filter(Number.isFinite));
            const assignedSet = new Set((pages || []).map(normalizePage).filter(Number.isFinite));
            list.forEach((p, idx) => {
              const btn = document.createElement('button');
              btn.className = 'sc-dd-page-btn';
              btn.textContent = p;
              const num = normalizePage(p);
              const isCompleted = (assignedSet.has(num) && completedSet.has(num)) || memorySet.has(num);
              if (isCompleted) btn.classList.add('completed');
              btn.draggable = !isCompleted;
              btn.dataset.page = p;
              btn.dataset.index = idx;
              btn.addEventListener('dragstart', (ev) => {
                if (isCompleted) { ev.preventDefault(); return; }
                ev.dataTransfer.effectAllowed = 'move';
                const sel = (pageSelection.todoId === todoId && pageSelection.set.size) ? Array.from(pageSelection.set) : [p];
                ev.dataTransfer.setData('text/plain', JSON.stringify({ todoId, fromDate: date, pages: sel, origin: 'chip-info' }));
                chipInfoDrag.todoId = todoId;
                chipInfoDrag.date = date;
                chipInfoDrag.el = btn;
                chipInfoDrag.changed = false;
                btn.classList.add('dragging');
              });
              btn.addEventListener('dragover', (ev) => {
                if (!chipInfoDrag.el || chipInfoDrag.todoId !== todoId || chipInfoDrag.date !== date) return;
                ev.preventDefault();
                const target = ev.currentTarget;
                if (target === chipInfoDrag.el) return;
                const prevRects = new Map();
                pageWrap.querySelectorAll('.sc-dd-page-btn').forEach(el => {
                  prevRects.set(el, el.getBoundingClientRect());
                });
                const rect = target.getBoundingClientRect();
                const before = ev.clientX < rect.left + rect.width / 2;
                pageWrap.insertBefore(chipInfoDrag.el, before ? target : target.nextSibling);
                requestAnimationFrame(() => {
                  pageWrap.querySelectorAll('.sc-dd-page-btn').forEach(el => {
                    const first = prevRects.get(el);
                    if (!first) return;
                    const last = el.getBoundingClientRect();
                    const dx = first.left - last.left;
                    const dy = first.top - last.top;
                    if (dx || dy) {
                      el.animate(
                        [
                          { transform: `translate(${dx}px, ${dy}px)` },
                          { transform: 'translate(0, 0)' }
                        ],
                        { duration: 160, easing: 'ease-out' }
                      );
                    }
                  });
                });
                chipInfoDrag.changed = true;
              });
              btn.addEventListener('dragend', () => {
                if (!chipInfoDrag.el || chipInfoDrag.todoId !== todoId || chipInfoDrag.date !== date) {
                  chipInfoDrag.todoId = null;
                  chipInfoDrag.date = null;
                  chipInfoDrag.el = null;
                  btn.classList.remove('dragging');
                  return;
                }
                chipInfoDrag.el.classList.remove('dragging');
                if (chipInfoDrag.changed) {
                  const ordered = collectPagesFromContainer(pageWrap);
                  setSchedulePageOrder(todoId, date, ordered);
                  refreshChipInfo();
                }
                chipInfoDrag.todoId = null;
                chipInfoDrag.date = null;
                chipInfoDrag.el = null;
                chipInfoDrag.changed = false;
              });
              btn.onclick = (ev) => {
                if (isCompleted) { ev.preventDefault(); ev.stopPropagation(); return; }
                if (ev.shiftKey || ev.ctrlKey || ev.metaKey) {
                  handlePageButtonSelection(ev, { todoId, idx, page: p, pages: list, container: pageWrap });
                  ev.stopPropagation();
                  ev.preventDefault();
                  return;
                }
                if (shouldClearSelectionOnClick(todoId, date)) {
                  clearPageSelection();
                  applySelectionStyles(pageWrap, todoId);
                  if (!selectedDate && date) showDayDetail(new Date(date));
                  return;
                }
                if (selectedDate) {
                  placePages(todoId, [p], formatDate(selectedDate));
                  return;
                }
                if (date) showDayDetail(new Date(date));
              };
              btn.oncontextmenu = (ev) => {
                ev.preventDefault();
                if (isCompleted) return;
                handlePageButtonSelection(ev, { todoId, idx, page: p, pages: list, container: pageWrap, forceToggle: true });
              };
              pageWrap.appendChild(btn);
            });
            pagesArea.appendChild(pageWrap);
            applySelectionStyles(pageWrap, todoId);
          }

          function refreshChipInfo() {
            const info = document.getElementById('scChipInfo');
            if (!info || info.style.display === 'none') return;
            const todoId = info.dataset.todoId;
            const date = info.dataset.date;
            if (!todoId || !date) return;
            const pages = (schedules[todoId]?.[date] || []).map(normalizePage).filter(Number.isFinite);
            if (!pages.length) { info.style.display = 'none'; return; }
            const todo = getTodos().find(t => t.id === todoId);
            renderChipInfoContent(info, { todoId, date, pages, todo });
          }

          function showChipInfo(e, task) {
            if (!task) return;
            e?.preventDefault?.();
            let info = document.getElementById('scChipInfo');
            const todoId = task.todoId;
            const date = task.date;

            if (info && info.style.display !== 'none' &&
              info.dataset?.todoId === String(todoId || '') &&
              info.dataset?.date === String(date || '')) {
              info.style.display = 'none';
              chipInfoState = { todoId: '', date: '' };
              return;
            }

            if (!info) {
              info = document.createElement('div');
              info.id = 'scChipInfo';
              info.innerHTML = `
                <div class="chip-info-header" id="scChipInfoHeader">
                  <span id="scChipInfoTitle">配分</span>
                  <div class="row" style="gap:4px">
                    <button class="btn ghost small" id="scChipInfoClose">×</button>
                  </div>
                </div>
                <div class="chip-info-body">
                  <div><strong>ページ:</strong></div>
                  <div id="scChipInfoPages"></div>
                  <div class="chip-info-actions">
                    <select id="scChipInfoSort" class="sc-chip-sort" title="ページ並び替え">
                      <option value="original">オリジナル</option>
                      <option value="asc">数字の小さい順</option>
                      <option value="desc">数字の大きい順</option>
                    </select>
                    <button class="btn ghost small danger" id="scChipInfoDelete">削除</button>
                  </div>
                </div>
              `;
              document.body.appendChild(info);
              const header = info.querySelector('#scChipInfoHeader');
              let drag = false, sx = 0, sy = 0, ox = 0, oy = 0;
              header?.addEventListener('pointerdown', (ev) => {
                drag = true; sx = ev.clientX; sy = ev.clientY;
                const rect = info.getBoundingClientRect(); ox = rect.left; oy = rect.top;
                ev.preventDefault();
              });
              window.addEventListener('pointermove', (ev) => {
                if (!drag) return;
                const nx = ox + (ev.clientX - sx);
                const ny = oy + (ev.clientY - sy);
                info.style.left = `${Math.max(12, Math.min(window.innerWidth - info.offsetWidth - 12, nx))}px`;
                info.style.top = `${Math.max(12, Math.min(window.innerHeight - info.offsetHeight - 12, ny))}px`;
              });
              window.addEventListener('pointerup', () => { drag = false; });
            }
            info.style.display = 'block';
            info.style.left = `${Math.min(window.innerWidth - 260, (e?.clientX || 80))}px`;
            info.style.top = `${Math.min(window.innerHeight - 200, (e?.clientY || 80))}px`;
            const pages = task.pages;
            const todo = getTodos().find(t => t.id === todoId) || task.todo;
            setChipOriginalOrder(todoId, date, (pages || []).map(normalizePage).filter(Number.isFinite));
            renderChipInfoContent(info, { todoId, date, pages, todo });

            const closeBtn = info.querySelector('#scChipInfoClose');
            const delBtn = info.querySelector('#scChipInfoDelete');
            const sortSel = info.querySelector('#scChipInfoSort');
            closeBtn.onclick = () => {
              delete chipInfoOriginalOrders[getChipOrderKey(todoId, date)];
              info.style.display = 'none';
              chipInfoState = { todoId: '', date: '' };
            };
            delBtn.onclick = () => {
              delete chipInfoOriginalOrders[getChipOrderKey(todoId, date)];
              removeTaskFromDate(todoId, date);
              info.style.display = 'none';
              chipInfoState = { todoId: '', date: '' };
            };
            if (sortSel) {
              sortSel.value = 'original';
              sortSel.onchange = () => {
                const mode = sortSel.value;
                const key = getChipOrderKey(todoId, date);
                let ordered = [];
                const current = (schedules[todoId]?.[date] || []).map(normalizePage).filter(Number.isFinite);
                if (mode === 'asc') {
                  ordered = current.slice().sort((a, b) => a - b);
                } else if (mode === 'desc') {
                  ordered = current.slice().sort((a, b) => b - a);
                } else {
                  ordered = (chipInfoOriginalOrders[key] || current).slice();
                }
                setSchedulePageOrder(todoId, date, ordered);
                refreshChipInfo();
              };
            }
          }
          window.__scShowChipInfo = showChipInfo;

          function populateDDTodoSelect() {
            const select = $('scDDTodoSelect');
            if (!select) return;
            const todos = getTodos().filter(t => !t.done);
            select.innerHTML = '<option value="">-- ToDoを選択 --</option>';
            todos.forEach(todo => {
              const opt = document.createElement('option');
              opt.value = todo.id;
              opt.textContent = todo.title || '無題';
              select.appendChild(opt);
            });
          }

          function renderDDPageGrid(todoId) {
            const grid = $('scDDPageGrid');
            if (!grid) return;
            if (!selectedDate) {
              grid.innerHTML = '<div class="sc-hint">左の日付を先に選択してください</div>';
              return;
            }
            if (!todoId) { grid.innerHTML = ''; return; }

            const todo = getTodos().find(t => t.id === todoId);
            if (!todo || !todo.pages) { grid.innerHTML = ''; return; }

            grid.innerHTML = '';
            const completedSet = new Set((todo.completedPages || []).map(normalizePage).filter(Number.isFinite));
            const memSet = selectedDate ? getScheduleMemorySet(todoId, formatDate(selectedDate)) : new Set();
            const assignedToday = new Set((schedules[todoId]?.[formatDate(selectedDate)] || []).map(normalizePage).filter(Number.isFinite));
            const pagesArr = todo.pages.slice();
            clearPageSelection();
            pageSelection.todoId = todoId;

            todo.pages.forEach((page, idx) => {
              const btn = document.createElement('button');
              btn.className = 'sc-dd-page-btn';
              const normalizedPage = normalizePage(page);
              const isCompleted = (completedSet.has(normalizedPage) || memSet.has(normalizedPage)) && assignedToday.has(normalizedPage);
              if (isCompleted) btn.classList.add('completed');
              btn.textContent = page;
              const assignedDate = findAssignedDate(todoId, page);
              if (assignedDate) btn.classList.add('assigned');
              btn.draggable = !isCompleted;
              btn.dataset.todoId = todoId;
              btn.dataset.page = page;
              btn.dataset.index = idx;
              btn.title = isCompleted
                ? '完了済み（配分は保持）'
                : assignedDate
                  ? `予定: ${assignedDate}`
                  : 'ドラッグで日付へ移動';
              btn.addEventListener('dragstart', (ev) => {
                if (btn.classList.contains('completed')) { ev.preventDefault(); return; }
                ev.dataTransfer.effectAllowed = 'move';
                const sel = (pageSelection.todoId === todoId && pageSelection.set.size) ? Array.from(pageSelection.set) : [page];
                ev.dataTransfer.setData('text/plain', JSON.stringify({ todoId, pages: sel, fromDate: assignedDate || null, origin: 'todo-page-grid' }));
              });
              btn.onclick = (ev) => {
                if (btn.classList.contains('completed')) { ev.preventDefault(); return; }
                if (ev.shiftKey || ev.ctrlKey || ev.metaKey) {
                  handlePageButtonSelection(ev, { todoId, idx, page, pages: pagesArr, container: grid });
                  return;
                }
                if (!selectedDate) {
                  clearPageSelection();
                  applySelectionStyles(grid, todoId);
                  return;
                }
                placePages(todoId, [page], formatDate(selectedDate));
              };
              btn.oncontextmenu = (ev) => {
                ev.preventDefault();
                if (btn.classList.contains('completed')) return;
                handlePageButtonSelection(ev, { todoId, idx, page, pages: pagesArr, container: grid, forceToggle: true });
              };
              grid.appendChild(btn);
            });
            applySelectionStyles(grid, todoId);
          }

          function findAssignedDate(todoId, page) {
            if (!todoId || !Number.isFinite(normalizePage(page))) return null;
            const map = schedules[todoId] || {};
            const target = normalizePage(page);
            for (const [dateStr, list] of Object.entries(map)) {
              const norm = (Array.isArray(list) ? list : []).map(normalizePage).filter(Number.isFinite);
              if (norm.includes(target)) return dateStr;
            }
            return null;
          }

          function applySelectionStyles(container, todoId) {
            if (!container) return;
            container.querySelectorAll('.sc-dd-page-btn').forEach(btn => {
              const p = normalizePage(btn.dataset.page);
              const matched = pageSelection.todoId === todoId && pageSelection.set.has(p);
              btn.classList.toggle('selected', matched);
            });
          }

          function handlePageButtonSelection(ev, { todoId, idx, page, pages, container, forceToggle = false }) {
            ensureSelectionTodo(todoId);
            const range = ev.shiftKey && pageSelection.lastIndex !== null;
            const multi = ev.ctrlKey || ev.metaKey || forceToggle;
            if (!multi && !range) {
              pageSelection.set.clear();
            }
            if (range && Array.isArray(pages)) {
              const start = Math.min(pageSelection.lastIndex ?? idx, idx);
              const end = Math.max(pageSelection.lastIndex ?? idx, idx);
              for (let i = start; i <= end; i++) {
                const pg = normalizePage(pages[i]);
                if (Number.isFinite(pg)) pageSelection.set.add(pg);
              }
            } else {
              const num = normalizePage(page);
              if (Number.isFinite(num)) {
                if (pageSelection.set.has(num)) {
                  pageSelection.set.delete(num);
                } else {
                  pageSelection.set.add(num);
                }
              }
            }
            pageSelection.lastIndex = idx;
            applySelectionStyles(container, todoId);
          }

          function ensureSelectionTodo(todoId) {
            if (pageSelection.todoId && pageSelection.todoId !== todoId) {
              clearPageSelection();
            }
            pageSelection.todoId = todoId;
          }

          function placePages(todoId, pages, toDate) {
            if (!todoId || !toDate) return;
            const list = (Array.isArray(pages) ? pages : [pages]).map(normalizePage).filter(Number.isFinite);
            if (!list.length) return;
            const todo = getTodos().find(t => t.id === todoId);
            const completedSet = getTodoCompletedSet(todo);
            pushUndo();
            if (!schedules[todoId]) schedules[todoId] = {};
            const existingTarget = Array.isArray(schedules[todoId][toDate]) ? schedules[todoId][toDate].map(normalizePage).filter(Number.isFinite) : [];

            // Remove these pages from other dates to avoid duplicates
            Object.keys(schedules[todoId]).forEach(dateKey => {
              if (dateKey === toDate) return;
              const src = Array.isArray(schedules[todoId][dateKey]) ? schedules[todoId][dateKey].map(normalizePage).filter(Number.isFinite) : [];
              const removed = src.filter(p => list.includes(p));
              const completedRemoved = removed.filter(p => completedSet.has(p));
              if (completedRemoved.length) rememberCompletedPages(todoId, dateKey, completedRemoved);
              const remain = src.filter(p => !list.includes(p));
              if (remain.length) {
                schedules[todoId][dateKey] = remain;
              } else {
                delete schedules[todoId][dateKey];
              }
            });

            schedules[todoId][toDate] = Array.from(new Set([...existingTarget, ...list]));
            saveSettings();
            render();
            refreshChipInfo();
          }

          function removeTaskFromDate(todoId, dateStr) {
            if (schedules[todoId] && schedules[todoId][dateStr]) {
              pushUndo();
              const todo = getTodos().find(t => t.id === todoId);
              const completedSet = getTodoCompletedSet(todo);
              const src = Array.isArray(schedules[todoId][dateStr]) ? schedules[todoId][dateStr].map(normalizePage).filter(Number.isFinite) : [];
              const completedRemoved = src.filter(p => completedSet.has(p));
              if (completedRemoved.length) rememberCompletedPages(todoId, dateStr, completedRemoved);
              delete schedules[todoId][dateStr];
              saveSettings();
              render();
              if (selectedDate) showDayDetail(selectedDate);
              refreshChipInfo();
            }
          }

          function openTodoBook(todoId) {
            const todo = getTodos().find(t => t.id === todoId);
            if (todo && todo.bookId && window.openBook) {
              window.openBook(todo.bookId);
            }
          }

          function openBookAtPage(bookId, page) {
            if (window.openBook) window.openBook(bookId, page);
          }

          // Open daily summary (完了ページビューア)
          function openDailySummary(dateStr) {
            const targetDate = dateStr || formatDate(new Date());
            if (typeof window.openCompletedViewer === 'function') {
              window.openCompletedViewer(null, { date: targetDate });
            } else {
              const completed = getCompletedForDate(targetDate);
              if (completed.length === 0) {
                alert('この日の完了記録がありません');
                return;
              }
              const first = completed[0];
              if (first?.bookId && window.openBook) {
                window.openBook(first.bookId, first.page);
              }
            }
          }

          // Make calendar cells clickable and droppable
          function enhanceCalendarCells() {
            document.querySelectorAll('.sc-day, .sc-h-day, .sc-week-day').forEach(cell => {
              cell.ondragover = (e) => { e.preventDefault(); cell.classList.add('drop-target'); };
              cell.ondragleave = () => cell.classList.remove('drop-target');
              cell.ondrop = (e) => {
                e.preventDefault();
                cell.classList.remove('drop-target');
                try {
                  const data = JSON.parse(e.dataTransfer.getData('text/plain'));
                  const toDate = cell.dataset.date;
                  if (!toDate || !data.todoId) return;
                  if (data.type === 'due') {
                    if (data.fromDate && data.fromDate === toDate) return;
                    if (window.TodoStore && typeof window.TodoStore.update === 'function') {
                      pushUndo();
                      window.TodoStore.update(data.todoId, { due: toDate });
                      render();
                    }
                    return;
                  }
                  const pages = Array.isArray(data.pages) ? data.pages : (Number.isFinite(data.page) ? [data.page] : null);
                  if (data.fromDate && data.fromDate !== toDate) {
                    moveTask(data.todoId, data.fromDate, toDate, pages || null);
                  } else if (pages && pages.length) {
                    placePages(data.todoId, pages, toDate);
                  }
                } catch (err) { }
              };
            });
          }

          function playMoveAnimation(startX, startY, targetEl, label = '') {
            if (!targetEl) return;
            const rect = targetEl.getBoundingClientRect();
            const tx = rect.left + rect.width / 2;
            const ty = rect.top + rect.height / 2;
            const sx = Number.isFinite(startX) ? startX : tx;
            const sy = Number.isFinite(startY) ? startY : ty;
            const fly = document.createElement('div');
            fly.className = 'sc-fly-chip';
            fly.textContent = label || '移動';
            fly.style.left = `${sx}px`;
            fly.style.top = `${sy}px`;
            document.body.appendChild(fly);
            const dx = tx - sx;
            const dy = ty - sy;
            requestAnimationFrame(() => {
              fly.style.transform = `translate(${dx}px, ${dy}px) scale(0.9)`;
              fly.style.opacity = '0';
            });
            setTimeout(() => fly.remove(), 420);
          }

          function moveTask(todoId, fromDate, toDate, pages = null) {
            if (!schedules[todoId]) return;
            const srcPagesRaw = Array.isArray(schedules[todoId][fromDate]) ? schedules[todoId][fromDate] : [];
            if (!srcPagesRaw.length) return;
            const srcPages = srcPagesRaw.map(normalizePage).filter(Number.isFinite);
            const todo = getTodos().find(t => t.id === todoId);
            const completedSet = getTodoCompletedSet(todo);
            const memSet = getScheduleMemorySet(todoId, fromDate);
            const isCompleted = (p) => completedSet.has(p) || memSet.has(p);
            const requestedMove = Array.isArray(pages) && pages.length ? pages.map(normalizePage).filter(Number.isFinite) : srcPages;
            const movePages = requestedMove.filter(p => !isCompleted(p));
            if (!movePages.length) {
              // Nothing movable; just leave as-is
              return;
            }
            pushUndo();
            const remaining = srcPages.filter(p => !movePages.includes(p));
            const completedOnly = remaining.filter(p => isCompleted(p));
            if (completedOnly.length) rememberCompletedPages(todoId, fromDate, completedOnly);
            const pendingRemain = remaining.filter(p => !isCompleted(p));
            if (pendingRemain.length) {
              schedules[todoId][fromDate] = pendingRemain;
            } else {
              delete schedules[todoId][fromDate];
            }

            if (!schedules[todoId]) schedules[todoId] = {};
            const targetExisting = Array.isArray(schedules[todoId][toDate]) ? schedules[todoId][toDate].map(normalizePage).filter(Number.isFinite) : [];
            schedules[todoId][toDate] = Array.from(new Set([...targetExisting, ...movePages]));
            saveSettings();
            render();
            refreshChipInfo();
            try { showToast && showToast('タスクを移動しました', 'ok'); } catch (e) { }
          }

          // Enhanced render with click handlers
          const originalRenderMonth = renderMonth;
          renderMonth = function () {
            originalRenderMonth();
            const year = currentDate.getFullYear();
            const month = currentDate.getMonth();
            const firstDay = new Date(year, month, 1);
            const startOffset = (firstDay.getDay() - weekStart + 7) % 7;
            const startDate = new Date(firstDay);
            startDate.setDate(startDate.getDate() - startOffset);
            document.querySelectorAll('.sc-day').forEach((cell, i) => {
              const d = new Date(startDate);
              d.setDate(startDate.getDate() + i);
              const dateStr = formatDate(d);
              cell.dataset.date = dateStr;
              cell.classList.toggle('selected', !!selectedDate && isSameDay(d, selectedDate));
              cell.onclick = () => showDayDetail(d);
            });
            enhanceCalendarCells();
          };

          // Initialize
          function init() {
            loadSettings();
            loadCompleted();
            loadMiniLog();
            weekStart = Number(settings.weekStart ?? 1) || 1;
            settings.weekStart = weekStart;
            applyLayoutSettings();
            setupResizer();
            syncSchedulesWithTodos();
            bind();
            const repopulateTodos = (opts = {}) => {
              const ready = opts.ready === true;
              const hasTodos = (getTodos() || []).length > 0;
              if (ready || hasTodos) todosReady = true;
              populateTodoSelect();
              populateDDTodoSelect();
              syncSchedulesWithTodos();
              render();
            };
            repopulateTodos();
            window.addEventListener('todo:updated', () => repopulateTodos({ ready: true }));
            render();
            initMiniUI();
            renderMiniLog();
            window.addEventListener('planner:nl-updated', () => { updateMiniSummary(); render(); });
            setupPanelToggles();
            setupCompletedResizer();
            if (window.TodoStore?.ready) {
              try {
                TodoStore.ready().then(() => { repopulateTodos({ ready: true }); }).catch(() => { });
              } catch (_) { }
            }

            // Additional bindings
            $('scDDClose')?.addEventListener('click', hideDayDetail);
            $('scDDTodoSelect')?.addEventListener('change', (e) => renderDDPageGrid(e.target.value));
            $('scDDOpenDailyBook')?.addEventListener('click', () => openDailySummary(selectedDate ? formatDate(selectedDate) : null));
          }

          return { init, render, populateTodoSelect, recordCompletion, getCompletedForDate, getCompletedSnapshot, removeCompletedForDate, openDailySummary, syncSchedulesWithTodos, onTodoPageCompleted, getScheduleMapForDate };
        })();

        window.StudyCalendar = StudyCalendar;
        setTimeout(() => StudyCalendar.init(), 100);
        try {
          if (window.StudyActionMenu && !window.StudyActionMenu.__progressPatched) {
            const wrapCall = (fn) => (...args) => { const res = fn?.(...args); try { window.__pageProgressOverlayRender?.(); } catch (_) { } return res; };
            if (window.StudyActionMenu.open) window.StudyActionMenu.open = wrapCall(window.StudyActionMenu.open.bind(window.StudyActionMenu));
            if (window.StudyActionMenu.close) window.StudyActionMenu.close = wrapCall(window.StudyActionMenu.close.bind(window.StudyActionMenu));
            if (window.StudyActionMenu.toggle) window.StudyActionMenu.toggle = wrapCall(window.StudyActionMenu.toggle.bind(window.StudyActionMenu));
            if (window.StudyActionMenu.refresh) window.StudyActionMenu.refresh = wrapCall(window.StudyActionMenu.refresh.bind(window.StudyActionMenu));
            window.StudyActionMenu.__progressPatched = true;
          }
        } catch (_) { }

        // ===== Original Lesson Planner =====
        const OriginalLesson = (function () {
          const LS_KEY = 'ol_lessons_v1';
          const SETTINGS_KEY = 'ol_settings_v1';
          const SESSION_KEY = 'ol_session_v1';
          const META_KEY = 'ol_meta_v1';
          const PRE_NOTIFY_MS = 10 * 60 * 1000;
          const SNOOZE_MS = 5 * 60 * 1000;
          const MAX_VIEW_DAYS = 400;
          const DAY_MS = 86400000;
          const WEEKDAYS = ['日', '月', '火', '水', '木', '金', '土'];
          const state = {
            lessons: [],
            filter: 'all',
            selectedDate: null,
            viewStart: null,
            viewEnd: null,
            weekdays: new Set(),
            hScrollLeft: null,
            sessionTargetId: null,
            editingId: null,
            notify: {
              activeId: null,
              activeType: null
            }
          };
          let session = null;
          let tickTimer = null;
          let syncingTime = false;
          let syncingEditTime = false;
          let clockBound = false;
          let editBound = false;
          let clockDragging = false;
          let clockActiveTarget = null;
          let clockPointerId = null;
          const clockState = {
            start: { lastAngleRaw: null },
            end: { lastAngleRaw: null }
          };
          let saveTimer = null;
          let lessonBackupTimer = null;
          let idbSaveTimer = null;
          let idbRestoreTimer = null;
          let idbRestoreInFlight = false;
          let idbRestoreDone = false;
          let restoreBound = false;
          let lessonToast = null;
          let lessonToastTitle = null;
          let lessonToastSub = null;
          let lessonToastTime = null;
          let lessonToastMeta = null;
          let lessonToastClose = null;
          let lessonToastActions = null;
          let lessonToastTimer = null;
          const $ = (id) => document.getElementById(id);
          const pad2 = (n) => String(n).padStart(2, '0');
          const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
          const safe = (txt) => (typeof escapeHTML === 'function' ? escapeHTML(txt || '') : (txt || ''));
          const readStorageItem = (key) => {
            try {
              const val = localStorage.getItem(key);
              if (val !== null && val !== undefined) return val;
            } catch (_) { }
            try { return sessionStorage.getItem(key); } catch (_) { }
            return null;
          };

          const formatDateValue = (d) => `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`;
          const parseDateValue = (str) => {
            if (!str) return null;
            const parts = String(str).split('-').map(n => parseInt(n, 10));
            if (parts.length < 3 || parts.some(n => !Number.isFinite(n))) return null;
            const d = new Date(parts[0], parts[1] - 1, parts[2]);
            if (isNaN(d.getTime())) return null;
            d.setHours(0, 0, 0, 0);
            return d;
          };
          const startOfDay = (d) => {
            const dt = (d instanceof Date) ? new Date(d) : new Date();
            dt.setHours(0, 0, 0, 0);
            return dt;
          };
          const addDays = (d, days) => {
            const dt = new Date(d);
            dt.setDate(dt.getDate() + days);
            return dt;
          };
          const toMinutes = (timeStr) => {
            if (!timeStr || typeof timeStr !== 'string') return null;
            const parts = timeStr.split(':');
            if (parts.length < 2) return null;
            const h = parseInt(parts[0], 10);
            const m = parseInt(parts[1], 10);
            if (!Number.isFinite(h) || !Number.isFinite(m)) return null;
            return clamp(h, 0, 23) * 60 + clamp(m, 0, 59);
          };
          const minutesToTime = (mins) => {
            const total = clamp(Math.round(mins || 0), 0, 1439);
            const h = Math.floor(total / 60);
            const m = total % 60;
            return `${pad2(h)}:${pad2(m)}`;
          };
          const combineDateTime = (dateStr, timeStr) => {
            const d = parseDateValue(dateStr);
            const mins = toMinutes(timeStr);
            if (!d || mins == null) return null;
            d.setHours(Math.floor(mins / 60), mins % 60, 0, 0);
            return d;
          };
          const formatHM = (ms) => {
            const d = new Date(ms);
            return `${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
          };
          const formatTimeRange = (s, e) => `${formatHM(s)}-${formatHM(e)}`;
          const formatMinutes = (mins) => {
            if (!Number.isFinite(mins)) return '--';
            const total = Math.max(0, Math.round(mins));
            const h = Math.floor(total / 60);
            const m = total % 60;
            return h ? `${h}時間${pad2(m)}分` : `${m}分`;
          };
          const colorToRgba = (hex, alpha = 0.18) => {
            const fallback = `rgba(96,165,250,${alpha})`;
            if (!hex) return fallback;
            let h = String(hex).trim();
            if (h.startsWith('#')) h = h.slice(1);
            if (h.length === 3) h = h.split('').map(c => c + c).join('');
            if (h.length !== 6) return fallback;
            const r = parseInt(h.slice(0, 2), 16);
            const g = parseInt(h.slice(2, 4), 16);
            const b = parseInt(h.slice(4, 6), 16);
            if (![r, g, b].every(Number.isFinite)) return fallback;
            return `rgba(${r},${g},${b},${alpha})`;
          };
          const LESSON_TIMER_COLOR = '#ef4444';
          const LESSON_TIMER_SOURCE = 'lesson';
          const ensureTimersReady = () => {
            if (!Array.isArray(window.timers)) window.timers = [];
            if (typeof window.timerId !== 'number') {
              const maxId = (window.timers || []).reduce((acc, t) => {
                const id = Number.isFinite(t?.id) ? t.id : -1;
                return Math.max(acc, id);
              }, -1);
              window.timerId = maxId + 1;
            }
            return Array.isArray(window.timers);
          };
          const isLessonTimer = (t, lessonId) => {
            if (!t || t.source !== LESSON_TIMER_SOURCE) return false;
            if (!lessonId) return true;
            return String(t.lessonId) === String(lessonId);
          };
          const refreshTimerUI = (forceFly = false) => {
            try { if (typeof renderTimers === 'function') renderTimers(); } catch (_) { }
            try { if (typeof drawTimerArcs === 'function') drawTimerArcs(); } catch (_) { }
            try { if (typeof nlRenderTimerOverlays === 'function') nlRenderTimerOverlays(); } catch (_) { }
            try { if (typeof window.__requestTimerVizUpdate === 'function') window.__requestTimerVizUpdate(!!forceFly); } catch (_) { }
            try { if (typeof refreshPlannerFlyClock === 'function') refreshPlannerFlyClock(true); } catch (_) { }
          };
          function findLessonTimerIndex(lessonId) {
            if (!Array.isArray(window.timers)) return -1;
            return window.timers.findIndex(t => isLessonTimer(t, lessonId));
          }
          function removeLessonTimer(lessonId) {
            if (!Array.isArray(window.timers)) return false;
            let changed = false;
            window.timers = window.timers.filter(t => {
              if (!isLessonTimer(t, lessonId)) return true;
              changed = true;
              return false;
            });
            if (changed) refreshTimerUI(true);
            return changed;
          }
          function syncLessonTimer(lesson, opts = {}) {
            if (!lesson) return false;
            if (lesson.done) { removeLessonTimer(lesson.id); return false; }
            if (!ensureTimersReady()) return false;
            const nowMs = Date.now();
            const nowSec = Math.floor(nowMs / 1000);
            const endSec = Math.round(lesson.end / 1000);
            const remainSec = endSec - nowSec;
            if (!Number.isFinite(remainSec) || remainSec <= 0) {
              removeLessonTimer(lesson.id);
              return false;
            }
            let idx = findLessonTimerIndex(lesson.id);
            let timer = null;
            if (idx < 0) {
              timer = {
                id: window.timerId++,
                total: Math.max(1, remainSec),
                remain: Math.max(1, remainSec),
                running: true,
                start: nowMs,
                alerted: false,
                overtime: false,
                startMin: new Date(nowMs).getMinutes(),
                minutes: Math.max(1, Math.round(remainSec / 60)),
                gaugeColor: LESSON_TIMER_COLOR,
                clockMode: 'outer',
                __hasStarted: true,
                source: LESSON_TIMER_SOURCE,
                lessonId: lesson.id,
                lessonTitle: lesson.title || '授業',
                label: lesson.title || '授業',
                locked: true,
                _endSec: endSec
              };
              if (typeof window.__resetTimerSoundFlags === 'function') {
                window.__resetTimerSoundFlags(timer);
              }
              window.timers.push(timer);
              idx = window.timers.length - 1;
            } else {
              timer = window.timers[idx];
              const startMs = Number.isFinite(timer.start) ? timer.start : nowMs;
              const elapsed = Math.max(0, (nowMs - startMs) / 1000);
              const nextTotal = Math.max(1, Math.round(elapsed + remainSec));
              timer.total = nextTotal;
              timer.remain = Math.max(0, remainSec);
              timer.minutes = Math.max(1, Math.round(nextTotal / 60));
              timer.running = true;
              timer.start = startMs;
              timer._endSec = endSec;
              timer.alerted = false;
              timer.overtime = false;
              timer.__hasStarted = true;
              timer.gaugeColor = LESSON_TIMER_COLOR;
              timer.clockMode = 'outer';
              timer.source = LESSON_TIMER_SOURCE;
              timer.lessonId = lesson.id;
              timer.lessonTitle = lesson.title || '授業';
              timer.label = lesson.title || '授業';
              timer.locked = true;
              if (opts.resetSounds && typeof window.__resetTimerSoundFlags === 'function') {
                window.__resetTimerSoundFlags(timer);
              }
            }
            try { if (typeof updateTimer === 'function' && idx >= 0) updateTimer(idx); } catch (_) { }
            refreshTimerUI(true);
            return true;
          }
          function ensureSessionTimer(lesson) {
            if (!lesson) return;
            if (!Array.isArray(window.timers)) return;
            const nowMs = Date.now();
            const nowSec = Math.floor(nowMs / 1000);
            const endSec = Math.round(lesson.end / 1000);
            if (lesson.end <= nowMs || lesson.done) {
              removeLessonTimer(lesson.id);
              return;
            }
            const idx = findLessonTimerIndex(lesson.id);
            const remainSec = endSec - nowSec;
            if (idx < 0) {
              syncLessonTimer(lesson, { resetSounds: true });
              return;
            }
            const timer = window.timers[idx];
            const drift = Math.abs((timer?.remain || 0) - remainSec);
            if (!timer?.running || drift > 2 || !isLessonTimer(timer, lesson.id)) {
              syncLessonTimer(lesson, { resetSounds: drift > 2 });
            }
          }
          function cleanupLessonTimers(nowMs) {
            if (!Array.isArray(window.timers) || !window.timers.length) return;
            const now = Number.isFinite(nowMs) ? nowMs : Date.now();
            let changed = false;
            const lessonMap = new Map(state.lessons.map(l => [l.id, l]));
            window.timers = window.timers.filter(t => {
              if (!isLessonTimer(t)) return true;
              const lesson = lessonMap.get(t.lessonId);
              if (!lesson || lesson.done || lesson.end <= now) {
                changed = true;
                return false;
              }
              return true;
            });
            if (changed) refreshTimerUI(true);
          }

          function toast(msg, type) {
            try { if (typeof showToast === 'function') showToast(msg, type || 'info'); } catch (_) { }
          }

          function ensureLessonToast() {
            if (lessonToast) return;
            lessonToast = $('lessonToast');
            if (!lessonToast) return;
            lessonToastTitle = $('lessonToastTitle');
            lessonToastSub = $('lessonToastSub');
            lessonToastTime = $('lessonToastTime');
            lessonToastMeta = $('lessonToastMeta');
            lessonToastClose = $('lessonToastClose');
            lessonToastActions = $('lessonToastActions');
            if (lessonToastClose) lessonToastClose.addEventListener('click', () => hideLessonToast());
          }

          function hideLessonToast() {
            if (!lessonToast) return;
            lessonToast.classList.remove('show', 'pre', 'active', 'end', 'stacked');
            if (lessonToastTimer) { clearTimeout(lessonToastTimer); lessonToastTimer = null; }
            state.notify.activeId = null;
            state.notify.activeType = null;
          }

          function setToastActions(actions) {
            if (!lessonToastActions) return;
            lessonToastActions.innerHTML = '';
            (actions || []).forEach(action => {
              const btn = document.createElement('button');
              btn.className = action.className || 'btn ghost small';
              btn.textContent = action.label || '操作';
              btn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                try { action.onClick && action.onClick(); } catch (_) { }
              });
              lessonToastActions.appendChild(btn);
            });
          }

          function focusLesson(lesson) {
            if (!lesson) return;
            const targetDate = startOfDay(new Date(lesson.start));
            state.selectedDate = targetDate;
            const vs = parseDateValue($('olViewStart')?.value || '');
            const ve = parseDateValue($('olViewEnd')?.value || '');
            if (!vs || !ve || targetDate < vs || targetDate > ve) {
              const newStart = addDays(targetDate, -3);
              const newEnd = addDays(newStart, 21);
              if ($('olViewStart')) $('olViewStart').value = formatDateValue(newStart);
              if ($('olViewEnd')) $('olViewEnd').value = formatDateValue(newEnd);
              state.hScrollLeft = null;
            }
            scheduleSave();
            render();
            try { if (typeof showTab === 'function') showTab('planner', { preserveOpenTab: true }); } catch (_) { }
            try { if (typeof __activatePlannerTab === 'function') __activatePlannerTab('original-lesson'); } catch (_) { }
          }

          function snoozeLesson(lesson, ms) {
            if (!lesson) return;
            lesson.snoozeUntil = Date.now() + (ms || SNOOZE_MS);
            lesson.preNotifiedAt = Date.now();
            saveLessons();
            hideLessonToast();
            toast('5分後に再通知します', 'info');
          }

          function showLessonToast(type, lesson, opts = {}) {
            ensureLessonToast();
            if (!lessonToast || !lesson) return;
            const kind = type || 'start';
            state.notify.activeId = lesson.id;
            state.notify.activeType = kind;
            lessonToast.classList.remove('pre', 'active', 'end', 'stacked');
            if (kind === 'pre') lessonToast.classList.add('pre');
            if (kind === 'start') lessonToast.classList.add('active');
            if (kind === 'end') lessonToast.classList.add('end');
            const timerToast = document.getElementById('timerFinishToast');
            if (timerToast && timerToast.classList.contains('show')) lessonToast.classList.add('stacked');
            const timeLabel = formatTimeRange(lesson.start, lesson.end);
            const durMin = Math.max(1, Math.round((lesson.end - lesson.start) / 60000));
            if (lessonToastTitle) lessonToastTitle.textContent = (kind === 'end' ? '授業終了' : '授業のお知らせ');
            if (lessonToastSub) {
              lessonToastSub.textContent = kind === 'pre'
                ? '授業の10分前です'
                : (kind === 'end' ? '授業が終了しました' : (opts.auto ? '授業を自動で開始しました' : '授業を開始しました'));
            }
            if (lessonToastTime) lessonToastTime.textContent = timeLabel;
            if (lessonToastMeta) lessonToastMeta.textContent = `${lesson.title || '授業'} / ${formatMinutes(durMin)}`;
            if (kind === 'pre') {
              setToastActions([
                { label: '今すぐ開始', className: 'btn primary small', onClick: () => startSession(lesson.id, { auto: false, alignStart: false }) },
                { label: '5分後に通知', className: 'btn ghost small', onClick: () => snoozeLesson(lesson, SNOOZE_MS) },
                { label: '詳細', className: 'btn ghost small', onClick: () => focusLesson(lesson) },
                {
                  label: 'スキップ',
                  className: 'btn ghost small danger',
                  onClick: () => {
                    lesson.done = true;
                    lesson.skipped = true;
                    lesson.completedAt = Date.now();
                    saveLessons();
                    hideLessonToast();
                    render();
                  }
                }
              ]);
            } else if (kind === 'end') {
              setToastActions([
                { label: '完了', className: 'btn primary small', onClick: () => completeLesson(lesson) },
                { label: '+5分', className: 'btn ghost small', onClick: () => extendLessonById(lesson.id, 5) },
                { label: '詳細', className: 'btn ghost small', onClick: () => focusLesson(lesson) }
              ]);
            } else {
              setToastActions([
                { label: '完了', className: 'btn primary small', onClick: () => finishSession() },
                { label: '+5分', className: 'btn ghost small', onClick: () => extendLessonById(lesson.id, 5) },
                { label: '詳細', className: 'btn ghost small', onClick: () => focusLesson(lesson) }
              ]);
            }
            lessonToast.classList.add('show');
          }

          function refreshLessonToast(lesson) {
            if (!lesson || state.notify.activeId !== lesson.id || !state.notify.activeType) return;
            const auto = !!(session && session.lessonId === lesson.id && session.auto);
            showLessonToast(state.notify.activeType, lesson, { auto });
          }

          function completeLesson(lesson) {
            if (!lesson) return;
            lesson.done = true;
            lesson.completedAt = Date.now();
            saveLessons();
            if (session && session.lessonId === lesson.id) {
              session = null;
              saveSession();
            }
            removeLessonTimer(lesson.id);
            hideLessonToast();
            render();
          }

          function extendLessonById(id, minutes = 5) {
            const lesson = state.lessons.find(l => l.id === id);
            if (!lesson) return null;
            const addMs = Math.max(1, minutes) * 60000;
            lesson.end += addMs;
            lesson.endNotifiedAt = null;
            saveLessons();
            if ((session && session.lessonId === lesson.id) || findLessonTimerIndex(lesson.id) >= 0) {
              syncLessonTimer(lesson, { resetSounds: true });
            }
            render();
            refreshLessonToast(lesson);
            return lesson;
          }

          function loadLessons() {
            try {
              let raw = readStorageItem(LS_KEY);
              if (raw) state.lessons = JSON.parse(raw) || [];
            } catch (_) { state.lessons = []; }
            if (!Array.isArray(state.lessons)) state.lessons = [];
          }
          function scheduleLessonBackup() {
            if (lessonBackupTimer) return;
            lessonBackupTimer = setTimeout(() => {
              lessonBackupTimer = null;
              try {
                if (typeof backupSettingsToIDB === 'function') backupSettingsToIDB();
              } catch (_) { }
            }, 400);
          }
          const OLDB = {
            dbName: 'OriginalLessonDB',
            storeName: 'ol_store',
            version: 1,
            db: null,
            _openPromise: null,
            async open() {
              if (this.db) return this.db;
              if (this._openPromise) return this._openPromise;
              if (typeof indexedDB === 'undefined') {
                return Promise.reject(new Error('indexedDB unavailable'));
              }
              this._openPromise = new Promise((resolve, reject) => {
                const req = indexedDB.open(this.dbName, this.version);
                req.onupgradeneeded = (e) => {
                  const db = e.target.result;
                  if (!db.objectStoreNames.contains(this.storeName)) {
                    db.createObjectStore(this.storeName, { keyPath: 'key' });
                  }
                };
                req.onsuccess = (e) => {
                  this.db = e.target.result;
                  this.db.onversionchange = () => {
                    try { this.db.close(); } catch (_) { }
                    this.db = null;
                  };
                  this.db.onclose = () => { this.db = null; };
                  resolve(this.db);
                };
                req.onerror = () => reject(req.error);
                req.onblocked = () => {
                  console.warn('[OriginalLessonDB] Open blocked');
                };
              }).finally(() => {
                this._openPromise = null;
              });
              return this._openPromise;
            },
            async getMany(keys) {
              const db = await this.open();
              const safeKeys = Array.isArray(keys) ? keys.filter(Boolean) : [];
              if (!safeKeys.length) return new Map();
              return new Promise((resolve) => {
                const tx = db.transaction(this.storeName, 'readonly');
                const store = tx.objectStore(this.storeName);
                const readOne = (key) => new Promise((res) => {
                  try {
                    const req = store.get(key);
                    req.onsuccess = () => res(req.result || null);
                    req.onerror = () => res(null);
                  } catch (_) { res(null); }
                });
                Promise.all(safeKeys.map(readOne)).then((results) => {
                  const out = new Map();
                  safeKeys.forEach((key, idx) => out.set(key, results[idx]));
                  resolve(out);
                }).catch(() => resolve(new Map()));
              });
            },
            async putMany(entries) {
              const db = await this.open();
              const list = Array.isArray(entries) ? entries.filter(item => item && item.key) : [];
              if (!list.length) return;
              return new Promise((resolve, reject) => {
                const tx = db.transaction(this.storeName, 'readwrite');
                const store = tx.objectStore(this.storeName);
                const now = Date.now();
                list.forEach(item => {
                  store.put({ key: item.key, data: item.data, updatedAt: now });
                });
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
              });
            }
          };
          function normalizeLessonData(raw) {
            if (Array.isArray(raw)) return raw;
            if (typeof raw === 'string') {
              try {
                const parsed = JSON.parse(raw);
                return Array.isArray(parsed) ? parsed : null;
              } catch (_) { }
            }
            return null;
          }
          function normalizeMeta(raw) {
            if (!raw) return null;
            let meta = raw;
            if (typeof raw === 'string') {
              try { meta = JSON.parse(raw); } catch (_) { return null; }
            }
            if (!meta || typeof meta !== 'object') return null;
            const updatedAt = Number(meta.updatedAt) || 0;
            const count = Number.isFinite(meta.count) ? meta.count : null;
            return { updatedAt, count };
          }
          function buildLessonMeta(lessons) {
            const count = Array.isArray(lessons) ? lessons.length : 0;
            return { updatedAt: Date.now(), count };
          }
          function writeLessonMeta(meta) {
            const payload = meta ? JSON.stringify(meta) : '';
            if (!payload) return;
            try { localStorage.setItem(META_KEY, payload); } catch (_) { }
            try { sessionStorage.setItem(META_KEY, payload); } catch (_) { }
          }
          function chooseLessonSource(localLessons, localMeta, idbLessons, idbMeta) {
            const localCount = Array.isArray(localLessons) ? localLessons.length : 0;
            const idbCount = Array.isArray(idbLessons) ? idbLessons.length : 0;
            const localStamp = localMeta?.updatedAt || 0;
            const idbStamp = idbMeta?.updatedAt || 0;
            if (localStamp && idbStamp && localStamp !== idbStamp) {
              return localStamp > idbStamp ? 'local' : 'idb';
            }
            if (!localCount && idbCount) return 'idb';
            if (localCount && !idbCount) return 'local';
            if (localCount && idbCount) {
              if (localStamp !== idbStamp) return localStamp > idbStamp ? 'local' : 'idb';
              return localCount >= idbCount ? 'local' : 'idb';
            }
            if (localStamp || idbStamp) return localStamp >= idbStamp ? 'local' : 'idb';
            return null;
          }
          function normalizeSettingsData(raw) {
            if (raw && typeof raw === 'object') return raw;
            if (typeof raw === 'string') {
              try {
                const parsed = JSON.parse(raw);
                return parsed && typeof parsed === 'object' ? parsed : null;
              } catch (_) { }
            }
            return null;
          }
          function normalizeSessionData(raw) {
            if (raw === null) return null;
            if (raw && typeof raw === 'object') return raw;
            if (typeof raw === 'string') {
              try { return JSON.parse(raw); } catch (_) { }
            }
            return undefined;
          }
          function scheduleLessonIdbSave() {
            if (idbSaveTimer) return;
            idbSaveTimer = setTimeout(() => {
              idbSaveTimer = null;
              persistLessonDataToIdb();
            }, 0);
          }
          async function persistLessonDataToIdb() {
            const hasLessons = Array.isArray(state.lessons) && state.lessons.length > 0;
            const noLocalLessons = localStorage.getItem(LS_KEY) === null && sessionStorage.getItem(LS_KEY) === null;
            if (!idbRestoreDone && noLocalLessons && !hasLessons) return;
            try {
              const meta = buildLessonMeta(state.lessons);
              await OLDB.putMany([
                { key: LS_KEY, data: Array.isArray(state.lessons) ? state.lessons : [] },
                { key: SETTINGS_KEY, data: buildSettingsPayload() },
                { key: SESSION_KEY, data: session || null },
                { key: META_KEY, data: meta }
              ]);
            } catch (_) { }
          }
          function scheduleLessonRestoreFromIdb(delay = 0) {
            if (idbRestoreTimer) return;
            idbRestoreTimer = setTimeout(() => {
              idbRestoreTimer = null;
              restoreFromIdbIfMissing();
            }, delay);
          }
          async function restoreFromIdbIfMissing() {
            if (idbRestoreDone || idbRestoreInFlight) return;
            if (typeof indexedDB === 'undefined') {
              idbRestoreDone = true;
              return;
            }
            idbRestoreInFlight = true;
            const localLessons = normalizeLessonData(readStorageItem(LS_KEY)) || [];
            const localSettings = normalizeSettingsData(readStorageItem(SETTINGS_KEY));
            const localSession = normalizeSessionData(readStorageItem(SESSION_KEY));
            const localMeta = normalizeMeta(readStorageItem(META_KEY));
            let lessonsData = null;
            let settingsData = null;
            let sessionData = null;
            let metaData = null;
            const readLegacyFromMainDb = async (keys) => {
              const ready = window.__dbReady;
              if (!ready || typeof ready.then !== 'function') return {};
              let database = null;
              try { database = await ready; } catch (_) { return {}; }
              if (!database || !database.objectStoreNames?.contains?.('settings')) return {};
              const t = database.transaction('settings', 'readonly');
              const store = t.objectStore('settings');
              const read = (key) => new Promise((res) => {
                try {
                  const req = store.get(key);
                  req.onsuccess = () => {
                    const rec = req.result;
                    const val = rec ? (rec.data ?? rec.value ?? rec.payload ?? null) : undefined;
                    res(val);
                  };
                  req.onerror = () => res(undefined);
                } catch (_) { res(undefined); }
              });
              const values = await Promise.all((keys || []).map(read));
              const out = {};
              (keys || []).forEach((key, idx) => {
                if (values[idx] !== undefined) out[key] = values[idx];
              });
              return out;
            };
            try {
              const records = await OLDB.getMany([LS_KEY, SETTINGS_KEY, SESSION_KEY, META_KEY]);
              const pick = (rec) => (rec ? (rec.data ?? rec.value ?? rec.payload ?? null) : undefined);
              lessonsData = pick(records.get(LS_KEY));
              settingsData = pick(records.get(SETTINGS_KEY));
              sessionData = pick(records.get(SESSION_KEY));
              metaData = pick(records.get(META_KEY));
            } catch (_) {
              idbRestoreDone = true;
              idbRestoreInFlight = false;
              return;
            }
            const hasLessonsPayload = lessonsData !== undefined;
            const hasSettingsPayload = settingsData !== undefined;
            const hasSessionPayload = sessionData !== undefined;
            const hasMetaPayload = metaData !== undefined;
            if (!hasLessonsPayload && !hasSettingsPayload && !hasSessionPayload && !hasMetaPayload) {
              try {
                const legacy = await readLegacyFromMainDb([LS_KEY, SETTINGS_KEY, SESSION_KEY, META_KEY]);
                if (legacy[LS_KEY] !== undefined) lessonsData = legacy[LS_KEY];
                if (legacy[SETTINGS_KEY] !== undefined) settingsData = legacy[SETTINGS_KEY];
                if (legacy[SESSION_KEY] !== undefined) sessionData = legacy[SESSION_KEY];
                if (legacy[META_KEY] !== undefined) metaData = legacy[META_KEY];
                const migrate = [];
                if (legacy[LS_KEY] !== undefined) migrate.push({ key: LS_KEY, data: legacy[LS_KEY] });
                if (legacy[SETTINGS_KEY] !== undefined) migrate.push({ key: SETTINGS_KEY, data: legacy[SETTINGS_KEY] });
                if (legacy[SESSION_KEY] !== undefined) migrate.push({ key: SESSION_KEY, data: legacy[SESSION_KEY] });
                if (legacy[META_KEY] !== undefined) migrate.push({ key: META_KEY, data: legacy[META_KEY] });
                if (migrate.length) { try { await OLDB.putMany(migrate); } catch (_) { } }
              } catch (_) { }
            }
            const idbLessons = normalizeLessonData(lessonsData) || [];
            const idbSettings = normalizeSettingsData(settingsData);
            const idbSession = normalizeSessionData(sessionData);
            const idbMeta = normalizeMeta(metaData);
            const source = chooseLessonSource(localLessons, localMeta, idbLessons, idbMeta);
            let changed = false;
            if (source === 'idb') {
              state.lessons = Array.isArray(idbLessons) ? idbLessons : [];
              if (idbSettings) applySettingsPayload(idbSettings);
              session = idbSession !== undefined ? idbSession : null;
              if (session && !state.lessons.some(l => l.id === session.lessonId)) session = null;
              const meta = idbMeta || buildLessonMeta(state.lessons);
              writeLessonMeta(meta);
              saveLessons();
              if (idbSettings) saveSettings();
              if (idbSession !== undefined) saveSession();
              changed = true;
            } else if (source === 'local') {
              try {
                const meta = localMeta || buildLessonMeta(localLessons);
                await OLDB.putMany([
                  { key: LS_KEY, data: Array.isArray(localLessons) ? localLessons : [] },
                  { key: SETTINGS_KEY, data: localSettings || buildSettingsPayload() },
                  { key: SESSION_KEY, data: localSession ?? null },
                  { key: META_KEY, data: meta }
                ]);
              } catch (_) { }
            } else if (!localLessons.length && idbLessons.length) {
              state.lessons = idbLessons;
              if (idbSettings) applySettingsPayload(idbSettings);
              session = idbSession !== undefined ? idbSession : null;
              if (session && !state.lessons.some(l => l.id === session.lessonId)) session = null;
              const meta = idbMeta || buildLessonMeta(state.lessons);
              writeLessonMeta(meta);
              saveLessons();
              if (idbSettings) saveSettings();
              if (idbSession !== undefined) saveSession();
              changed = true;
            }
            if (changed) {
              render();
              try { checkAutoStartAndNotify(); } catch (_) { }
            }
            idbRestoreDone = true;
            idbRestoreInFlight = false;
          }
          function saveLessons() {
            let raw = '[]';
            try { raw = JSON.stringify(Array.isArray(state.lessons) ? state.lessons : []); } catch (_) { raw = '[]'; }
            try { localStorage.setItem(LS_KEY, raw); } catch (_) { }
            try { sessionStorage.setItem(LS_KEY, raw); } catch (_) { }
            writeLessonMeta(buildLessonMeta(state.lessons));
            scheduleLessonBackup();
            scheduleLessonIdbSave();
          }
          function applySettingsPayload(saved) {
            if (!saved || typeof saved !== 'object') return;
            if (Array.isArray(saved.weekdays)) state.weekdays = new Set(saved.weekdays);
            if (typeof saved.filter === 'string') state.filter = saved.filter;
            if (saved.viewStart) state.viewStart = parseDateValue(saved.viewStart);
            if (saved.viewEnd) state.viewEnd = parseDateValue(saved.viewEnd);
            if (saved.selectedDate) state.selectedDate = parseDateValue(saved.selectedDate);
            if (Number.isFinite(saved.hScrollLeft)) state.hScrollLeft = saved.hScrollLeft;
          }
          function buildSettingsPayload() {
            return {
              weekdays: Array.from(state.weekdays || []),
              filter: state.filter || 'all',
              viewStart: state.viewStart ? formatDateValue(state.viewStart) : '',
              viewEnd: state.viewEnd ? formatDateValue(state.viewEnd) : '',
              selectedDate: state.selectedDate ? formatDateValue(state.selectedDate) : '',
              hScrollLeft: Number.isFinite(state.hScrollLeft) ? state.hScrollLeft : 0
            };
          }
          function loadSettings() {
            let saved = null;
            try {
              const raw = localStorage.getItem(SETTINGS_KEY) || sessionStorage.getItem(SETTINGS_KEY) || '{}';
              saved = JSON.parse(raw);
            } catch (_) { }
            applySettingsPayload(saved);
          }
          function saveSettings() {
            const payload = buildSettingsPayload();
            let raw = '{}';
            try { raw = JSON.stringify(payload); } catch (_) { raw = '{}'; }
            try { localStorage.setItem(SETTINGS_KEY, raw); } catch (_) { }
            try { sessionStorage.setItem(SETTINGS_KEY, raw); } catch (_) { }
            scheduleLessonIdbSave();
          }
          function scheduleSave() {
            if (saveTimer) clearTimeout(saveTimer);
            saveTimer = setTimeout(saveSettings, 240);
          }
          function loadSession() {
            try {
              let raw = localStorage.getItem(SESSION_KEY);
              if (!raw) raw = sessionStorage.getItem(SESSION_KEY);
              session = JSON.parse(raw || 'null');
            } catch (_) { session = null; }
            if (session && !state.lessons.some(l => l.id === session.lessonId)) session = null;
          }
          function saveSession() {
            const raw = JSON.stringify(session || null);
            try { localStorage.setItem(SESSION_KEY, raw); } catch (_) { }
            try { sessionStorage.setItem(SESSION_KEY, raw); } catch (_) { }
            scheduleLessonBackup();
            scheduleLessonIdbSave();
          }
          function handleSettingsRestored(e) {
            const keys = e?.detail?.keys;
            if (!Array.isArray(keys) || !keys.some(k => typeof k === 'string' && k.startsWith('ol_'))) return;
            loadLessons();
            loadSettings();
            loadSession();
            render();
            try { checkAutoStartAndNotify(); } catch (_) { }
            scheduleLessonRestoreFromIdb(0);
          }

          function updateWeekdayButtons() {
            const wrap = $('olWeekdays');
            if (!wrap) return;
            wrap.querySelectorAll('button[data-day]').forEach(btn => {
              const day = parseInt(btn.dataset.day || '', 10);
              btn.classList.toggle('active', state.weekdays.has(day));
            });
          }
          function setWeekdays(days) {
            state.weekdays = new Set(days);
            updateWeekdayButtons();
            scheduleSave();
          }
          function getSelectedWeekdays() {
            const set = new Set(state.weekdays || []);
            if (!set.size) return new Set([0, 1, 2, 3, 4, 5, 6]);
            return set;
          }
          function formatDaysLabel(daysSet) {
            const arr = Array.from(daysSet).sort((a, b) => a - b);
            const isWeekdays = [1, 2, 3, 4, 5].every(d => arr.includes(d)) && arr.length === 5;
            if (arr.length === 7) return '毎日';
            if (isWeekdays) return '平日';
            if (arr.length === 2 && arr.includes(0) && arr.includes(6)) return '土日';
            return arr.map(d => WEEKDAYS[d]).join('');
          }
          function buildGroupLabel(startDate, endDate, daysSet, startMin, endMin) {
            const rangeLabel = `${formatDateValue(startDate)}〜${formatDateValue(endDate)}`;
            const dayLabel = formatDaysLabel(daysSet);
            const timeLabel = `${minutesToTime(startMin)}-${minutesToTime(endMin)}`;
            return `${rangeLabel} / ${dayLabel} / ${timeLabel}`;
          }
          function initDefaults() {
            const today = startOfDay(new Date());
            if (!state.selectedDate) state.selectedDate = today;
            if (!state.weekdays || !state.weekdays.size) state.weekdays = new Set([0, 1, 2, 3, 4, 5, 6]);
            updateWeekdayButtons();

            const rangeStart = $('olRangeStart');
            const rangeEnd = $('olRangeEnd');
            if (rangeStart && !rangeStart.value) rangeStart.value = formatDateValue(today);
            if (rangeEnd && !rangeEnd.value) rangeEnd.value = formatDateValue(addDays(today, 30));

            const viewStart = $('olViewStart');
            const viewEnd = $('olViewEnd');
            if (viewStart) viewStart.value = formatDateValue(state.viewStart || addDays(today, -7));
            if (viewEnd) viewEnd.value = formatDateValue(state.viewEnd || addDays(today, 30));

            const filter = $('olFilter');
            if (filter) filter.value = state.filter || 'all';

            const startTime = $('olStartTime');
            const endTime = $('olEndTime');
            const duration = $('olDuration');
            if (duration && !duration.value) duration.value = '60';
            const now = new Date();
            const nowMin = now.getHours() * 60 + now.getMinutes();
            const durVal = Math.max(1, parseInt(duration?.value || '60', 10) || 60);
            const endMin = clamp(nowMin + durVal, nowMin + 1, 1439);
            if (startTime) startTime.value = minutesToTime(nowMin);
            if (endTime) endTime.value = minutesToTime(endMin);
            syncDurationFromTimes();
          }

          function syncDurationFromTimes() {
            if (syncingTime) return;
            const startMin = toMinutes($('olStartTime')?.value || '');
            const endMin = toMinutes($('olEndTime')?.value || '');
            if (!Number.isFinite(startMin) || !Number.isFinite(endMin) || endMin <= startMin) return;
            syncingTime = true;
            const dur = Math.max(1, endMin - startMin);
            if ($('olDuration')) $('olDuration').value = String(dur);
            syncingTime = false;
          }
          function syncEndFromDuration() {
            if (syncingTime) return;
            const startMin = toMinutes($('olStartTime')?.value || '');
            const duration = parseInt($('olDuration')?.value || '', 10);
            if (!Number.isFinite(startMin) || !Number.isFinite(duration) || duration <= 0) return;
            const endMin = clamp(startMin + duration, startMin + 1, 1439);
            syncingTime = true;
            if ($('olEndTime')) $('olEndTime').value = minutesToTime(endMin);
            syncingTime = false;
          }

          function getClockInput(target) {
            return target === 'end' ? $('olEndTime') : $('olStartTime');
          }

          function getClockTimeParts(target) {
            const input = getClockInput(target);
            const mins = toMinutes(input?.value || '');
            if (!Number.isFinite(mins)) {
              const now = new Date();
              return { hour: now.getHours(), minute: now.getMinutes() };
            }
            return { hour: Math.floor(mins / 60), minute: mins % 60 };
          }

          function setClockTimeParts(target, hour, minute) {
            const input = getClockInput(target);
            if (!input) return;
            const h = clamp(hour, 0, 23);
            const m = clamp(minute, 0, 59);
            input.value = `${pad2(h)}:${pad2(m)}`;
            if (target === 'start') syncEndFromDuration();
            else syncDurationFromTimes();
          }

          function getClockMinMinutes(target) {
            const now = new Date();
            const nowMin = now.getHours() * 60 + now.getMinutes();
            let min = nowMin;
            if (target === 'end') {
              const startMin = toMinutes($('olStartTime')?.value || '');
              if (Number.isFinite(startMin)) min = Math.max(min, startMin + 1);
            }
            return clamp(min, 0, 1439);
          }

          function applyClockValue(target, hour, minute) {
            let total = clamp(hour * 60 + minute, 0, 1439);
            const min = getClockMinMinutes(target);
            if (Number.isFinite(min)) total = Math.max(min, total);
            setClockTimeParts(target, Math.floor(total / 60), total % 60);
            return total;
          }

          function setClockToNow() {
            const now = new Date();
            const startMin = now.getHours() * 60 + now.getMinutes();
            const duration = Math.max(1, parseInt($('olDuration')?.value || '60', 10) || 60);
            const endMin = clamp(startMin + duration, startMin + 1, 1439);
            if ($('olStartTime')) $('olStartTime').value = minutesToTime(startMin);
            if ($('olEndTime')) $('olEndTime').value = minutesToTime(endMin);
            updateClockUI();
          }

          function updateClockUI(targets) {
            const list = Array.isArray(targets) ? targets : (targets ? [targets] : ['start', 'end']);
            list.forEach((target) => {
              const { hour, minute } = getClockTimeParts(target);
              const readout = document.querySelector(`.ol-clock-readout[data-clock-readout="${target}"]`);
              if (readout) readout.textContent = `${pad2(hour)}:${pad2(minute)}`;
              const dial = document.querySelector(`.ol-clock[data-clock-target="${target}"]`);
              if (!dial) return;
              const hourHand = dial.querySelector('.ol-clock-hour-hand');
              const minuteHand = dial.querySelector('.ol-clock-minute-hand');
              if (hourHand) {
                const hourDeg = ((hour % 12) + (minute / 60)) * 30;
                hourHand.setAttribute('transform', `rotate(${hourDeg} 100 100)`);
              }
              if (minuteHand) {
                const minDeg = minute * 6;
                minuteHand.setAttribute('transform', `rotate(${minDeg} 100 100)`);
              }
            });
          }

          function buildClockTicks(ticksEl, numbersEl) {
            if (!ticksEl) return;
            ticksEl.innerHTML = '';
            if (numbersEl) numbersEl.innerHTML = '';
            for (let i = 0; i < 60; i++) {
              const a = (i / 60) * 2 * Math.PI - Math.PI / 2;
              const r1 = i % 5 === 0 ? 62 : 70;
              const r2 = 82;
              const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
              line.setAttribute('x1', (100 + r1 * Math.cos(a)).toFixed(2));
              line.setAttribute('y1', (100 + r1 * Math.sin(a)).toFixed(2));
              line.setAttribute('x2', (100 + r2 * Math.cos(a)).toFixed(2));
              line.setAttribute('y2', (100 + r2 * Math.sin(a)).toFixed(2));
              line.setAttribute('stroke', i % 5 === 0 ? 'rgba(148, 163, 184, 0.9)' : 'rgba(148, 163, 184, 0.45)');
              line.setAttribute('stroke-width', i % 5 === 0 ? '2' : '1');
              ticksEl.appendChild(line);
            }
            if (!numbersEl) return;
            for (let n = 1; n <= 12; n++) {
              const a = (n / 12) * 2 * Math.PI - Math.PI / 2;
              const r = 52;
              const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
              text.setAttribute('x', (100 + r * Math.cos(a)).toFixed(2));
              text.setAttribute('y', (100 + r * Math.sin(a)).toFixed(2));
              text.setAttribute('class', 'ol-clock-number');
              text.textContent = String(n);
              numbersEl.appendChild(text);
            }
          }

          function handleClockPointer(target, dial, e) {
            if (!dial) return;
            const rect = dial.getBoundingClientRect();
            const cx = rect.left + rect.width / 2;
            const cy = rect.top + rect.height / 2;
            const x = e.clientX - cx;
            const y = e.clientY - cy;
            const angle = (Math.atan2(y, x) * 180 / Math.PI + 90 + 360) % 360;
            const current = getClockTimeParts(target);
            const newMinute = Math.floor(angle / 6) % 60;
            let hour = current.hour;
            const dragState = clockState[target] || (clockState[target] = { lastAngleRaw: null });
            const lastAngle = dragState.lastAngleRaw;
            if (typeof lastAngle === 'number') {
              let delta = angle - lastAngle;
              if (delta > 180) delta -= 360;
              if (delta < -180) delta += 360;
              const crossingForward = delta > 0 && lastAngle > 300 && angle < 60;
              const crossingBackward = delta < 0 && lastAngle < 60 && angle > 300;
              if (crossingForward) hour += 1;
              if (crossingBackward) hour -= 1;
            } else {
              const diff = newMinute - current.minute;
              if (diff > 30) hour -= 1;
              else if (diff < -30) hour += 1;
            }
            const total = applyClockValue(target, clamp(hour, 0, 23), newMinute);
            dragState.lastAngleRaw = angle;
            updateClockUI();
          }

          function initClockPanel() {
            if (clockBound) return;
            const dials = Array.from(document.querySelectorAll('.ol-clock[data-clock-target]'));
            if (!dials.length) return;
            clockBound = true;
            dials.forEach((dial) => {
              const ticks = dial.querySelector('.ol-clock-ticks');
              const numbers = dial.querySelector('.ol-clock-numbers');
              buildClockTicks(ticks, numbers);
            });
            updateClockUI();
            $('olClockSetNow')?.addEventListener('click', () => setClockToNow());
            dials.forEach((dial) => {
              const target = dial.dataset.clockTarget || 'start';
              dial.addEventListener('pointerdown', (e) => {
                clockDragging = true;
                clockActiveTarget = target;
                clockPointerId = e.pointerId;
                if (clockState[target]) clockState[target].lastAngleRaw = null;
                dial.setPointerCapture(e.pointerId);
                handleClockPointer(target, dial, e);
                e.preventDefault();
              });
              dial.addEventListener('pointermove', (e) => {
                if (!clockDragging || clockActiveTarget !== target || e.pointerId !== clockPointerId) return;
                handleClockPointer(target, dial, e);
                e.preventDefault();
              });
              const stopDrag = (e) => {
                if (e && e.pointerId !== clockPointerId) return;
                if (clockDragging && clockActiveTarget === target) {
                  try { handleClockPointer(target, dial, e); } catch (_) { }
                }
                clockDragging = false;
                clockActiveTarget = null;
                clockPointerId = null;
                if (clockState[target]) clockState[target].lastAngleRaw = null;
              };
              dial.addEventListener('pointerup', stopDrag);
              dial.addEventListener('pointercancel', stopDrag);
            });
          }

          function syncEditDurationFromTimes() {
            if (syncingEditTime) return;
            const startMin = toMinutes($('olEditStart')?.value || '');
            const endMin = toMinutes($('olEditEnd')?.value || '');
            if (!Number.isFinite(startMin) || !Number.isFinite(endMin) || endMin <= startMin) return;
            syncingEditTime = true;
            const dur = Math.max(1, endMin - startMin);
            if ($('olEditDuration')) $('olEditDuration').value = String(dur);
            syncingEditTime = false;
          }

          function syncEditEndFromDuration() {
            if (syncingEditTime) return;
            const startMin = toMinutes($('olEditStart')?.value || '');
            const duration = parseInt($('olEditDuration')?.value || '', 10);
            if (!Number.isFinite(startMin) || !Number.isFinite(duration) || duration <= 0) return;
            const endMin = clamp(startMin + duration, startMin + 1, 1439);
            syncingEditTime = true;
            if ($('olEditEnd')) $('olEditEnd').value = minutesToTime(endMin);
            syncingEditTime = false;
          }

          function updateGroupLabel(groupId) {
            if (!groupId) return;
            const items = state.lessons.filter(l => l.groupId === groupId);
            if (!items.length) return;
            const dates = items.map(l => startOfDay(new Date(l.start)).getTime());
            const minDate = new Date(Math.min(...dates));
            const maxDate = new Date(Math.max(...dates));
            const daysSet = new Set(items.map(l => new Date(l.start).getDay()));
            const startMin = toMinutes(formatHM(items[0].start));
            const endMin = toMinutes(formatHM(items[0].end));
            const label = buildGroupLabel(minDate, maxDate, daysSet, startMin, endMin);
            items.forEach(l => { l.groupLabel = label; });
          }

          function openEdit(lessonId, anchorEl) {
            const lesson = state.lessons.find(l => l.id === lessonId);
            if (!lesson) return;
            state.editingId = lessonId;
            if ($('olEditTitle')) $('olEditTitle').value = lesson.title || '授業';
            if ($('olEditDate')) $('olEditDate').value = formatDateValue(new Date(lesson.start));
            if ($('olEditStart')) $('olEditStart').value = formatHM(lesson.start);
            if ($('olEditEnd')) $('olEditEnd').value = formatHM(lesson.end);
            if ($('olEditDuration')) $('olEditDuration').value = String(Math.max(1, Math.round((lesson.end - lesson.start) / 60000)));
            if ($('olEditColor')) $('olEditColor').value = lesson.color || '#60a5fa';
            if ($('olEditApplySeries')) $('olEditApplySeries').checked = false;
            const overlay = $('olEditOverlay');
            overlay?.classList.remove('hidden');
            positionEditOverlay(anchorEl);
            syncEditDurationFromTimes();
          }

          function positionEditOverlay(anchorEl) {
            const overlay = $('olEditOverlay');
            const modal = overlay?.querySelector('.ol-edit-modal');
            if (!overlay || !modal) return;
            if (!anchorEl) {
              overlay.dataset.anchor = '0';
              overlay.removeAttribute('data-placement');
              overlay.style.removeProperty('--ol-edit-left');
              overlay.style.removeProperty('--ol-edit-top');
              overlay.style.removeProperty('--ol-edit-shift-x');
              overlay.style.removeProperty('--ol-edit-shift-y');
              overlay.style.removeProperty('--ol-edit-arrow-left');
              overlay.style.removeProperty('--ol-edit-arrow-top');
              return;
            }
            overlay.dataset.anchor = '1';
            requestAnimationFrame(() => {
              const rect = anchorEl.getBoundingClientRect();
              const modalRect = modal.getBoundingClientRect();
              const padding = 12;
              const centerY = rect.top + rect.height / 2;
              let placement = 'left';
              let left = rect.left - 12;
              let shiftX = '-100%';
              let shiftY = '-50%';
              if (left - modalRect.width < padding) {
                placement = 'right';
                left = rect.right + 12;
                shiftX = '0';
              }
              let top = clamp(centerY, padding + modalRect.height / 2, window.innerHeight - padding - modalRect.height / 2);
              const modalTop = top - modalRect.height / 2;
              const arrowTop = clamp(centerY - modalTop, 16, modalRect.height - 16);
              overlay.dataset.placement = placement;
              overlay.style.setProperty('--ol-edit-left', `${left}px`);
              overlay.style.setProperty('--ol-edit-top', `${top}px`);
              overlay.style.setProperty('--ol-edit-shift-x', shiftX);
              overlay.style.setProperty('--ol-edit-shift-y', shiftY);
              overlay.style.setProperty('--ol-edit-arrow-top', `${arrowTop}px`);
            });
          }

          function closeEdit() {
            state.editingId = null;
            const overlay = $('olEditOverlay');
            overlay?.classList.add('hidden');
            overlay?.removeAttribute('data-placement');
            if (overlay) overlay.dataset.anchor = '0';
            overlay?.style.removeProperty('--ol-edit-arrow-top');
          }

          function applyEditShift(target, delta) {
            const input = target === 'end' ? $('olEditEnd') : $('olEditStart');
            if (!input) return;
            const cur = toMinutes(input.value || '');
            if (!Number.isFinite(cur)) return;
            const next = clamp(cur + delta, 0, 1439);
            input.value = minutesToTime(next);
            if (target === 'start') syncEditEndFromDuration();
            else syncEditDurationFromTimes();
          }

          function applyEditDayShift(delta) {
            const date = parseDateValue($('olEditDate')?.value || '');
            if (!date) return;
            const next = addDays(date, delta);
            if ($('olEditDate')) $('olEditDate').value = formatDateValue(next);
          }

          function duplicateEditLesson() {
            const lesson = state.lessons.find(l => l.id === state.editingId);
            if (!lesson) return;
            const baseTitle = lesson.title || '授業';
            const copyTitle = baseTitle.includes('コピー') ? `${baseTitle}2` : `${baseTitle} (コピー)`;
            const id = `ol_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 6)}`;
            state.lessons.push({
              id,
              title: copyTitle,
              start: lesson.start,
              end: lesson.end,
              color: lesson.color || '#60a5fa',
              groupId: '',
              groupLabel: '',
              done: false,
              created: Date.now()
            });
            saveLessons();
            render();
            toast('複製しました', 'ok');
          }

          function getCopyTargetDate() {
            const raw = $('olCopyTarget')?.value || '';
            return parseDateValue(raw);
          }

          function copyLessonToDate(lessonId, targetDate) {
            const lesson = state.lessons.find(l => l.id === lessonId);
            if (!lesson || !targetDate) return 0;
            const startMin = toMinutes(formatHM(lesson.start));
            const endMin = toMinutes(formatHM(lesson.end));
            if (!Number.isFinite(startMin) || !Number.isFinite(endMin)) return 0;
            const ok = createLesson(targetDate, startMin, endMin, {
              title: lesson.title || '授業',
              color: lesson.color || '#60a5fa'
            });
            return ok ? 1 : 0;
          }

          function copyDayToDate(sourceDate, targetDate) {
            if (!sourceDate || !targetDate) return 0;
            if (startOfDay(sourceDate).getTime() === startOfDay(targetDate).getTime()) return 0;
            const lessons = getLessonsForDateRaw(sourceDate, { includeDone: true });
            let added = 0;
            lessons.forEach(lesson => {
              const startMin = toMinutes(formatHM(lesson.start));
              const endMin = toMinutes(formatHM(lesson.end));
              if (!Number.isFinite(startMin) || !Number.isFinite(endMin)) return;
              if (createLesson(targetDate, startMin, endMin, {
                title: lesson.title || '授業',
                color: lesson.color || '#60a5fa'
              })) {
                added++;
              }
            });
            return added;
          }

          function saveEdit() {
            const lesson = state.lessons.find(l => l.id === state.editingId);
            if (!lesson) return;
            const title = ($('olEditTitle')?.value || '').trim() || '授業';
            const dateStr = $('olEditDate')?.value || '';
            const date = parseDateValue(dateStr);
            if (!date) { toast('日付を入力してください', 'error'); return; }
            const startMin = toMinutes($('olEditStart')?.value || '');
            if (!Number.isFinite(startMin)) { toast('開始時刻を入力してください', 'error'); return; }
            let endMin = toMinutes($('olEditEnd')?.value || '');
            const duration = parseInt($('olEditDuration')?.value || '', 10);
            if (!Number.isFinite(endMin) || endMin <= startMin) {
              if (Number.isFinite(duration) && duration > 0) {
                endMin = clamp(startMin + duration, startMin + 1, 1439);
                if ($('olEditEnd')) $('olEditEnd').value = minutesToTime(endMin);
              } else {
                toast('終了時刻か時間(分)を入力してください', 'error');
                return;
              }
            }
            const color = $('olEditColor')?.value || '#60a5fa';
            const applySeries = !!$('olEditApplySeries')?.checked && lesson.groupId;
            const updatedIds = new Set();

            const updateOne = (targetLesson, baseDate) => {
              const s = new Date(baseDate);
              s.setHours(Math.floor(startMin / 60), startMin % 60, 0, 0);
              const e = new Date(baseDate);
              e.setHours(Math.floor(endMin / 60), endMin % 60, 0, 0);
              targetLesson.title = title;
              targetLesson.color = color;
              targetLesson.start = s.getTime();
              targetLesson.end = e.getTime();
              targetLesson.preNotifiedAt = null;
              targetLesson.startNotifiedAt = null;
              targetLesson.endNotifiedAt = null;
              targetLesson.snoozeUntil = null;
              if (!session || session.lessonId !== targetLesson.id) {
                targetLesson.startedAt = null;
                targetLesson.autoStartedAt = null;
              }
              updatedIds.add(targetLesson.id);
            };

            if (applySeries) {
              const baseOld = startOfDay(new Date(lesson.start));
              const deltaDays = Math.round((date.getTime() - baseOld.getTime()) / DAY_MS);
              state.lessons.forEach(l => {
                if (l.groupId !== lesson.groupId) return;
                const baseDate = addDays(startOfDay(new Date(l.start)), deltaDays);
                updateOne(l, baseDate);
              });
              updateGroupLabel(lesson.groupId);
            } else {
              updateOne(lesson, date);
            }
            state.selectedDate = startOfDay(date);
            saveLessons();
            updatedIds.forEach(id => {
              const item = state.lessons.find(l => l.id === id);
              if (!item) { removeLessonTimer(id); return; }
              if ((session && session.lessonId === id) || findLessonTimerIndex(id) >= 0) {
                syncLessonTimer(item, { resetSounds: true });
              }
            });
            render();
            closeEdit();
            toast('更新しました', 'ok');
          }

          function initEditOverlay() {
            if (editBound) return;
            const overlay = $('olEditOverlay');
            if (!overlay) return;
            editBound = true;
            $('olEditClose')?.addEventListener('click', closeEdit);
            $('olEditCancel')?.addEventListener('click', closeEdit);
            $('olEditSave')?.addEventListener('click', saveEdit);
            $('olEditDuplicate')?.addEventListener('click', duplicateEditLesson);
            $('olEditDelete')?.addEventListener('click', () => {
              if (!state.editingId) return;
              if (!confirm('この授業を削除しますか？')) return;
              deleteLesson(state.editingId);
              closeEdit();
            });
            $('olEditStart')?.addEventListener('input', syncEditEndFromDuration);
            $('olEditEnd')?.addEventListener('input', syncEditDurationFromTimes);
            $('olEditDuration')?.addEventListener('input', syncEditEndFromDuration);
            overlay.addEventListener('click', (e) => {
              if (e.target === overlay) closeEdit();
            });
            overlay.querySelector('.ol-edit-quick')?.addEventListener('click', (e) => {
              const btn = e.target.closest('button');
              if (!btn) return;
              if (btn.dataset.editShift) {
                const shift = parseInt(btn.dataset.editShift, 10);
                const target = btn.dataset.editTarget || 'start';
                if (Number.isFinite(shift)) applyEditShift(target, shift);
              }
              if (btn.dataset.editDay) {
                const delta = parseInt(btn.dataset.editDay, 10);
                if (Number.isFinite(delta)) applyEditDayShift(delta);
              }
            });
          }

          function createLesson(dateObj, startMin, endMin, meta) {
            if (!dateObj || !Number.isFinite(startMin) || !Number.isFinite(endMin) || endMin <= startMin) return false;
            const start = new Date(dateObj);
            start.setHours(Math.floor(startMin / 60), startMin % 60, 0, 0);
            const end = new Date(dateObj);
            end.setHours(Math.floor(endMin / 60), endMin % 60, 0, 0);
            const title = meta.title || '授業';
            const dup = state.lessons.some(l => l.start === start.getTime() && l.end === end.getTime() && l.title === title);
            if (dup) return false;
            const id = `ol_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 6)}`;
            state.lessons.push({
              id,
              title,
              start: start.getTime(),
              end: end.getTime(),
              color: meta.color || '#60a5fa',
              groupId: meta.groupId || '',
              groupLabel: meta.groupLabel || '',
              done: false,
              created: Date.now()
            });
            return true;
          }

          function addRange() {
            const startStr = $('olRangeStart')?.value || '';
            const endStr = $('olRangeEnd')?.value || startStr;
            let startDate = parseDateValue(startStr);
            let endDate = parseDateValue(endStr);
            if (!startDate) { toast('開始日を入力してください', 'error'); return; }
            if (!endDate) endDate = startDate;
            if (endDate < startDate) { const tmp = startDate; startDate = endDate; endDate = tmp; }

            const startMin = toMinutes($('olStartTime')?.value || '');
            if (!Number.isFinite(startMin)) { toast('開始時刻を入力してください', 'error'); return; }
            let endMin = toMinutes($('olEndTime')?.value || '');
            const duration = parseInt($('olDuration')?.value || '', 10);
            if (!Number.isFinite(endMin) || endMin <= startMin) {
              if (Number.isFinite(duration) && duration > 0) {
                endMin = clamp(startMin + duration, startMin + 1, 1439);
                if ($('olEndTime')) $('olEndTime').value = minutesToTime(endMin);
              } else {
                toast('終了時刻か時間(分)を入力してください', 'error');
                return;
              }
            }
            const daysSet = getSelectedWeekdays();
            let eligible = 0;
            const totalDays = Math.floor((endDate.getTime() - startDate.getTime()) / DAY_MS) + 1;
            for (let i = 0; i < totalDays; i++) {
              const d = addDays(startDate, i);
              if (daysSet.has(d.getDay())) eligible++;
            }
            if (!eligible) { toast('範囲内に指定曜日がありません', 'error'); return; }
            if (state.lessons.length + eligible > 2000) { toast('予定が多すぎます（2000件まで）', 'error'); return; }

            const title = ($('olTitle')?.value || '授業').trim() || '授業';
            const color = $('olColor')?.value || '#60a5fa';
            const groupId = `ol_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 6)}`;
            const groupLabel = buildGroupLabel(startDate, endDate, daysSet, startMin, endMin);
            let added = 0;
            for (let i = 0; i < totalDays; i++) {
              const d = addDays(startDate, i);
              if (!daysSet.has(d.getDay())) continue;
              if (createLesson(d, startMin, endMin, { title, color, groupId, groupLabel })) added++;
            }
            if (added) {
              saveLessons();
              render();
              toast(`授業を追加しました（${added}件）`, 'ok');
            } else {
              toast('追加できる授業がありません', 'info');
            }
          }

          function addSelected() {
            const target = state.selectedDate || startOfDay(new Date());
            const startMin = toMinutes($('olStartTime')?.value || '');
            let endMin = toMinutes($('olEndTime')?.value || '');
            const duration = parseInt($('olDuration')?.value || '', 10);
            if (!Number.isFinite(startMin)) { toast('開始時刻を入力してください', 'error'); return; }
            if (!Number.isFinite(endMin) || endMin <= startMin) {
              if (Number.isFinite(duration) && duration > 0) {
                endMin = clamp(startMin + duration, startMin + 1, 1439);
                if ($('olEndTime')) $('olEndTime').value = minutesToTime(endMin);
              } else {
                toast('終了時刻か時間(分)を入力してください', 'error');
                return;
              }
            }
            const title = ($('olTitle')?.value || '授業').trim() || '授業';
            const color = $('olColor')?.value || '#60a5fa';
            const ok = createLesson(target, startMin, endMin, { title, color });
            if (ok) {
              saveLessons();
              render();
              toast('選択日に追加しました', 'ok');
            } else {
              toast('同じ時間の授業が既にあります', 'info');
            }
          }

          function clearAll() {
            if (!confirm('オリジナル授業を全削除しますか？')) return;
            state.lessons = [];
            session = null;
            saveLessons();
            saveSession();
            hideLessonToast();
            cleanupLessonTimers(Date.now());
            render();
            toast('すべて削除しました', 'ok');
          }

          function deleteLesson(id) {
            const before = state.lessons.length;
            state.lessons = state.lessons.filter(l => l.id !== id);
            if (session && session.lessonId === id) session = null;
            if (before !== state.lessons.length) {
              saveLessons();
              saveSession();
              if (state.notify.activeId === id) hideLessonToast();
              removeLessonTimer(id);
              render();
            }
          }
          function deleteSeries(groupId) {
            if (!groupId) return;
            const before = state.lessons.length;
            const ids = state.lessons.filter(l => l.groupId === groupId).map(l => l.id);
            state.lessons = state.lessons.filter(l => l.groupId !== groupId);
            if (session && session.lessonId && !state.lessons.some(l => l.id === session.lessonId)) session = null;
            if (before !== state.lessons.length) {
              saveLessons();
              saveSession();
              if (state.notify.activeType && state.notify.activeId && !state.lessons.some(l => l.id === state.notify.activeId)) hideLessonToast();
              ids.forEach(id => removeLessonTimer(id));
              render();
            }
          }
          function toggleDone(id) {
            const lesson = state.lessons.find(l => l.id === id);
            if (!lesson) return;
            lesson.done = !lesson.done;
            lesson.completedAt = lesson.done ? Date.now() : null;
            saveLessons();
            if (lesson.done && session && session.lessonId === lesson.id) {
              session = null;
              saveSession();
            }
            if (lesson.done && state.notify.activeId === lesson.id) hideLessonToast();
            if (lesson.done) removeLessonTimer(lesson.id);
            render();
          }

          function getLessonsForDateRaw(dateObj, opts = {}) {
            if (!dateObj) return [];
            const includeDone = opts.includeDone !== false;
            const startMs = startOfDay(dateObj).getTime();
            const endMs = startMs + DAY_MS;
            return state.lessons.filter(l => {
              if (!l || l.end <= startMs || l.start >= endMs) return false;
              if (!includeDone && l.done) return false;
              return true;
            }).sort((a, b) => (a.start || 0) - (b.start || 0));
          }

          function lessonsForDate(dateObj) {
            const base = getLessonsForDateRaw(dateObj, { includeDone: true });
            return base.filter(l => {
              if (state.filter === 'active' && l.done) return false;
              if (state.filter === 'done' && !l.done) return false;
              return true;
            });
          }

          function renderTimeline() {
            const timeline = $('olTimeline');
            const host = $('olHorizontalView');
            if (!timeline) return;
            let viewStart = parseDateValue($('olViewStart')?.value || '');
            let viewEnd = parseDateValue($('olViewEnd')?.value || '');
            if (!viewStart || !viewEnd) {
              const today = startOfDay(new Date());
              viewStart = viewStart || addDays(today, -7);
              viewEnd = viewEnd || addDays(today, 30);
              if ($('olViewStart')) $('olViewStart').value = formatDateValue(viewStart);
              if ($('olViewEnd')) $('olViewEnd').value = formatDateValue(viewEnd);
            }
            if (viewEnd < viewStart) { const tmp = viewStart; viewStart = viewEnd; viewEnd = tmp; }
            let dayCount = Math.floor((viewEnd.getTime() - viewStart.getTime()) / DAY_MS) + 1;
            if (dayCount > MAX_VIEW_DAYS) {
              viewEnd = addDays(viewStart, MAX_VIEW_DAYS - 1);
              if ($('olViewEnd')) $('olViewEnd').value = formatDateValue(viewEnd);
              dayCount = MAX_VIEW_DAYS;
              toast('表示期間が長すぎるため短縮しました', 'info');
            }
            state.viewStart = viewStart;
            state.viewEnd = viewEnd;
            scheduleSave();

            timeline.innerHTML = '';
            const today = startOfDay(new Date());
            let selectedEl = null;
            for (let i = 0; i < dayCount; i++) {
              const d = addDays(viewStart, i);
              const dayDiv = document.createElement('div');
              dayDiv.className = 'sc-h-day';
              dayDiv.dataset.date = formatDateValue(d);
              if (d.getTime() === today.getTime()) dayDiv.classList.add('today');
              if (d.getDay() === 0 || d.getDay() === 6) dayDiv.classList.add('weekend');
              if (state.selectedDate && d.getTime() === startOfDay(state.selectedDate).getTime()) {
                dayDiv.classList.add('selected');
                selectedEl = dayDiv;
              }

              const header = document.createElement('div');
              header.className = 'sc-h-day-header';
              header.innerHTML = `<div class="sc-h-day-date">${d.getMonth() + 1}/${d.getDate()}</div><div class="sc-h-day-name">${WEEKDAYS[d.getDay()]}</div>`;
              dayDiv.appendChild(header);

              const tasksDiv = document.createElement('div');
              tasksDiv.className = 'sc-h-day-tasks';
              const lessons = lessonsForDate(d);
              lessons.forEach(lesson => {
                const chip = document.createElement('div');
                chip.className = 'sc-h-task';
                if (lesson.done) chip.classList.add('done');
                const color = lesson.color || '#60a5fa';
                chip.style.background = colorToRgba(color, 0.18);
                chip.style.borderColor = color;
                chip.style.borderLeft = `3px solid ${color}`;
                chip.innerHTML = `<span class="sc-chip-title">${safe(lesson.title || '授業')}</span><span class="sc-chip-meta">${formatTimeRange(lesson.start, lesson.end)}</span>`;
                chip.addEventListener('click', (e) => {
                  e.stopPropagation();
                  if (host) state.hScrollLeft = host.scrollLeft;
                  state.selectedDate = startOfDay(d);
                  scheduleSave();
                  render();
                });
                tasksDiv.appendChild(chip);
              });
              dayDiv.appendChild(tasksDiv);
              dayDiv.addEventListener('click', () => {
                if (host) state.hScrollLeft = host.scrollLeft;
                state.selectedDate = startOfDay(d);
                scheduleSave();
                render();
              });
              timeline.appendChild(dayDiv);
            }

            if (host && !host.__olBound) {
              host.addEventListener('scroll', () => {
                state.hScrollLeft = host.scrollLeft;
                scheduleSave();
              }, { passive: true });
              host.__olBound = true;
            }
            if (host) {
              requestAnimationFrame(() => {
                if (state.hScrollLeft != null) {
                  host.scrollLeft = state.hScrollLeft;
                } else if (selectedEl) {
                  host.scrollLeft = Math.max(0, selectedEl.offsetLeft - 16);
                  state.hScrollLeft = host.scrollLeft;
                }
              });
            }
          }

          function renderDayList() {
            const list = $('olDayList');
            const empty = $('olDayEmpty');
            const title = $('olDayTitle');
            const total = $('olDayTotal');
            if (!list) return;
            const date = state.selectedDate || startOfDay(new Date());
            const label = `${date.getMonth() + 1}/${date.getDate()} (${WEEKDAYS[date.getDay()]})`;
            if (title) title.textContent = label;
            const copyTarget = $('olCopyTarget');
            if (copyTarget && !copyTarget.value) {
              copyTarget.value = formatDateValue(addDays(date, 1));
            }

            const lessons = lessonsForDate(date);
            const totalMin = lessons.reduce((acc, l) => acc + Math.max(0, (l.end - l.start) / 60000), 0);
            if (total) total.textContent = lessons.length ? `合計 ${formatMinutes(totalMin)}` : '--';

            list.innerHTML = '';
            if (!lessons.length) {
              if (empty) empty.classList.remove('hidden');
              return;
            }
            if (empty) empty.classList.add('hidden');

            lessons.forEach(lesson => {
              const item = document.createElement('div');
              item.className = 'ol-day-item' + (lesson.done ? ' done' : '');
              const head = document.createElement('div');
              head.className = 'row space';
              head.style.alignItems = 'center';

              const time = document.createElement('strong');
              time.textContent = formatTimeRange(lesson.start, lesson.end);
              const dot = document.createElement('span');
              dot.style.width = '10px';
              dot.style.height = '10px';
              dot.style.borderRadius = '999px';
              dot.style.background = lesson.color || '#60a5fa';
              dot.style.display = 'inline-block';
              dot.style.marginLeft = '6px';

              const left = document.createElement('div');
              left.appendChild(time);
              left.appendChild(dot);

              const badge = document.createElement('span');
              badge.className = 'tiny';
              badge.style.color = 'var(--muted)';
              badge.textContent = lesson.done ? '完了' : '未完';

              head.appendChild(left);
              head.appendChild(badge);

              const titleEl = document.createElement('div');
              titleEl.textContent = lesson.title || '授業';

              const meta = document.createElement('div');
              meta.className = 'meta';
              meta.textContent = lesson.groupLabel || '';

              const actions = document.createElement('div');
              actions.className = 'ol-day-actions';
              const btnEdit = document.createElement('button');
              btnEdit.className = 'btn ghost small';
              btnEdit.dataset.action = 'edit';
              btnEdit.dataset.id = lesson.id;
              btnEdit.textContent = '編集';
              const btnCopy = document.createElement('button');
              btnCopy.className = 'btn ghost small';
              btnCopy.dataset.action = 'copy';
              btnCopy.dataset.id = lesson.id;
              btnCopy.textContent = 'コピー';
              const btnStart = document.createElement('button');
              btnStart.className = 'btn small';
              btnStart.dataset.action = 'start';
              btnStart.dataset.id = lesson.id;
              btnStart.textContent = '開始';
              const btnDone = document.createElement('button');
              btnDone.className = 'btn ghost small';
              btnDone.dataset.action = 'done';
              btnDone.dataset.id = lesson.id;
              btnDone.textContent = lesson.done ? '未完に戻す' : '完了';
              const btnDel = document.createElement('button');
              btnDel.className = 'btn ghost small danger';
              btnDel.dataset.action = 'delete';
              btnDel.dataset.id = lesson.id;
              btnDel.textContent = '削除';
              actions.appendChild(btnEdit);
              actions.appendChild(btnCopy);
              actions.appendChild(btnStart);
              actions.appendChild(btnDone);
              actions.appendChild(btnDel);
              if (lesson.groupId) {
                const btnSeries = document.createElement('button');
                btnSeries.className = 'btn ghost small';
                btnSeries.dataset.action = 'delete-series';
                btnSeries.dataset.id = lesson.id;
                btnSeries.dataset.group = lesson.groupId;
                btnSeries.textContent = '系列削除';
                actions.appendChild(btnSeries);
              }

              item.appendChild(head);
              item.appendChild(titleEl);
              if (lesson.groupLabel) item.appendChild(meta);
              item.appendChild(actions);
              list.appendChild(item);
            });
          }

          function sumMinutesBetween(startMs, endMs) {
            let minutes = 0;
            state.lessons.forEach(l => {
              const overlap = Math.min(l.end, endMs) - Math.max(l.start, startMs);
              if (overlap > 0) minutes += overlap / 60000;
            });
            return minutes;
          }

          function renderStats() {
            const statWeek = $('olStatWeek');
            const statToday = $('olStatToday');
            const statMonth = $('olStatMonth');
            const statTotal = $('olStatTotal');
            const now = new Date();
            const today = startOfDay(now);
            const weekStart = addDays(today, -((today.getDay() + 6) % 7));
            const weekEnd = addDays(weekStart, 7);
            const dayStart = today;
            const dayEnd = addDays(dayStart, 1);
            const monthStart = new Date(today.getFullYear(), today.getMonth(), 1);
            const monthEnd = new Date(today.getFullYear(), today.getMonth() + 1, 1);
            const dayMin = sumMinutesBetween(dayStart.getTime(), dayEnd.getTime());
            const weekMin = sumMinutesBetween(weekStart.getTime(), weekEnd.getTime());
            const monthMin = sumMinutesBetween(monthStart.getTime(), monthEnd.getTime());
            const totalMin = state.lessons.reduce((acc, l) => acc + Math.max(0, (l.end - l.start) / 60000), 0);
            if (statWeek) statWeek.textContent = formatMinutes(weekMin);
            if (statToday) statToday.textContent = formatMinutes(dayMin);
            if (statMonth) statMonth.textContent = formatMinutes(monthMin);
            if (statTotal) statTotal.textContent = formatMinutes(totalMin);
          }

          function getUpcomingLessons(nowMs) {
            const pending = state.lessons.filter(l => !l.done && l.end > nowMs).sort((a, b) => (a.start || 0) - (b.start || 0));
            const current = pending.find(l => l.start <= nowMs && l.end > nowMs) || null;
            const next = pending.find(l => l.start > nowMs) || null;
            return { current, next };
          }

          function getGaugeInfo(nowMs) {
            const now = Number.isFinite(nowMs) ? nowMs : Date.now();
            let lesson = null;
            if (session && session.lessonId) {
              lesson = state.lessons.find(l => l.id === session.lessonId) || null;
            }
            if (!lesson) {
              const { current } = getUpcomingLessons(now);
              lesson = current;
            }
            if (!lesson || lesson.done) return null;
            const totalMs = Math.max(1, lesson.end - lesson.start);
            const remainMs = Math.max(0, lesson.end - now);
            const ratio = clamp(remainMs / totalMs, 0, 1);
            return { lesson, ratio, remainMs, totalMs, color: lesson.color || '#60a5fa' };
          }

          function shouldPreNotify(lesson, nowMs) {
            if (!lesson || lesson.done) return false;
            if (lesson.startedAt) return false;
            if (lesson.start <= nowMs) return false;
            if ((lesson.start - nowMs) > PRE_NOTIFY_MS) return false;
            if (lesson.snoozeUntil && lesson.snoozeUntil > nowMs) return false;
            if (lesson.preNotifiedAt && !lesson.snoozeUntil) return false;
            return true;
          }

          function shouldEndNotify(lesson, nowMs) {
            if (!lesson || lesson.done) return false;
            if (lesson.end > nowMs) return false;
            if (lesson.endNotifiedAt) return false;
            return true;
          }

          function checkAutoStartAndNotify() {
            const nowMs = Date.now();
            let touched = false;
            const due = state.lessons
              .filter(l => l && !l.done && !l.startedAt && l.start <= nowMs && l.end > nowMs)
              .sort((a, b) => (a.start || 0) - (b.start || 0));
            if (due.length) {
              startSession(due[0].id, { auto: true, alignStart: true });
            }

            let candidate = null;
            state.lessons.forEach(lesson => {
              if (!lesson) return;
              if (lesson.snoozeUntil && lesson.snoozeUntil <= nowMs) {
                lesson.snoozeUntil = null;
                lesson.preNotifiedAt = null;
                touched = true;
              }
              if (shouldPreNotify(lesson, nowMs)) {
                if (!candidate || lesson.start < candidate.start) candidate = lesson;
              }
            });
            if (candidate && state.notify.activeType !== 'start' && state.notify.activeType !== 'end') {
              if (state.notify.activeType !== 'pre' || state.notify.activeId !== candidate.id) {
                candidate.preNotifiedAt = nowMs;
                touched = true;
                showLessonToast('pre', candidate);
              }
            }
            let endCandidate = null;
            state.lessons.forEach(lesson => {
              if (!lesson) return;
              if (shouldEndNotify(lesson, nowMs)) {
                if (!endCandidate || lesson.end > endCandidate.end) endCandidate = lesson;
              }
            });
            if (endCandidate) {
              endCandidate.endNotifiedAt = nowMs;
              touched = true;
              showLessonToast('end', endCandidate);
            }
            cleanupLessonTimers(nowMs);
            if (touched) saveLessons();
          }

          function renderSession() {
            const statusEl = $('olSessionStatus');
            const metaEl = $('olSessionMeta');
            const progressEl = $('olSessionProgress');
            const startBtn = $('olSessionStart');
            const finishBtn = $('olSessionFinish');
            const extendBtn = $('olSessionExtend');
            if (!statusEl || !metaEl || !progressEl || !startBtn || !finishBtn || !extendBtn) return;

            const nowMs = Date.now();
            let lesson = session ? state.lessons.find(l => l.id === session.lessonId) : null;
            if (session && !lesson) { session = null; saveSession(); }
            if (session && lesson) {
              ensureSessionTimer(lesson);
              const elapsed = clamp(nowMs - lesson.start, 0, lesson.end - lesson.start);
              const planned = Math.max(1, lesson.end - lesson.start);
              const remainMin = Math.max(0, (lesson.end - nowMs) / 60000);
              const progress = clamp(elapsed / planned, 0, 1) * 100;
              progressEl.style.width = `${progress}%`;
              statusEl.textContent = `▶ 授業中: ${lesson.title || '授業'}`;
              metaEl.textContent = `予定 ${formatTimeRange(lesson.start, lesson.end)} / 経過 ${formatMinutes(elapsed / 60000)} / 残り ${formatMinutes(remainMin)}`;
              startBtn.style.display = 'none';
              finishBtn.style.display = '';
              extendBtn.style.display = '';
              return;
            }

            const { current, next } = getUpcomingLessons(nowMs);
            lesson = current || next;
            state.sessionTargetId = lesson ? lesson.id : null;
            progressEl.style.width = '0%';
            finishBtn.style.display = 'none';
            extendBtn.style.display = 'none';
            startBtn.style.display = lesson ? '' : 'none';
            if (lesson && current) {
              const remain = Math.max(0, (lesson.end - nowMs) / 60000);
              statusEl.textContent = `🔔 今の授業: ${lesson.title || '授業'}`;
              metaEl.textContent = `予定 ${formatTimeRange(lesson.start, lesson.end)} / 残り ${formatMinutes(remain)}`;
            } else if (lesson) {
              const until = Math.max(0, (lesson.start - nowMs) / 60000);
              statusEl.textContent = `次の授業: ${lesson.title || '授業'}`;
              metaEl.textContent = `開始まで ${formatMinutes(until)} / 予定 ${formatTimeRange(lesson.start, lesson.end)}`;
            } else {
              statusEl.textContent = '次の授業はありません';
              metaEl.textContent = '範囲を指定して授業を追加できます。';
            }
          }

          function startSession(lessonId, opts = {}) {
            const lesson = state.lessons.find(l => l.id === lessonId);
            if (!lesson) return;
            if (session && session.lessonId === lessonId) {
              if (opts.notify !== false) showLessonToast('start', lesson, { auto: !!opts.auto });
              return;
            }
            const nowMs = Date.now();
            const startedAt = opts.alignStart ? lesson.start : nowMs;
            session = {
              lessonId,
              startedAt,
              auto: !!opts.auto
            };
            let touched = false;
            if (!lesson.startedAt) { lesson.startedAt = startedAt; touched = true; }
            if (opts.auto && !lesson.autoStartedAt) { lesson.autoStartedAt = nowMs; touched = true; }
            if (lesson.snoozeUntil) { lesson.snoozeUntil = null; touched = true; }
            if (lesson.endNotifiedAt) { lesson.endNotifiedAt = null; touched = true; }
            if (lesson.done) { lesson.done = false; lesson.completedAt = null; touched = true; }
            if (opts.notify !== false) {
              if (!lesson.startNotifiedAt) { lesson.startNotifiedAt = nowMs; touched = true; }
              showLessonToast('start', lesson, { auto: !!opts.auto });
            }
            if (touched) saveLessons();
            saveSession();
            syncLessonTimer(lesson, { resetSounds: true });
            renderSession();
          }
          function finishSession() {
            if (!session) return;
            const lesson = state.lessons.find(l => l.id === session.lessonId);
            if (lesson) {
              lesson.done = true;
              lesson.completedAt = Date.now();
              saveLessons();
            }
            if (lesson) removeLessonTimer(lesson.id);
            session = null;
            saveSession();
            hideLessonToast();
            render();
          }
          function extendSession(minutes = 5) {
            if (!session) return;
            extendLessonById(session.lessonId, minutes);
          }

          function render() {
            renderTimeline();
            renderDayList();
            renderStats();
            renderSession();
          }

          function bind() {
            $('olAddRange')?.addEventListener('click', addRange);
            $('olAddSelected')?.addEventListener('click', addSelected);
            $('olClearAll')?.addEventListener('click', clearAll);

            $('olRangeWeek')?.addEventListener('click', () => {
              const now = startOfDay(new Date());
              const start = addDays(now, -((now.getDay() + 6) % 7));
              const end = addDays(start, 6);
              if ($('olRangeStart')) $('olRangeStart').value = formatDateValue(start);
              if ($('olRangeEnd')) $('olRangeEnd').value = formatDateValue(end);
            });
            $('olRangeMonth')?.addEventListener('click', () => {
              const now = startOfDay(new Date());
              const start = new Date(now.getFullYear(), now.getMonth(), 1);
              const end = new Date(now.getFullYear(), now.getMonth() + 1, 0);
              if ($('olRangeStart')) $('olRangeStart').value = formatDateValue(start);
              if ($('olRangeEnd')) $('olRangeEnd').value = formatDateValue(end);
            });
            $('olRange30')?.addEventListener('click', () => {
              const now = startOfDay(new Date());
              if ($('olRangeStart')) $('olRangeStart').value = formatDateValue(now);
              if ($('olRangeEnd')) $('olRangeEnd').value = formatDateValue(addDays(now, 29));
            });
            $('olRange90')?.addEventListener('click', () => {
              const now = startOfDay(new Date());
              if ($('olRangeStart')) $('olRangeStart').value = formatDateValue(now);
              if ($('olRangeEnd')) $('olRangeEnd').value = formatDateValue(addDays(now, 89));
            });

            $('olWeekAll')?.addEventListener('click', () => setWeekdays([0, 1, 2, 3, 4, 5, 6]));
            $('olWeekWeekdays')?.addEventListener('click', () => setWeekdays([1, 2, 3, 4, 5]));
            $('olWeekWeekends')?.addEventListener('click', () => setWeekdays([0, 6]));
            $('olWeekdays')?.addEventListener('click', (e) => {
              const btn = e.target.closest('button[data-day]');
              if (!btn) return;
              const day = parseInt(btn.dataset.day || '', 10);
              if (!Number.isFinite(day)) return;
              if (state.weekdays.has(day)) state.weekdays.delete(day);
              else state.weekdays.add(day);
              updateWeekdayButtons();
              scheduleSave();
            });

            $('olDurationQuick')?.addEventListener('click', (e) => {
              const btn = e.target.closest('button[data-duration]');
              if (!btn) return;
              const dur = parseInt(btn.dataset.duration || '', 10);
              if (!Number.isFinite(dur)) return;
              if ($('olDuration')) $('olDuration').value = String(dur);
              syncEndFromDuration();
              updateClockUI();
            });

            $('olStartTime')?.addEventListener('input', syncEndFromDuration);
            $('olEndTime')?.addEventListener('input', syncDurationFromTimes);
            $('olDuration')?.addEventListener('input', syncEndFromDuration);
            $('olStartTime')?.addEventListener('input', updateClockUI);
            $('olEndTime')?.addEventListener('input', updateClockUI);
            $('olDuration')?.addEventListener('input', updateClockUI);
            initClockPanel();
            const olTab = document.querySelector('#plannerApp .tab[data-tab="original-lesson"]');
            if (olTab && !olTab.__clockNowBound) {
              olTab.__clockNowBound = true;
              olTab.addEventListener('click', () => {
                if (!olTab.classList.contains('active')) setClockToNow();
              });
            }
            initEditOverlay();

            $('olFilter')?.addEventListener('change', (e) => {
              state.filter = e.target.value || 'all';
              scheduleSave();
              render();
            });
            $('olViewStart')?.addEventListener('change', () => { state.hScrollLeft = null; render(); });
            $('olViewEnd')?.addEventListener('change', () => { state.hScrollLeft = null; render(); });
            $('olViewSync')?.addEventListener('click', () => {
              const rs = parseDateValue($('olRangeStart')?.value || '');
              const re = parseDateValue($('olRangeEnd')?.value || '');
              if (rs && re) {
                if ($('olViewStart')) $('olViewStart').value = formatDateValue(rs);
                if ($('olViewEnd')) $('olViewEnd').value = formatDateValue(re);
                state.hScrollLeft = null;
                render();
              }
            });

            const shiftView = (dir) => {
              const vs = parseDateValue($('olViewStart')?.value || '');
              const ve = parseDateValue($('olViewEnd')?.value || '');
              if (!vs || !ve) return;
              const days = Math.floor((ve.getTime() - vs.getTime()) / DAY_MS) + 1;
              const newStart = addDays(vs, dir * days);
              const newEnd = addDays(ve, dir * days);
              if ($('olViewStart')) $('olViewStart').value = formatDateValue(newStart);
              if ($('olViewEnd')) $('olViewEnd').value = formatDateValue(newEnd);
              state.hScrollLeft = null;
              render();
            };
            $('olPrevRange')?.addEventListener('click', () => shiftView(-1));
            $('olNextRange')?.addEventListener('click', () => shiftView(1));
            $('olToday')?.addEventListener('click', () => {
              const today = startOfDay(new Date());
              state.selectedDate = today;
              const vs = parseDateValue($('olViewStart')?.value || '');
              const ve = parseDateValue($('olViewEnd')?.value || '');
              if (vs && ve && (today < vs || today > ve)) {
                const days = Math.floor((ve.getTime() - vs.getTime()) / DAY_MS) + 1;
                const newStart = addDays(today, -Math.floor(days / 3));
                const newEnd = addDays(newStart, days - 1);
                if ($('olViewStart')) $('olViewStart').value = formatDateValue(newStart);
                if ($('olViewEnd')) $('olViewEnd').value = formatDateValue(newEnd);
                state.hScrollLeft = null;
              }
              scheduleSave();
              render();
            });

            $('olSessionStart')?.addEventListener('click', () => {
              const targetId = state.sessionTargetId;
              if (targetId) startSession(targetId);
            });
            $('olSessionFinish')?.addEventListener('click', () => finishSession());
            $('olSessionExtend')?.addEventListener('click', () => extendSession(5));

            $('olCopyDay')?.addEventListener('click', () => {
              const source = state.selectedDate || startOfDay(new Date());
              const target = getCopyTargetDate();
              if (!target) { toast('コピー先の日付を選択してください', 'info'); return; }
              const added = copyDayToDate(source, target);
              if (added) {
                saveLessons();
                render();
                toast(`授業をコピーしました（${added}件）`, 'ok');
              } else {
                toast('コピーできる授業がありません', 'info');
              }
            });
            $('olCopyTomorrow')?.addEventListener('click', () => {
              const source = state.selectedDate || startOfDay(new Date());
              const target = addDays(source, 1);
              if ($('olCopyTarget')) $('olCopyTarget').value = formatDateValue(target);
              const added = copyDayToDate(source, target);
              if (added) {
                saveLessons();
                render();
                toast(`明日へコピーしました（${added}件）`, 'ok');
              } else {
                toast('コピーできる授業がありません', 'info');
              }
            });
            $('olCopyNextWeek')?.addEventListener('click', () => {
              const source = state.selectedDate || startOfDay(new Date());
              const target = addDays(source, 7);
              if ($('olCopyTarget')) $('olCopyTarget').value = formatDateValue(target);
              const added = copyDayToDate(source, target);
              if (added) {
                saveLessons();
                render();
                toast(`来週へコピーしました（${added}件）`, 'ok');
              } else {
                toast('コピーできる授業がありません', 'info');
              }
            });

            $('olDayList')?.addEventListener('click', (e) => {
              const btn = e.target.closest('[data-action]');
              if (!btn) return;
              const action = btn.dataset.action;
              const id = btn.dataset.id;
              if (!id) return;
              if (action === 'edit') openEdit(id, btn);
              if (action === 'start') startSession(id);
              if (action === 'done') toggleDone(id);
              if (action === 'delete') deleteLesson(id);
              if (action === 'copy') {
                const targetDate = getCopyTargetDate();
                if (!targetDate) { toast('コピー先の日付を選択してください', 'info'); return; }
                const added = copyLessonToDate(id, targetDate);
                if (added) {
                  saveLessons();
                  render();
                  toast('コピーしました', 'ok');
                } else {
                  toast('コピーできませんでした', 'info');
                }
              }
              if (action === 'delete-series') {
                const gid = btn.dataset.group;
                if (gid && confirm('この系列をまとめて削除しますか？')) deleteSeries(gid);
              }
            });
          }

          function init() {
            loadLessons();
            loadSettings();
            loadSession();
            initDefaults();
            bind();
            render();
            scheduleLessonRestoreFromIdb(0);
            if (!restoreBound) {
              restoreBound = true;
              window.addEventListener('settings:restored', handleSettingsRestored);
            }
            try { checkAutoStartAndNotify(); } catch (_) { }
            if (tickTimer) clearInterval(tickTimer);
            tickTimer = setInterval(() => {
              try { checkAutoStartAndNotify(); } catch (_) { }
              try { renderSession(); } catch (_) { }
            }, 1000);
          }

          return { init, render, startSession, getGaugeInfo, getLessonsForDate: getLessonsForDateRaw };
        })();
        window.OriginalLesson = OriginalLesson;

        function initUI() {
          const tabsWrap = plannerRoot?.querySelector('.tabs');
          if (tabsWrap && !tabsWrap.querySelector('.tab-indicator')) {
            const indicator = document.createElement('span');
            indicator.className = 'tab-indicator';
            tabsWrap.appendChild(indicator);
            const moveIndicator = (target) => {
              if (!target) return;
              const width = target.offsetWidth;
              const left = target.offsetLeft;
              indicator.style.width = `${width}px`;
              indicator.style.transform = `translateX(${left}px)`;
            };
            tabsWrap.__moveIndicator = moveIndicator;
            requestAnimationFrame(() => moveIndicator(tabsWrap.querySelector('.tab.active') || tabsWrap.querySelector('.tab')));
            window.addEventListener('resize', () => moveIndicator(tabsWrap.querySelector('.tab.active')));
          }
          // --- Ensure Numberline Style Panel exists before binding events ---
          const rowsMount = document.getElementById('nlRows');
          if (rowsMount && !document.getElementById('nlStylePanel')) {
            const panel = document.createElement('div');
            panel.id = 'nlStylePanel';
            panel.style.display = 'grid';
            panel.style.gridTemplateColumns = 'repeat(3, minmax(0,1fr))';
            panel.style.gap = '8px';
            panel.style.margin = '8px 0 4px 80px';
            panel.style.alignItems = 'center';
            panel.innerHTML = `
        <div style="display:flex;align-items:center;gap:8px;">
          <label style="font-size:12px;opacity:.8;">透明度</label>
          <input id="nlOpacity" type="range" min="0.2" max="1" step="0.05" value="0.8" style="width:140px;">
          <span id="nlOpacityVal" style="font-size:12px;opacity:.8;">0.80</span>
        </div>
        <div style="display:flex;align-items:center;gap:8px;">
          <label style="font-size:12px;opacity:.8;">見た目</label>
          <select id="nlTheme" style="padding:4px 8px;font-size:12px;">
            <option value="glass">ガラス（高品質）</option>
            <option value="metal">メタル</option>
            <option value="solid">ソリッド</option>
            <option value="gradient" selected>グラデーション</option>
            <option value="neon">ネオン</option>
            <option value="outline">アウトライン</option>
          </select>
        </div>
        <div style="display:flex;align-items:center;gap:8px;">
          <label style="font-size:12px;opacity:.8;">形</label>
          <select id="nlShape" style="padding:4px 8px;font-size:12px;">
            <option value="pill">ピル（丸）</option>
            <option value="rect" selected>角</option>
            <option value="underline">アンダーライン</option>
            <option value="bevel">ベベル</option>
          </select>
        </div>
        <div style="display:flex;align-items:center;gap:8px;">
          <label style="font-size:12px;opacity:.8;">バー高さ</label>
          <input id="nlBarHeight" type="range" min="12" max="120" step="2" value="30" style="width:140px;">
          <span id="nlHeightVal" style="font-size:12px;opacity:.8;">30px</span>
        </div>
        <div style="display:flex;align-items:center;gap:8px;">
          <button id="nlFullResetBtn" class="btn small danger" style="padding:4px 8px;font-size:11px;">予定リセット</button>
        </div>
          <span id="nlHeightVal" style="font-size:12px;opacity:.8;">30px</span>
        </div>
        <div style="display:flex;align-items:center;gap:8px;">
          <label style="font-size:12px;opacity:.8;">ゲージデザイン</label>
          <select id="nlGaugeStyle" style="padding:4px 8px;font-size:12px;">
            <option value="standard" selected>通常</option>
            <option value="guide">目安ゲージ風</option>
          </select>
        </div>`;
            rowsMount.parentNode.insertBefore(panel, rowsMount.nextSibling);
          }

          // --- Tick Style Panel (メモリ設定) ---
          if (rowsMount && !document.getElementById('nlTickPanel')) {
            const tp = document.createElement('div');
            tp.id = 'nlTickPanel';
            tp.style.display = 'grid';
            tp.style.gridTemplateColumns = 'repeat(3, minmax(0,1fr))';
            tp.style.gap = '8px';
            tp.style.margin = '2px 0 10px 80px';
            tp.style.alignItems = 'center';
            tp.innerHTML = `
        <div style="display:flex;align-items:center;gap:8px;">
          <label style="font-size:12px;opacity:.8;">細目盛 長さ(%)</label>
          <input id="tickMinorLen" type="range" min="10" max="60" step="2" value="28" style="width:140px;">
          <span id="tickMinorLenVal" style="font-size:12px;opacity:.8;">28%</span>
        </div>
        <div style="display:flex;align-items:center;gap:8px;">
          <label style="font-size:12px;opacity:.8;">細目盛 太さ(px)</label>
          <input id="tickMinorThick" type="range" min="1" max="6" step="1" value="1" style="width:140px;">
          <span id="tickMinorThickVal" style="font-size:12px;opacity:.8;">1px</span>
        </div>
        <div style="display:flex;align-items:center;gap:8px;">
          <label style="font-size:12px;opacity:.8;">細目盛 色</label>
          <input id="tickMinorColor" type="color" value="#9fb5c9" style="width:44px;height:26px;padding:0;border:none;">
        </div>
        <div style="display:flex;align-items:center;gap:8px;">
          <label style="font-size:12px;opacity:.8;">太目盛 長さ(%)</label>
          <input id="tickMajorLen" type="range" min="20" max="90" step="2" value="40" style="width:140px;">
          <span id="tickMajorLenVal" style="font-size:12px;opacity:.8;">40%</span>
        </div>
        <div style="display:flex;align-items:center;gap:8px;">
          <label style="font-size:12px;opacity:.8;">太目盛 太さ(px)</label>
          <input id="tickMajorThick" type="range" min="2" max="10" step="1" value="3" style="width:140px;">
          <span id="tickMajorThickVal" style="font-size:12px;opacity:.8;">3px</span>
        </div>
        <div style="display:flex;align-items:center;gap:8px;">
          <label style="font-size:12px;opacity:.8;">太目盛 色</label>
          <input id="tickMajorColor" type="color" value="#285078" style="width:44px;height:26px;padding:0;border:none;">
        </div>
        <div style="display:flex;align-items:center;gap:8px;">
          <label style="font-size:12px;opacity:.8;">グロー(光)</label>
          <input id="tickGlow" type="range" min="0" max="20" step="1" value="6" style="width:140px;">
          <span id="tickGlowVal" style="font-size:12px;opacity:.8;">6</span>
        </div>
        <div style="display:flex;align-items:center;gap:8px;">
          <label style="font-size:12px;opacity:.8;">影(シャドウ)</label>
          <input id="tickShadow" type="range" min="0" max="20" step="1" value="6" style="width:140px;">
          <span id="tickShadowVal" style="font-size:12px;opacity:.8;">6</span>
        </div>
        <div style="display:flex;align-items:center;gap:8px;">
          <label style="font-size:12px;opacity:.8;">形</label>
          <select id="tickShape" style="padding:4px 8px;font-size:12px;">
            <option value="line">ライン</option>
            <option value="rounded">丸端</option>
            <option value="diamond">ダイヤ</option>
            <option value="dot">ドット</option>
          </select>
        </div>
      `;
            rowsMount.parentNode.insertBefore(tp, rowsMount.nextSibling);
          }
          // テーマ/モード変更で再描画
          if ($('theme')) $('theme').onchange = e => {
            if (window.__setPlannerTheme) __setPlannerTheme(e.target.value); drawPlanner(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
            try { scheduleStudyWatchdog(); } catch (e) { }
          };
          // set body class on load if theme preselected
          if ($('theme') && $('theme').value) { if (window.__setPlannerTheme) __setPlannerTheme($('theme').value); }
          if ($('mode')) $('mode').onchange = () => drawPlanner(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
          try { scheduleStudyWatchdog(); } catch (e) { }

          // New: planner-specific appearance bindings
          if ($('style')) $('style').onchange = () => drawPlanner(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
          try { scheduleStudyWatchdog(); } catch (e) { }

          if ($('shape')) $('shape').onchange = () => drawPlanner(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
          try { scheduleStudyWatchdog(); } catch (e) { }

          if ($('motion')) $('motion').onchange = () => drawPlanner(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
          try { scheduleStudyWatchdog(); } catch (e) { }

          if ($('clockDesign')) $('clockDesign').onchange = () => drawPlanner(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
          try { scheduleStudyWatchdog(); } catch (e) { }


          // 既存「追加」ボタンをNLStoreに接続
          if ($('add')) $('add').onclick = addEventFromPlannerInputs;
          if ($('quickBreak5')) $('quickBreak5').onclick = () => addQuickBlock(5, 'break');
          if ($('quickBreak15')) $('quickBreak15').onclick = () => addQuickBlock(15, 'break');
          if ($('quickLesson25')) $('quickLesson25').onclick = () => addQuickBlock(25, 'lesson');

          // 予定一覧表示
          renderList();
          try { scheduleStudyWatchdog(); } catch (e) { }

          // 勉強管理を有効化（自動延長の前提）
          try {
            StudyMgr.active = true; StudyMgr.pageIds = newIds; StudyMgr.delay = {}; StudyMgr.save && StudyMgr.save(); StudyUI.update && StudyUI.update(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
            try { scheduleStudyWatchdog(); } catch (e) { }
          } catch (e) { }


          // 数直線タブを開いたら再構築・同期
          (plannerRoot?.querySelectorAll('.tab') || []).forEach(t => {
            t.onclick = () => {
              (plannerRoot?.querySelectorAll('.tab') || []).forEach(x => x.classList.remove('active'));
              (plannerRoot?.querySelectorAll('.tab-content') || []).forEach(x => x.classList.remove('active'));
              t.classList.add('active');
              const panel = plannerRoot?.querySelector(`[data-content="${t.dataset.tab}"]`);
              if (panel) panel.classList.add('active');
              if (tabsWrap && typeof tabsWrap.__moveIndicator === 'function') {
                tabsWrap.__moveIndicator(t);
              }
              if (t.dataset.tab === 'numberline') {
                setBarStyleFromUI(); setTickStyleFromUI();
                nlRebuildAll(); renderList(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
                try { scheduleStudyWatchdog(); } catch (e) { }

                nlStartTimers();
              }
              if (t.dataset.tab === 'planner') {
                drawPlanner(); renderList(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
                try { scheduleStudyWatchdog(); } catch (e) { }

              }
              if (t.dataset.tab === 'study') {
                updateStudyStats();
              }
              if (t.dataset.tab === 'todo') {
                try { TodoUI.render(); } catch (_) { }
              }
              if (t.dataset.tab === 'calendar') {
                try { PlannerCalendar.refresh(); } catch (_) { }
              }
              if (t.dataset.tab === 'original-lesson') {
                try { OriginalLesson && OriginalLesson.render && OriginalLesson.render(); } catch (_) { }
              }
            };
          });

          // 数直線から追加
          if ($('nlAdd')) $('nlAdd').onclick = nlAddFromInputs;
          if ($('nlSync')) $('nlSync').onclick = () => {
            setBarStyleFromUI(); nlRebuildAll(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
            try { scheduleStudyWatchdog(); } catch (e) { }
          };
          const nlStyleControls = ['nlOpacity', 'nlTheme', 'nlShape', 'nlBarHeight', 'nlGaugeStyle']
            .map(id => document.getElementById(id))
            .filter(Boolean);
          nlStyleControls.forEach(ctrl => {
            const evt = ctrl.tagName === 'SELECT' ? 'change' : 'input';
            ctrl.addEventListener(evt, () => {
              setBarStyleFromUI();
              nlRebuildAll(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
              try { scheduleStudyWatchdog(); } catch (e) { }
            });
          });
          const tmIds = ['tickMinorLen', 'tickMinorThick', 'tickMinorColor', 'tickMajorLen', 'tickMajorThick', 'tickMajorColor', 'tickGlow', 'tickShadow', 'tickShape'];
          tmIds.forEach(id => {
            const el = document.getElementById(id); if (el) {
              el.oninput = () => {
                setTickStyleFromUI(); applyTickStyleAll();

                // === Responsive: keep bars & hands aligned on resize ===
                (function () {
                  const root = document.getElementById('nlRows');
                  if (!root || typeof ResizeObserver === 'undefined') return;
                  const ro = new ResizeObserver(() => {
                    const nowD = (window.__getNow ? window.__getNow() : (window.__getNow ? window.__getNow() : new Date()));
                    document.querySelectorAll('.nl-row').forEach(row => {
                      // re-render bars
                      nlRenderBarsForHour(row);
                      // update hands if current
                      const isCurrent = row.classList.contains('current');
                      const sHand = row.querySelector('.nl-hand.s');
                      const mHand = row.querySelector('.nl-hand.m');
                      if (isCurrent) {
                        if (sHand) sHand.style.left = (nowD.getSeconds() / 60 * 100) + '%';
                        if (mHand) mHand.style.left = (nowD.getMinutes() / 60 * 100) + '%';
                      }
                    });
                    nlUpdateETA && nlUpdateETA();
                  });
                  ro.observe(root);
                })();


                // === ETA seconds toggle ===
                const NL_SEC_KEY = "nl_eta_show_seconds";
                function nlLoadShowSeconds() { try { return localStorage.getItem(NL_SEC_KEY) === '1'; } catch (e) { return false; } }
                function nlSaveShowSeconds(v) { try { localStorage.setItem(NL_SEC_KEY, v ? '1' : '0'); } catch (e) { } }
                (function () {
                  const cb = document.getElementById('nlShowSeconds');
                  if (cb) { cb.checked = nlLoadShowSeconds(); cb.onchange = () => nlSaveShowSeconds(cb.checked); }
                })();


                // ===== Fullscreen handling =====
                function nlEnterFullscreen() {
                  const cont = document.createElement('div'); cont.className = 'nl-fullscreen'; cont.id = 'nlFS';
                  const close = document.createElement('button'); close.className = 'nl-fs-close'; close.textContent = '閉じる';
                  close.onclick = () => {
                    const fs = document.getElementById('nlFS'); if (fs) fs.remove(); nlRebuildAll(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
                    try { scheduleStudyWatchdog(); } catch (e) { }
                  };
                  cont.appendChild(close);
                  document.body.appendChild(cont);
                  // Build a fresh current-hour row inside fullscreen
                  const nowD = (window.__getNow ? window.__getNow() : (window.__getNow ? window.__getNow() : new Date()));
                  const base = new Date(nowD.getFullYear(), nowD.getMonth(), nowD.getDate(), nowD.getHours(), 0, 0, 0);
                  const row = nlBuildRow(base, true);
                  cont.appendChild(row);
                }
                (function () { const btn = document.getElementById('nlFullscreenBtn'); if (btn) btn.onclick = nlEnterFullscreen; })();
              };
            }
          });
          setBarStyleFromUI();

          // 勉強
          if ($('studyGenerateCount')) $('studyGenerateCount').onclick = () => generateStudy('count');
          if ($('studyGenerateRange')) $('studyGenerateRange').onclick = () => generateStudy('range');
          try { initPlannerDirectMode(); } catch (e) { }
          try { initNlDirectMode(); } catch (e) { }
          try { initPlannerOpacityControl(); } catch (e) { }
          try { initPlannerHeightControl(); } catch (e) { }
          try { initPlannerGaugeStyleControl(); } catch (e) { }
          try { initPomodoroUI(); } catch (e) { }
          if ($('studyForceEnd')) $('studyForceEnd').onclick = () => StudyMgr && StudyMgr.forceEnd && StudyMgr.forceEnd();
          if ($('pageCompleteBtn')) $('pageCompleteBtn').onclick = () => {
            handlePlannerCompleteClick();
          };

          // エクスポート/インポート/全削除は NLStore に接続
          if ($('export')) $('export').onclick = () => {
            const blob = new Blob([JSON.stringify(NLStore.events, null, 2)], { type: 'application/json' });
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'nl_events.json'; a.click();
          };
          if ($('import')) $('import').onclick = () => $('file').click();
          if ($('file')) $('file').onchange = (e) => {
            const f = e.target.files[0]; if (!f) return;
            const r = new FileReader();
            r.onload = () => {
              try {
                const d = JSON.parse(r.result);
                if (Array.isArray(d)) {
                  NLStore.events = d; NLStore.save();
                  renderList();
                  try { scheduleStudyWatchdog(); } catch (e) { }
                  drawPlanner(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
                  try { scheduleStudyWatchdog(); } catch (e) { }
                  nlRebuildAll(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
                  try { scheduleStudyWatchdog(); } catch (e) { }

                }
              } catch (err) { alert('読込失敗'); }
            };
            r.readAsText(f);
          };
          if ($('clear')) $('clear').onclick = () => {
            if (confirm('全ての予定を削除しますか？')) {
              NLStore.clear(); renderList();
              try { scheduleStudyWatchdog(); } catch (e) { }
              drawPlanner(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
              try { scheduleStudyWatchdog(); } catch (e) { }
              nlRebuildAll(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
              try { scheduleStudyWatchdog(); } catch (e) { }

            }
          };
        }


        // === Theme binding (includes horror, upgraded) ===
        (function () {
          const sel = document.getElementById('theme');
          const root = document.documentElement;
          function applyThemeClass(v) {
            root.classList.forEach(c => { if (c.startsWith('theme-')) root.classList.remove(c); });
            if (v && v.startsWith('theme-')) root.classList.add(v);
            const wrap = document.querySelector('.clock-wrap');
            if (!wrap) return;
            // clear old
            wrap.querySelectorAll('.h-aura,.h-fog,.h-vignette,.h-scan,.bleed,.pulse').forEach(n => n.remove());
            if (v === 'theme-horror') {
              const aura = document.createElement('div'); aura.className = 'h-aura'; wrap.appendChild(aura);
              const fog1 = document.createElement('div'); fog1.className = 'h-fog f1'; wrap.appendChild(fog1);
              const fog2 = document.createElement('div'); fog2.className = 'h-fog f2'; wrap.appendChild(fog2);
              const vig = document.createElement('div'); vig.className = 'h-vignette'; wrap.appendChild(vig);
              const scan = document.createElement('div'); scan.className = 'h-scan'; wrap.appendChild(scan);
            }
          }
          if (sel) {
            applyThemeClass(sel.value);
            sel.addEventListener('change', () => applyThemeClass(sel.value));
          }
        })();

        // === Planner ETA (same design as numberline) ===
        const PL_SEC_KEY = "pl_eta_show_seconds";
        function plLoadShowSeconds() { try { return localStorage.getItem(PL_SEC_KEY) === '1'; } catch (e) { return false; } }
        function plSaveShowSeconds(v) { try { localStorage.setItem(PL_SEC_KEY, v ? '1' : '0'); } catch (e) { } }
        (function () {
          const cb = document.getElementById('plShowSeconds');
          if (cb) { cb.checked = plLoadShowSeconds(); cb.onchange = () => plSaveShowSeconds(cb.checked); }
        })();
        function plUpdateETA(secondAligned) {
          const now = secondAligned ? (Date.now() - (Date.now() % 1000)) : Date.now();
          const etaEl = document.getElementById('plEta'); if (!etaEl) return;
          const showSec = plLoadShowSeconds();
          const ev = (NLStore.events || []).find(ev => now >= ev.start && now < ev.end);
          if (!ev) {
            etaEl.style.display = 'none';
            if (typeof window.__setInfoVisibility === 'function') window.__setInfoVisibility();
            return;
          }
          const remainMs = Math.max(0, ev.end - now);
          etaEl.style.display = 'block';
          const title = (ev.title || '予定').toString();
          if (showSec) {
            const totalSec = Math.max(0, Math.floor(remainMs / 1000));
            const mm = Math.floor(totalSec / 60);
            const ss = totalSec % 60;
            const ssPad = String(ss).padStart(2, '0');
            etaEl.textContent = mm > 0 ? `${title} (${mm}分${ssPad}秒)` : `${title} (${ssPad}秒)`;
          } else {
            const mins = Math.max(0, Math.ceil(remainMs / 60000));
            etaEl.textContent = `${title} (${mins}分)`;
          }
          if (typeof window.__setInfoVisibility === 'function') window.__setInfoVisibility(true);
        }

        // ===== 予定終了1分前サウンド監視 =====
        const DeadlineSoonWatcher = (function () {
          const MINUTES = Array.from({ length: 20 }, (_, i) => i + 1);
          const state = new Map();
          const STALE_KEEP_MS = 30 * 60 * 1000; // keep past state for 30分 to cover再延長
          function cleanup(activeIds, existingIds, nowMs) {
            state.forEach((st, id) => {
              if (activeIds.has(id)) return;
              const exists = existingIds.has(id);
              const lastSeen = st.lastSeen || 0;
              if (!exists || (nowMs - lastSeen) > STALE_KEEP_MS) {
                state.delete(id);
              }
            });
          }
          function ensureState(ev, nowMs) {
            let st = state.get(ev.id);
            if (!st) {
              st = { end: ev.end, fired: {}, lastSeen: nowMs || Date.now() };
              state.set(ev.id, st);
            } else if (st.end !== ev.end) {
              // keep past firing flags so auto-extensions don't retrigger countdown sounds immediately
              st.end = ev.end;
            }
            st.lastSeen = nowMs || Date.now();
            return st;
          }
          function triggerForMinute(min) {
            const key = min === 1 ? 'deadline.soon' : `deadline.soon.m${String(min).padStart(2, '0')}`;
            try {
              if (window.SoundMgr && SoundMgr.trigger) {
                SoundMgr.trigger(key);
              }
            } catch (_) { }
          }
          function tick(nowMs) {
            if (!NLStore || !Array.isArray(NLStore.events)) return;
            const events = NLStore.events.filter(Boolean);
            const activeIds = new Set();
            const existingIds = new Set(events.map(ev => ev.id));
            events.forEach(ev => {
              if (!ev) return;
              if (nowMs < ev.start || nowMs >= ev.end) return;
              activeIds.add(ev.id);
              const st = ensureState(ev, nowMs);
              st.end = ev.end;
              const remain = ev.end - nowMs;
              MINUTES.forEach(min => {
                const upper = min * 60000;
                const lower = (min - 1) * 60000;
                const flag = st.fired[min] === true;
                if (remain <= upper && remain > lower) {
                  if (!flag) {
                    st.fired[min] = true;
                    triggerForMinute(min);
                  }
                }
              });
            });
            cleanup(activeIds, existingIds, nowMs);
          }
          return { tick };
        })();

        // ===== 勉強用サウンド監視 =====
        const StudySoundWatcher = (function () {
          const eventState = new Map();
          let lastEventId = null;

          function trigger(key) {
            try { window.SoundMgr && SoundMgr.trigger && SoundMgr.trigger(key); } catch (_) { }
          }
          function ensureState(ev) {
            if (!ev) return null;
            let st = eventState.get(ev.id);
            if (!st) {
              st = { mid: false, last5: false, last1: false, done: false, overtime: false, end: ev.end };
              eventState.set(ev.id, st);
            } else if (st.end !== ev.end) {
              st.end = ev.end;
            }
            return st;
          }
          function cleanup(validIds) {
            if (!validIds) {
              eventState.clear();
              return;
            }
            eventState.forEach((_v, id) => {
              if (!validIds.has(id)) { eventState.delete(id); }
            });
          }
          function tick(nowMs) {
            try {
              if (!window.StudyMgr || !StudyMgr.active) {
                lastEventId = null;
                eventState.clear();
                return;
              }
              const ctx = StudyMgr.currentAndNext(nowMs);
              const events = ctx && ctx.events ? ctx.events.filter(Boolean) : [];
              const ev = (ctx && ctx.curIdx >= 0) ? ctx.events[ctx.curIdx] : null;
              const validIds = new Set(events.map(e => e.id));
              if (ev && isBreakEvent(ev)) {
                lastEventId = null;
                cleanup(validIds);
                return;
              }
              if (ev) {
                const st = ensureState(ev);
                if (lastEventId !== ev.id) {
                  trigger('study.session.start');
                  lastEventId = ev.id;
                }
                if (st) {
                  const total = Math.max(1, ev.end - ev.start);
                  const elapsed = Math.max(0, nowMs - ev.start);
                  const remain = ev.end - nowMs;
                  if (!st.mid && elapsed >= total / 2) {
                    st.mid = true; trigger('study.session.mid');
                  }
                  if (!st.last5 && remain <= 5 * 60000 && remain > 0) {
                    st.last5 = true; trigger('study.session.last5');
                  }
                  if (!st.last1 && remain <= 60000 && remain > 0) {
                    st.last1 = true; trigger('study.session.last1');
                  }
                  if (!st.done && nowMs >= ev.end) {
                    st.done = true; trigger('study.session.done');
                  }
                  if (!st.overtime && nowMs >= ev.end + 2 * 60000) {
                    st.overtime = true; trigger('study.session.overtime');
                  }
                }
              } else {
                lastEventId = null;
              }
              cleanup(validIds);
            } catch (_) { }
          }
          function markManualComplete(evId) {
            if (!evId) return;
            let st = eventState.get(evId);
            if (!st) {
              st = { mid: false, last5: false, last1: false, done: false, overtime: false, end: 0 };
              eventState.set(evId, st);
            }
            if (!st.done) {
              st.done = true;
              trigger('study.session.done');
            }
          }
          return { tick, markManualComplete };
        })();
        window.__studySoundWatcher = StudySoundWatcher;
        // ============== メインループ ==============

        // ===== Second-aligned ticker =====
        (function () {
          if (window.__secAlignedTimer) { clearInterval(window.__secAlignedTimer); window.__secAlignedTimer = null; }
          if (window.__secAlignedKick) { clearTimeout(window.__secAlignedKick); window.__secAlignedKick = null; }
          if (window.__secAlignedFallback) { clearInterval(window.__secAlignedFallback); window.__secAlignedFallback = null; }
          let lastPulseSec = null;
          // ===== Study end-time watchdog =====
          window.__studyWatch && clearTimeout(window.__studyWatch);
          window.__studyWatch = null;
          let __studyWatchNext = null;
          function scheduleStudyWatchdog(force) {
            try {
              const cur = now().getTime();
              if (!StudyMgr || !StudyMgr.active) { __studyWatchNext = null; return; }
              const ctx = StudyMgr.currentAndNext(cur);
              if (!ctx || ctx.curIdx < 0) { __studyWatchNext = null; return; }
              const ev = ctx.events[ctx.curIdx];
              if (!ev) { __studyWatchNext = null; return; }
              if (!force && window.__studyWatch && __studyWatchNext === ev.end && __studyWatchNext > cur) { return; }
              if (window.__studyWatch) { clearTimeout(window.__studyWatch); window.__studyWatch = null; }
              const msRaw = Math.max(0, ev.end - cur);
              const scale = Math.max(1, (typeof window.__getTimeScale === 'function' ? window.__getTimeScale() : 1));
              const delay = Math.max(100, Math.min(60000, msRaw / scale));
              __studyWatchNext = ev.end;
              window.__studyWatch = setTimeout(function () {
                try { StudyMgr.autoExtendIfNeeded(now().getTime()); } catch (e) { }
                try { scheduleStudyWatchdog(); } catch (e) { }
              }, delay);
            } catch (e) { }
          }

          // ===== 強制延長＆再構築（ハードガード） =====
          // 仕様: 自動生成した勉強予定が、ページ完了ボタン未押下のまま終了時刻に到達したら
          // 1) 現在ページを +1分延長
          // 2) 後続の勉強予定も +1分ずつスライド
          // 3) それに合わせて全勉強予定を「今」から連続再構築（ズレの蓄積を防止）
          function shiftDelayEntry(evId, delta) {
            try {
              if (!StudyMgr || !StudyMgr.delay || !StudyMgr.delay[evId]) return;
              const ent = StudyMgr.delay[evId];
              if ('baseEnd' in ent && Number.isFinite(ent.baseEnd)) ent.baseEnd += delta;
              if ('next' in ent && ent.next != null && Number.isFinite(ent.next)) ent.next += delta;
            } catch (_) { }
          }
          function __rebuildStudyChainFrom(nowMs) {
            try {
              if (!StudyMgr || !StudyMgr.active) return false;
              const events = StudyMgr.pageIds.map(id => NLStore.events.find(e => e.id === id)).filter(Boolean);
              if (events.length === 0) return false;
              // 連続再配置: 現在時刻から順に、元の各イベントの「分丸めした長さ」を保って詰め直す
              let t = Math.floor(nowMs / 60000) * 60000;
              for (const ev of events) {
                const oldStart = ev.start;
                const durRaw = Math.max(60000, (ev.end - ev.start));
                const dur = Math.max(60000, Math.round(durRaw / 60000) * 60000);
                ev.start = t; ev.end = t + dur; t = ev.end;
                const shift = ev.start - oldStart;
                if (shift !== 0 && ev.id) shiftDelayEntry(ev.id, shift);
              }
              NLStore.save();
              try { drawPlanner(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { } } catch (e) { }
              try { nlRebuildAll(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { } } catch (e) { }
              try { StudyUI.update(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { } } catch (e) { }
              return true;
            } catch (e) { return false; }
          }

          function __forceExtendAndRebuild(nowMs) {
            try {
              if (!StudyMgr || !StudyMgr.active) return;
              // 現在・直前ページを特定（終了に到達したページを優先）
              const ctx = StudyMgr.currentAndNext(nowMs);
              if (!ctx || !ctx.events || ctx.events.length === 0) return;
              let idx = ctx.curIdx;
              let ev = (idx >= 0) ? ctx.events[idx] : null;
              if (!(ev && ev.end <= nowMs)) {
                // 直前に終了したページに切替
                let justEnded = -1, bestEnd = -1;
                for (let i = 0; i < ctx.events.length; i++) {
                  const e = ctx.events[i]; if (!e) continue;
                  if (e.end <= nowMs && e.end > bestEnd) { bestEnd = e.end; justEnded = i; }
                }
                if (justEnded >= 0) { idx = justEnded; ev = ctx.events[idx]; }
              }
              if (!ev) return;
              if (isBreakEvent(ev)) return;
              if (ev.end > nowMs) return; // まだ終わってない

              // 1分延長（現在ページ）
              const shift = 60000;
              if (!StudyMgr.delay) StudyMgr.delay = {};
              var st1 = StudyMgr.delay[ev.id] || { next: null, times: 0 };
              const hadBase = ("baseEnd" in st1);
              if (!hadBase) {
                st1.baseEnd = Math.max(ev.start, ev.end - Math.max(0, st1.times || 0) * 60000);
                st1.baseDurationMs = Math.max(60000, st1.baseEnd - ev.start);
                try { window.SoundMgr && SoundMgr.trigger("study.extend.start"); } catch (e) { }
              } else if (!('baseDurationMs' in st1)) {
                st1.baseDurationMs = Math.max(60000, st1.baseEnd - ev.start);
              }
              st1.times = (st1.times || 0) + 1;
              st1.next = (st1.next == null ? nowMs : st1.next) + shift;
              StudyMgr.delay[ev.id] = st1;
              ev.end += shift; try { window.SoundMgr && SoundMgr.trigger("study.extend.tick"); } catch (e) { } try { window.SoundMgr && SoundMgr.trigger("study.extend.tick"); } catch (e) { }
              for (let i = idx + 1; i < ctx.events.length; i++) {
                const e2 = ctx.events[i]; if (!e2) continue;
                e2.start += shift; e2.end += shift;
                if (e2.id) shiftDelayEntry(e2.id, shift);
              }
              // 今から全体を整列し直す（連続再構築）
              NLStore.save();
              try { markNlDirty && markNlDirty(); } catch (_) { }
              try { drawPlanner(); } catch (e) { }
              try { nlRebuildAll(true); } catch (e) { }
              try { refreshPlannerFlyClock && refreshPlannerFlyClock(true); } catch (_) { }
              try { renderNumberlineFly && renderNumberlineFly(); } catch (_) { }
              try { StudyUI.update(); } catch (e) { }
            } catch (e) { }
          }

          // ===== 延長表示UI =====
          function __fmtNeg(ms) {
            if (ms < 0) ms = 0;
            const s = Math.floor(ms / 1000);
            if (s < 60) return `-${s}秒`;
            const m = Math.floor(s / 60), ss = s % 60;
            if (ss === 0) return `-${m}分`;
            return `-${m}分${ss}秒`;
          }
          function updateDelayUI(nowMs) {
            try {
              const pBadge = document.getElementById('plannerDelayBadge');
              const nBadge = document.getElementById('nlDelayBadge');
              let showText = '';
              if (StudyMgr && StudyMgr.active) {
                const ctx = StudyMgr.currentAndNext(nowMs);
                if (ctx && ctx.events && ctx.events.length > 0) {
                  let idx = ctx.curIdx;
                  let ev = (idx >= 0) ? ctx.events[idx] : null;
                  if (!(ev && StudyMgr.delay && StudyMgr.delay[ev.id] && ('baseEnd' in StudyMgr.delay[ev.id]))) {
                    // 直前終了のページも確認
                    let justEnded = -1, bestEnd = -1;
                    for (let i = 0; i < ctx.events.length; i++) {
                      const e = ctx.events[i]; if (!e) continue;
                      const st = StudyMgr.delay && StudyMgr.delay[e.id];
                      if (st && ('baseEnd' in st) && e.end >= st.baseEnd && nowMs >= st.baseEnd) {
                        if (e.end > bestEnd) { bestEnd = e.end; justEnded = i; }
                      }
                    }
                    if (justEnded >= 0) { ev = ctx.events[justEnded]; }
                  }
                  if (ev && StudyMgr.delay && StudyMgr.delay[ev.id] && ('baseEnd' in StudyMgr.delay[ev.id])) {
                    const base = StudyMgr.delay[ev.id].baseEnd;
                    const dms = nowMs - base;
                    if (dms >= 0) { showText = __fmtNeg(dms); }
                  }
                }
              }
              const show = !!showText;
              if (pBadge) { pBadge.style.display = show ? 'inline' : 'none'; if (show) pBadge.textContent = showText; }
              if (nBadge) { nBadge.style.display = 'none'; nBadge.textContent = ''; }
            } catch (e) { }
          }

          // ===== 延長表示（各予定の残り時間ラベルの右に配置） =====
          function ensureInlineDelaySpans() {
            try {
              const pl = document.getElementById('plEta');
              if (pl && !document.getElementById('plDelayInline')) {
                const sp = document.createElement('span');
                sp.id = 'plDelayInline';
                sp.style.marginLeft = '6px';
                sp.style.fontSize = '14px'; sp.style.fontWeight = '700'; sp.style.opacity = '.95'; sp.style.padding = '2px 6px'; sp.style.borderRadius = '10px'; sp.style.background = 'rgba(193,18,31,.18)'; sp.style.color = 'var(--muted, #fff)'; sp.style.backdropFilter = 'blur(2px)';
                sp.style.display = 'none';
                pl.parentNode && pl.parentNode.insertBefore(sp, pl.nextSibling);
              }
            } catch (e) { }
          }
          function updateDelayInlineUI(nowMs) {
            try { ['plannerDelayBadge', 'nlDelayBadge'].forEach(id => { const el = document.getElementById(id); if (el) el.remove(); }); } catch (e) { }

            try {
              ensureInlineDelaySpans();
              const hasDelay = (ev) => {
                return (StudyMgr && StudyMgr.delay && ev && StudyMgr.delay[ev.id] && ('baseEnd' in StudyMgr.delay[ev.id]));
              };
              const getDelayText = (base) => {
                const d = nowMs - base; if (d < 0) return '';
                const s = Math.floor(d / 1000);
                if (s < 60) return `-${s}秒`;
                const m = Math.floor(s / 60), ss = s % 60;
                return ss === 0 ? `-${m}分` : `-${m}分${ss}秒`;
              };
              const ctx = (StudyMgr && StudyMgr.active) ? StudyMgr.currentAndNext(nowMs) : null;
              let curEv = null;
              if (ctx && ctx.events && ctx.events.length) {
                curEv = (ctx.curIdx >= 0) ? ctx.events[ctx.curIdx] : null;
                if (!(curEv && hasDelay(curEv))) {
                  // try just-ended
                  let je = -1, be = -1;
                  for (let i = 0; i < ctx.events.length; i++) {
                    const e = ctx.events[i]; if (!e) continue;
                    const st = StudyMgr.delay && StudyMgr.delay[e.id];
                    if (st && ('baseEnd' in st) && e.end >= st.baseEnd && nowMs >= st.baseEnd) {
                      if (e.end > be) { be = e.end; je = i; }
                    }
                  }
                  if (je >= 0) { curEv = ctx.events[je]; }
                }
              }
              // Planner inline
              const plEta = document.getElementById('plEta');
              const plBadge = document.getElementById('plDelayInline');
              let showTxt = '';
              if (curEv && hasDelay(curEv)) {
                const base = StudyMgr.delay[curEv.id].baseEnd;
                showTxt = getDelayText(base);
              }
              if (plEta && plBadge) {
                const show = !!showTxt;
                plBadge.style.display = show ? 'inline' : 'none';
                if (show) plBadge.textContent = showTxt;
              }
              // Numberline inline delay display is disabled in the ebook view
              try { document.getElementById('nlDelayInline')?.remove(); } catch (_) { }
            } catch (e) { }
          }

          function normalizeEvent(ev) {
            if (!ev) return null;
            const parseTs = (v) => {
              if (Number.isFinite(v)) return v;
              const n = Number(v);
              if (Number.isFinite(n)) return n;
              if (typeof v === 'string') {
                const d = Date.parse(v);
                if (Number.isFinite(d)) return d;
              }
              return null;
            };
            const s = parseTs(ev.start);
            const e = parseTs(ev.end);
            if (!Number.isFinite(s)) return null;
            let end = Number.isFinite(e) ? e : s + 60000;
            if (end <= s) end = s + 60000;
            return { ...ev, start: s, end: end };
          }
          function ensureStudyDataLoaded() {
            try {
              if (window.NLStore && (!Array.isArray(NLStore.events) || NLStore.events.length === 0)) {
                // Only load if not already initialized
                if (!NLStore._initialized && typeof NLStore.load === 'function') { NLStore.load(); }
                // Remove localStorage fallback - it can restore deleted events
                // IndexedDB is now the primary storage
              }
            } catch (_) { }
            try {
              if (window.StudyMgr && (!Array.isArray(StudyMgr.pageIds) || StudyMgr.pageIds.length === 0) && typeof StudyMgr.load === 'function') {
                StudyMgr.load();
              }
              // 意図的に終了した場合は自動復帰しない
              // StudyMgr.__intentionalEnd フラグをチェック
              if (window.StudyMgr && StudyMgr.__intentionalEnd) {
                // Skip auto-recovery
              } else if (window.StudyMgr && !StudyMgr.active && window.NLStore && Array.isArray(NLStore.events)) {
                // StudyMgrが非アクティブでも、NLStoreに勉強予定があるなら復帰させる
                // ただし、pausedに含まれているものは除外
                const pausedPageKeys = new Set();
                try {
                  const raw = localStorage.getItem('nl_paused_entries');
                  if (raw) {
                    const entries = JSON.parse(raw);
                    if (Array.isArray(entries)) {
                      entries.forEach(entry => {
                        if (entry.events && Array.isArray(entry.events)) {
                          entry.events.forEach(ev => {
                            if (ev.pageKey) pausedPageKeys.add(ev.pageKey);
                          });
                        }
                      });
                    }
                  }
                } catch (_) { }
                const studyIds = NLStore.events.filter(ev => {
                  if (!ev || ev.kind !== 'study') return false;
                  // Exclude paused items
                  if (ev.pageKey && pausedPageKeys.has(ev.pageKey)) return false;
                  return true;
                }).map(ev => ev.id).filter(Boolean);
                if (studyIds.length) {
                  StudyMgr.active = true;
                  StudyMgr.pageIds = studyIds;
                  StudyMgr.save && StudyMgr.save();
                }
              }
            } catch (_) { }
          }
          function findStudyContext(nowMs) {
            const now = nowMs;
            let evs = [];
            ensureStudyDataLoaded();
            let usedList = [];
            // 1) StudyMgr current/nextを信頼
            if (window.StudyMgr && StudyMgr.active) {
              try {
                const ctx = StudyMgr.currentAndNext(now);
                if (ctx && ctx.events) {
                  const norm = ctx.events.map(normalizeEvent).filter(Boolean);
                  const cur = (ctx.curIdx != null && ctx.curIdx >= 0) ? norm[ctx.curIdx] : null;
                  const next = (ctx.nextIdx != null) ? norm[ctx.nextIdx] : null;
                  evs = norm;
                  if (cur || next) return { current: cur, upcoming: next, list: norm, all: norm };
                }
              } catch (_) { }
            }
            // 2) NLStoreのstudy
            if (window.NLStore && Array.isArray(NLStore.events)) {
              evs = NLStore.events.map(normalizeEvent).filter(ev => ev && ev.kind === 'study');
            }
            evs = evs.sort((a, b) => a.start - b.start);
            usedList = evs.slice();
            const current = evs.find(ev => ev.start <= now && now < ev.end) || null;
            const upcoming = evs.find(ev => ev.start > now) || null;
            if (current || upcoming) return { current, upcoming, list: evs, all: evs };
            // 3) fallback: any event
            const all = (window.NLStore && Array.isArray(NLStore.events)) ? NLStore.events.map(normalizeEvent).filter(Boolean).sort((a, b) => a.start - b.start) : [];
            const anyCur = all.find(ev => ev.start <= now && now < ev.end) || null;
            const anyUpcoming = all.find(ev => ev.start > now) || null;
            return { current: anyCur, upcoming: anyUpcoming, list: usedList, all: all };
          }
          function getCurrentStudyEvent(nowMs) {
            const ctx = findStudyContext(nowMs);
            return ctx.current || ctx.upcoming || null;
          }
          function formatStudyRemain(ms) {
            ms = Math.max(0, ms | 0);
            const totalSec = Math.ceil(ms / 1000);
            const m = Math.floor(totalSec / 60);
            const s = totalSec % 60;
            return `${m}:${String(s).padStart(2, '0')}`;
          }
          function studyNowMs() { return (typeof window.__getNow === 'function') ? window.__getNow().getTime() : Date.now(); }

          // Viewer背景色（設定タブから変更可能）
          const STAGE_BG_KEY = 'reader-stage-bg-base';
          const STAGE_BG_PRESET_KEY = 'reader-stage-bg-preset';
          const STAGE_BG_DEFAULT = '#f6f7fb';
          const STAGE_BG_PRESETS = {
            default: { name: 'やわらかホワイト', base: '#f6f7fb' },
            'ui-same': { name: 'UI同', base: '#0f1522', flat: true },
            ui: { name: 'UIと同系（ダーク）', base: '#0f1522' },
            latte: { name: 'ラテ', base: '#f5f0e6' },
            mint: { name: 'ミント', base: '#e8f7f1' },
            dusk: { name: 'スモーク', base: '#dfe3eb' },
            custom: { name: 'カスタム', base: null }
          };
          function reapplyStageToDom() {
            let preset = 'default';
            try { preset = localStorage.getItem(STAGE_BG_PRESET_KEY) || 'default'; } catch (_) { }
            const entry = STAGE_BG_PRESETS[preset];
            const base = entry?.base || window.stageBgBase || STAGE_BG_DEFAULT;
            applyStageBackground(base, false, { flat: !!entry?.flat });
          }
          function stageParseHex(v) {
            if (!v) return STAGE_BG_DEFAULT;
            const m = String(v).trim().match(/^#?([0-9a-fA-F]{6})$/);
            if (!m) return STAGE_BG_DEFAULT;
            return '#' + m[1].toLowerCase();
          }
          function stageHexToRgb(hex) {
            hex = stageParseHex(hex);
            return { r: parseInt(hex.substr(1, 2), 16), g: parseInt(hex.substr(3, 2), 16), b: parseInt(hex.substr(5, 2), 16) };
          }
          function stageRgbToHex({ r, g, b }) {
            const toHex = (n) => Math.max(0, Math.min(255, Math.round(n))).toString(16).padStart(2, '0');
            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
          }
          function stageMix(rgb, pct) {
            // pct>0 → white方向にブレンド, pct<0 → 黒方向
            const mix = (v) => pct >= 0 ? v + (255 - v) * pct : v * (1 + pct);
            return { r: mix(rgb.r), g: mix(rgb.g), b: mix(rgb.b) };
          }
          // expose for settings wiring outside this module
          Object.assign(window, {
            STAGE_BG_KEY,
            STAGE_BG_PRESET_KEY,
            STAGE_BG_DEFAULT,
            STAGE_BG_PRESETS,
            stageParseHex,
            applyStageBackground,
            applyStagePreset,
            reapplyStageToDom
          });
          function paintStageDom({ base, bg1, bg2, bg3, host1, host2, tintSoft, tintGlow, tintLine, flat }) {
            const gradStage = `
      radial-gradient(120% 95% at 50% 20%, ${bg1} 0%, ${bg2} 55%, ${bg3} 100%),
      radial-gradient(85% 70% at 20% 25%, ${tintSoft} 0%, rgba(0,0,0,0) 65%),
      radial-gradient(80% 65% at 80% 22%, ${tintGlow} 0%, rgba(0,0,0,0) 70%),
      linear-gradient(180deg, rgba(255,255,255,.6) 0%, rgba(240,242,248,.35) 42%, rgba(228,231,238,.25) 72%, rgba(235,238,244,.6) 100%),
      radial-gradient(160% 140% at 50% -10%, ${tintLine} 0%, rgba(0,0,0,0) 70%)`.replace(/\s+/g, ' ');
            const gradHost = `radial-gradient(120% 120% at 50% 15%, ${bg1} 0%, ${host1} 60%, ${host2} 100%)`;
            document.querySelectorAll('.stage-host').forEach(el => {
              el.style.backgroundColor = base;
              el.style.backgroundImage = flat ? 'none' : gradHost;
            });
            document.querySelectorAll('.stage').forEach(el => {
              el.style.backgroundColor = base;
              el.style.backgroundImage = flat ? 'none' : gradStage;
            });
          }
          function applyStageBackground(baseHex, persist = true, opts = {}) {
            const flat = !!opts.flat;
            const base = stageParseHex(baseHex || STAGE_BG_DEFAULT);
            const rgb = stageHexToRgb(base);
            const bg1 = flat ? base : stageRgbToHex(stageMix(rgb, 0.25));
            const bg2 = flat ? base : stageRgbToHex(stageMix(rgb, 0.15));
            const bg3 = flat ? base : stageRgbToHex(stageMix(rgb, 0.05));
            const host1 = flat ? base : stageRgbToHex(stageMix(rgb, 0.12));
            const host2 = flat ? base : stageRgbToHex(stageMix(rgb, 0.20));
            const tintSoft = flat ? 'rgba(0,0,0,0)' : `rgba(${rgb.r},${rgb.g},${rgb.b},0.16)`;
            const tintGlow = flat ? 'rgba(0,0,0,0)' : `rgba(${rgb.r},${rgb.g},${rgb.b},0.10)`;
            const tintLine = flat ? 'rgba(0,0,0,0)' : `rgba(${rgb.r},${rgb.g},${rgb.b},0.14)`;
            const root = document.documentElement;
            root.style.setProperty('--stage-base', base);
            root.style.setProperty('--stage-bg1', bg1);
            root.style.setProperty('--stage-bg2', bg2);
            root.style.setProperty('--stage-bg3', bg3);
            root.style.setProperty('--stage-host1', host1);
            root.style.setProperty('--stage-host2', host2);
            root.style.setProperty('--stage-tint-soft', tintSoft);
            root.style.setProperty('--stage-tint-glow', tintGlow);
            root.style.setProperty('--stage-tint-line', tintLine);
            root.style.setProperty('--stage-border', stageRgbToHex(stageMix(rgb, 0.22)));
            paintStageDom({ base, bg1, bg2, bg3, host1, host2, tintSoft, tintGlow, tintLine, flat });
            window.stageBgBase = base;
            if (persist) {
              try { localStorage.setItem(STAGE_BG_KEY, base); localStorage.setItem(STAGE_BG_PRESET_KEY, 'custom'); } catch (_) { }
            }
          }
          function applyStagePreset(preset, persist = true) {
            const entry = STAGE_BG_PRESETS[preset] || STAGE_BG_PRESETS.default;
            const base = entry.base || STAGE_BG_DEFAULT;
            applyStageBackground(base, persist, { flat: !!entry.flat });
            if (persist) {
              try { localStorage.setItem(STAGE_BG_PRESET_KEY, preset); if (entry.base) localStorage.setItem(STAGE_BG_KEY, entry.base); } catch (_) { }
            }
          }
          function loadStageBackground() {
            let preset = 'default', savedBase = null;
            try {
              preset = localStorage.getItem(STAGE_BG_PRESET_KEY) || 'default';
              savedBase = localStorage.getItem(STAGE_BG_KEY);
            } catch (_) { }
            const entry = STAGE_BG_PRESETS[preset];
            if (entry && entry.base) {
              applyStagePreset(preset, false);
            } else {
              applyStageBackground(savedBase || STAGE_BG_DEFAULT, false, { flat: !!entry?.flat });
            }
          }
          try { loadStageBackground(); } catch (_) { try { applyStageBackground(STAGE_BG_DEFAULT, false); } catch (__) { } }
          window.__applyStagePreset = applyStagePreset;
          window.__applyStageBackground = applyStageBackground;
          window.__reapplyStageToDom = reapplyStageToDom;

          // HPバー設定（他スクリプト依存がなくても動くようにローカルフォールバック付き）
          var HP_BAR_ENABLED_KEY = 'reader-hpbar-enabled';
          var HP_BAR_STEP_KEY = 'reader-hpbar-step-ms';
          var HP_BAR_STEP_CHOICES = [60000, 30000, 10000, 5000, 1000];
          var HP_BAR_STYLE_KEY = 'reader-hpbar-style'; // legacy
          var HP_BAR_DESIGN_KEY = 'reader-hpbar-design';
          var HP_BAR_SIZE_KEY = 'reader-hpbar-size';
          var HP_BAR_SHAKE_KEY = 'reader-hpbar-shake';
          var HP_BAR_ALIGN_KEY = 'reader-hpbar-align';
          var HP_BAR_DESIGN_OPTIONS = ['standard', 'glass', 'translucent', 'muted'];
          var HP_BAR_SIZE_OPTIONS = ['normal', 'short', 'narrow'];
          var HP_BAR_SHAKE_OPTIONS = ['shake-x', 'shake-tilt', 'shake-bounce', 'shake-rumble', 'shake-quake'];
          var HP_BAR_ALIGN_OPTIONS = ['center', 'left', 'right'];
          function clampHpStepMs(v) {
            const n = parseInt(v, 10);
            return HP_BAR_STEP_CHOICES.includes(n) ? n : HP_BAR_STEP_CHOICES[0];
          }
          function hpLoadBool(key, fallback) {
            if (typeof loadStoredBool === 'function') return loadStoredBool(key, fallback);
            try {
              const raw = localStorage.getItem(key);
              if (raw === null) return fallback;
              return raw === '1';
            } catch (_) { return fallback; }
          }
          function hpLoadNumber(key) {
            if (typeof loadStoredNumber === 'function') return loadStoredNumber(key);
            try {
              const raw = localStorage.getItem(key);
              if (raw === null) return null;
              const n = parseInt(raw, 10);
              return Number.isNaN(n) ? null : n;
            } catch (_) { return null; }
          }
          function hpSaveBool(key, v) {
            if (typeof saveStoredBool === 'function') return saveStoredBool(key, v);
            try { localStorage.setItem(key, v ? '1' : '0'); } catch (_) { }
          }
          function hpSaveNumber(key, v) {
            if (typeof saveStoredNumber === 'function') return saveStoredNumber(key, v);
            try { localStorage.setItem(key, String(v)); } catch (_) { }
          }
          function hpLoadString(key, fallback) {
            try {
              const raw = localStorage.getItem(key);
              if (raw === null || raw === undefined) return fallback;
              return String(raw);
            } catch (_) { return fallback; }
          }
          function hpSaveString(key, v) {
            try { localStorage.setItem(key, String(v)); } catch (_) { }
          }
          window.clampHpStepMs = clampHpStepMs;
          window.hpLoadBool = hpLoadBool;
          window.hpLoadNumber = hpLoadNumber;
          window.hpSaveBool = hpSaveBool;
          window.hpSaveNumber = hpSaveNumber;
          window.hpLoadString = hpLoadString;
          window.hpSaveString = hpSaveString;
          function setHpBarEnabled(v) {
            hpBarEnabled = !!v;
            window.hpBarEnabled = hpBarEnabled;
          }
          function setHpBarStepMs(v) {
            hpBarStepMs = clampHpStepMs(v);
            window.hpBarStepMs = hpBarStepMs;
          }
          window.setHpBarEnabled = setHpBarEnabled;
          window.setHpBarStepMs = setHpBarStepMs;
          // migration from legacy style key
          const legacyStyle = hpLoadString(HP_BAR_STYLE_KEY, null);
          let hpBarEnabled = hpLoadBool(HP_BAR_ENABLED_KEY, true);
          let hpBarStepMs = clampHpStepMs(hpLoadNumber(HP_BAR_STEP_KEY) ?? HP_BAR_STEP_CHOICES[0]);
          let hpBarDesign = hpLoadString(HP_BAR_DESIGN_KEY, legacyStyle || 'standard');
          let hpBarSize = hpLoadString(HP_BAR_SIZE_KEY, (legacyStyle === 'mini') ? 'short' : 'normal');
          let hpBarShake = hpLoadString(HP_BAR_SHAKE_KEY, 'shake-x');
          let hpBarAlign = hpLoadString(HP_BAR_ALIGN_KEY, 'center');
          // sanitize
          if (!HP_BAR_DESIGN_OPTIONS.includes(hpBarDesign)) hpBarDesign = 'standard';
          if (!HP_BAR_SIZE_OPTIONS.includes(hpBarSize)) hpBarSize = 'normal';
          if (!HP_BAR_ALIGN_OPTIONS.includes(hpBarAlign)) hpBarAlign = 'center';
          setHpBarEnabled(hpBarEnabled);
          setHpBarStepMs(hpBarStepMs);
          setHpBarDesign(hpBarDesign);
          setHpBarSize(hpBarSize);
          setHpBarShake(hpBarShake);
          setHpBarAlign(hpBarAlign);

          function setHpBarDesign(v) {
            hpBarDesign = HP_BAR_DESIGN_OPTIONS.includes(v) ? v : 'standard';
            window.hpBarDesign = hpBarDesign;
            try { hpSaveString(HP_BAR_DESIGN_KEY, hpBarDesign); } catch (_) { }
            const wrap = document.getElementById('readerHpBar');
            if (wrap) applyHpBarTheme(wrap);
          }
          function setHpBarAlign(v) {
            hpBarAlign = HP_BAR_ALIGN_OPTIONS.includes(v) ? v : 'center';
            window.hpBarAlign = hpBarAlign;
            try { hpSaveString(HP_BAR_ALIGN_KEY, hpBarAlign); } catch (_) { }
            const wrap = document.getElementById('readerHpBar');
            if (wrap) applyHpBarTheme(wrap);
          }
          function setHpBarSize(v) {
            hpBarSize = HP_BAR_SIZE_OPTIONS.includes(v) ? v : 'normal';
            window.hpBarSize = hpBarSize;
            try { hpSaveString(HP_BAR_SIZE_KEY, hpBarSize); } catch (_) { }
            const wrap = document.getElementById('readerHpBar');
            if (wrap) applyHpBarTheme(wrap);
          }
          function setHpBarShake(v) {
            hpBarShake = HP_BAR_SHAKE_OPTIONS.includes(v) ? v : 'shake-x';
            window.hpBarShake = hpBarShake;
            try { hpSaveString(HP_BAR_SHAKE_KEY, hpBarShake); } catch (_) { }
            const wrap = document.getElementById('readerHpBar');
            if (wrap) applyHpBarTheme(wrap);
          }
          window.setHpBarDesign = setHpBarDesign;
          window.setHpBarSize = setHpBarSize;
          window.setHpBarShake = setHpBarShake;
          window.setHpBarAlign = setHpBarAlign;

          function applyHpBarTheme(wrap) {
            if (!wrap) return;
            const styleClasses = ['style-standard', 'style-glass', 'style-translucent', 'style-muted'];
            const sizeClasses = ['size-normal', 'size-short', 'size-narrow'];
            const alignClasses = ['align-center', 'align-left', 'align-right'];
            styleClasses.forEach(c => wrap.classList.remove(c));
            sizeClasses.forEach(c => wrap.classList.remove(c));
            alignClasses.forEach(c => wrap.classList.remove(c));
            HP_BAR_SHAKE_OPTIONS.forEach(s => wrap.classList.remove(s));

            const designClass = `style-${hpBarDesign || 'standard'}`;
            const sizeClass = `size-${hpBarSize || 'normal'}`;
            const alignClass = `align-${hpBarAlign || 'center'}`;
            wrap.classList.add(designClass);
            wrap.classList.add(sizeClass);
            wrap.classList.add(alignClass);
            wrap.classList.add(hpBarShake || 'shake-x');
          }

          // ===== Study HP overlay (KH-style) =====
          const StudyHpOverlay = (() => {
            const state = { wrap: null, fill: null, ticks: null, label: null, lastMinute: null, lastEvent: null, hitTimer: null };
            const disabled = true; // viewer上部の重複バーを出さない
            const clampHp = (v, min, max) => Math.max(min, Math.min(max, v));
            function ensureDom() {
              if (disabled) return null;
              const host = document.getElementById('stageHost');
              if (!host) return null;
              const stage = host.querySelector('.stage');
              if (state.wrap && state.wrap.isConnected) return state;
              const layer = document.createElement('div');
              layer.id = 'hpBarLayer';
              layer.className = 'hidden';
              layer.innerHTML = `
        <div class="hp-kh-shell">
          <div class="hp-kh-track">
            <div class="hp-kh-fill"></div>
            <div class="hp-kh-ticks"></div>
          </div>
          <div class="hp-kh-frame"></div>
        </div>
        <div class="hp-kh-label">--</div>
      `;
              (stage || host).appendChild(layer);
              state.wrap = layer;
              state.fill = layer.querySelector('.hp-kh-fill');
              state.ticks = layer.querySelector('.hp-kh-ticks');
              state.label = layer.querySelector('.hp-kh-label');
              return state;
            }
            function hide() {
              if (state.wrap) {
                state.wrap.classList.add('hidden');
                state.wrap.classList.remove('active', 'hit');
              }
              state.lastEvent = null;
              state.lastMinute = null;
            }
            function triggerHit() {
              if (!state.wrap) return;
              state.wrap.classList.remove('hit');
              if (state.fill) state.fill.classList.remove('hit');
              void state.wrap.offsetWidth;
              state.wrap.classList.add('hit');
              if (state.fill) state.fill.classList.add('hit');
              clearTimeout(state.hitTimer);
              state.hitTimer = setTimeout(() => {
                if (state.wrap) state.wrap.classList.remove('hit');
                if (state.fill) state.fill.classList.remove('hit');
              }, 520);
            }
            function update(nowMs) {
              if (disabled) {
                const existing = document.getElementById('hpBarLayer');
                if (existing) { existing.remove(); }
                state.wrap = null; state.fill = null; state.ticks = null; state.label = null;
                return;
              }
              const ts = (nowMs == null) ? studyNowMs() : nowMs;
              const host = document.getElementById('stageHost');
              const viewer = document.getElementById('viewerView');
              const reading = document.body && document.body.classList.contains('reading');
              if (!(host && viewer && !viewer.classList.contains('hidden') && reading)) {
                hide();
                return;
              }
              const ev = getCurrentStudyEvent(ts);
              if (!ev) {
                hide();
                return;
              }
              const evId = ev.id || `${ev.start}-${ev.end}`;
              const evStart = Number(ev.start) || 0;
              const evEnd = Math.max(evStart + 60000, Number(ev.end) || 0);
              const total = Math.max(60000, evEnd - evStart);
              const remain = Math.max(0, evEnd - ts);
              const dom = ensureDom(); if (!dom) return;
              dom.wrap.classList.remove('hidden');
              dom.wrap.classList.add('active');
              const pct = Math.max(0, Math.min(1, remain / total));
              const pct100 = Math.max(0, Math.min(100, pct * 100));
              if (dom.fill) dom.fill.style.width = pct100 + '%';
              const segments = clampHp(Math.round(total / 60000), 4, 60);
              dom.wrap.style.setProperty('--hp-segments', segments);
              if (dom.label) dom.label.textContent = `${ev.title || '学習中'} 残り ${formatStudyRemain(remain)}`;
              const minuteNow = Math.max(0, Math.ceil(remain / 60000));
              if (state.lastEvent !== ev.id) {
                state.lastEvent = ev.id;
                state.lastMinute = minuteNow;
              } else if (minuteNow < (state.lastMinute ?? minuteNow)) {
                triggerHit();
                state.lastMinute = minuteNow;
              } else {
                state.lastMinute = minuteNow;
              }
            }
            return { update };
          })();

          // ===== Viewer内のHPバー（シンプル版） =====
          const ReaderHpBar = (() => {
            const READER_OVERTIME_SNAP_KEY = 'reader-overtime-snapshot';
            const OVERTIME_SNAP_MAX_AGE_MS = 30 * 60 * 1000; // 延長状態を再読み込み後も長めに保持
            const loadOvertimeSnapshot = () => {
              try {
                const snap = loadStoredJSON(READER_OVERTIME_SNAP_KEY) || null;
                const now = studyNowMs();
                if (!snap || !snap.lastSeen) return null;
                const lastSeen = Number(snap.lastSeen);
                if (!Number.isFinite(lastSeen)) return null;
                if ((now - lastSeen) >= OVERTIME_SNAP_MAX_AGE_MS) return null;
                const overtimeStartMs = Number(snap.overtimeStartMs);
                const baseDurationMs = Number(snap.baseDurationMs);
                return {
                  id: snap.id || null,
                  title: snap.title || '',
                  start: Number(snap.start) || null,
                  overtimeStartMs: Number.isFinite(overtimeStartMs) ? overtimeStartMs : null,
                  baseDurationMs: Number.isFinite(baseDurationMs) ? baseDurationMs : null,
                  baseTotalMin: snap.baseTotalMin || null,
                  lastSeen
                };
              } catch (_) {
                return null;
              }
            };
            const saveOvertimeSnapshot = (snap) => {
              try { saveStoredJSON(READER_OVERTIME_SNAP_KEY, snap || null); } catch (_) { }
            };
            const state = { wrap: null, fill: null, damage: null, label: null, lastEvent: null, lastMinute: null, hitTimer: null, lastPct: 0, dmgTimer: null, overtimeEventId: null, overtimeSeen: false, overtimeStartMs: null, overtimeBaseMs: null, overtimeSnapshot: loadOvertimeSnapshot(), lastEventData: null };
            const OVERTIME_STICKY_MS = 4000;   // 再構築でcurrentがズレても延長表示を保持する猶予
            const SNAP_RETAIN_MS = 8000;       // 延長スナップショットを保持する最低期間
            const SNAP_PREFER_MS = 15000;      // currentが次のページに飛んでも延長中スナップショットを優先する猶予
            const END_HOLD_MS = 0;             // 終了直後の保持を無効化しフルHP再表示を防止
            const DELAY_STICK_MS = 20000;      // delay情報を優先的に使う猶予
            const OVERTIME_GRACE_MS = 12000;   // 延長が反映されるまでの猶予中は直前の予定を維持
            const findEventTitleById = (id) => {
              if (!id) return null;
              try {
                const events = (window.NLStore && Array.isArray(NLStore.events)) ? NLStore.events : [];
                const hit = events.find(e => e && e.id === id);
                return hit?.title || null;
              } catch (_) { return null; }
            };
            function ensureDom() {
              const host = document.getElementById('stageHost');
              if (!host) return null;
              if (state.wrap && state.wrap.isConnected) return state;
              const wrap = document.createElement('div');
              wrap.id = 'readerHpBar';
              wrap.className = 'hp-bar-container';
              wrap.innerHTML = `
        <div class="hp-bar-outer">
          <div class="hp-bar-damage" id="readerHpDamage"></div>
          <div class="hp-bar-fill" id="readerHpFill">
            <div class="hp-bar-shine"></div>
          </div>
          <div class="hp-bar-bg"></div>
          <div class="hp-bar-ticks"></div>
        </div>
        <div class="hp-bar-label" id="readerHpLabel">残り --</div>
      `;
              host.appendChild(wrap);
              state.wrap = wrap;
              state.fill = wrap.querySelector('#readerHpFill');
              state.damage = wrap.querySelector('#readerHpDamage');
              state.label = wrap.querySelector('#readerHpLabel');
              if (state.label && !state.label.dataset.boundMenu) {
                state.label.dataset.boundMenu = '1';
                state.label.classList.add('click-target');
                state.label.addEventListener('click', (e) => {
                  e.stopPropagation();
                  try { window.StudyActionMenu && StudyActionMenu.open && StudyActionMenu.open({ source: 'hp-label' }); } catch (_) { }
                });
              }
              const bar = wrap.querySelector('.hp-bar-outer');
              if (bar && !bar.dataset.bound) {
                bar.dataset.bound = '1';
                bar.classList.add('click-target');
                bar.addEventListener('click', () => {
                  if (!wrap.classList.contains('clickable')) return;
                  wrap.classList.add('press', 'burst');
                  clearTimeout(state.hitTimer);
                  state.hitTimer = setTimeout(() => { wrap.classList.remove('press', 'burst'); }, 420);
                  try {
                    StudyMgr && StudyMgr.completePageNow && StudyMgr.completePageNow();
                    ReaderHpBar.update(studyNowMs());
                    StudyActionMenu && StudyActionMenu.refresh && StudyActionMenu.refresh();
                  } catch (_) { }
                });
              }
              applyHpBarTheme(wrap);
              return state;
            }
            function hide() {
              const dom = state;
              if (dom.wrap) { dom.wrap.classList.remove('active', 'hit', 'overtime', 'break'); }
              if (dom.fill) { dom.fill.style.width = '0%'; }
              if (dom.damage) { dom.damage.style.width = '0%'; dom.damage.style.opacity = '0'; }
              if (dom.label) { dom.label.textContent = '残り --'; }
              clearTimeout(state.hitTimer);
              clearTimeout(state.dmgTimer);
              state.lastEvent = null;
              state.lastMinute = null;
              state.lastPct = 0;
              state.overtimeEventId = null;
              state.overtimeSeen = false;
              state.overtimeStartMs = null;
              state.overtimeBaseMs = null;
              state.overtimeSnapshot = null;
              saveOvertimeSnapshot(null);
              state.lastEventData = null;
              if (dom.wrap) { dom.wrap.classList.remove('clickable', 'press', 'burst'); }
            }
            function triggerHit(wrap) {
              if (!wrap) return;
              wrap.classList.remove('hit');
              void wrap.offsetWidth;
              wrap.classList.add('hit');
              clearTimeout(state.hitTimer);
              state.hitTimer = setTimeout(() => { wrap.classList.remove('hit'); }, 520);
            }
            function update(nowMs) {
              const viewer = document.getElementById('viewerView');
              const reading = document.body && document.body.classList.contains('reading');
              if (!(viewer && !viewer.classList.contains('hidden') && reading)) { hide(); return; }
              if (!hpBarEnabled) { hide(); return; }
              if (!(window.StudyMgr && StudyMgr.active && Array.isArray(StudyMgr.pageIds) && StudyMgr.pageIds.length > 0)) {
                hide();
                return;
              }
              const dom = ensureDom(); if (!dom) return;
              const ts = (nowMs == null) ? studyNowMs() : nowMs;
              const ctx = findStudyContext(ts);
              const snapValid = (state.overtimeSnapshot && state.overtimeSnapshot.overtimeStartMs != null && (ts - (state.overtimeSnapshot.lastSeen || 0)) < OVERTIME_SNAP_MAX_AGE_MS);
              let snap = snapValid ? state.overtimeSnapshot : null;
              const delayMap = (window.StudyMgr && StudyMgr.delay) ? StudyMgr.delay : null;
              const snapInEvents = snap && ctx && Array.isArray(ctx.all) ? ctx.all.some(e => e && e.id === snap.id) : false;
              const snapHasDelay = snap && snap.id ? !!(delayMap && delayMap[snap.id]) : false;
              const snapAlive = !!(snap && (snapInEvents || snapHasDelay));
              // 完了済みなどで消えた延長スナップショットは強制的に破棄する
              if (snap && !snapAlive) {
                state.overtimeSnapshot = null;
                snap = null;
              }
              const lastOvertimeSeen = snap?.lastSeen || state.overtimeSnapshot?.lastSeen || 0;
              const lastId = state.lastEventData?.id || null;
              const lastFromAll = lastId && ctx && Array.isArray(ctx.all) ? ctx.all.find(e => e && e.id === lastId) : null;
              const lastEnd = lastFromAll?.end ?? state.lastEventData?.end ?? null;
              const lastStart = lastFromAll?.start ?? state.lastEventData?.start ?? null;
              const hasDelayLast = lastId && delayMap && delayMap[lastId];
              const withinGrace = lastEnd != null && ts >= lastEnd && (ts - lastEnd) < OVERTIME_GRACE_MS;
              let ev = ctx.current || null;
              // 延長が付与されるまでの境界瞬間では直前の予定を優先
              if (withinGrace && (hasDelayLast || lastFromAll) && (!ev || ev.id !== lastId)) {
                const fallback = lastFromAll || state.lastEventData;
                if (fallback) {
                  ev = { ...fallback, id: fallback.id || lastId, start: lastStart ?? fallback.start ?? ts - 60000, end: lastEnd ?? fallback.end ?? ts };
                  if (hasDelayLast) {
                    const info = delayMap[lastId];
                    state.overtimeSeen = true;
                    state.overtimeEventId = lastId;
                    state.overtimeStartMs = info.baseEnd;
                    state.overtimeBaseMs = info.baseDurationMs || Math.max(60000, info.baseEnd - (lastStart ?? info.baseEnd - 60000));
                  }
                }
              }
              // 延長が発動した瞬間に次予定へ飛ばないよう、直前イベントのdelayを優先的に使用
              const lastDelayId = state.lastEventData?.id;
              const lastDelayInfo = lastDelayId ? delayMap?.[lastDelayId] : null;
              const lastDelayOvertime = lastDelayInfo && ('baseEnd' in lastDelayInfo) && ts >= lastDelayInfo.baseEnd;
              if (lastDelayOvertime && (!ev || ev.id !== lastDelayId)) {
                const evFromAll = (ctx && Array.isArray(ctx.all)) ? ctx.all.find(e => e && e.id === lastDelayId) : null;
                const fallback = evFromAll || state.lastEventData;
                if (fallback) {
                  ev = { ...fallback, id: fallback.id || lastDelayId };
                  state.overtimeSeen = true;
                  state.overtimeEventId = lastDelayId;
                  state.overtimeStartMs = lastDelayInfo.baseEnd;
                  const baseDur = lastDelayInfo.baseDurationMs || Math.max(60000, lastDelayInfo.baseEnd - (fallback.start || lastDelayInfo.baseEnd - 60000));
                  state.overtimeBaseMs = baseDur;
                }
              }
              if (!ev && (!ctx || !Array.isArray(ctx.all) || ctx.all.length === 0)) {
                hide(); return;
              }
              // currentが消える瞬間は次のページに飛ばさず、直前ページを少し保持して緑フルHPへの瞬断を防ぐ
              if (!ev && state.lastEventData && (ts - (state.lastEventData.end || 0)) < END_HOLD_MS) {
                ev = { ...state.lastEventData };
              }
              // 延長スナップショットがあり、currentが別ページを指していても延長中のイベントを優先
              if (ev && snap && snapAlive && snap.id && ev.id !== snap.id && snap.overtimeStartMs != null && (ts - (snap.lastSeen || 0)) < SNAP_PREFER_MS && ts >= snap.overtimeStartMs) {
                const snapTitle = snap.title || state.lastEventData?.title || findEventTitleById(snap.id) || findEventTitleById(ev.id) || ev.title || '予定';
                ev = {
                  id: snap.id,
                  start: snap.start || snap.overtimeStartMs - (snap.baseDurationMs || 60000),
                  end: (snap.overtimeStartMs + (snap.baseDurationMs || 60000)),
                  title: snapTitle
                };
                state.overtimeSeen = true;
                state.overtimeEventId = snap.id;
                state.overtimeStartMs = snap.overtimeStartMs;
                state.overtimeBaseMs = snap.baseDurationMs || state.overtimeBaseMs;
              }
              // delayテーブルから「直近に延長中」のイベントを強制的に拾う
              if (window.StudyMgr && StudyMgr.delay) {
                let candidate = null;
                Object.keys(StudyMgr.delay).forEach(id => {
                  const st = StudyMgr.delay[id];
                  if (!st || !('baseEnd' in st)) return;
                  if (ts < st.baseEnd) return;
                  if (candidate && st.baseEnd <= candidate.baseEnd) return;
                  candidate = { id, st };
                });
                if (candidate && (ts - candidate.st.baseEnd) < DELAY_STICK_MS) {
                  const evObj = (ctx && Array.isArray(ctx.all)) ? ctx.all.find(e => e && e.id === candidate.id) : null;
                  const baseDur = candidate.st.baseDurationMs || (evObj ? Math.max(60000, candidate.st.baseEnd - (evObj.start || 0)) : 60000);
                  const fallbackTitle = evObj?.title || findEventTitleById(candidate.id) || state.lastEventData?.title || '予定';
                  const forcedBase = evObj ? { ...evObj } : { id: candidate.id, start: candidate.st.baseEnd - baseDur, end: candidate.st.baseEnd + baseDur };
                  const forced = forcedBase.title ? forcedBase : { ...forcedBase, title: fallbackTitle };
                  if (!ev || ev.id !== candidate.id) {
                    ev = forced;
                    state.overtimeSeen = true;
                    state.overtimeEventId = candidate.id;
                    state.overtimeStartMs = candidate.st.baseEnd;
                    state.overtimeBaseMs = baseDur;
                  }
                }
              }
              // 直前に延長中だったイベントを優先的に使う（再構築でcurrentが次のページに飛んでも粘る）
              const trackedId = state.overtimeEventId;
              const trackedEv = (trackedId && ctx && Array.isArray(ctx.all)) ? ctx.all.find(e => e && e.id === trackedId) : null;
              const trackedDelay = (trackedId && window.StudyMgr && StudyMgr.delay) ? StudyMgr.delay[trackedId] : null;
              const trackedBaseEnd = (trackedDelay && ('baseEnd' in trackedDelay)) ? trackedDelay.baseEnd : (snap?.overtimeStartMs ?? null);
              const stickToOvertime = trackedEv && trackedBaseEnd && state.overtimeSeen && lastOvertimeSeen && ts >= trackedBaseEnd && (ts - lastOvertimeSeen) < OVERTIME_STICKY_MS;
              if (stickToOvertime && (!ev || ev.id !== trackedId)) {
                ev = trackedEv;
              }
              if (!ev && snap && snapAlive) {
                const snapTitle = snap.title || state.lastEventData?.title || findEventTitleById(snap.id) || '予定';
                ev = {
                  id: snap.id,
                  start: snap.start || ts,
                  end: snap.overtimeStartMs + snap.baseDurationMs,
                  title: snapTitle
                };
                if (!state.overtimeSeen) {
                  state.overtimeSeen = true;
                  state.overtimeEventId = snap.id || state.overtimeEventId;
                  state.overtimeStartMs = snap.overtimeStartMs;
                  state.overtimeBaseMs = snap.baseDurationMs;
                }
              }
              if (!ev) { hide(); return; }
              const isBreak = isBreakEvent(ev);
              const total = Math.max(60000, ev.end - ev.start);
              const remain = Math.max(0, ev.end - ts);
              let evId = ev.id || `start-${ev.start || 0}`;
              if (!ev.id && snap && snap.start != null && Math.abs((ev.start || 0) - snap.start) < 300000) {
                evId = snap.id || evId;
              }
              const delayInfo = (window.StudyMgr && StudyMgr.delay && ev && StudyMgr.delay[ev.id]) ? StudyMgr.delay[ev.id] : null;
              const baseEnd = (delayInfo && ('baseEnd' in delayInfo)) ? delayInfo.baseEnd : ev.end;
              const baseDurationMs = Math.max(60000, baseEnd - ev.start);
              const baseTotalMin = Math.max(1, Math.round(baseDurationMs / 60000));
              const overtimeRaw = (delayInfo && ('baseEnd' in delayInfo)) ? ts >= delayInfo.baseEnd : false;
              if (state.lastEvent !== evId) {
                state.overtimeEventId = evId;
                state.overtimeSeen = false;
                state.overtimeStartMs = null;
                state.overtimeBaseMs = null;
              }
              if (overtimeRaw && !state.overtimeSeen) {
                state.overtimeSeen = true;
                state.overtimeStartMs = (delayInfo && ('baseEnd' in delayInfo)) ? delayInfo.baseEnd : ev.end;
                state.overtimeBaseMs = baseDurationMs;
              }
              const overtimeStart = (state.overtimeStartMs ?? ((delayInfo && ('baseEnd' in delayInfo)) ? delayInfo.baseEnd : ev.end)) || snap?.overtimeStartMs || ev.end;
              const overtimeBase = state.overtimeBaseMs || snap?.baseDurationMs || baseDurationMs;
              const overtimeMs = Math.max(0, ts - overtimeStart);
              const overtimeMin = Math.max(0, Math.floor(overtimeMs / 60000));
              const showOvertime = overtimeRaw || (state.overtimeSeen && state.overtimeEventId === evId) || (snapAlive && snapValid && snap?.id === evId);
              const remainMin = Math.max(0, Math.ceil(remain / 60000));
              const stepMs = hpBarStepMs || HP_BAR_STEP_CHOICES[0];
              const remainForBar = Math.max(0, Math.ceil(remain / stepMs) * stepMs);
              const overtimeForBar = Math.max(0, Math.floor(overtimeMs / stepMs) * stepMs);
              const pct100 = showOvertime
                ? Math.max(0, Math.min(100, (overtimeForBar / overtimeBase) * 100))
                : Math.max(0, Math.min(100, remainForBar / total * 100));
              const segments = Math.max(4, Math.min(60, baseTotalMin));
              dom.wrap.style.setProperty('--hp-segments', segments);
              dom.wrap.classList.toggle('overtime', showOvertime);
              dom.wrap.classList.toggle('break', isBreak);
              applyHpBarTheme(dom.wrap);
              const prevPct = state.lastPct == null ? 100 : state.lastPct;
              if (dom.fill) dom.fill.style.width = pct100 + '%';
              if (dom.damage) {
                clearTimeout(state.dmgTimer);
                if (pct100 < prevPct) {
                  dom.damage.style.opacity = '0.9';
                  dom.damage.style.width = prevPct + '%';
                  state.dmgTimer = setTimeout(() => {
                    if (dom.damage) {
                      dom.damage.style.width = Math.max(0, pct100) + '%';
                      dom.damage.style.opacity = '.45';
                      setTimeout(() => {
                        if (dom.damage) {
                          dom.damage.style.opacity = '0';
                        }
                      }, 200);
                    }
                  }, 100);
                } else {
                  dom.damage.style.opacity = '0';
                  dom.damage.style.width = pct100 + '%';
                }
              }
              state.lastPct = pct100;
              const fallbackTitle = isBreak ? STUDY_BREAK_TITLE : '予定';
              const displayTitle = ev.title || state.lastEventData?.title || (ev.id ? findEventTitleById(ev.id) : null) || (snap?.id ? findEventTitleById(snap.id) : null) || snap?.title || fallbackTitle;
              if (dom.label) {
                if (showOvertime) {
                  dom.label.textContent = `${displayTitle} 延長 ${formatStudyRemain(overtimeMs)}`;
                } else {
                  dom.label.textContent = `${displayTitle} 残り ${formatStudyRemain(remain)}`;
                }
              }
              dom.wrap.classList.add('active', 'clickable');
              const minuteNow = Math.max(0, showOvertime ? overtimeMin : remainMin);
              if (state.lastEvent !== evId) {
                state.lastEvent = evId;
                state.lastMinute = minuteNow;
                dom.wrap.classList.remove('hit');
              } else if (minuteNow < (state.lastMinute ?? minuteNow)) {
                triggerHit(dom.wrap);
                state.lastMinute = minuteNow;
              } else {
                state.lastMinute = minuteNow;
              }
              state.lastEventData = { id: evId, start: ev.start, end: ev.end, title: displayTitle };

              // snapshot for overtime continuity
              if (showOvertime) {
                state.overtimeSnapshot = {
                  id: evId,
                  overtimeStartMs: overtimeStart,
                  baseDurationMs: overtimeBase,
                  baseTotalMin: baseTotalMin,
                  title: displayTitle,
                  start: ev.start,
                  lastSeen: ts
                };
                saveOvertimeSnapshot(state.overtimeSnapshot);
              } else if (state.overtimeSnapshot && state.overtimeSnapshot.id === evId && lastOvertimeSeen && (ts - lastOvertimeSeen) < SNAP_RETAIN_MS && ts >= (state.overtimeStartMs || snap?.overtimeStartMs || 0)) {
                // ほんの一瞬の再構築切替で延長フラグが落ちても、短時間はスナップショットを維持する
                state.overtimeSnapshot.lastSeen = ts;
                saveOvertimeSnapshot(state.overtimeSnapshot);
              } else {
                state.overtimeSnapshot = null;
                saveOvertimeSnapshot(null);
              }
            }
            function resetOvertimeState() {
              state.overtimeEventId = null;
              state.overtimeSeen = false;
              state.overtimeStartMs = null;
              state.overtimeBaseMs = null;
              state.overtimeSnapshot = null;
              saveOvertimeSnapshot(null);
            }
            return { update, hide, resetOvertimeState };
          })();

          // ===== 勉強予定クイックメニュー（HPバー下のラベルから開く） =====
          const StudyActionMenu = (() => {
            const state = {
              overlay: null,
              list: null,
              pages: null,
              meta: null,
              current: null,
              todoSel: null,
              scroll: null,
              grip: null,
              toolbar: null,
              head: null,
              sheet: null,
              todoInline: null,
              paused: null,
              breakBtn: null,
              breakInput: null,
              open: false,
              timer: null,
              view: 'list',
              drag: null,
              pos: { x: 0, y: 0 },
              currentEvId: null,
              freeze: false,
              lastRender: 0,
              draggingMode: null,
              hasEvents: false,
              hasActive: false,
              keyHandler: null,
              mode: 'study',
              miss: { search: '', type: '', bookId: '', sort: 'newest', status: 'all' },
              missDirty: true,
              missRenderToken: 0,
              missAllBooks: null,
              missAllBooksDirty: true,
              missSection: null,
              missList: null,
              missMeta: null,
              missSearch: null,
              missType: null,
              missBook: null,
              missSort: null,
              missStatus: null,
              map: { rangeMode: 'all', anchor: '', start: '', end: '', recentDays: 7, bookId: '', pageFilter: '', completeDate: '' },
              mapDirty: true,
              mapRenderToken: 0,
              mapAllBooks: null,
              mapAllBooksDirty: true,
              mapSection: null,
              mapMeta: null,
              mapGrid: null,
              mapBook: null,
              mapRangeMode: null,
              mapAnchor: null,
              mapStart: null,
              mapEnd: null,
              mapRecentDays: null,
              mapRangeWrap: null,
              mapRecentWrap: null,
              mapCompleteDate: null,
              mapPageFilter: null,
              mapCompleteInput: null,
              scheduleSections: []
            };
            const PAUSE_KEY = 'study_paused_v1';
            const MAX_PAUSED = 8;
            const pausedSelection = new Set();
            const esc = (typeof escapeHTML === 'function')
              ? escapeHTML
              : (s) => String(s || '').replace(/[&<>"]/g, c => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", "\"": "&quot;" }[c]));
            const pad2 = (n) => String(n).padStart(2, '0');
            const formatYMD = (d) => `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`;
            const normalizeTodoPage = (v) => {
              const n = typeof v === 'string' ? parseInt(v, 10) : Number(v);
              return Number.isFinite(n) ? n : null;
            };
            const getTodayScheduleMap = () => {
              const todayStr = formatYMD(new Date());
              const direct = window.StudyCalendar?.getScheduleMapForDate?.(todayStr);
              if (direct instanceof Map && direct.size) return direct;
              const map = new Map();
              try {
                const raw = localStorage.getItem('sc-schedules');
                if (raw && raw.trim().startsWith('{')) {
                  const parsed = JSON.parse(raw) || {};
                  Object.entries(parsed).forEach(([todoId, dateMap]) => {
                    const pages = (dateMap && dateMap[todayStr]) || [];
                    const nums = (Array.isArray(pages) ? pages : []).map(normalizeTodoPage).filter(Number.isFinite);
                    if (nums.length) map.set(String(todoId), new Set(nums));
                  });
                }
              } catch (_) { }
              if (map.size) return map;
              return direct instanceof Map ? direct : map;
            };
            const getCompletedRecordsForDate = (dateStr) => {
              const direct = window.StudyCalendar?.getCompletedForDate?.(dateStr);
              if (Array.isArray(direct)) return direct;
              try {
                const raw = localStorage.getItem('sc-completed');
                if (!raw) return [];
                const parsed = JSON.parse(raw);
                const val = parsed?.[dateStr];
                return Array.isArray(val) ? val : [];
              } catch (_) { return []; }
            };
            const parseEventPage = (ev) => {
              if (!ev) return null;
              if (Number.isFinite(ev.pageNumber)) return ev.pageNumber;
              const key = String(ev.pageKey || '');
              const m = key.match(/-(\d+)$/);
              if (m) {
                const n = parseInt(m[1], 10);
                if (Number.isFinite(n)) return n;
              }
              const title = String(ev.title || '');
              const m2 = title.match(/p(\d+)/i);
              if (m2) {
                const n = parseInt(m2[1], 10);
                if (Number.isFinite(n)) return n;
              }
              return null;
            };
            const isPageCompletedToday = (ev) => {
              const pageNum = normalizeTodoPage(parseEventPage(ev));
              if (!Number.isFinite(pageNum)) return false;
              const todayStr = formatYMD(new Date());
              const list = getCompletedRecordsForDate(todayStr);
              if (!Array.isArray(list) || !list.length) return false;
              const evBook = ev?.bookId != null ? String(ev.bookId).trim() : '';
              return list.some(rec => {
                const recPage = normalizeTodoPage(rec?.page);
                if (recPage !== pageNum) return false;
                const recBook = rec?.bookId != null ? String(rec.bookId).trim() : '';
                if (!recBook || !evBook) return true;
                return recBook === evBook;
              });
            };
            const isTypingTarget = (target) => {
              if (!target) return false;
              return target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.tagName === 'SELECT' || target.isContentEditable;
            };
            const toHM = (ts) => { const d = new Date(ts); return `${pad2(d.getHours())}:${pad2(d.getMinutes())}`; };
            const trimName = (s, len = 18) => { const str = String(s || ''); return str.length > len ? str.slice(0, len - 1) + '…' : str; };
            const badgeStyle = (color) => {
              const base = color || '#4da3ff';
              if (typeof nlHexToRgba === 'function') {
                const bg = nlHexToRgba(base, 0.18);
                const bd = nlHexToRgba(base, 0.5);
                return `background:${bg};border-color:${bd};color:${base};`;
              }
              return `border-color:${base};color:${base};`;
            };
            const toast = (msg, type = 'info') => { try { showToast && showToast(msg, type); } catch (_) { console.log(msg); } };
            const hasStudy = () => !!(window.StudyMgr && StudyMgr.active && Array.isArray(StudyMgr.pageIds) && StudyMgr.pageIds.length);
            const requireStudy = () => { if (hasStudy()) return true; toast('操作できる勉強予定がありません', 'error'); return false; };
            const normId = (v) => v == null ? null : String(v);
            const findIdx = (evId) => {
              if (!window.StudyMgr || !Array.isArray(StudyMgr.pageIds)) return -1;
              const target = normId(evId);
              return StudyMgr.pageIds.findIndex(id => normId(id) === target);
            };
            const findEvent = (evId) => {
              if (!evId || !window.NLStore || !Array.isArray(NLStore.events)) return null;
              const target = normId(evId);
              return NLStore.events.find(e => normId(e?.id) === target) || null;
            };
            const BREAK_GHOST_ID = '__study_break__';
            const getBreakMinutes = () => {
              if (typeof getStudyBreakMinutes === 'function') return getStudyBreakMinutes();
              try {
                const raw = localStorage.getItem(STUDY_BREAK_KEY);
                if (raw != null) return clampStudyBreakMinutes(raw);
              } catch (_) { }
              return STUDY_BREAK_DEFAULT_MIN;
            };
            const resolveOrderKeys = (keys) => {
              const out = [];
              const seen = new Set();
              (Array.isArray(keys) ? keys : []).forEach((key) => {
                if (key == null) return;
                const ev = findEvent(key);
                const id = ev ? ev.id : key;
                const nid = normId(id);
                if (!nid || seen.has(nid)) return;
                seen.add(nid);
                out.push(id);
              });
              return out;
            };
            const buildActiveOrderIds = (nowMs) => {
              if (!window.StudyMgr || !Array.isArray(StudyMgr.pageIds)) return [];
              const now = Number.isFinite(nowMs) ? nowMs : studyNowMs();
              return StudyMgr.pageIds
                .map(id => findEvent(id))
                .filter(ev => ev && ev.end > now)
                .map(ev => ev.id);
            };
            const createBreakEvent = (startMs, durationMin) => {
              if (!window.NLStore || typeof NLStore.addAbs !== 'function') return null;
              const mins = clampStudyBreakMinutes(durationMin ?? getBreakMinutes());
              const start = Math.floor((Number.isFinite(startMs) ? startMs : studyNowMs()) / 60000) * 60000;
              const end = start + mins * 60000;
              const ev = NLStore.addAbs(start, end, STUDY_BREAK_TITLE, STUDY_BREAK_COLOR, 'break');
              if (ev) {
                ev.isBreak = true;
                ev.color = STUDY_BREAK_COLOR;
                NLStore.save();
              }
              return ev;
            };
            const ensureBreakGhostRow = () => {
              if (!state.list) return null;
              let row = state.list.querySelector(`.study-menu-row[data-ev="${BREAK_GHOST_ID}"]`);
              if (row) return row;
              const mins = getBreakMinutes();
              row = document.createElement('div');
              row.className = 'study-menu-row break break-ghost';
              row.dataset.ev = BREAK_GHOST_ID;
              row.innerHTML = `
                <div class="title">休憩 <span class="meta">${mins}分</span></div>
              `;
              state.list.appendChild(row);
              return row;
            };
            const removeBreakGhostRow = () => {
              const row = state.list?.querySelector(`.study-menu-row[data-ev="${BREAK_GHOST_ID}"]`);
              if (row) row.remove();
            };
            const insertBreakNow = () => {
              const nowMs = studyNowMs();
              const ev = createBreakEvent(nowMs, getBreakMinutes());
              if (!ev) { toast('休憩を追加できませんでした', 'error'); return; }
              const ids = buildActiveOrderIds(nowMs);
              const nextIds = [ev.id, ...ids.filter(id => normId(id) !== normId(ev.id))];
              if (window.StudyMgr) {
                StudyMgr.active = true;
                StudyMgr.__intentionalEnd = false;
              }
              applyOrder(nextIds);
              toast('休憩を開始しました', 'success');
              render(false);
            };
            const insertBreakAtOrderKeys = (orderKeys) => {
              const keys = Array.isArray(orderKeys) ? orderKeys : [];
              const idx = keys.indexOf(BREAK_GHOST_ID);
              if (idx < 0) return false;
              const ev = createBreakEvent(studyNowMs(), getBreakMinutes());
              if (!ev) { toast('休憩を追加できませんでした', 'error'); return false; }
              const filtered = keys.filter(k => k !== BREAK_GHOST_ID);
              const orderedIds = resolveOrderKeys(filtered);
              const insertAt = Math.max(0, Math.min(orderedIds.length, idx));
              orderedIds.splice(insertAt, 0, ev.id);
              if (window.StudyMgr) {
                StudyMgr.active = true;
                StudyMgr.__intentionalEnd = false;
              }
              applyOrder(orderedIds);
              toast('休憩を挿入しました', 'success');
              render(false);
              return true;
            };
            function ensureDom() {
              if (state.overlay) return state;
              const ov = document.createElement('div');
              ov.id = 'studyMenuOverlay';
              ov.className = 'study-menu-backdrop';
              ov.innerHTML = `
        <div class="study-menu-sheet" role="dialog" aria-label="勉強予定コントロール">
          <div class="study-menu-head">
            <div class="study-menu-drag"></div>
            <div class="study-menu-head-actions">
              <button class="mini-menu" id="studyMenuClose">閉じる</button>
            </div>
          </div>
          <div class="study-menu-toolbar" id="studyMenuToolbar">
            <button class="chip-btn" data-action="complete-now">✓ 完了</button>
            <button class="chip-btn ghost" data-action="recover-current">⟳ 回復</button>
            <button class="chip-btn" data-action="todo-popup" title="TODO連携を別ウィンドウで開く">ToDo</button>
            <button class="chip-btn break" id="studyBreakBtn" data-action="break-now" draggable="true" title="休憩を追加して開始（ドラッグで挿入）">☕ 休憩</button>
            <label class="study-break-config">休憩
              <input type="number" id="studyBreakMinutes" min="1" max="180" step="1">
              分
            </label>
            <button class="chip-btn danger" data-action="stop-study">⏸ 中断</button>
            <button class="chip-btn danger" data-action="force-end">⏹ 終了</button>
            <button class="chip-btn ghost" data-action="toggle-map" id="studyMapToggle">マップ</button>
            <button class="chip-btn ghost" data-action="toggle-miss" id="studyMissToggle">ミス</button>
            <div class="study-menu-overall" id="studyMenuOverall" style="margin-left:auto;font-size:12px;"></div>
          </div>
          <div class="study-menu-scroll" id="studyMenuScroll">
              <div class="study-menu-section" id="studyMenuCurrent"></div>
              <div class="study-menu-section study-menu-miss hidden" id="studyMenuMiss">
                <div class="study-menu-head" style="margin:0 0 6px; gap:6px; cursor:default;">
                  <h4 style="margin:0">🧷 ミス一覧</h4>
                </div>
                <div class="study-miss-controls">
                  <input id="studyMissSearch" class="input" placeholder="名前/理由/ページ検索…">
                  <select id="studyMissType" class="input">
                    <option value="">種類: すべて</option>
                    <option value="important">重要</option>
                    <option value="hard">難</option>
                    <option value="note">注</option>
                    <option value="careless">凡ミス</option>
                    <option value="lack">理解不足</option>
                    <option value="remember">覚える</option>
                    <option value="question">？</option>
                  </select>
                  <select id="studyMissStatus" class="input">
                    <option value="all">状態: すべて</option>
                    <option value="checked">確認済み</option>
                    <option value="unchecked">未確認</option>
                    <option value="named">名前あり</option>
                    <option value="reason">理由あり</option>
                  </select>
                </div>
                <div class="study-miss-controls">
                  <select id="studyMissBook" class="input"></select>
                  <select id="studyMissSort" class="input">
                    <option value="newest">新しい順</option>
                    <option value="oldest">古い順</option>
                    <option value="page-asc">ページ昇順</option>
                    <option value="page-desc">ページ降順</option>
                    <option value="checks-desc">確認ポイント多い順</option>
                  </select>
                </div>
                <div class="study-miss-meta" id="studyMissMeta"></div>
                <div class="study-miss-list" id="studyMissList"></div>
              </div>
              <div class="study-menu-section study-menu-map hidden" id="studyMenuMap">
                <div class="study-menu-head" style="margin:0 0 6px; gap:6px; cursor:default;">
                  <h4 style="margin:0">🗺 ページマップ</h4>
                </div>
                <div class="study-map-controls">
                  <label>表示</label>
                  <select id="studyMapRangeMode" class="input">
                    <option value="all" selected>全て</option>
                    <option value="day">1日</option>
                    <option value="week">週</option>
                    <option value="month">月</option>
                    <option value="range">範囲</option>
                    <option value="recent">直近</option>
                  </select>
                  <label>基準日</label>
                  <input id="studyMapAnchor" type="date" class="input">
                  <span id="studyMapRangeWrap">
                    <label>範囲</label>
                    <input id="studyMapStart" type="date" class="input">
                    <span>〜</span>
                    <input id="studyMapEnd" type="date" class="input">
                  </span>
                  <span id="studyMapRecentWrap">
                    <label>直近日数</label>
                    <input id="studyMapRecentDays" type="number" min="1" max="365" value="7" class="input" style="width:64px">
                    <span>日</span>
                  </span>
                </div>
                <div class="study-map-controls">
                  <label>本</label>
                  <select id="studyMapBook" class="input"></select>
                  <label>完了日</label>
                  <input id="studyMapCompleteDate" type="date" class="input">
                </div>
                <div class="study-map-controls">
                  <label>ページ</label>
                  <input id="studyMapCompleteInput" class="input" placeholder="例: 12, 15-20">
                  <button class="mini-menu" id="studyMapCompleteAdd">追加</button>
                </div>
                <div class="study-map-controls">
                  <label>絞り込み</label>
                  <input id="studyMapPageFilter" class="input" placeholder="例: 10-30 / 42 / 3,5,9">
                  <button class="mini-menu" id="studyMapPageFilterClear">クリア</button>
                </div>
                <div class="study-map-meta" id="studyMapMeta"></div>
                <div class="study-map-grid" id="studyMapGrid"></div>
              </div>
              <div class="study-menu-section">
                <div class="study-menu-head" style="margin:0 0 6px; gap:6px; cursor:default;">
                  <h4 style="margin:0">並び替え・ジャンプ</h4>
                  <div class="study-menu-sort">
                    <select id="studySortSelect" class="input" style="min-width:110px;width:110px;font-size:11px;padding:4px 6px;">
                      <option value="manual">手動</option>
                      <option value="time-asc">開始早い</option>
                      <option value="time-desc">開始遅い</option>
                      <option value="page-asc">ページ小</option>
                      <option value="page-desc">ページ大</option>
                      <option value="todo-due">期限早い</option>
                    </select>
                  </div>
                  <div class="study-menu-mode">
                    表示:
                    <button class="mini-menu" data-action="mode-list">リスト</button>
                    <button class="mini-menu" data-action="mode-pages">ページ</button>
                  </div>
                </div>
                <div class="study-menu-list" id="studyMenuList"></div>
                <div class="study-page-grid hidden" id="studyMenuPages"></div>
              </div>
            <div class="study-menu-section study-menu-todo">
              <h4>ToDo連携</h4>
              <div class="row" style="align-items:center;">
                <div class="muted" style="font-size:12px;">未完のToDoを下に一覧表示します</div>
                <button class="mini-menu" data-action="todo-add-all">未完を予定に追加</button>
                <button class="mini-menu" data-action="todo-open">ToDoフォーム</button>
              </div>
              <div class="study-todo-inline" id="studyTodoInline"></div>
              <div class="study-paused" id="studyPausedWrap" style="margin-top:14px;">
                <div class="row space" style="gap:6px; align-items:center; flex-wrap:wrap;">
                  <div class="row" style="gap:6px; align-items:center;">
                    <h4 style="margin:0">中断した予定</h4>
                    <span class="muted" style="font-size:12px;">下のリストから再開・統合できます</span>
                  </div>
                  <div class="row" style="gap:6px; align-items:center;">
                    <button class="mini-menu ghost" data-action="merge-paused">統合</button>
                  </div>
                </div>
              <div class="study-paused-list" id="studyPausedList"></div>
              </div>
              <div class="study-menu-section" style="border-top: 1px solid var(--border); margin-top: 12px; padding-top: 12px;">
                <div class="row" style="gap:8px; align-items:center; flex-wrap:wrap;">
                  <span class="muted" style="font-size:11px;">ストレージ管理:</span>
                  <button class="mini-menu ghost" data-action="cleanup-storage">古いデータを整理</button>
                  <button class="mini-menu danger" data-action="reset-schedule">予定リセット</button>
                  <button class="mini-menu danger" data-action="emergency-clean">容量確認・解放</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      `;
              document.body.appendChild(ov);
              state.overlay = ov;
              state.list = ov.querySelector('#studyMenuList');
              state.pages = ov.querySelector('#studyMenuPages');
              state.meta = ov.querySelector('#studyMenuMeta');
              state.current = ov.querySelector('#studyMenuCurrent');
              state.todoSel = null;
              state.scroll = ov.querySelector('#studyMenuScroll');
              state.grip = ov.querySelector('.study-menu-grip');
              state.toolbar = ov.querySelector('#studyMenuToolbar');
              state.head = ov.querySelector('.study-menu-head');
              state.sheet = ov.querySelector('.study-menu-sheet');
              state.todoInline = ov.querySelector('#studyTodoInline');
              state.paused = ov.querySelector('#studyPausedList');
              state.breakBtn = ov.querySelector('#studyBreakBtn');
              state.breakInput = ov.querySelector('#studyBreakMinutes');
              state.missSection = ov.querySelector('#studyMenuMiss');
              state.missList = ov.querySelector('#studyMissList');
              state.missMeta = ov.querySelector('#studyMissMeta');
              state.missSearch = ov.querySelector('#studyMissSearch');
              state.missType = ov.querySelector('#studyMissType');
              state.missBook = ov.querySelector('#studyMissBook');
              state.missSort = ov.querySelector('#studyMissSort');
              state.missStatus = ov.querySelector('#studyMissStatus');
              state.mapSection = ov.querySelector('#studyMenuMap');
              state.mapMeta = ov.querySelector('#studyMapMeta');
              state.mapGrid = ov.querySelector('#studyMapGrid');
              state.mapBook = ov.querySelector('#studyMapBook');
              state.mapRangeMode = ov.querySelector('#studyMapRangeMode');
              state.mapAnchor = ov.querySelector('#studyMapAnchor');
              state.mapStart = ov.querySelector('#studyMapStart');
              state.mapEnd = ov.querySelector('#studyMapEnd');
              state.mapRecentDays = ov.querySelector('#studyMapRecentDays');
              state.mapRangeWrap = ov.querySelector('#studyMapRangeWrap');
              state.mapRecentWrap = ov.querySelector('#studyMapRecentWrap');
              state.mapCompleteDate = ov.querySelector('#studyMapCompleteDate');
              state.mapPageFilter = ov.querySelector('#studyMapPageFilter');
              state.mapCompleteInput = ov.querySelector('#studyMapCompleteInput');
              state.scheduleSections = Array.from(ov.querySelectorAll('.study-menu-section'))
                .filter(sec => sec && !['studyMenuMiss', 'studyMenuMap'].includes(sec.id));
              const sortSelect = ov.querySelector('#studySortSelect');
              if (sortSelect && !sortSelect.__boundAuto) {
                sortSelect.__boundAuto = true;
                sortSelect.addEventListener('change', () => applySort());
              }
              const setMissState = (patch) => {
                Object.assign(state.miss, patch);
                state.missDirty = true;
                render(false);
              };
              if (state.missSearch && !state.missSearch.__bound) {
                state.missSearch.__bound = true;
                state.missSearch.addEventListener('input', () => setMissState({ search: state.missSearch.value || '' }));
              }
              if (state.missType && !state.missType.__bound) {
                state.missType.__bound = true;
                state.missType.addEventListener('change', () => setMissState({ type: state.missType.value || '' }));
              }
              if (state.missStatus && !state.missStatus.__bound) {
                state.missStatus.__bound = true;
                state.missStatus.addEventListener('change', () => setMissState({ status: state.missStatus.value || 'all' }));
              }
              if (state.missBook && !state.missBook.__bound) {
                state.missBook.__bound = true;
                state.missBook.addEventListener('change', () => setMissState({ bookId: state.missBook.value || '' }));
              }
              if (state.missSort && !state.missSort.__bound) {
                state.missSort.__bound = true;
                state.missSort.addEventListener('change', () => setMissState({ sort: state.missSort.value || 'newest' }));
              }
              const setMapState = (patch) => {
                Object.assign(state.map, patch);
                state.mapDirty = true;
                render(false);
              };
              if (state.mapRangeMode && !state.mapRangeMode.__bound) {
                state.mapRangeMode.__bound = true;
                state.mapRangeMode.addEventListener('change', () => setMapState({ rangeMode: state.mapRangeMode.value || 'all' }));
              }
              if (state.mapAnchor && !state.mapAnchor.__bound) {
                state.mapAnchor.__bound = true;
                state.mapAnchor.addEventListener('change', () => setMapState({ anchor: state.mapAnchor.value || '' }));
              }
              if (state.mapStart && !state.mapStart.__bound) {
                state.mapStart.__bound = true;
                state.mapStart.addEventListener('change', () => setMapState({ start: state.mapStart.value || '' }));
              }
              if (state.mapEnd && !state.mapEnd.__bound) {
                state.mapEnd.__bound = true;
                state.mapEnd.addEventListener('change', () => setMapState({ end: state.mapEnd.value || '' }));
              }
              if (state.mapRecentDays && !state.mapRecentDays.__bound) {
                state.mapRecentDays.__bound = true;
                state.mapRecentDays.addEventListener('change', () => {
                  const next = Math.max(1, parseInt(state.mapRecentDays.value, 10) || 1);
                  setMapState({ recentDays: next });
                });
              }
              if (state.mapBook && !state.mapBook.__bound) {
                state.mapBook.__bound = true;
                state.mapBook.addEventListener('change', () => setMapState({ bookId: state.mapBook.value || '' }));
              }
              if (state.mapCompleteDate && !state.mapCompleteDate.__bound) {
                state.mapCompleteDate.__bound = true;
                state.mapCompleteDate.addEventListener('change', () => setMapState({ completeDate: state.mapCompleteDate.value || '' }));
              }
              if (state.mapPageFilter && !state.mapPageFilter.__bound) {
                state.mapPageFilter.__bound = true;
                state.mapPageFilter.addEventListener('input', () => setMapState({ pageFilter: state.mapPageFilter.value || '' }));
              }
              const mapPageFilterClear = ov.querySelector('#studyMapPageFilterClear');
              if (mapPageFilterClear && !mapPageFilterClear.__bound) {
                mapPageFilterClear.__bound = true;
                mapPageFilterClear.addEventListener('click', () => {
                  if (state.mapPageFilter) state.mapPageFilter.value = '';
                  setMapState({ pageFilter: '' });
                });
              }
              const mapCompleteAdd = ov.querySelector('#studyMapCompleteAdd');
              if (mapCompleteAdd && !mapCompleteAdd.__bound) {
                mapCompleteAdd.__bound = true;
                mapCompleteAdd.addEventListener('click', () => {
                  if (state.mapCompleteInput) {
                    const ev = new Event('mapcomplete');
                    state.mapCompleteInput.dispatchEvent(ev);
                  }
                });
              }
              if (state.mapCompleteInput && !state.mapCompleteInput.__bound) {
                state.mapCompleteInput.__bound = true;
                state.mapCompleteInput.addEventListener('keydown', (e) => {
                  if (e.key === 'Enter') {
                    e.preventDefault();
                    if (mapCompleteAdd) mapCompleteAdd.click();
                  }
                });
                state.mapCompleteInput.addEventListener('mapcomplete', (e) => {
                  e.preventDefault();
                  const bookId = state.map.bookId;
                  if (!bookId) { toast('本を選択してください', 'warn'); return; }
                  const raw = state.mapCompleteInput.value || '';
                  const pages = homeParsePageList(raw);
                  if (!pages.length) { toast('ページ番号を入力してください', 'info'); return; }
                  const dateStr = mapClampToToday(state.map.completeDate || '');
                  state.map.completeDate = dateStr;
                  const bookTitle = state.mapBook?.selectedOptions?.[0]?.textContent || '本';
                  pages.forEach(p => {
                    try { window.StudyCalendar?.recordCompletion?.(bookId, p, bookTitle, dateStr); } catch (_) { }
                  });
                  state.mapCompleteInput.value = '';
                  state.mapDirty = true;
                  render(false);
                  toast(`完了を${pages.length}件追加しました`, 'ok');
                });
              }
              ov.addEventListener('click', (e) => { e.stopPropagation(); /* 外側クリックで閉じない */ });
              ['pointerdown', 'mousedown', 'touchstart'].forEach(ev => {
                ov.addEventListener(ev, (e) => { if (e.target === ov) e.stopPropagation(); });
              });
              const sheet = ov.querySelector('.study-menu-sheet');
              const header = ov.querySelector('.study-menu-head');
              if (sheet && header) {
                const enter = () => { state.freeze = true; };
                const leave = () => { state.freeze = false; };
                sheet.addEventListener('mouseenter', enter);
                sheet.addEventListener('mouseleave', leave);
                ov.addEventListener('mouseenter', enter);
                ov.addEventListener('mouseleave', leave);
                // ヘッダーのみドラッグ可
                let drag = null;
                const onDown = (e) => {
                  if (e.target.closest('button, input, textarea, select, a, [data-action]')) return;
                  const rect = sheet.getBoundingClientRect();
                  drag = { x: e.clientX, y: e.clientY, left: rect.left, top: rect.top };
                  sheet.classList.add('dragging');
                  window.addEventListener('pointermove', onMove);
                  window.addEventListener('pointerup', onUp, { once: true });
                };
                const onMove = (e) => {
                  if (!drag) return;
                  const dx = e.clientX - drag.x;
                  const dy = e.clientY - drag.y;
                  sheet.style.left = `${drag.left + dx}px`;
                  sheet.style.top = `${drag.top + dy}px`;
                };
                const onUp = () => {
                  drag = null;
                  sheet.classList.remove('dragging');
                  window.removeEventListener('pointermove', onMove);
                };
                header.addEventListener('pointerdown', onDown);
              }
              ov.querySelector('#studyMenuClose')?.addEventListener('click', close);
              ov.addEventListener('click', onAction);
              bindDrag();
              bindDnd();
              bindRowTap();
              return state;
            }
            function bindDrag() {
              const handles = [state.grip, state.head].filter(Boolean);
              if (!handles.length) return;
              const onDown = (e) => {
                if (e.target.closest('button, select, input, textarea, a, [data-action]')) return;
                const sheet = state.overlay?.querySelector('.study-menu-sheet');
                const rect = sheet?.getBoundingClientRect();
                if (sheet && e.currentTarget === sheet) {
                  const topPad = 32;
                  if ((e.clientY - (rect?.top || 0)) > topPad) return; // only top band starts drag
                }
                const startLeft = rect?.left ?? 0;
                const startTop = rect?.top ?? 0;
                state.drag = {
                  startY: e.clientY,
                  startX: e.clientX,
                  y: e.clientY,
                  x: e.clientX,
                  offsetX: startLeft,
                  offsetY: startTop,
                  w: rect?.width || 0,
                  h: rect?.height || 0
                };
                sheet?.classList.add('dragging');
                window.addEventListener('pointermove', onMove);
                window.addEventListener('pointerup', onUp, { once: true });
                e.preventDefault();
              };
              const onMove = (e) => {
                if (!state.drag) return;
                state.drag.y = e.clientY; state.drag.x = e.clientX;
                const dx = state.drag.x - state.drag.startX;
                const dy = state.drag.y - state.drag.startY;
                const rawX = (state.drag.offsetX || 0) + dx;
                const rawY = (state.drag.offsetY || 0) + dy;
                const maxX = Math.max(8, window.innerWidth - (state.drag.w || 300) - 8);
                const maxY = Math.max(8, window.innerHeight - (state.drag.h || 300) - 8);
                const clampedX = Math.min(Math.max(8, rawX), maxX);
                const clampedY = Math.min(Math.max(8, rawY), maxY);
                const sheet = state.overlay?.querySelector('.study-menu-sheet');
                state.pos = { x: clampedX, y: clampedY };
                if (sheet) {
                  sheet.style.left = `${clampedX}px`;
                  sheet.style.top = `${clampedY}px`;
                }
              };
              const onUp = () => {
                if (!state.drag) return;
                const sheet = state.overlay?.querySelector('.study-menu-sheet');
                sheet?.classList.remove('dragging');
                state.drag = null;
                window.removeEventListener('pointermove', onMove);
              };
              handles.forEach(h => h.addEventListener('pointerdown', onDown));
            }
            function animateReorder(listEl, prevRects) {
              if (!listEl || !prevRects) return;
              const rows = Array.from(listEl.querySelectorAll('.study-menu-row'));
              rows.forEach(row => {
                const prev = prevRects.get(row);
                const next = row.getBoundingClientRect();
                if (!prev || !next) return;
                const dx = prev.left - next.left;
                const dy = prev.top - next.top;
                if (!dx && !dy) return;
                const frames = [
                  { transform: `translate(${dx}px, ${dy}px)` },
                  { transform: 'translate(0,0)' }
                ];
                const timing = { duration: 260, easing: 'cubic-bezier(0.22, 1, 0.36, 1)' };
                if (typeof row.animate === 'function') {
                  row.animate(frames, timing);
                } else {
                  row.style.transform = frames[0].transform;
                  row.offsetHeight; // force reflow
                  row.style.transition = `transform ${timing.duration}ms ${timing.easing}`;
                  row.style.transform = frames[1].transform;
                  const cleanup = () => {
                    row.style.transition = '';
                    row.style.transform = '';
                    row.removeEventListener('transitionend', cleanup);
                  };
                  row.addEventListener('transitionend', cleanup);
                }
              });
            }
            function bindDnd() {
              if (!state.list || state.list.__boundDnd) return;
              state.list.__boundDnd = true;
              const stateDrag = { over: null, startOrder: [], currentOrder: [], raf: null, lastY: 0, lastDir: null, didDrop: false, draggingBreak: false };
              const clearDropHints = () => {
                state.list.querySelectorAll('.study-menu-row').forEach(row => {
                  row.classList.remove('drop-before', 'drop-after', 'drop-target');
                });
              };
              const getOrderKeys = () => Array.from(state.list.querySelectorAll('.study-menu-row'))
                .map(el => el.dataset.ev)
                .filter(Boolean);
              const resolveOrder = (keys) => {
                const out = [];
                const seen = new Set();
                (Array.isArray(keys) ? keys : []).forEach((key) => {
                  if (key == null) return;
                  const ev = findEvent(key);
                  const id = ev ? ev.id : key;
                  const nid = normId(id);
                  if (!nid || seen.has(nid)) return;
                  seen.add(nid);
                  out.push(id);
                });
                return out;
              };
              const getOtherRows = () => Array.from(state.list.querySelectorAll('.study-menu-row'))
                .filter(row => row.dataset.ev && row.dataset.ev !== state.draggingId);
              const findDropTarget = (clientY) => {
                const rows = getOtherRows();
                if (!rows.length) return { row: null, before: true };
                const listRect = state.list.getBoundingClientRect();
                if (clientY < listRect.top + 6) return { row: rows[0], before: true };
                if (clientY > listRect.bottom - 6) return { row: rows[rows.length - 1], before: false };
                let target = null;
                for (const row of rows) {
                  const rect = row.getBoundingClientRect();
                  if (clientY >= rect.top && clientY <= rect.bottom) { target = row; break; }
                }
                if (!target) {
                  let closest = null;
                  let minDist = Infinity;
                  rows.forEach(row => {
                    const rect = row.getBoundingClientRect();
                    const mid = rect.top + rect.height / 2;
                    const dist = Math.abs(clientY - mid);
                    if (dist < minDist) { minDist = dist; closest = row; }
                  });
                  target = closest;
                }
                if (!target) return { row: null, before: true };
                const rect = target.getBoundingClientRect();
                const ratio = rect.height ? (clientY - rect.top) / rect.height : 0.5;
                const dir = stateDrag.lastDir || (clientY >= stateDrag.lastY ? 'down' : 'up');
                const threshold = dir === 'down' ? 0.38 : 0.62;
                return { row: target, before: ratio < threshold };
              };
              const applyDragPosition = (clientY) => {
                if (!state.draggingId) return;
                const dragRow = state.list.querySelector(`.study-menu-row[data-ev="${state.draggingId}"]`);
                if (!dragRow) return;
                const { row, before } = findDropTarget(clientY);
                const key = row ? `${row.dataset.ev}-${before ? 'before' : 'after'}` : 'end';
                if (stateDrag.over === key) return;
                stateDrag.over = key;
                const prevRects = new Map();
                state.list.querySelectorAll('.study-menu-row').forEach(el => prevRects.set(el, el.getBoundingClientRect()));
                clearDropHints();
                if (row) {
                  row.classList.add('drop-target', before ? 'drop-before' : 'drop-after');
                  if (before) row.parentNode.insertBefore(dragRow, row);
                  else row.parentNode.insertBefore(dragRow, row.nextSibling);
                } else {
                  state.list.appendChild(dragRow);
                }
                animateReorder(state.list, prevRects);
                stateDrag.currentOrder = getOrderKeys();
              };
              const scheduleDragMove = (clientY) => {
                if (clientY > stateDrag.lastY) stateDrag.lastDir = 'down';
                else if (clientY < stateDrag.lastY) stateDrag.lastDir = 'up';
                stateDrag.lastY = clientY;
                if (stateDrag.raf) return;
                stateDrag.raf = requestAnimationFrame(() => {
                  stateDrag.raf = null;
                  applyDragPosition(stateDrag.lastY);
                });
              };
              const autoScroll = (clientY) => {
                const scroller = state.scroll || state.list;
                if (!scroller || typeof scroller.scrollTop !== 'number') return;
                const rect = scroller.getBoundingClientRect();
                const edge = 36;
                if (clientY < rect.top + edge) {
                  scroller.scrollTop -= Math.ceil((rect.top + edge - clientY) / 6);
                } else if (clientY > rect.bottom - edge) {
                  scroller.scrollTop += Math.ceil((clientY - (rect.bottom - edge)) / 6);
                }
              };
              const finishDrag = (opts = {}) => {
                const dropInside = !!opts.dropInside;
                const isBreakDrag = stateDrag.draggingBreak || state.draggingId === BREAK_GHOST_ID;
                if (!state.draggingId && !stateDrag.draggingBreak) {
                  clearDropHints();
                  return;
                }
                const draggedRow = state.list.querySelector('.study-menu-row.dragging');
                if (draggedRow) draggedRow.classList.remove('dragging');
                state.list.classList.remove('dragging');
                clearDropHints();
                if (state.draggingId) {
                  const keys = getOrderKeys();
                  if (isBreakDrag) {
                    if (dropInside) {
                      insertBreakAtOrderKeys(keys);
                    }
                    removeBreakGhostRow();
                  } else {
                    const changed = keys.join(',') !== stateDrag.startOrder.join(',');
                    if (changed) {
                      const resolved = resolveOrder(keys);
                      if (resolved.length) applyOrder(resolved);
                    }
                  }
                }
                if (state.breakBtn) state.breakBtn.classList.remove('dragging');
                state.draggingId = null;
                stateDrag.over = null;
                stateDrag.startOrder = [];
                stateDrag.currentOrder = [];
                stateDrag.lastDir = null;
                stateDrag.draggingBreak = false;
                stateDrag.didDrop = false;
                if (stateDrag.raf) { cancelAnimationFrame(stateDrag.raf); stateDrag.raf = null; }
              };
              state.list.addEventListener('dragstart', (e) => {
                const row = e.target.closest('.study-menu-row');
                if (!row || !row.dataset.ev) return;
                state.draggingId = row.dataset.ev;
                stateDrag.startOrder = getOrderKeys();
                stateDrag.currentOrder = stateDrag.startOrder.slice();
                stateDrag.over = null;
                stateDrag.lastY = e.clientY;
                stateDrag.lastDir = null;
                stateDrag.didDrop = false;
                stateDrag.draggingBreak = state.draggingId === BREAK_GHOST_ID;
                row.classList.add('dragging');
                state.list.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', state.draggingId);
              });
              state.list.addEventListener('dragover', (e) => {
                if (!state.draggingId) return;
                e.preventDefault();
                if (e.dataTransfer) e.dataTransfer.dropEffect = stateDrag.draggingBreak ? 'copy' : 'move';
                autoScroll(e.clientY);
                scheduleDragMove(e.clientY);
              });
              state.list.addEventListener('drop', (e) => {
                if (!state.draggingId) return;
                e.preventDefault();
                stateDrag.didDrop = true;
              });
              state.list.addEventListener('dragend', () => {
                finishDrag({ dropInside: true });
              });
              if (state.breakBtn && !state.breakBtn.__boundDrag) {
                state.breakBtn.__boundDrag = true;
                state.breakBtn.addEventListener('dragstart', (e) => {
                  if (!state.list) return;
                  if (state.view !== 'list') {
                    state.view = 'list';
                    render(false);
                  }
                  const row = ensureBreakGhostRow();
                  state.draggingId = BREAK_GHOST_ID;
                  stateDrag.startOrder = getOrderKeys();
                  stateDrag.currentOrder = stateDrag.startOrder.slice();
                  stateDrag.over = null;
                  stateDrag.lastY = e.clientY;
                  stateDrag.lastDir = null;
                  stateDrag.didDrop = false;
                  stateDrag.draggingBreak = true;
                  if (row) row.classList.add('dragging');
                  state.list.classList.add('dragging');
                  state.breakBtn.classList.add('dragging');
                  if (e.dataTransfer) {
                    e.dataTransfer.effectAllowed = 'copy';
                    e.dataTransfer.setData('text/plain', BREAK_GHOST_ID);
                  }
                });
                state.breakBtn.addEventListener('dragend', () => {
                  finishDrag({ dropInside: stateDrag.didDrop });
                });
              }
              state.list.addEventListener('dragleave', (e) => {
                if (!state.draggingId) return;
                const rel = e.relatedTarget;
                if (rel && state.list.contains(rel)) return;
                clearDropHints();
              });
            }
            function bindRowTap() {
              if (!state.list || state.list.__boundTap) return;
              state.list.__boundTap = true;
              state.list.addEventListener('click', (e) => {
                const row = e.target.closest('.study-menu-row');
                if (!row || e.target.closest('.study-menu-row-buttons') || e.target.closest('[data-action]')) return;
                const evId = row.dataset.ev;
                if (evId) jumpTo(evId);
              });
            }
            function reorderByIds(srcId, dstId, before = true) {
              if (!srcId || !dstId || !requireStudy()) return;
              const ids = Array.isArray(StudyMgr.pageIds) ? StudyMgr.pageIds.slice() : [];
              const si = findIdx(srcId), di = findIdx(dstId);
              if (si < 0 || di < 0) return;
              const moved = ids.splice(si, 1)[0];
              const insertAt = before ? di : di + (si < di ? 0 : 1);
              ids.splice(insertAt, 0, moved);
              applyOrder(ids);
              render(false);
            }
            const todoList = () => {
              if (typeof TodoStore !== 'undefined' && TodoStore && typeof TodoStore.all === 'function') return TodoStore.all();
              if (window.TodoStore && typeof window.TodoStore.all === 'function') return window.TodoStore.all();
              return [];
            };
            const todoRemaining = (todo) => {
              if (!todo) return [];
              if (typeof TodoUI?.remainingPages === 'function') return TodoUI.remainingPages(todo);
              const doneSet = new Set(todo.completedPages || []);
              return Array.isArray(todo.pages) ? todo.pages.filter(p => !doneSet.has(p)) : [];
            };
            const isTodoDone = (todo) => {
              if (!todo) return true;
              const remain = todoRemaining(todo);
              if (remain.length > 0) return false;
              if (Array.isArray(todo.pages) && todo.pages.length) {
                return todo.completedPages?.length >= todo.pages.length;
              }
              return !!todo.done;
            };
            const TODO_COLOR_MODE_KEY = 'todo-color-mode';
            const TODO_CUSTOM_COLORS_KEY = 'todo-custom-colors';
            const TODO_DEFAULT_COLORS = ['#4da3ff', '#51cf66', '#ffd43b', '#a78bfa', '#fb7185', '#38bdf8', '#fb923c'];
            const normalizeTodoColors = (list) => {
              const seen = new Set();
              const items = Array.isArray(list) ? list : [];
              return items.map(c => String(c || '').trim()).filter(c => {
                if (!/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(c)) return false;
                const key = c.toLowerCase();
                if (seen.has(key)) return false;
                seen.add(key);
                return true;
              }).map(c => c.toLowerCase());
            };
            const loadTodoPaletteConfig = () => {
              let mode = 'default';
              let colors = [];
              try { mode = localStorage.getItem(TODO_COLOR_MODE_KEY) || 'default'; } catch (_) { }
              try { colors = JSON.parse(localStorage.getItem(TODO_CUSTOM_COLORS_KEY) || '[]'); } catch (_) { colors = []; }
              return { mode: mode === 'custom' ? 'custom' : 'default', colors: normalizeTodoColors(colors) };
            };
            const saveTodoPaletteMode = (mode) => {
              try { localStorage.setItem(TODO_COLOR_MODE_KEY, mode === 'custom' ? 'custom' : 'default'); } catch (_) { }
            };
            const saveTodoCustomColors = (colors) => {
              try { localStorage.setItem(TODO_CUSTOM_COLORS_KEY, JSON.stringify(normalizeTodoColors(colors))); } catch (_) { }
            };
            let todoPalette = TODO_DEFAULT_COLORS.slice();
            let todoColorCycle = [];
            let todoColorIndex = 0;
            let todoColorLast = null;
            const refreshTodoPalette = () => {
              const cfg = loadTodoPaletteConfig();
              const useCustom = cfg.mode === 'custom' && cfg.colors.length > 0;
              todoPalette = (useCustom ? cfg.colors : TODO_DEFAULT_COLORS).slice();
              todoColorCycle = [];
              todoColorIndex = 0;
              todoColorLast = null;
            };
            refreshTodoPalette();
            try {
              window.__getTodoPaletteConfig = loadTodoPaletteConfig;
              window.__setTodoPaletteMode = (mode) => { saveTodoPaletteMode(mode); refreshTodoPalette(); };
              window.__setTodoCustomColors = (colors) => { saveTodoCustomColors(colors); refreshTodoPalette(); };
              window.__todoDefaultPalette = TODO_DEFAULT_COLORS.slice();
              window.__refreshTodoPalette = refreshTodoPalette;
            } catch (_) { }
            const shuffleTodoColors = () => {
              const base = todoPalette.length ? todoPalette : TODO_DEFAULT_COLORS;
              const arr = base.slice();
              for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                const tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp;
              }
              if (todoColorLast && arr.length > 1 && arr[0] === todoColorLast) {
                const swapIdx = 1 + Math.floor(Math.random() * (arr.length - 1));
                const tmp = arr[0]; arr[0] = arr[swapIdx]; arr[swapIdx] = tmp;
              }
              return arr;
            };
            const pickColor = () => {
              if (!todoColorCycle.length || todoColorIndex >= todoColorCycle.length) {
                todoColorCycle = shuffleTodoColors();
                todoColorIndex = 0;
              }
              const color = todoColorCycle[todoColorIndex++] || (todoPalette[0] || TODO_DEFAULT_COLORS[0]);
              todoColorLast = color;
              return color;
            };
            let plannerRefreshPending = false;
            let scheduledCache = { rev: 0, map: new Map() };
            function invalidateScheduleCache() {
              scheduledCache = { rev: '', map: null };
              // Also increment a global modification counter to force UI refresh
              window.__nlRev = (window.__nlRev || 0) + 1;
              try { window.__invalidateScheduleCache = invalidateScheduleCache; } catch (_) { }
            }
            try { window.__invalidateScheduleCache = invalidateScheduleCache; } catch (_) { }
            const queuePlannerRefresh = () => {
              if (plannerRefreshPending) return;
              plannerRefreshPending = true;
              requestAnimationFrame(() => {
                plannerRefreshPending = false;
                try { drawPlanner && drawPlanner(); } catch (_) { }
                try { nlRebuildAll && nlRebuildAll(); } catch (_) { }
                try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (_) { }
                try { updateOverallStudyUI && updateOverallStudyUI(); } catch (_) { }
                try { ReaderHpBar && ReaderHpBar.update && ReaderHpBar.update(studyNowMs()); } catch (_) { }
                try { refreshPlannerFlyClock && refreshPlannerFlyClock(true); } catch (_) { }
                try { renderNumberlineFly && renderNumberlineFly(); } catch (_) { }
              });
            };
            function scheduleTodoPages(todo, pages, opts = {}) {
              if (!pages || !pages.length) { toast('追加できるページがありません', 'error'); return; }
              const valid = pages.map(p => parseInt(p, 10)).filter(n => Number.isFinite(n) && n > 0);
              if (!valid.length) { toast('ページ番号が不正です', 'error'); return; }
              // 既に同じToDo・同じページが予定化されているものを除外
              const existing = new Set();
              if (Array.isArray(NLStore?.events)) {
                NLStore.events.forEach(ev => {
                  if (ev && ev.todoId && Number.isFinite(ev.pageNumber)) {
                    existing.add(`${ev.todoId}-${ev.pageNumber}`);
                  }
                });
              }
              const filtered = valid.filter(pg => !existing.has(`${todo?.id || 'bulk'}-${pg}`));
              if (!filtered.length) {
                if (!opts.silent) toast('すでに予定に追加済みです', 'info');
                return false;
              }
              const per = Math.max(1, parseInt(todo?.perPage, 10) || 5);
              const nowMs = (typeof studyNowMs === 'function') ? studyNowMs() : Date.now();
              let tail = nowMs;
              if (Array.isArray(NLStore?.events)) {
                NLStore.events.forEach(ev => {
                  if (ev && ev.kind === 'study' && Number.isFinite(ev.end)) tail = Math.max(tail, ev.end);
                });
              }
              if (Array.isArray(StudyMgr?.pageIds)) {
                StudyMgr.pageIds.forEach(id => {
                  const ev = NLStore?.events?.find(e => e.id === id);
                  if (ev && Number.isFinite(ev.end)) tail = Math.max(tail, ev.end);
                });
              }
              let cursor = new Date(Math.floor(tail / 60000) * 60000);
              const newIds = [];
              filtered.slice(0, 200).forEach((pg, idx) => {
                const start = new Date(cursor.getTime());
                const end = new Date(cursor.getTime() + per * 60000);
                const ev = NLStore.addAbs(start, end, `${todo?.title || 'ToDo'} p${pg}`, pickColor(idx, todo?.id), 'study');
                if (ev) {
                  ev.pageKey = `todo-${todo?.id || 'bulk'}-${pg}`;
                  ev.pageNumber = pg;
                  ev.todoId = todo?.id || null;
                  ev.bookId = todo?.bookId || null;
                  ev.bookTitle = todo?.bookTitle || '';
                  newIds.push(ev.id);
                }
                cursor = new Date(end.getTime());
              });
              if (!newIds.length) { toast('予定を作成できませんでした', 'error'); return; }
              // Only keep pageIds that still exist in NLStore
              const validExistingIds = new Set(NLStore.events.map(ev => ev.id));
              const currentValid = Array.isArray(StudyMgr.pageIds)
                ? StudyMgr.pageIds.filter(id => validExistingIds.has(id))
                : [];
              const merged = [...currentValid];
              newIds.forEach(id => { if (!merged.includes(id)) merged.push(id); });
              // Clear intentional end flag since user is actively adding pages
              StudyMgr.__intentionalEnd = false;
              StudyMgr.active = true;
              StudyMgr.pageIds = merged;
              StudyMgr.save && StudyMgr.save();
              StudyUI.update && StudyUI.update();
              setCompleteBtnText();
              NLStore.save();
              invalidateScheduleCache();
              queuePlannerRefresh();
              if (!opts.silent) toast(`${valid.length}ページを予定に追加しました`, 'success');
              return true;
            }
            function unscheduleTodoPage(todoId, page) {
              if (!todoId || !Number.isFinite(page)) return false;
              const before = NLStore.events.length;
              NLStore.events = NLStore.events.filter(ev => !(ev && ev.todoId === todoId && ev.pageNumber === page));
              const removedIds = new Set();
              NLStore.events.forEach(ev => { if (!removedIds.has(ev?.id) && ev?.todoId === todoId && ev?.pageNumber === page) removedIds.add(ev.id); });
              if (Array.isArray(StudyMgr?.pageIds)) {
                StudyMgr.pageIds = StudyMgr.pageIds.filter(id => {
                  const ev = NLStore.events.find(e => e.id === id);
                  return ev && !(ev.todoId === todoId && ev.pageNumber === page);
                });
                StudyMgr.save && StudyMgr.save();
              }
              NLStore.save();
              invalidateScheduleCache();
              queuePlannerRefresh();
              return before !== NLStore.events.length;
            }
            function fillTodoSelect() {
              if (!state.todoSel) return;
              const active = todoList().filter(t => !isTodoDone(t));
              const prev = state.todoSel.value;
              state.todoSel.innerHTML = '<option value="">' + 'ToDoを選択...' + '</option>' + active.map(t => {
                const remain = todoRemaining(t).length;
                return `<option value="${t.id}">${esc(t.title || '無題')}${remain ? ` (${remain}p残)` : ''}</option>`;
              }).join('');
              if (prev && active.some(t => t.id === prev)) state.todoSel.value = prev;
            }
            function bindTodoInlineActions() {
              if (!state.todoInline || state.todoInline.__bound) return;
              state.todoInline.__bound = true;
              // Track last clicked page per todo for Shift range selection
              const lastClickedPage = {};

              const applyBtn = (btn, modeOverride, ev) => {
                if (!btn) return;
                const id = btn.dataset.todo;
                const page = parseInt(btn.dataset.page || '', 10);
                const todo = todoList().find(t => t.id === id);
                if (!todo) return;

                const schedMap = buildScheduledMap();
                const scheduledSet = (schedMap.live || schedMap).get(todo.id) || new Set();
                const doneSet = new Set(todo.completedPages || []);
                const act = btn.dataset.todoAction;

                if (act === 'plan-remaining') {
                  const remain = todoRemaining(todo);
                  if (remain.length === 0) {
                    toast('追加できるページがありません', 'info');
                    return;
                  }
                  scheduleTodoPages(todo, remain);
                  invalidateScheduleCache();
                  render(false);
                  toast(`${remain.length}ページを予定に追加しました`, 'success');
                  return;
                }
                if (act === 'open-book') {
                  try { TodoUI && TodoUI.openBookAt && TodoUI.openBookAt(todo, Number.isFinite(page) ? page : undefined); } catch (_) { }
                  return;
                }
                if (act === 'page-add') {
                  if (!Number.isFinite(page)) return;

                  const pausedMap = schedMap.paused || new Map();
                  const pausedSet = pausedMap.get(todo.id) || new Set();

                  // Shift+click for range selection
                  if (ev && ev.shiftKey && lastClickedPage[id] !== undefined) {
                    const startPage = Math.min(lastClickedPage[id], page);
                    const endPage = Math.max(lastClickedPage[id], page);
                    const allPages = Array.isArray(todo.pages) ? todo.pages : [];
                    const range = allPages.filter(p => p >= startPage && p <= endPage && !doneSet.has(p) && !scheduledSet.has(p));
                    if (range.length > 0) {
                      scheduleTodoPages(todo, range);
                      invalidateScheduleCache();
                      render(false);
                      toast(`${range.length}ページを一括追加しました`, 'success');
                    }
                    return;
                  }

                  // Remember last clicked page for range selection
                  lastClickedPage[id] = page;

                  // If paused (yellow), move from paused to active
                  if (pausedSet.has(page)) {
                    const removeFn = typeof removePausedPage === 'function' ? removePausedPage : window.__removePausedPage;
                    if (removeFn) removeFn(todo.id, page);
                    scheduleTodoPages(todo, [page]);
                    invalidateScheduleCache();
                    render(false);
                    toast('中断から予定に移動しました', 'success');
                    return;
                  }

                  if (doneSet.has(page)) {
                    TodoStore.togglePage(todo.id, page);
                    toast('完了を解除しました', 'info');
                    invalidateScheduleCache();
                    render(false);
                    return;
                  }
                  const removing = modeOverride === 'remove' || scheduledSet.has(page);
                  if (removing) {
                    unscheduleTodoPage(todo.id, page);
                    invalidateScheduleCache();
                    render(false);
                    return;
                  }
                  if (ev && (ev.metaKey || ev.ctrlKey || ev.altKey)) {
                    try { TodoUI && TodoUI.openBookAt && TodoUI.openBookAt(todo, page); } catch (_) { }
                    return;
                  }
                  scheduleTodoPages(todo, [page]);
                  invalidateScheduleCache();
                  render(false);
                }
              };
              state.todoInline.addEventListener('click', (e) => {
                const btn = e.target.closest('[data-todo-action]');
                if (!btn) return;
                applyBtn(btn, null, e);
              });
            }
            let showArchive = false;
            function buildScheduledMap() {
              const rev = window.__nlRev || NLStore?.__rev || 0;
              let pausedSig = '';
              try {
                const pausedRaw = localStorage.getItem(PAUSE_KEY) || '';
                // Use length + hash of content for better cache invalidation
                pausedSig = `${pausedRaw.length}:${pausedRaw.slice(0, 100)}:${pausedRaw.slice(-50)}`;
              } catch (_) { pausedSig = ''; }
              const cacheKey = `${rev}:${pausedSig}`;
              if (scheduledCache.rev === cacheKey && scheduledCache.map) return scheduledCache.map;
              const map = new Map();
              const liveMap = new Map();
              const pausedMap = new Map();
              const add = (target, todoId, page) => {
                if (!target.has(todoId)) target.set(todoId, new Set());
                target.get(todoId).add(page);
              };
              if (Array.isArray(NLStore?.events)) {
                NLStore.events.forEach(ev => {
                  if (ev && ev.todoId && Number.isFinite(ev.pageNumber)) {
                    add(map, ev.todoId, ev.pageNumber);
                    add(liveMap, ev.todoId, ev.pageNumber);
                  }
                });
              }
              // paused entries also count as scheduled to keep button states after中断
              try {
                const paused = loadPausedList();
                paused.forEach(ent => {
                  (ent.events || []).forEach(ev => {
                    if (ev && ev.todoId && Number.isFinite(ev.pageNumber)) {
                      add(map, ev.todoId, ev.pageNumber);
                      add(pausedMap, ev.todoId, ev.pageNumber);
                    }
                  });
                });
              } catch (_) { }
              map.live = liveMap;
              map.paused = pausedMap;
              scheduledCache = { rev: cacheKey, map };
              return map;
            }
            function toggleSchedule(todoId, page) {
              const todo = todoList().find(t => t.id === todoId);
              if (!todo || !Number.isFinite(page)) {
                console.log('[toggleSchedule] Invalid todo or page:', todoId, page);
                return;
              }

              // Force cache invalidation before checking
              invalidateScheduleCache();
              const schedMap = buildScheduledMap();
              const scheduled = (schedMap.live || schedMap).get(todoId) || new Set();
              const doneSet = new Set(todo.completedPages || []);

              if (scheduled.has(page)) {
                console.log('[toggleSchedule] Removing page from schedule:', page);
                unscheduleTodoPage(todoId, page);
              } else {
                if (doneSet.has(page)) {
                  console.log('[toggleSchedule] Page already done, skipping:', page);
                  return;
                }
                console.log('[toggleSchedule] Adding page to schedule:', page);
                scheduleTodoPages(todo, [page], { silent: true });
              }

              // Ensure cache is invalidated again after changes
              invalidateScheduleCache();
              render();
            }
            function renderTodoInline() {
              if (!state.todoInline) return;
              // Force fresh data on every render
              invalidateScheduleCache();
              const scheduledMap = buildScheduledMap();
              const pausedMap = scheduledMap.paused || new Map();
              const todayScheduleMap = getTodayScheduleMap();
              const active = todoList().filter(t => !isTodoDone(t));
              if (!active.length) {
                state.todoInline.innerHTML = '<div class="muted" style="font-size:11px;">未完了のToDoはありません（フォームで追加してください）</div>';
                bindTodoInlineActions();
                return;
              }
              state.todoInline.innerHTML = active.map(t => {
                const remainList = todoRemaining(t);
                const total = Array.isArray(t.pages) ? t.pages.length : 0;
                const eta = Math.max(1, Math.round(remainList.length * Math.max(1, parseInt(t.perPage, 10) || 5)));
                const scheduled = (scheduledMap.live || scheduledMap).get(t.id) || new Set();
                const paused = pausedMap.get(t.id) || new Set();
                const doneSet = new Set(t.completedPages || []);
                const todayPages = todayScheduleMap.get(String(t.id)) || new Set();
                const pageList = Array.isArray(t.pages) && t.pages.length ? t.pages : remainList;
                const pages = pageList.slice(0, 120).map(p => {
                  const cls = ['study-todo-page'];
                  const num = normalizeTodoPage(p);
                  if (num != null && todayPages.has(num)) cls.push('today-assigned');
                  if (doneSet.has(p)) cls.push('done');
                  else if (scheduled.has(p)) cls.push('scheduled');
                  else if (paused.has(p)) cls.push('paused');
                  return `<button class="${cls.join(' ')}" data-todo-action="page-add" data-todo="${t.id}" data-page="${p}">p${p}</button>`;
                }).join('') || '<span class="tiny" style="color:var(--muted)">ページなし</span>';
                const bookLabel = t.bookTitle ? esc(t.bookTitle) : '紐付けなし';
                return `<div class="study-todo-mini" data-todo="${t.id}">
          <div class="head">
            <div class="title">${esc(t.title || '無題')}</div>
            <div class="meta">${esc(`残り ${remainList.length}/${total || 0}p`)} / ${esc(`約${eta}分`)} / ${esc(bookLabel)}</div>
          </div>
          <div class="actions">
            <button class="mini-menu" data-todo-action="plan-remaining" data-todo="${t.id}">残りを予定に入れる</button>
            <button class="mini-menu ghost" data-todo-action="open-book" data-todo="${t.id}">本で開く</button>
          </div>
          <div class="pages" title="クリック:追加 / Shift+クリック:範囲追加 / Ctrl+クリック:ジャンプ">${pages}</div>
        </div>`;
              }).join('');
              bindTodoInlineActions();
            }
            function gather() {
              ensureStudyDataLoaded();
              const now = studyNowMs();
              if (!window.StudyMgr || !StudyMgr.active) {
                const history = Array.isArray(StudyMgr?.doneHistory) ? StudyMgr.doneHistory : [];
                return { now, events: history.map(ev => ({ ...ev, _history: true })), ids: [], delay: {} };
              }
              const ids = Array.isArray(StudyMgr.pageIds) ? StudyMgr.pageIds.slice() : [];
              const delay = (StudyMgr && StudyMgr.delay) ? StudyMgr.delay : {};
              const events = ids.map((id, idx) => {
                const raw = (window.NLStore && Array.isArray(NLStore.events)) ? NLStore.events.find(e => normId(e?.id) === normId(id)) : null;
                const ev = normalizeEvent(raw);
                if (!ev) return null;
                return { ...ev, todoId: raw?.todoId, pageNumber: raw?.pageNumber, color: raw?.color, _idx: idx, _normId: normId(ev.id || id) };
              }).filter(Boolean);
              const history = Array.isArray(StudyMgr.doneHistory) ? StudyMgr.doneHistory.map(ev => ({ ...ev, _history: true })) : [];
              return { now, ids, delay, events: events.concat(history) };
            }
            function statusInfo(ev, now, delayMap) {
              const d = delayMap && delayMap[ev.id];
              const baseEnd = (d && ('baseEnd' in d)) ? d.baseEnd : ev.end;
              const overtimeMs = d && ('baseEnd' in d) ? Math.max(0, now - d.baseEnd) : 0;
              const remainMs = Math.max(0, ev.end - now);
              const status = (now < ev.start) ? 'upcoming' : (remainMs <= 0 ? 'done' : 'active');
              const label = overtimeMs > 0 ? '延長中' : (status === 'active' ? '進行中' : (status === 'upcoming' ? 'これから' : '完了済み'));
              return { status, label, overtimeMs, remainMs, baseEnd };
            }
            function resetOvertimeForReorder(ids) {
              if (!window.StudyMgr || !StudyMgr.delay || !Array.isArray(NLStore?.events)) return;
              const list = Array.isArray(ids) ? ids : (Array.isArray(StudyMgr.pageIds) ? StudyMgr.pageIds : []);
              let changed = false;
              list.forEach((id) => {
                const ev = NLStore.events.find(e => normId(e?.id) === normId(id));
                if (!ev) return;
                const d = StudyMgr.delay?.[ev.id];
                if (!d) return;
                const baseDur = Math.max(60000, Number.isFinite(d.baseDurationMs)
                  ? d.baseDurationMs
                  : (Number.isFinite(d.baseEnd) ? d.baseEnd - ev.start : (ev.end - ev.start)));
                ev.end = ev.start + baseDur;
                try { delete StudyMgr.delay[ev.id]; } catch (_) { }
                changed = true;
              });
              if (changed) {
                try { ReaderHpBar && ReaderHpBar.resetOvertimeState && ReaderHpBar.resetOvertimeState(); } catch (_) { }
              }
            }
            function applyOrder(ids) {
              if (!window.StudyMgr) return;
              // Reset overtime state on reorder to avoid carrying overtime into swapped schedules
              resetOvertimeForReorder(ids);
              StudyMgr.pageIds = ids.filter(Boolean);
              StudyMgr.save && StudyMgr.save();
              try { __rebuildStudyChainFrom(studyNowMs()); } catch (_) { }
              try { StudyUI && StudyUI.update && StudyUI.update(); } catch (_) { }
              try { ReaderHpBar && ReaderHpBar.update && ReaderHpBar.update(studyNowMs()); } catch (_) { }
              try { queuePlannerRefresh(); } catch (_) { }
            }
            function startFrom(evId) {
              if (!evId || !requireStudy()) return;
              const ids = Array.isArray(StudyMgr.pageIds) ? StudyMgr.pageIds.slice() : [];
              const idx = findIdx(evId);
              if (idx < 0) { toast('指定の予定が見つかりません', 'error'); return; }
              if (idx === 0) { toast('すでにこの予定から始まっています', 'info'); return; }
              const rotated = ids.slice(idx).concat(ids.slice(0, idx));
              applyOrder(rotated);
              toast('この予定から開始しました', 'success');
              render(false);
            }
            function move(evId, delta) {
              if (!evId || !requireStudy()) return;
              const ids = Array.isArray(StudyMgr.pageIds) ? StudyMgr.pageIds.slice() : [];
              const idx = findIdx(evId); if (idx < 0) { toast('指定の予定が見つかりません', 'error'); return; }
              const ni = Math.max(0, Math.min(ids.length - 1, idx + delta));
              if (ni === idx) { toast('これ以上動かせません', 'info'); return; }
              const moved = ids.splice(idx, 1)[0];
              ids.splice(ni, 0, moved);
              applyOrder(ids);
              toast('順番を更新しました', 'success');
              render(false);
            }
            function deleteEvent(evId) {
              if (!evId || !requireStudy()) return;
              const ids = Array.isArray(StudyMgr.pageIds) ? StudyMgr.pageIds.slice() : [];
              const target = normId(evId);
              const filtered = ids.filter(id => normId(id) !== target);
              if (filtered.length === ids.length) { toast('指定の予定が見つかりません', 'error'); return; }
              if (window.StudyMgr && StudyMgr.delay) { try { delete StudyMgr.delay[target]; } catch (_) { } }
              if (window.NLStore && Array.isArray(NLStore.events)) {
                NLStore.events = NLStore.events.filter(ev => normId(ev?.id) !== target);
                NLStore.save();
              }
              applyOrder(filtered);
              if (window.StudyMgr) {
                StudyMgr.active = filtered.length > 0;
                StudyMgr.save && StudyMgr.save();
              }
              toast('予定を削除しました', 'info');
              render(false);
            }
            function rebuildNow() {
              if (!requireStudy()) return;
              try {
                __rebuildStudyChainFrom(studyNowMs());
                render(false);
                toast('最新の時刻で並べ直しました', 'success');
              } catch (_) {
                toast('再構築に失敗しました', 'error');
              }
            }
            function cleanupStorage() {
              try {
                const beforeEvents = NLStore.events.length;
                NLStore.compact(true); // Aggressive cleanup
                NLStore.save();
                const afterEvents = NLStore.events.length;

                // Also clean up paused list - keep only last 20
                const paused = loadPausedList();
                if (paused.length > 20) {
                  savePausedList(paused.slice(-20));
                }

                invalidateScheduleCache();
                render(false);
                toast(`古いデータを整理しました (${beforeEvents} → ${afterEvents}イベント)`, 'success');
              } catch (e) {
                console.error('[cleanupStorage]', e);
                toast('整理に失敗しました', 'error');
              }
            }
            function resetAllSchedule() {
              const deepClean = confirm('すべての予定データをリセットしますか？\n\n• 現在の予定\n• 中断した予定\n• 予定履歴\n\nこの操作は元に戻せません。\n\n[OK] = リセット実行');
              if (!deepClean) return;

              console.log('[resetAllSchedule] Starting reset...');

              // Step 1: Clear localStorage items FIRST (before any save operations)
              const keysToRemove = ['nl_events_v1', PAUSE_KEY, 'studyMgr', 'study_mgr', 'StudyMgr'];
              keysToRemove.forEach(key => {
                try {
                  localStorage.removeItem(key);
                  console.log(`[resetAllSchedule] Removed ${key}`);
                } catch (e) {
                  console.warn(`[resetAllSchedule] Failed to remove ${key}:`, e);
                }
              });

              // Step 2: Clear in-memory data
              NLStore.events = [];
              NLStore.__rev = Date.now();
              window.__nlRev = NLStore.__rev;

              if (window.StudyMgr) {
                StudyMgr.active = false;
                StudyMgr.pageIds = [];
                StudyMgr.delay = {};
              }

              // Step 3: Clear schedule cache
              invalidateScheduleCache();

              // Step 4: Try to save the now-empty state (should succeed after clearing)
              try {
                localStorage.setItem('nl_events_v1', '[]');
                console.log('[resetAllSchedule] Saved empty events');
              } catch (e) {
                console.warn('[resetAllSchedule] Could not save empty events:', e);
              }

              // Step 5: Update UI
              try { StudyUI.update && StudyUI.update(); } catch (_) { }
              render(false);

              toast('すべての予定データをリセットしました', 'success');
              console.log('[resetAllSchedule] Complete');
            }
            function emergencyStorageClean() {
              // Show storage usage first
              let report = 'LocalStorage使用状況:\n\n';
              let totalSize = 0;
              const items = [];
              Object.keys(localStorage).forEach(key => {
                const size = (localStorage.getItem(key) || '').length * 2;
                totalSize += size;
                items.push({ key, size });
              });
              items.sort((a, b) => b.size - a.size);
              items.slice(0, 10).forEach(item => {
                const mb = (item.size / 1024 / 1024).toFixed(2);
                report += `${item.key}: ${mb} MB\n`;
              });
              report += `\n合計: ${(totalSize / 1024 / 1024).toFixed(2)} MB`;
              report += '\n\n大きなデータを削除して容量を確保しますか？';

              if (!confirm(report)) return;

              // Remove the largest items that are not critical
              const criticalKeys = ['books', 'bookList', 'todoList', 'memoData'];
              let freed = 0;
              items.forEach(item => {
                if (item.size > 100000 && !criticalKeys.some(k => item.key.includes(k))) {
                  try {
                    localStorage.removeItem(item.key);
                    freed += item.size;
                    console.log(`[emergencyStorageClean] Removed ${item.key} (${(item.size / 1024 / 1024).toFixed(2)} MB)`);
                  } catch (_) { }
                }
              });

              // Also clean old paused data
              try { localStorage.removeItem(PAUSE_KEY); } catch (_) { }
              try { localStorage.removeItem('nl_events_v1'); } catch (_) { }

              toast(`${(freed / 1024 / 1024).toFixed(2)} MB を解放しました`, 'success');
            }
            function recoverCurrent() {
              if (!requireStudy()) return;
              ensureStudyDataLoaded();
              const now = studyNowMs();
              const ctx = StudyMgr.currentAndNext(now);
              if (!ctx || ctx.curIdx < 0) { toast('回復できる予定がありません', 'error'); return; }
              const ev = ctx.events[ctx.curIdx];
              if (!ev) { toast('予定が見つかりません', 'error'); return; }
              const delayInfo = (StudyMgr.delay && StudyMgr.delay[ev.id]) ? StudyMgr.delay[ev.id] : null;
              const baseDur = Math.max(60000, delayInfo?.baseDurationMs ?? (delayInfo?.baseEnd ? delayInfo.baseEnd - ev.start : ev.end - ev.start));
              const start = now;
              ev.start = start;
              ev.end = start + baseDur;
              if (!StudyMgr.delay) StudyMgr.delay = {};
              StudyMgr.delay[ev.id] = { baseEnd: ev.end, baseDurationMs: baseDur, next: null, times: 0 };
              try { ReaderHpBar && ReaderHpBar.resetOvertimeState && ReaderHpBar.resetOvertimeState(); } catch (_) { }
              __rebuildStudyChainFrom(start);
              NLStore.save();
              try { StudyMgr.save && StudyMgr.save(); } catch (_) { }
              try { StudyUI.update && StudyUI.update(); ReaderHpBar && ReaderHpBar.update && ReaderHpBar.update(studyNowMs()); } catch (_) { }
              toast('残り時間をリセットしました', 'success');
              render(false);
            }
            function applySort() {
              if (!requireStudy()) return;
              const select = document.getElementById('studySortSelect');
              const mode = select ? select.value : 'manual';
              const ids = Array.isArray(StudyMgr.pageIds) ? StudyMgr.pageIds.slice() : [];
              const events = ids.map(id => NLStore.events.find(e => e.id === id)).filter(Boolean);
              const todoDue = (ev) => {
                if (!ev?.todoId) return null;
                const todos = (typeof TodoStore?.all === 'function') ? TodoStore.all() : (window.TodoStore && typeof window.TodoStore.all === 'function' ? window.TodoStore.all() : []);
                const hit = todos.find(t => t.id === ev.todoId);
                const due = hit?.due || hit?.deadline || hit?.dueDate || hit?.due_at || hit?.dueAt;
                const ts = due ? new Date(due).getTime() : null;
                return Number.isFinite(ts) ? ts : null;
              };
              const sorted = events.slice().sort((a, b) => {
                switch (mode) {
                  case 'time-asc': return (a.start || 0) - (b.start || 0);
                  case 'time-desc': return (b.start || 0) - (a.start || 0);
                  case 'page-asc': return (a.pageNumber ?? Infinity) - (b.pageNumber ?? Infinity);
                  case 'page-desc': return (b.pageNumber ?? -Infinity) - (a.pageNumber ?? -Infinity);
                  case 'todo-due': {
                    const da = todoDue(a) ?? Infinity;
                    const db = todoDue(b) ?? Infinity;
                    if (da === db) return (a.start || 0) - (b.start || 0);
                    return da - db;
                  }
                  default: return 0;
                }
              });
              const newIds = sorted.map(ev => ev.id).filter(Boolean);
              if (mode !== 'manual' && newIds.length) {
                applyOrder(newIds);
                toast('並び替えを適用しました', 'success');
                render(false);
              } else {
                toast('現在の順番を維持しました', 'info');
              }
            }
            function stopStudy() {
              if (!requireStudy()) return;
              try { pauseStudy(); } catch (_) { toast('中断できませんでした', 'error'); }
            }
            async function jumpTo(evId) {
              const targetId = normId(evId || state.currentEvId);
              if (!targetId) { toast('ジャンプできる予定がありません', 'error'); return; }
              const ev = findEvent(targetId);
              if (!ev) { toast('予定データが見つかりません', 'error'); return; }
              if (ev.todoId && window.TodoStore && typeof TodoStore.all === 'function' && window.TodoUI && typeof TodoUI.openBookAt === 'function') {
                const todo = TodoStore.all().find(t => t.id === ev.todoId);
                if (todo) { await TodoUI.openBookAt(todo, ev.pageNumber); return; }
              }
              const page = Number.isFinite(ev.pageNumber) ? ev.pageNumber : null;
              const targetBookId = ev.bookId || null;
              const waitForRender = async () => {
                for (let i = 0; i < 8; i++) {
                  await new Promise(res => setTimeout(res, i === 0 ? 16 : 80));
                  if (document.getElementById('jumpInput')) return;
                }
              };
              const jumpInsideViewer = (pg) => {
                const jump = document.getElementById('jumpInput'); const btn = document.getElementById('jumpGo');
                if (!jump) return false;
                jump.value = pg;
                btn?.click?.();
                return true;
              };
              const tryOpenBook = async (bookId) => {
                if (!bookId || typeof Book?.get !== 'function' || typeof mountBookViewer !== 'function') return false;
                try {
                  const book = await Book.get(bookId);
                  if (!book) return false;
                  const res = mountBookViewer(book);
                  if (res && typeof res.then === 'function') { await res; }
                  await waitForRender();
                  return true;
                } catch (_) { return false; }
              };
              const ensureViewerOpen = async () => {
                const currentBookId = viewerMemory?.book?.id || null;
                const readingReady = document.body?.classList.contains('reading') && document.getElementById('jumpInput');
                if (targetBookId && currentBookId && normId(targetBookId) !== normId(currentBookId)) {
                  if (await tryOpenBook(targetBookId)) return true;
                } else if (readingReady) {
                  return true;
                }
                if (await tryOpenBook(targetBookId)) return true;
                if (viewerMemory?.book?.id && !viewerMemory.book.closed) {
                  if (await tryOpenBook(viewerMemory.book.id)) return true;
                }
                try { showTab && showTab('library', { preserveOpenTab: true }); } catch (_) { }
                await waitForRender();
                return document.getElementById('jumpInput') != null;
              };
              if (page != null) {
                const ready = await ensureViewerOpen();
                if (ready && jumpInsideViewer(page)) return;
                toast('ページを開けませんでした', 'error');
                return;
              }
              toast('ジャンプできるページ情報がありません', 'error');
            }
            function completeNow() {
              if (hasStudy()) {
                try { StudyMgr && StudyMgr.completePageNow && StudyMgr.completePageNow(); toast('このページを完了にしました', 'success'); } catch (_) { toast('完了処理に失敗しました', 'error'); }
                render(false);
                return;
              }
              let ok = false;
              try {
                if (typeof completeCurrentBookPage === 'function') {
                  ok = !!completeCurrentBookPage();
                } else if (typeof handlePlannerCompleteClick === 'function') {
                  handlePlannerCompleteClick();
                  ok = true;
                }
              } catch (_) { ok = false; }
              if (ok) {
                toast('このページを完了にしました', 'success');
              } else {
                toast('完了できるページがありません', 'error');
              }
              render(false);
            }
            function planTodoFromSelect() {
              if (!state.todoSel) return;
              const id = state.todoSel.value;
              if (!id) {
                toast('ToDoを選んでください', 'error');
                return;
              }
              const todo = todoList().find(t => t.id === id);
              if (todo) {
                const remain = todoRemaining(todo);
                scheduleTodoPages(todo, remain.length ? remain : (todo.pages || []));
                render(false);
                return;
              }
              try { TodoUI && TodoUI.planTodo && TodoUI.planTodo(id); toast('ToDoを予定に入れました', 'success'); } catch (_) { toast('ToDoを追加できませんでした', 'error'); }
              render(false);
            }
            function planAllTodos() {
              const active = todoList().filter(t => !isTodoDone(t));
              let total = 0;
              active.forEach(todo => {
                const remain = todoRemaining(todo);
                const targetPages = (remain.length ? remain : (todo.pages || [])).filter(n => Number.isFinite(n));
                if (!targetPages.length) return;
                const before = Array.isArray(NLStore?.events) ? NLStore.events.length : 0;
                const ok = scheduleTodoPages(todo, targetPages, { silent: true });
                const after = Array.isArray(NLStore?.events) ? NLStore.events.length : before;
                if (ok) total += Math.max(0, after - before);
              });
              if (total > 0) {
                toast(`未完のToDoから ${total}ページ を予定に追加しました`, 'success');
                render(false);
              } else {
                toast('追加できる未完ToDoがありません', 'error');
              }
            }
            function openTodoForm() {
              try { showTab && showTab('planner', { preserveOpenTab: true }); __activatePlannerTab && __activatePlannerTab('todo'); } catch (_) { }
              try { TodoUI && TodoUI.openForm && TodoUI.openForm(); } catch (_) { }
            }
            const loadPausedList = () => {
              try {
                const raw = localStorage.getItem(PAUSE_KEY) || '[]';
                const arr = JSON.parse(raw);
                return Array.isArray(arr) ? arr.filter(ent => ent && Array.isArray(ent.events)) : [];
              } catch (_) { return []; }
            };
            const savePausedList = (list) => { try { localStorage.setItem(PAUSE_KEY, JSON.stringify((list || []).slice(0, MAX_PAUSED))); } catch (_) { } };
            function renderPausedList() {
              if (!state.paused) return;
              const list = loadPausedList();
              const validIds = new Set(list.map(ent => ent?.id).filter(Boolean));
              Array.from(pausedSelection).forEach(id => { if (!validIds.has(id)) pausedSelection.delete(id); });
              if (!list.length) {
                state.paused.innerHTML = '<div class="muted" style="font-size:12px;">中断中の予定はありません</div>';
                return;
              }
              state.paused.innerHTML = list.map(ent => {
                const d = new Date(ent.savedAt || Date.now());
                const ts = `${pad2(d.getMonth() + 1)}/${pad2(d.getDate())} ${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
                const title = esc(ent.label || ent.events?.[ent.currentIndex || 0]?.title || '中断した予定');
                const count = Array.isArray(ent.events) ? ent.events.length : 0;
                const id = esc(ent.id || '');
                const selected = pausedSelection.has(ent.id);
                return `
              <div class="study-paused-row${selected ? ' selected' : ''}" data-id="${id}">
                <div class="row" style="gap:8px; align-items:flex-start;">
                  <input type="checkbox" class="paused-select" data-id="${id}" ${selected ? 'checked' : ''} />
                  <div>
                    <div class="title">${title}</div>
                    <div class="meta muted" style="font-size:12px;">${ts} ・ ${count}件</div>
                  </div>
                </div>
                <div class="study-menu-row-buttons">
                  <button class="mini-menu" data-action="rename-paused" data-id="${id}" title="名前を変更">✏️</button>
                  <button class="mini-menu" data-action="resume-paused" data-id="${id}">再開</button>
                  <button class="mini-menu ghost" data-action="delete-paused" data-id="${id}">削除</button>
                </div>
              </div>
            `;
              }).join('');
              state.paused.querySelectorAll('.paused-select').forEach(chk => {
                chk.addEventListener('change', (e) => {
                  const pid = chk.dataset.id || '';
                  if (!pid) return;
                  if (chk.checked) pausedSelection.add(pid); else pausedSelection.delete(pid);
                  chk.closest('.study-paused-row')?.classList.toggle('selected', chk.checked);
                });
              });
              if (!state.paused.__boundRowSel) {
                state.paused.__boundRowSel = true;
                state.paused.addEventListener('click', (e) => {
                  const row = e.target.closest('.study-paused-row');
                  if (!row || e.target.closest('button') || e.target.closest('input')) return;
                  const box = row.querySelector('.paused-select');
                  if (box) { box.checked = !box.checked; box.dispatchEvent(new Event('change')); }
                });
              }
            }
            const clonePausedEvent = (ev) => {
              if (!ev) return null;
              const dur = Math.max(60000, Math.round((ev.durationMs || ev.remainingMs || 60000) / 60000) * 60000);
              const rem = Math.max(60000, Math.round((ev.remainingMs || ev.durationMs || 60000) / 60000) * 60000);
              return {
                title: ev.title,
                color: ev.color,
                pageNumber: ev.pageNumber,
                todoId: ev.todoId,
                pageKey: ev.pageKey,
                bookId: ev.bookId || null,
                bookTitle: ev.bookTitle || null,
                kind: ev.kind || 'study',
                durationMs: dur,
                remainingMs: rem
              };
            };
            function mergePaused(ids) {
              const list = loadPausedList();
              const targetIds = Array.isArray(ids) ? ids.filter(Boolean) : Array.from(pausedSelection);
              const idsToUse = targetIds.length ? targetIds : list.map(ent => ent?.id).filter(Boolean);
              const targets = list.filter(ent => ent && idsToUse.includes(ent.id));
              if (targets.length < 2) { toast('統合する中断データを2つ以上選んでください', 'error'); return; }
              const mergedEvents = [];
              targets.forEach(ent => {
                (ent.events || []).forEach(ev => {
                  const cloned = clonePausedEvent(ev);
                  if (cloned) mergedEvents.push(cloned);
                });
              });
              if (!mergedEvents.length) { toast('統合できる予定がありません', 'error'); return; }
              const mergedLabel = (targets.find(t => t?.label)?.label || '中断した予定') + ' (統合)';
              const merged = { id: `paused-${Date.now()}`, savedAt: Date.now(), label: mergedLabel, currentIndex: 0, events: mergedEvents };
              const remaining = list.filter(ent => ent && !idsToUse.includes(ent.id));
              remaining.unshift(merged);
              savePausedList(remaining);
              pausedSelection.clear();
              renderPausedList();
              toast('中断した予定を統合しました', 'success');
            }
            function snapshotPausedPlan() {
              // Don't require study to be active - just check if there are pageIds
              ensureStudyDataLoaded();
              const now = studyNowMs();
              const ids = Array.isArray(StudyMgr?.pageIds) ? StudyMgr.pageIds.slice() : [];
              if (!ids.length) {
                console.log('[snapshotPausedPlan] No pageIds to snapshot');
                return null;
              }
              const events = ids.map(id => NLStore.events.find(e => e.id === id)).filter(Boolean);
              if (!events.length) {
                console.log('[snapshotPausedPlan] No matching events found');
                return null;
              }
              const ctx = StudyMgr.currentAndNext ? StudyMgr.currentAndNext(now) : { curIdx: 0 };
              const curIdx = Math.max(0, Math.min(events.length - 1, ctx?.curIdx ?? 0));
              const payload = events.map((ev, idx) => {
                const delayInfo = StudyMgr.delay?.[ev.id];
                const baseDur = Math.max(60000, delayInfo?.baseDurationMs ?? (delayInfo?.baseEnd ? delayInfo.baseEnd - ev.start : ev.end - ev.start));
                const delayTimes = Number.isFinite(delayInfo?.times) ? delayInfo.times : 0;
                const baseEndAbs = Number.isFinite(delayInfo?.baseEnd) ? delayInfo.baseEnd : ev.end;
                const baseEndRel = baseEndAbs - now; // 再開時はこの相対値を再適用
                const remain = Math.max(60000, ev.end - now);
                const dur = Math.max(60000, Math.round(((idx === curIdx ? remain : baseDur)) / 60000) * 60000);
                return {
                  title: ev.title,
                  color: ev.color,
                  pageNumber: ev.pageNumber,
                  todoId: ev.todoId,
                  pageKey: ev.pageKey,
                  bookId: ev.bookId || null,
                  bookTitle: ev.bookTitle || null,
                  kind: ev.kind || 'study',
                  durationMs: dur,
                  remainingMs: Math.max(60000, Math.round(remain / 60000) * 60000),
                  baseDurationMs: baseDur,
                  baseEndRel,
                  delayTimes
                };
              });
              return {
                id: `paused-${Date.now()}`,
                savedAt: now,
                label: `${events[curIdx]?.title || '予定'} を中断`,
                currentIndex: curIdx,
                events: payload
              };
            }
            function pauseStudy() {
              // Check if there are any study items to pause
              const hasItems = Array.isArray(StudyMgr?.pageIds) && StudyMgr.pageIds.length > 0;
              if (!hasItems) {
                toast('中断できる勉強予定がありません', 'error');
                return;
              }

              // Create snapshot BEFORE stopping or clearing anything
              const snap = snapshotPausedPlan();
              if (!snap || !snap.events || snap.events.length === 0) {
                toast('中断できる予定がありません（データが空です）', 'error');
                return;
              }

              // Save to paused list FIRST
              const list = loadPausedList();
              list.unshift(snap);
              savePausedList(list);
              console.log('[pauseStudy] Saved snapshot with', snap.events.length, 'events');

              // Keep a copy of the pageIds before clearing
              const pageIdsToClear = StudyMgr.pageIds.slice();

              // Now stop current chain
              try { StudyMgr && StudyMgr.forceEnd && StudyMgr.forceEnd({ silentToast: true, keepIntentional: true }); } catch (_) { }

              // Remove events from NLStore
              try {
                NLStore.events = NLStore.events.filter(ev => !pageIdsToClear.includes(ev.id));
                NLStore.save();
              } catch (_) { }

              // Invalidate cache and refresh UI
              if (typeof window.__invalidateScheduleCache === 'function') window.__invalidateScheduleCache();
              queuePlannerRefresh();
              renderPausedList();
              render(false);
              toast('中断リストに保存しました。再開は下のリストから行えます', 'info');
            }
            function resumePaused(id) {
              const list = loadPausedList();
              const entry = list.find(ent => ent && ent.id === id);
              if (!entry || !Array.isArray(entry.events) || !entry.events.length) { toast('復元できる中断データがありません', 'error'); return; }
              try { StudyMgr && StudyMgr.forceEnd && StudyMgr.forceEnd({ silentToast: true }); } catch (_) { }
              try {
                if (Array.isArray(StudyMgr?.pageIds)) {
                  NLStore.events = NLStore.events.filter(ev => !StudyMgr.pageIds.includes(ev.id));
                  NLStore.save();
                }
              } catch (_) { }
              const startAt = Math.floor(studyNowMs() / 60000) * 60000;
              let cursor = startAt;
              const newIds = [];
              const delayMap = {};
              entry.events.forEach((ev, idx) => {
                const durRaw = (idx === entry.currentIndex) ? (ev.remainingMs || ev.durationMs) : (ev.durationMs || ev.remainingMs);
                const dur = Math.max(60000, Math.round((durRaw || 60000) / 60000) * 60000);
                const baseDur = Math.max(60000, Math.round((ev.baseDurationMs || dur) / 60000) * 60000);
                const times = Number.isFinite(ev.delayTimes) ? Math.max(0, ev.delayTimes) : 0;
                const baseEndRel = Number.isFinite(ev.baseEndRel) ? ev.baseEndRel : baseDur;
                const created = NLStore.addAbs(cursor, cursor + dur, ev.title || `予定 ${idx + 1}`, ev.color || '#4da3ff', ev.kind || 'study');
                if (created) {
                  created.pageNumber = ev.pageNumber;
                  created.todoId = ev.todoId;
                  created.pageKey = ev.pageKey || null;
                  if (ev.bookId) created.bookId = ev.bookId;
                  if (ev.bookTitle) created.bookTitle = ev.bookTitle;
                  newIds.push(created.id);
                  const baseEnd = cursor + baseEndRel;
                  delayMap[created.id] = {
                    baseEnd,
                    baseDurationMs: baseDur,
                    next: baseEnd + (times + 1) * 60000,
                    times
                  };
                }
                cursor += dur;
              });
              NLStore.save();
              if (!newIds.length) { toast('予定を復元できませんでした', 'error'); return; }
              StudyMgr.active = true;
              StudyMgr.pageIds = newIds;
              StudyMgr.delay = delayMap;
              StudyMgr.save && StudyMgr.save();
              StudyUI.update && StudyUI.update();
              setCompleteBtnText();
              if (typeof window.__invalidateScheduleCache === 'function') window.__invalidateScheduleCache();
              queuePlannerRefresh();
              const filtered = list.filter(ent => ent && ent.id !== id);
              savePausedList(filtered);
              pausedSelection.delete(id);
              renderPausedList();
              render(false);
              toast('中断した予定を再開しました', 'success');
            }
            function deletePaused(id) {
              const list = loadPausedList();
              const next = list.filter(ent => ent && ent.id !== id);
              savePausedList(next);
              pausedSelection.delete(id);
              renderPausedList();
            }
            function renamePaused(id) {
              const list = loadPausedList();
              const entry = list.find(ent => ent && ent.id === id);
              if (!entry) { toast('対象が見つかりません', 'error'); return; }
              const currentLabel = entry.label || entry.events?.[entry.currentIndex || 0]?.title || '中断した予定';
              const newLabel = prompt('新しい名前を入力してください:', currentLabel);
              if (newLabel === null) return; // キャンセル
              const trimmed = newLabel.trim();
              if (!trimmed) { toast('名前を入力してください', 'error'); return; }
              entry.label = trimmed;
              savePausedList(list);
              renderPausedList();
              invalidateScheduleCache();
              toast('名前を変更しました', 'success');
            }
            function updateToolbar(cur, hasEvents) {
              if (!state.toolbar) return;
              const completeBtn = state.toolbar.querySelector('[data-action="complete-now"]');
              const todoBtn = state.toolbar.querySelector('[data-action="todo-open"]');
              const stopBtn = state.toolbar.querySelector('[data-action="stop-study"]');
              const forceBtn = state.toolbar.querySelector('[data-action="force-end"]');
              const jumpBtn = state.overlay?.querySelector('[data-action="jump-current"]');
              const doneToday = !!(cur && isPageCompletedToday(cur));
              if (completeBtn) {
                completeBtn.disabled = false;
                completeBtn.classList.remove('disabled');
                completeBtn.classList.toggle('complete-done', doneToday);
              }
              if (todoBtn) { todoBtn.disabled = !hasEvents; todoBtn.classList.toggle('disabled', !hasEvents); }
              if (stopBtn) { stopBtn.disabled = !hasEvents; stopBtn.classList.toggle('disabled', !hasEvents); }
              if (forceBtn) { forceBtn.disabled = !hasEvents; forceBtn.classList.toggle('disabled', !hasEvents); }
              if (jumpBtn) { jumpBtn.disabled = !cur; jumpBtn.classList.toggle('disabled', !cur); }
            }
            function updateOverallBar(nowMs) {
              const el = state.overlay?.querySelector('#studyMenuOverall');
              if (!el) return;
              const summary = computeOverallStudy(nowMs ?? studyNowMs());
              if (!summary) { el.textContent = ''; return; }
              el.textContent = `残り ${__fmtHM(summary.remainMs)} ・ 終了 ${__fmtClock(summary.lastEnd)}`;
            }
            function updateMissToggleButton() {
              const btn = state.toolbar?.querySelector('#studyMissToggle');
              if (!btn) return;
              btn.textContent = state.mode === 'miss' ? '予定' : 'ミス';
              btn.classList.toggle('active', state.mode === 'miss');
            }
            function updateMapToggleButton() {
              const btn = state.toolbar?.querySelector('#studyMapToggle');
              if (!btn) return;
              btn.textContent = state.mode === 'map' ? '予定' : 'マップ';
              btn.classList.toggle('active', state.mode === 'map');
            }
            const mapClampToToday = (str) => {
              const todayStr = formatYMD(new Date());
              if (!str) return todayStr;
              const d = new Date(`${str}T00:00:00`);
              if (!(d instanceof Date) || isNaN(d)) return todayStr;
              const max = new Date(`${todayStr}T00:00:00`);
              if (d > max) return todayStr;
              return formatYMD(d);
            };
            async function ensureMissBookOptions() {
              if (!state.missBook) return;
              if (state.missBook.__loading) return;
              if (state.missBook.__loaded && !state.missAllBooksDirty) return;
              state.missBook.__loading = true;
              let metas = [];
              try { metas = await Book.listMeta(); } catch (_) { metas = []; }
              const currentId = viewerMemory?.book?.id || null;
              if (currentId && !metas.some(m => String(m.id) === String(currentId)) && viewerMemory?.book?.ref) {
                metas.unshift({ id: currentId, title: viewerMemory.book.ref.title || '本' });
              }
              metas.sort((a, b) => (a.title || '').localeCompare(b.title || ''));
              let options = '<option value="">すべて</option>';
              metas.forEach(meta => { options += `<option value="${meta.id}">${esc(meta.title || '無題')}</option>`; });
              state.missBook.innerHTML = options;
              if (state.miss.bookId && !metas.some(m => String(m.id) === String(state.miss.bookId))) {
                state.miss.bookId = '';
              }
              state.missBook.value = state.miss.bookId || '';
              state.missBook.__loaded = true;
              state.missBook.__loading = false;
            }
            async function ensureMapBookOptions() {
              if (!state.mapBook) return;
              if (state.mapBook.__loading) return;
              if (state.mapBook.__loaded && !state.mapAllBooksDirty) return;
              state.mapBook.__loading = true;
              let metas = [];
              try { metas = await Book.listMeta(); } catch (_) { metas = []; }
              const currentId = viewerMemory?.book?.id || null;
              if (currentId && !metas.some(m => String(m.id) === String(currentId)) && viewerMemory?.book?.ref) {
                metas.unshift({ id: currentId, title: viewerMemory.book.ref.title || '本' });
              }
              metas.sort((a, b) => (a.title || '').localeCompare(b.title || ''));
              let options = '<option value="">本を選択</option>';
              metas.forEach(meta => { options += `<option value="${meta.id}">${esc(meta.title || '無題')}</option>`; });
              state.mapBook.innerHTML = options;
              if (state.map.bookId && !metas.some(m => String(m.id) === String(state.map.bookId))) {
                state.map.bookId = '';
              }
              state.mapBook.value = state.map.bookId || '';
              state.mapBook.__loaded = true;
              state.mapBook.__loading = false;
            }
            const resolveMapBook = async (bookId) => {
              if (!bookId) return null;
              if (viewerMemory?.book?.id && String(viewerMemory.book.id) === String(bookId) && viewerMemory.book.ref) {
                return viewerMemory.book.ref;
              }
              try { return await Book.get(bookId); } catch (_) { return null; }
            };
            async function resolveMissBooks() {
              const targetId = state.miss.bookId || '';
              if (targetId) {
                if (viewerMemory?.book?.id && String(viewerMemory.book.id) === String(targetId) && viewerMemory.book.ref) {
                  return [viewerMemory.book.ref];
                }
                try {
                  const b = await Book.get(targetId);
                  return b ? [b] : [];
                } catch (_) { return []; }
              }
              if (!state.missAllBooks || state.missAllBooksDirty) {
                try { state.missAllBooks = await Book.list(); } catch (_) { state.missAllBooks = []; }
                state.missAllBooksDirty = false;
              }
              return state.missAllBooks || [];
            }
            const renderMap = () => {
              if (!state.mapSection || !state.mapGrid) return;
              const token = ++state.mapRenderToken;
              const todayStr = formatYMD(new Date());
              if (!state.map.anchor) state.map.anchor = todayStr;
              state.map.anchor = mapClampToToday(state.map.anchor);
              if (!state.map.start) state.map.start = state.map.anchor;
              if (!state.map.end) state.map.end = state.map.anchor;
              if (!state.map.recentDays) state.map.recentDays = 7;
              if (!state.map.rangeMode) state.map.rangeMode = 'all';
              if (!state.map.completeDate) state.map.completeDate = todayStr;
              state.map.completeDate = mapClampToToday(state.map.completeDate);
              if (state.mapRangeMode) state.mapRangeMode.value = state.map.rangeMode;
              if (state.mapAnchor) { state.mapAnchor.value = state.map.anchor; state.mapAnchor.max = todayStr; }
              if (state.mapStart) { state.mapStart.value = state.map.start; state.mapStart.max = todayStr; }
              if (state.mapEnd) { state.mapEnd.value = state.map.end; state.mapEnd.max = todayStr; }
              if (state.mapRecentDays) state.mapRecentDays.value = String(state.map.recentDays);
              if (state.mapCompleteDate) { state.mapCompleteDate.value = state.map.completeDate; state.mapCompleteDate.max = todayStr; }
              if (state.mapPageFilter) state.mapPageFilter.value = state.map.pageFilter || '';
              if (state.mapRangeWrap) state.mapRangeWrap.style.display = state.map.rangeMode === 'range' ? 'inline-flex' : 'none';
              if (state.mapRecentWrap) state.mapRecentWrap.style.display = state.map.rangeMode === 'recent' ? 'inline-flex' : 'none';
              if (!state.map.bookId && viewerMemory?.book?.id) {
                state.map.bookId = viewerMemory.book.id;
              }
              ensureMapBookOptions();
              const clampDateObj = (d) => {
                const today = new Date(`${todayStr}T00:00:00`);
                if (!(d instanceof Date) || isNaN(d)) return today;
                return d > today ? today : d;
              };
              const anchorDate = clampDateObj(new Date(`${state.map.anchor}T00:00:00`));
              let rangeStart = new Date(anchorDate);
              let rangeEnd = new Date(anchorDate);
              let rangeDates = [];
              const allCompletedMap = (() => {
                const snap = window.StudyCalendar?.getCompletedSnapshot?.();
                if (snap && Object.keys(snap).length) return snap;
                try {
                  const raw = localStorage.getItem('sc-completed');
                  if (!raw) return {};
                  const parsed = JSON.parse(raw);
                  return parsed && typeof parsed === 'object' ? parsed : {};
                } catch (_) { return {}; }
              })();
              if (state.map.rangeMode === 'all') {
                rangeDates = Object.keys(allCompletedMap || {}).sort();
                if (rangeDates.length) {
                  rangeStart = new Date(`${rangeDates[0]}T00:00:00`);
                  rangeEnd = new Date(`${rangeDates[rangeDates.length - 1]}T00:00:00`);
                } else {
                  rangeStart = new Date(anchorDate);
                  rangeEnd = new Date(anchorDate);
                  rangeDates = [formatYMD(rangeStart)];
                }
              } else {
                if (state.map.rangeMode === 'week') {
                  const raw = localStorage.getItem('sc-settings');
                  let ws = 1;
                  try { if (raw) ws = Number(JSON.parse(raw)?.weekStart ?? 1) || 1; } catch (_) { }
                  const dayOfWeek = (anchorDate.getDay() - ws + 7) % 7;
                  rangeStart = new Date(anchorDate);
                  rangeStart.setDate(anchorDate.getDate() - dayOfWeek);
                  rangeEnd = new Date(rangeStart);
                  rangeEnd.setDate(rangeStart.getDate() + 6);
                } else if (state.map.rangeMode === 'month') {
                  rangeStart = new Date(anchorDate.getFullYear(), anchorDate.getMonth(), 1);
                  rangeEnd = new Date(anchorDate.getFullYear(), anchorDate.getMonth() + 1, 0);
                } else if (state.map.rangeMode === 'range') {
                  const s = clampDateObj(new Date(`${state.map.start}T00:00:00`));
                  const e = clampDateObj(new Date(`${state.map.end}T00:00:00`));
                  rangeStart = s <= e ? s : e;
                  rangeEnd = s <= e ? e : s;
                } else if (state.map.rangeMode === 'recent') {
                  const days = Math.max(1, parseInt(state.map.recentDays, 10) || 7);
                  rangeEnd = clampDateObj(new Date(`${todayStr}T00:00:00`));
                  rangeStart = new Date(rangeEnd);
                  rangeStart.setDate(rangeEnd.getDate() - (days - 1));
                }
                rangeEnd = clampDateObj(rangeEnd);
                const walk = new Date(rangeStart);
                while (walk <= rangeEnd) {
                  rangeDates.push(formatYMD(walk));
                  walk.setDate(walk.getDate() + 1);
                }
              }
              const rangeLabel = state.map.rangeMode === 'all'
                ? '全期間'
                : `${formatYMD(rangeStart)}〜${formatYMD(rangeEnd)}`;
              if (state.map.rangeMode !== 'all') {
                const rangeStartStr = formatYMD(rangeStart);
                const rangeEndStr = formatYMD(rangeEnd);
                const withinRange = state.map.completeDate >= rangeStartStr && state.map.completeDate <= rangeEndStr;
                if (!withinRange) state.map.completeDate = rangeEndStr;
              }
              if (state.mapCompleteDate) state.mapCompleteDate.value = state.map.completeDate;
              const pageBookId = state.map.bookId || '';
              if (!pageBookId) {
                state.mapMeta && (state.mapMeta.textContent = '本を選択するとページマップが表示されます');
                state.mapGrid.innerHTML = '<div class="study-menu-empty">本を選択してください</div>';
                state.mapGrid.onclick = null;
                return;
              }
              (async () => {
                const book = await resolveMapBook(pageBookId);
                if (token !== state.mapRenderToken) return;
                if (!book || !Array.isArray(book.pages) || !book.pages.length) {
                  state.mapMeta && (state.mapMeta.textContent = 'ページ情報がありません');
                  state.mapGrid.innerHTML = '<div class="study-menu-empty">ページ情報がありません</div>';
                  state.mapGrid.onclick = null;
                  return;
                }
                const rangeCompletedSet = new Set();
                rangeDates.forEach(dateStr => {
                  const list = Array.isArray(allCompletedMap?.[dateStr]) ? allCompletedMap[dateStr] : [];
                  list.forEach(rec => {
                    if (String(rec?.bookId || '') !== String(pageBookId)) return;
                    const pageNum = homeParsePageNumber(rec?.page);
                    if (Number.isFinite(pageNum)) rangeCompletedSet.add(pageNum);
                  });
                });
                const filterPages = homeParsePageList(state.map.pageFilter || '');
                const filterSet = filterPages.length ? new Set(filterPages) : null;
                let shown = 0;
                let gridHtml = '';
                for (let i = 0; i < book.pages.length; i++) {
                  const pageNum = homeRealPageOf(book, i);
                  const label = Number.isFinite(pageNum) ? pageNum : i + 1;
                  if (filterSet && !filterSet.has(label)) continue;
                  const done = rangeCompletedSet.has(label);
                  gridHtml += `<button class="study-map-btn${done ? ' done' : ''}" data-page="${label}">${label}</button>`;
                  shown++;
                }
                if (!gridHtml) {
                  gridHtml = '<div class="study-menu-empty">該当ページがありません</div>';
                }
                state.mapGrid.innerHTML = gridHtml;
                const baseMeta = `${book.title || '本'} / ${book.pages.length}P`;
                const rangeMeta = `範囲 ${rangeLabel}・完了 ${rangeCompletedSet.size}P`;
                const filterMeta = filterSet ? `・表示 ${shown}P` : '';
                if (state.mapMeta) state.mapMeta.textContent = `${baseMeta} / ${rangeMeta}${filterMeta}・クリックで完了記録`;
                state.mapGrid.onclick = (e) => {
                  const btn = e.target.closest('.study-map-btn');
                  if (!btn) return;
                  const page = homeParsePageNumber(btn.dataset.page);
                  if (!Number.isFinite(page)) return;
                  const dateStr = mapClampToToday(state.map.completeDate || '');
                  state.map.completeDate = dateStr;
                  try { window.StudyCalendar?.recordCompletion?.(pageBookId, page, book.title || '本', dateStr); } catch (_) { }
                  state.mapDirty = true;
                  render(false);
                };
              })();
            };
            const resolveMissMark = async (bookId, pageIndex, missId) => {
              if (!bookId || !Number.isFinite(pageIndex) || !missId) return null;
              let targetBook = null;
              if (viewerMemory?.book?.id && String(viewerMemory.book.id) === String(bookId) && viewerMemory.book.ref) {
                targetBook = viewerMemory.book.ref;
              }
              if (!targetBook) {
                try { targetBook = await Book.get(bookId); } catch (_) { targetBook = null; }
              }
              if (!targetBook || !Array.isArray(targetBook.pages) || !targetBook.pages[pageIndex]) return null;
              const marks = MissStore.ensurePage(targetBook.pages[pageIndex], { bookId: targetBook.id, pageIndex });
              const mark = marks.find(m => m.id === missId);
              if (!mark) return null;
              return { book: targetBook, mark };
            };
            const openMissListEditModal = (book, pageIndex, mark) => {
              if (!book || !mark) return;
              const modal = document.createElement('div');
              modal.className = 'modal';
              modal.style.display = 'flex';
              const box = document.createElement('div');
              box.className = 'box';
              box.innerHTML = `
                <h3>ミス目印を編集</h3>
                <label>名前</label>
                <input id="studyMissEditName" class="input" />
                <label style="margin-top:8px">理由メモ</label>
                <textarea id="studyMissEditReason" class="input" rows="4"></textarea>
                <label style="margin-top:8px">種類</label>
                <select id="studyMissEditType" class="input"></select>
                <label style="margin-top:8px">確認ポイント</label>
                <input id="studyMissEditChecks" class="input" type="number" min="-999" step="1" />
                <div class="row space" style="margin-top:12px">
                  <button class="btn ghost" data-close>閉じる</button>
                  <button class="btn primary" data-save>保存</button>
                </div>
              `;
              modal.appendChild(box);
              document.body.appendChild(modal);
              const nameInput = box.querySelector('#studyMissEditName');
              const reasonInput = box.querySelector('#studyMissEditReason');
              const typeSelect = box.querySelector('#studyMissEditType');
              const checksInput = box.querySelector('#studyMissEditChecks');
              if (nameInput) nameInput.value = mark.name || '';
              if (reasonInput) reasonInput.value = mark.reason || '';
              if (typeSelect) {
                typeSelect.innerHTML = MISS_TYPES.map(t => `<option value="${t.id}">${esc(t.label)}</option>`).join('');
                typeSelect.value = MISS_TYPE_MAP[mark.type] ? mark.type : 'important';
              }
              if (checksInput) checksInput.value = String(Number.isFinite(mark.checks) ? mark.checks : 0);
              const close = () => modal.remove();
              box.querySelector('[data-close]')?.addEventListener('click', close);
              box.querySelector('[data-save]')?.addEventListener('click', () => {
                let checksVal = parseInt(checksInput?.value || '0', 10);
                if (!Number.isFinite(checksVal)) checksVal = 0;
                const nextType = typeSelect?.value || mark.type || 'important';
                MissStore.updateMark(book, pageIndex, mark.id, {
                  name: nameInput?.value?.trim() || '',
                  reason: reasonInput?.value?.trim() || '',
                  type: nextType,
                  checks: checksVal
                });
                MissStore.queueSave(book);
                MissStore.emitUpdate(book.id);
                close();
              });
              setTimeout(() => nameInput?.focus?.(), 0);
            };
            const renderMissList = () => {
              if (!state.missSection || !state.missList) return;
              const token = ++state.missRenderToken;
              const currentBookId = viewerMemory?.book?.id || '';
              if (!state.miss.bookId && currentBookId) state.miss.bookId = currentBookId;
              if (state.missSearch) state.missSearch.value = state.miss.search || '';
              if (state.missType) state.missType.value = state.miss.type || '';
              if (state.missStatus) state.missStatus.value = state.miss.status || 'all';
              if (state.missSort) state.missSort.value = state.miss.sort || 'newest';
              ensureMissBookOptions();
              (async () => {
                const books = await resolveMissBooks();
                if (token !== state.missRenderToken) return;
                let list = MissStore.listMarksForBooks(books);
                if (state.miss.bookId) {
                  list = list.filter(mark => String(mark.bookId || '') === String(state.miss.bookId));
                }
                if (state.miss.type) {
                  list = list.filter(mark => mark.type === state.miss.type);
                }
                const status = state.miss.status || 'all';
                if (status === 'checked') list = list.filter(mark => (mark.checks || 0) > 0);
                if (status === 'unchecked') list = list.filter(mark => (mark.checks || 0) <= 0);
                if (status === 'named') list = list.filter(mark => (mark.name || '').trim().length > 0);
                if (status === 'reason') list = list.filter(mark => (mark.reason || '').trim().length > 0);
                const q = (state.miss.search || '').trim().toLowerCase();
                if (q) {
                  const tokens = q.split(/\s+/).filter(Boolean);
                  list = list.filter(mark => {
                    const info = MISS_TYPE_MAP[mark.type] || MISS_TYPE_MAP.important;
                    const hay = [
                      mark.name,
                      mark.reason,
                      info.label,
                      info.short,
                      mark.bookTitle,
                      String(mark.realPage || '')
                    ].join(' ').toLowerCase();
                    return tokens.every(t => hay.includes(t));
                  });
                }
                const sort = state.miss.sort || 'newest';
                list.sort((a, b) => {
                  if (sort === 'oldest') return (a.createdAt || 0) - (b.createdAt || 0);
                  if (sort === 'page-asc') return (a.realPage || 0) - (b.realPage || 0);
                  if (sort === 'page-desc') return (b.realPage || 0) - (a.realPage || 0);
                  if (sort === 'checks-desc') return (b.checks || 0) - (a.checks || 0);
                  return (b.createdAt || 0) - (a.createdAt || 0);
                });
                const bookSet = new Set();
                list.forEach(mark => { if (mark.bookId) bookSet.add(String(mark.bookId)); });
                if (state.missMeta) {
                  state.missMeta.textContent = `${list.length}件 / ${bookSet.size}冊`;
                }
                if (!list.length) {
                  state.missList.innerHTML = '<div class="study-menu-empty">ミスがありません</div>';
                  return;
                }
                state.missList.innerHTML = list.map(mark => {
                  const info = MISS_TYPE_MAP[mark.type] || MISS_TYPE_MAP.important;
                  const nameLabel = mark.name || info.label;
                  const pageLabel = Number.isFinite(mark.realPage) ? mark.realPage : '?';
                  const dateLabel = Number.isFinite(mark.createdAt) ? `${formatYMD(new Date(mark.createdAt))}` : '';
                  const reason = mark.reason ? esc(mark.reason.slice(0, 60)) : '';
                  const checks = Number.isFinite(mark.checks) ? mark.checks : 0;
                  const checksLabel = checks < 0 ? `<span class="study-miss-alert">危険${checks}</span>` : `確認${checks}`;
                  const dangerClass = checks < 0 ? ' danger' : '';
                  return `
                    <div class="study-miss-item${dangerClass}" data-book-id="${mark.bookId || ''}" data-page-index="${mark.pageIndex}" data-miss-id="${mark.id}" data-x="${mark.x}" data-y="${mark.y}">
                      <div class="study-miss-badge" style="--miss-color:${info.color}">${info.short}</div>
                      <div class="study-miss-body">
                        <div class="study-miss-title">${esc(nameLabel)} <span class="muted">P.${pageLabel}</span></div>
                        <div class="study-miss-sub">${esc(mark.bookTitle || '本')} ・ ${dateLabel} ・ ${checksLabel}</div>
                        ${reason ? `<div class="study-miss-reason">${reason}</div>` : ''}
                      </div>
                      <div class="study-miss-actions">
                        <button class="mini-menu" data-miss-action="edit" type="button">編集</button>
                        <button class="mini-menu danger" data-miss-action="delete" type="button">削除</button>
                      </div>
                    </div>
                  `;
                }).join('');
                state.missList.onclick = async (e) => {
                  const actionBtn = e.target.closest('[data-miss-action]');
                  if (actionBtn) {
                    const action = actionBtn.dataset.missAction;
                    const item = actionBtn.closest('.study-miss-item');
                    if (!item) return;
                    e.stopPropagation();
                    const bookId = item.dataset.bookId || '';
                    const pageIndex = parseInt(item.dataset.pageIndex || '', 10);
                    const missId = item.dataset.missId;
                    const payload = await resolveMissMark(bookId, pageIndex, missId);
                    if (!payload) { toast('ミス目印が見つかりません', 'error'); return; }
                    if (action === 'delete') {
                      if (MissStore.removeMark(payload.book, pageIndex, missId)) {
                        MissStore.queueSave(payload.book);
                        MissStore.emitUpdate(payload.book.id);
                      }
                      return;
                    }
                    if (action === 'edit') {
                      openMissListEditModal(payload.book, pageIndex, payload.mark);
                      return;
                    }
                    return;
                  }
                  const item = e.target.closest('.study-miss-item');
                  if (!item) return;
                  const bookId = item.dataset.bookId;
                  const pageIndex = parseInt(item.dataset.pageIndex, 10);
                  const missId = item.dataset.missId;
                  const x = parseFloat(item.dataset.x);
                  const y = parseFloat(item.dataset.y);
                  window.__jumpToMissMarker?.({ bookId, pageIndex, missId, x, y });
                };
              })();
            };
            function render(light) {
              ensureDom();
              if (state.freeze && light) return;
              updateMissToggleButton();
              updateMapToggleButton();
              if (state.mode === 'miss') {
                state.scheduleSections.forEach(sec => sec?.classList.add('hidden'));
                state.mapSection?.classList.add('hidden');
                state.missSection?.classList.remove('hidden');
                if (light && !state.missDirty) return;
                state.missDirty = false;
                renderMissList();
                return;
              }
              if (state.mode === 'map') {
                state.scheduleSections.forEach(sec => sec?.classList.add('hidden'));
                state.missSection?.classList.add('hidden');
                state.mapSection?.classList.remove('hidden');
                if (light && !state.mapDirty) return;
                state.mapDirty = false;
                renderMap();
                return;
              }
              state.missSection?.classList.add('hidden');
              state.mapSection?.classList.add('hidden');
              state.scheduleSections.forEach(sec => sec?.classList.remove('hidden'));
              state.lastRender = Date.now();
              // Only auto-recover if not intentionally ended
              if (window.StudyMgr && !StudyMgr.active && !StudyMgr.__intentionalEnd && window.NLStore && Array.isArray(NLStore.events)) {
                const studyIds = NLStore.events.filter(ev => ev && ev.kind === 'study').map(ev => ev.id).filter(Boolean);
                if (studyIds.length) {
                  StudyMgr.active = true;
                  StudyMgr.pageIds = studyIds;
                  StudyMgr.delay = StudyMgr.delay || {};
                  StudyMgr.save && StudyMgr.save();
                }
              }
              const data = gather();
              const activeEvents = data.events.filter(ev => !ev._history);
              const now = data.now;
              const hasEvents = data.events.length > 0;
              const hasActive = activeEvents.length > 0;
              state.hasEvents = hasEvents;
              state.hasActive = hasActive;
              if (state.meta) { state.meta.textContent = ''; }
              fillTodoSelect();
              renderTodoInline();
              renderPausedList();
              let cur = null;
              if (state.current) {
                if (!hasEvents) {
                  state.current.innerHTML = ``;
                } else {
                  cur = activeEvents.find(ev => ev.start <= now && now < ev.end) || activeEvents.find(ev => ev.start > now) || activeEvents[0] || null;
                  const st = statusInfo(cur, now, data.delay);
                  const badgePage = Number.isFinite(cur.pageNumber) ? `<span class="study-menu-badge" style="${badgeStyle(cur.color)}">p${cur.pageNumber}</span>` : '';
                  const evId = normId(cur.id ?? cur._normId ?? cur._idx);
                  state.current.innerHTML = `
              <div class="study-menu-current">
                <div class="label">現在のページ</div>
                <div class="name-row">
                  <div class="name">${esc(cur.title || '学習中')}</div>
                  <div class="meta-inline">${st.overtimeMs > 0 ? `延長 ${formatStudyRemain(st.overtimeMs)}` : `残り ${formatStudyRemain(st.remainMs)}`} ・ ${toHM(cur.start)} - ${toHM(cur.end)}</div>
                  <div class="study-menu-badges">${badgePage}</div>
                </div>
                <div class="study-menu-actions">
                  <button class="btn primary small" data-action="complete-now">✓ 完了</button>
                  <button class="btn ghost small" data-action="jump" data-ev="${evId}">ページへジャンプ</button>
                  <button class="btn ghost small danger" data-action="delete-ev" data-ev="${evId}">削除</button>
                </div>
              </div>
            `;
                }
              }
              state.currentEvId = normId(cur?.id ?? cur?._normId ?? cur?._idx) || null;
              updateToolbar(cur, hasActive);
              updateOverallBar(now);
              if (state.list) {
                if (!hasEvents) {
                  state.list.innerHTML = ``;
                } else if (state.view === 'list') {
                  state.list.classList.remove('hidden');
                  const listData = data.events.map((ev, idx) => {
                    const evId = normId(ev.id ?? ev._normId ?? ev._idx);
                    const st = statusInfo(ev, now, data.delay);
                    return { ev, evId, st, idx };
                  }).filter(x => !x.ev._history && x.st.status !== 'done');
                  state.list.innerHTML = listData.map(({ ev, evId, st }) => {
                    const pageTag = Number.isFinite(ev.pageNumber) ? `<span class="study-menu-badge" style="${badgeStyle(ev.color)}">p${ev.pageNumber}</span>` : '';
                    const rowCls = ['study-menu-row', st.status];
                    if (ev._history) rowCls.push('history');
                    const disableControls = !!ev._history;
                    const metaText = [toHM(ev.start) + ' - ' + toHM(ev.end), pageTag].filter(Boolean).join(' / ');
                    return `
              <div class="${rowCls.join(' ')}" draggable="${disableControls ? 'false' : 'true'}" data-ev="${evId}">
                <div class="title">
                  ${esc(ev.title || '学習中')}
                  <span class="meta">${metaText}</span>
                </div>
                <div class="study-menu-row-buttons">
                  <button class="mini-menu ghost" data-action="move-up" data-ev="${evId}">↑</button>
                  <button class="mini-menu ghost" data-action="move-down" data-ev="${evId}">↓</button>
                  <button class="mini-menu" data-action="start-from" data-ev="${evId}">ここから</button>
                  <button class="mini-menu" data-action="jump" data-ev="${evId}">開く</button>
                  <button class="mini-menu danger${disableControls ? ' disabled' : ''}" data-action="delete-ev" data-ev="${evId}" ${disableControls ? 'disabled' : ''}>削除</button>
                </div>
              </div>
            `;
                  }).join('');
                } else {
                  state.list.classList.add('hidden');
                  state.list.innerHTML = '';
                }
              }
              if (state.pages) {
                const pageEvents = data.events.filter(ev => {
                  if (ev._history) return false;
                  const st = statusInfo(ev, now, data.delay);
                  return st.status !== 'done';
                });
                if (state.view === 'pages' && pageEvents.length) {
                  state.pages.classList.remove('hidden');
                  state.pages.innerHTML = pageEvents.map((ev, idx) => {
                    const evId = normId(ev.id ?? ev._normId ?? ev._idx);
                    const label = Number.isFinite(ev.pageNumber) ? `p${ev.pageNumber}` : `#${idx + 1}`;
                    const st = statusInfo(ev, now, data.delay);
                    const cls = ['study-page-chip', st.status];
                    if (ev._history) cls.push('history');
                    return `<div class="${cls.join(' ')}" data-action="jump" data-ev="${evId}">
              <span class="pg-label">${esc(label)}</span>
              <span class="pg-meta">${st.label} / ${toHM(ev.start)}-${toHM(ev.end)}</span>
            </div>`;
                  }).join('');
                } else {
                  state.pages.classList.add('hidden');
                  state.pages.innerHTML = '';
                }
              }
              if (state.list && state.view === 'list') { state.list.classList.remove('hidden'); }
              if (!light && state.todoSel) fillTodoSelect();
            }
            function onAction(e) {
              const btn = e.target.closest('[data-action]');
              if (!btn) return;
              const act = btn.dataset.action;
              const evId = btn.dataset.ev;
              e.stopPropagation();
              switch (act) {
                case 'start-from': startFrom(evId); break;
                case 'move-up': move(evId, -1); break;
                case 'move-down': move(evId, 1); break;
                case 'jump': jumpTo(evId); break;
                case 'jump-current': jumpTo(evId || state.currentEvId); break;
                case 'complete-now': completeNow(); break;
                case 'recover-current': recoverCurrent(); break;
                case 'break-now': insertBreakNow(); break;
                case 'delete-ev': deleteEvent(evId); break;
                case 'stop-study': stopStudy(); break;
                case 'normal-end': normalEnd(); break;
                case 'force-end': forceEndWithSave(); break;
                case 'todo-add': planTodoFromSelect(); break;
                case 'todo-add-all': planAllTodos(); break;
                case 'todo-open': openTodoForm(); break;
                case 'todo-popup': openTodoPopup(); break;
                case 'resume-paused': resumePaused(evId || btn.dataset.id); break;
                case 'delete-paused': deletePaused(evId || btn.dataset.id); break;
                case 'rename-paused': renamePaused(evId || btn.dataset.id); break;
                case 'merge-paused': mergePaused(Array.from(pausedSelection)); break;
                case 'mode-list': state.view = 'list'; render(false); break;
                case 'mode-pages': state.view = 'pages'; render(false); break;
                case 'toggle-map':
                  state.mode = state.mode === 'map' ? 'study' : 'map';
                  state.mapDirty = true;
                  render(false);
                  break;
                case 'toggle-miss':
                  state.mode = state.mode === 'miss' ? 'study' : 'miss';
                  state.missDirty = true;
                  render(false);
                  break;
                case 'rebuild-now': rebuildNow(); break;
                case 'cleanup-storage': cleanupStorage(); break;
                case 'reset-schedule': resetAllSchedule(); break;
                case 'emergency-clean': emergencyStorageClean(); break;
                default: break;
              }
            }

            // Normal end - just clear current schedule, keep paused list
            function normalEnd() {
              if (!window.StudyMgr) return;
              // Mark as intentionally ended to prevent auto-recovery
              StudyMgr.__intentionalEnd = true;
              // Remove all events tracked by current session
              const toRemove = new Set(StudyMgr.pageIds || []);
              NLStore.events = NLStore.events.filter(ev => !toRemove.has(ev.id));
              StudyMgr.active = false;
              StudyMgr.pageIds = [];
              StudyMgr.delay = {};
              // Don't clear doneHistory or paused list
              StudyMgr.save();
              NLStore.save();
              invalidateScheduleCache();
              toast('予定を終了しました（中断リストは保持）', 'info');
              render(false);
              try { queuePlannerRefresh(); } catch (_) { }
            }

            // Force end with proper save
            function forceEndWithSave() {
              try {
                // Mark as intentionally ended to prevent auto-recovery
                if (StudyMgr) StudyMgr.__intentionalEnd = true;
                if (StudyMgr && StudyMgr.forceEnd) {
                  StudyMgr.forceEnd();
                }
                // Force additional save and cache invalidation
                if (window.NLStore) {
                  NLStore.save();
                }
                invalidateScheduleCache();
              } catch (e) {
                console.error('[forceEnd] Error:', e);
                toast('リセットに失敗しました', 'error');
              }
              render(false);
              try { queuePlannerRefresh(); } catch (_) { }
            }

            // Open TODO in separate popup window
            function openTodoPopup() {
              const popup = document.getElementById('todoPopupOverlay');
              if (popup) {
                popup.classList.add('open');
                renderTodoPopup();
                return;
              }
              createTodoPopup();
            }

            function createTodoPopup() {
              const overlay = document.createElement('div');
              overlay.id = 'todoPopupOverlay';
              overlay.className = 'todo-popup-overlay open';
              overlay.innerHTML = `
                <div class="todo-popup-sheet">
                  <div class="todo-popup-header">
                    <span>📋 TODO連携</span>
                    <div class="todo-popup-actions">
                      <button class="mini-menu" id="todoPopupRefresh">更新</button>
                      <button class="mini-menu" id="todoPopupClose">閉じる</button>
                    </div>
                  </div>
                  <div class="todo-popup-body" id="todoPopupBody"></div>
                  <div class="todo-popup-resizer"></div>
                </div>
              `;
              document.body.appendChild(overlay);

              // Event handlers - no close on outside click
              overlay.querySelector('#todoPopupClose').onclick = () => closeTodoPopup();
              overlay.querySelector('#todoPopupRefresh').onclick = () => renderTodoPopup();
              // Remove click-outside-to-close behavior

              // Make draggable
              const sheet = overlay.querySelector('.todo-popup-sheet');
              let isDragging = false, startX, startY, origX, origY;
              const header = overlay.querySelector('.todo-popup-header');
              header.style.cursor = 'move';
              header.onmousedown = (e) => {
                if (e.target.tagName === 'BUTTON') return;
                isDragging = true;
                startX = e.clientX; startY = e.clientY;
                const rect = sheet.getBoundingClientRect();
                origX = rect.left; origY = rect.top;
                e.preventDefault();
              };
              document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                sheet.style.left = `${origX + e.clientX - startX}px`;
                sheet.style.top = `${origY + e.clientY - startY}px`;
              });
              document.addEventListener('mouseup', () => { isDragging = false; });

              // Make resizable
              const resizer = overlay.querySelector('.todo-popup-resizer');
              let isResizing = false, resizeStartX, resizeStartY, origW, origH;
              resizer.onmousedown = (e) => {
                isResizing = true;
                resizeStartX = e.clientX;
                resizeStartY = e.clientY;
                origW = sheet.offsetWidth;
                origH = sheet.offsetHeight;
                e.preventDefault();
              };
              document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                const newW = origW + e.clientX - resizeStartX;
                const newH = origH + e.clientY - resizeStartY;
                sheet.style.width = `${Math.max(200, newW)}px`;
                sheet.style.height = `${Math.max(150, newH)}px`;
              });
              document.addEventListener('mouseup', () => { isResizing = false; });

              // Touch support for dragging
              header.ontouchstart = (e) => {
                if (e.target.tagName === 'BUTTON') return;
                isDragging = true;
                const touch = e.touches[0];
                startX = touch.clientX; startY = touch.clientY;
                const rect = sheet.getBoundingClientRect();
                origX = rect.left; origY = rect.top;
              };
              document.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const touch = e.touches[0];
                sheet.style.left = `${origX + touch.clientX - startX}px`;
                sheet.style.top = `${origY + touch.clientY - startY}px`;
              });
              document.addEventListener('touchend', () => { isDragging = false; });

              renderTodoPopup();
            }

            function closeTodoPopup() {
              const popup = document.getElementById('todoPopupOverlay');
              if (popup) popup.classList.remove('open');
            }

            function renderTodoPopup() {
              const body = document.getElementById('todoPopupBody');
              if (!body) return;

              invalidateScheduleCache();
              const scheduledMap = buildScheduledMap();
              const pausedMap = scheduledMap.paused || new Map();
              const todayScheduleMap = getTodayScheduleMap();
              const active = todoList().filter(t => !isTodoDone(t));

              if (!active.length) {
                body.innerHTML = '<div class="muted" style="padding:16px;font-size:12px;">未完了のToDoはありません</div>';
                return;
              }

              // Track last clicked page for range selection
              if (!window.__todoPopupLastClicked) window.__todoPopupLastClicked = {};

              body.innerHTML = active.map(t => {
                const remainList = todoRemaining(t);
                const total = Array.isArray(t.pages) ? t.pages.length : 0;
                const scheduled = (scheduledMap.live || scheduledMap).get(t.id) || new Set();
                const paused = pausedMap.get(t.id) || new Set();
                const doneSet = new Set(t.completedPages || []);
                const todayPages = todayScheduleMap.get(String(t.id)) || new Set();
                const pageList = Array.isArray(t.pages) && t.pages.length ? t.pages : remainList;

                const pages = pageList.slice(0, 150).map(p => {
                  const cls = ['study-todo-page'];
                  const num = normalizeTodoPage(p);
                  if (num != null && todayPages.has(num)) cls.push('today-assigned');
                  if (doneSet.has(p)) cls.push('done');
                  else if (scheduled.has(p)) cls.push('scheduled');
                  else if (paused.has(p)) cls.push('paused');
                  return `<button class="${cls.join(' ')}" data-popup-todo="${t.id}" data-popup-page="${p}">p${p}</button>`;
                }).join('') || '<span class="tiny" style="color:var(--muted)">ページなし</span>';

                return `<div class="todo-popup-item">
                  <div class="todo-popup-title">${esc(t.title || '無題')} <span style="opacity:0.6;font-size:11px">(残り${remainList.length}/${total}p)</span></div>
                  <div class="todo-popup-pages" title="クリック:追加 / Shift:範囲 / 黄:中断から追加">${pages}</div>
                </div>`;
              }).join('');

              // Bind page button clicks
              body.querySelectorAll('[data-popup-todo]').forEach(btn => {
                btn.onclick = (e) => {
                  const todoId = btn.dataset.popupTodo;
                  const page = parseInt(btn.dataset.popupPage, 10);
                  handleTodoPopupPageClick(todoId, page, e);
                };
              });
            }

            function handleTodoPopupPageClick(todoId, page, e) {
              const todo = todoList().find(t => t.id === todoId);
              if (!todo || !Number.isFinite(page)) return;

              invalidateScheduleCache();
              const schedMap = buildScheduledMap();
              const scheduledSet = (schedMap.live || schedMap).get(todoId) || new Set();
              const pausedSet = (schedMap.paused || new Map()).get(todoId) || new Set();
              const doneSet = new Set(todo.completedPages || []);

              // Shift + click for range selection
              if (e.shiftKey && window.__todoPopupLastClicked[todoId] !== undefined) {
                const startPage = Math.min(window.__todoPopupLastClicked[todoId], page);
                const endPage = Math.max(window.__todoPopupLastClicked[todoId], page);
                const allPages = Array.isArray(todo.pages) ? todo.pages : [];
                const range = allPages.filter(p => p >= startPage && p <= endPage && !doneSet.has(p) && !scheduledSet.has(p));
                if (range.length > 0) {
                  scheduleTodoPages(todo, range);
                  invalidateScheduleCache();
                  render(false);
                  renderTodoPopup();
                  toast(`${range.length}ページを一括追加しました`, 'success');
                }
                return;
              }

              window.__todoPopupLastClicked[todoId] = page;

              // If paused (yellow), move from paused to active
              if (pausedSet.has(page)) {
                // Remove from paused list
                removePausedPage(todoId, page);
                // Add to active schedule
                scheduleTodoPages(todo, [page]);
                invalidateScheduleCache();
                render(false);
                renderTodoPopup();
                toast('中断から予定に移動しました', 'success');
                return;
              }

              // If done, toggle completion
              if (doneSet.has(page)) {
                TodoStore.togglePage(todoId, page);
                toast('完了を解除しました', 'info');
                invalidateScheduleCache();
                render(false);
                renderTodoPopup();
                return;
              }

              // If scheduled (blue), remove from schedule
              if (scheduledSet.has(page)) {
                unscheduleTodoPage(todoId, page);
                invalidateScheduleCache();
                render(false);
                renderTodoPopup();
                return;
              }

              // Otherwise add to schedule
              scheduleTodoPages(todo, [page]);
              invalidateScheduleCache();
              render(false);
              renderTodoPopup();
            }

            // Remove a specific page from paused list
            function removePausedPage(todoId, page) {
              const PAUSE_KEY = 'nl_paused_entries';
              try {
                const raw = localStorage.getItem(PAUSE_KEY);
                if (!raw) return;
                let entries = JSON.parse(raw);
                if (!Array.isArray(entries)) return;
                // Find entries that contain this todoId+page and remove just that page
                entries = entries.map(entry => {
                  if (!entry.events || !Array.isArray(entry.events)) return entry;
                  entry.events = entry.events.filter(ev => !(ev.todoId === todoId && ev.pageNumber === page));
                  return entry;
                }).filter(entry => entry.events && entry.events.length > 0);
                localStorage.setItem(PAUSE_KEY, JSON.stringify(entries));
                // Force cache invalidation after modifying paused list
                invalidateScheduleCache();
              } catch (e) {
                console.warn('[removePausedPage] Error:', e);
              }
            }
            // Expose for external access
            window.__removePausedPage = removePausedPage;
            window.addEventListener('miss-marks-updated', () => {
              state.missDirty = true;
              state.missAllBooksDirty = true;
            });
            function open() {
              ensureDom();
              // Ensure cache is invalidated when opening
              invalidateScheduleCache();
              state.overlay.classList.add('open');
              state.open = true;
              state.missDirty = true;
              if (!state.keyHandler) {
                state.keyHandler = (e) => {
                  if (!state.open) return;
                  if (e.key !== 'Enter') return;
                  if (isTypingTarget(e.target)) return;
                  if (state.hasEvents) return;
                  completeNow();
                  e.preventDefault();
                };
              }
              document.addEventListener('keydown', state.keyHandler);
              const sheet = state.overlay.querySelector('.study-menu-sheet');
              if (sheet) {
                if (!state.pos) {
                  const rect = sheet.getBoundingClientRect();
                  const preferX = Math.max(12, window.innerWidth - (rect.width || 420) - 20);
                  const preferY = 18;
                  state.pos = { x: preferX, y: preferY };
                }
                sheet.style.left = `${state.pos.x || 0}px`;
                sheet.style.top = `${state.pos.y || 0}px`;
              }
              render();
              clearInterval(state.timer);
              state.timer = setInterval(() => {
                if (!state.open) return;
                if (state.freeze) return;
                render(true);
              }, 1200);
              if (state.scroll) state.scroll.scrollTop = 0;
              // Reopen TODO popup if it was open before
              if (state.todoPopupWasOpen) {
                setTimeout(() => { try { openTodoPopup(); } catch (_) { } }, 100);
              }
            }
            function close() {
              if (state.overlay) {
                state.overlay.classList.remove('open');
                const sheet = state.overlay.querySelector('.study-menu-sheet');
                if (sheet) { sheet.style.left = ''; sheet.style.top = ''; }
              }
              if (state.keyHandler) {
                document.removeEventListener('keydown', state.keyHandler);
              }
              // Save TODO popup state and close it
              const todoPopup = document.getElementById('todoPopupOverlay');
              state.todoPopupWasOpen = todoPopup && todoPopup.classList.contains('open');
              try { closeTodoPopup(); } catch (_) { }
              state.open = false;
              state.freeze = false;
              clearInterval(state.timer); state.timer = null;
            }
            return { open, close, tick() { if (state.open && !state.freeze) render(true); }, refresh: render, isOpen: () => state.open, render, toggle() { state.open ? close() : open(); } };
          })();
          window.StudyActionMenu = StudyActionMenu;

          function cleanupEndedBreaks(nowMs) {
            try {
              if (!window.NLStore || !Array.isArray(NLStore.events)) return false;
              const now = Number.isFinite(nowMs) ? nowMs : studyNowMs();
              const endedIds = new Set();
              let colorUpdated = false;
              NLStore.events.forEach(ev => {
                if (!ev || !isBreakEvent(ev)) return;
                if (ev.color !== STUDY_BREAK_COLOR) {
                  ev.color = STUDY_BREAK_COLOR;
                  colorUpdated = true;
                }
                if (Number.isFinite(ev.end) && ev.end <= now) {
                  endedIds.add(ev.id);
                }
              });
              if (!endedIds.size && !colorUpdated) return false;
              let changed = false;
              if (window.StudyMgr && Array.isArray(StudyMgr.pageIds)) {
                const nextIds = StudyMgr.pageIds.filter(id => !endedIds.has(id));
                if (nextIds.length !== StudyMgr.pageIds.length) {
                  StudyMgr.pageIds = nextIds;
                  StudyMgr.active = nextIds.length > 0;
                  if (StudyMgr.delay) {
                    endedIds.forEach(id => { try { delete StudyMgr.delay[id]; } catch (_) { } });
                  }
                  StudyMgr.save && StudyMgr.save();
                  changed = true;
                }
              }
              let needsSave = false;
              if (endedIds.size) {
                const before = NLStore.events.length;
                NLStore.events = NLStore.events.filter(ev => !(ev && endedIds.has(ev.id)));
                if (NLStore.events.length !== before) needsSave = true;
              }
              if (colorUpdated) needsSave = true;
              if (needsSave) {
                NLStore.save();
                changed = true;
              }
              if (changed) {
                try { window.__invalidateScheduleCache && window.__invalidateScheduleCache(); } catch (_) { }
                try { drawPlanner && drawPlanner(); } catch (_) { }
                try { nlRebuildAll && nlRebuildAll(); } catch (_) { }
                try { StudyUI && StudyUI.update && StudyUI.update(); } catch (_) { }
                try { StudyActionMenu && StudyActionMenu.refresh && StudyActionMenu.refresh(); } catch (_) { }
                try { refreshPlannerFlyClock && refreshPlannerFlyClock(false); } catch (_) { }
                try { renderNumberlineFly && renderNumberlineFly(); } catch (_) { }
              }
              return changed;
            } catch (_) {
              return false;
            }
          }

          function runSecondAligned(nowD) {
            const curHour = nowD.getHours();
            if (nlLastHour === null) nlLastHour = curHour;
            if (nlLastHour !== curHour) {
              nlLastHour = curHour;
              try { markNlDirty && markNlDirty(); } catch (_) { }
              try { nlRebuildAll && nlRebuildAll(true); } catch (_) { }
            }
            const nms = nowD.getTime();
            cleanupEndedBreaks(nms);
            try {
              try { StudyMgr.autoExtendIfNeeded(nms); } catch (e) { }
              try { updateDelayInlineUI(nms); } catch (e) { } try { window.SoundMgr && SoundMgr.timeTick(nms); } catch (e) { }
              try { DeadlineSoonWatcher.tick(nms); } catch (e) { }
              try { StudySoundWatcher.tick(nms); } catch (e) { }
              try { StudyHpOverlay.update(nms); } catch (e) { }
              try { ReaderHpBar.update(studyNowMs()); } catch (e) { }
              try { StudyActionMenu.tick(); } catch (e) { }
              try { window.__pageProgressOverlayRender?.(); } catch (e) { }
              try { nlUpdateDigitalDisplays(nms); } catch (e) { }
              try { updateDelayUI(nms); } catch (e) { }
              const rows = Array.from(document.querySelectorAll('.nl-row'));
              rows.forEach(r => { r.__nlStack = 0; r.__nlOuterStack = 0; });
              setClockPulseDate(nowD);
              updateDigital(nowD);
              const motionSel = document.getElementById('motion');
              const motionVal = motionSel ? motionSel.value : 'smooth';
              if (motionVal !== 'smooth') { updatePlannerHandRotation(nowD, motionVal); }
              rows.forEach(row => {
                const ts = parseInt(row.dataset.startTs || '0', 10);
                const d = new Date(ts);
                const isCurrent = row.classList.contains('current') ||
                  (d.getFullYear() === nowD.getFullYear() && d.getMonth() === nowD.getMonth() &&
                    d.getDate() === nowD.getDate() && d.getHours() === nowD.getHours());
                const sHand = row.querySelector('.nl-hand.s');
                const mHand = row.querySelector('.nl-hand.m');
                if (isCurrent) {
                  if (sHand) sHand.style.left = (nowD.getSeconds() / 60 * 100) + '%';
                  if (mHand) mHand.style.left = (nowD.getMinutes() / 60 * 100) + '%';
                }
              });
              if (nlPlannerMirrorHost) {
                nlMirrorPlannerClock(nowD);
              }
              try { refreshPlannerFlyClock && refreshPlannerFlyClock(false); } catch (e) { }
            } catch (e) { }

            try { if (typeof nlUpdateETA === 'function') nlUpdateETA(true); } catch (e) { }
            try { if (typeof plUpdateETA === 'function') plUpdateETA(true); } catch (e) { }
          }

          function ensureSecondAligned(nowSrc) {
            const base = nowSrc instanceof Date ? nowSrc : now();
            const sec = Math.floor(base.getTime() / 1000);
            if (lastPulseSec === null) {
              lastPulseSec = sec;
              runSecondAligned(new Date(sec * 1000));
              return;
            }
            if (sec > lastPulseSec) {
              while (lastPulseSec < sec) {
                lastPulseSec++;
                runSecondAligned(new Date(lastPulseSec * 1000));
              }
              return;
            }
            if (sec < lastPulseSec) {
              lastPulseSec = sec;
              runSecondAligned(new Date(sec * 1000));
            }
          }
          window.__ensureSecondAligned = ensureSecondAligned;
          window.__secAlignedFallback = setInterval(() => {
            if (document.hidden) return;
            if (typeof plannerBackgroundNeedsTick === 'function' && !plannerBackgroundNeedsTick()) return;
            try { ensureSecondAligned(); } catch (_) { }
          }, 200);
          // ハードウォッチドッグ（500ms間隔）: 終了瞬間の取りこぼし防止
          function startStudyHardWatch() {
            try {
              if (window.__studyHardWatch) clearInterval(window.__studyHardWatch);
              window.__studyHardWatch = setInterval(function () {
                if (typeof plannerBackgroundNeedsTick === 'function' && !plannerBackgroundNeedsTick()) return;
                try { __forceExtendAndRebuild(now().getTime()); } catch (e) { }
              }, 500);
            } catch (_) { }
          }
          window.startStudyHardWatch = startStudyHardWatch;
          startStudyHardWatch();

          try { scheduleStudyWatchdog(); } catch (e) { }

        })();


        // ===== Overall Study (sum of remaining time & final end) =====
        function __fmtHM(ms) {
          ms = Math.max(0, ms | 0);
          const totalSec = Math.floor(ms / 1000);
          const h = Math.floor(totalSec / 3600);
          const m = Math.floor((totalSec % 3600) / 60);
          if (h > 0) return `${h}時間${m}分`;  // 切り捨て表示
          return `${m}分`;                  // 切り捨て表示（予定の残り時間と同じ感覚）
        }
        function __fmtClock(d) {
          const pad = (n) => ('' + n).padStart(2, '0');
          return `${pad(d.getHours())}:${pad(d.getMinutes())}`;
        }

        function computeOverallStudy(nowMs) {
          try {
            let events = [];
            if (window.StudyMgr && StudyMgr.active && Array.isArray(StudyMgr.pageIds) && StudyMgr.pageIds.length > 0) {
              events = StudyMgr.pageIds
                .map(id => NLStore.events.find(e => e.id === id))
                .filter(ev => ev && ev.end > nowMs);
            } else {
              events = (NLStore.events || []).filter(ev => ev && ev.kind === 'study' && ev.end > nowMs);
            }
            events.sort((a, b) => a.start - b.start);
            if (events.length === 0) { return null; }
            const lastEnd = events[events.length - 1].end;
            const remainMs = Math.max(0, lastEnd - nowMs); // 連続割付前提: 全体は最終終了時刻-現在時刻
            return { remainMs, lastEnd: new Date(lastEnd) };
          } catch (e) { return null; }
        }

        function ensureNlOverallBadge() {
          const nlRoot = document.getElementById('nlRows');
          if (!nlRoot) return null;
          // find current hour row (plannerタブ内の本体のみを対象にする)
          const nowD = (window.__getNow ? window.__getNow() : new Date());
          const nowHourStart = new Date(nowD.getFullYear(), nowD.getMonth(), nowD.getDate(), nowD.getHours(), 0, 0).getTime();
          let currentRow = null;
          nlRoot.querySelectorAll('.nl-row').forEach(row => { const ts = parseInt(row.dataset.startTs || '0', 10); if (ts === nowHourStart) currentRow = row; });
          if (!currentRow) return null;
          const lane = currentRow.querySelector('.nl-lane');
          if (!lane) return null;
          let badge = document.getElementById('nlOverallBadge');
          if (!badge) {
            badge = document.createElement('div');
            badge.id = 'nlOverallBadge';
            badge.className = 'nl-overall-inline';
            badge.style.display = 'none';
            badge.innerHTML = `<span id="nlOverallRemain">残り --</span> <span id="nlOverallEnd">終了 --:--</span>`;
            lane.appendChild(badge);
          } else {
            // ensure it is inside the current row scale
            if (badge.parentNode !== lane) { badge.remove(); lane.appendChild(badge); }
            badge.className = 'nl-overall-inline';
          }
          return badge;
        }
        let __osi_ticking = false;
        function updateOverallStudyUI() {
          if (typeof window.__plannerBackgroundNeedsTick === 'function' && !window.__plannerBackgroundNeedsTick()) {
            return;
          }
          if (__osi_ticking) return; __osi_ticking = true; setTimeout(() => { __osi_ticking = false; }, 100);
          const now = (window.__getNow ? window.__getNow() : new Date());
          const info = computeOverallStudy(now.getTime());
          const banner = document.getElementById('overallStudyInfo');
          const badge = ensureNlOverallBadge();
          if (info) {
            const rtxt = __fmtHM(info.remainMs);
            const etxt = __fmtClock(info.lastEnd);
            if (banner) {
              banner.style.display = 'flex';
              const r = document.getElementById('osiRemain'), e = document.getElementById('osiEnd');
              if (r) r.textContent = `残り ${rtxt}`;
              if (e) e.textContent = `終了 ${etxt}`;
            }
            if (badge) {
              badge.style.display = 'block';
              const rr = document.getElementById('nlOverallRemain');
              const ee = document.getElementById('nlOverallEnd');
              if (rr) rr.textContent = `残り ${rtxt}`;
              if (ee) ee.textContent = `終了 ${etxt}`;
            }
            if (typeof window.__setInfoVisibility === 'function') window.__setInfoVisibility(true);
          } else {
            if (banner) banner.style.display = 'none';
            const b = document.getElementById('nlOverallBadge');
            if (b) b.style.display = 'none';
            if (typeof window.__setInfoVisibility === 'function') window.__setInfoVisibility();
          }
        }


        // ===== Overall Study updater: second-aligned interval (rAF非依存) =====
        (function () {
          function startSecondAlignedOverall() {
            try {
              if (window.__overallKick) clearTimeout(window.__overallKick);
              if (window.__overallTimer) clearInterval(window.__overallTimer);
            } catch (e) { }
            function kick() {
              if (window.__overallTimer) clearInterval(window.__overallTimer);
              updateOverallStudyUI();
              window.__overallTimer = setInterval(updateOverallStudyUI, 1000);
            }
            var delay = 1000 - (Date.now() % 1000);
            window.__overallKick = setTimeout(kick, delay);
          }
          window.__startOverallTicker = startSecondAlignedOverall;
        })();

        let __lastPlannerDraw = 0, __lastWatchdogTick = 0, __lastDigitalTick = 0;
        const plannerBackgroundNeedsTick = () => {
          const plannerApp = document.getElementById('plannerApp');
          if (plannerApp && !plannerApp.classList.contains('hidden')) return true;
          const flyPlanner = document.getElementById('plannerFly');
          const flyNumberline = document.getElementById('numberlineFly');
          if (flyPlanner?.classList.contains('active') || flyNumberline?.classList.contains('active')) return true;
          if (window.StudyMgr && window.StudyMgr.active) return true;
          const timers = window.timers || [];
          if (timers.some(t => t && t.running)) return true;
          const sws = window.sws || [];
          if (sws.some(sw => sw && sw.running)) return true;
          return false;
        };
        window.__plannerBackgroundNeedsTick = plannerBackgroundNeedsTick;
        function tick() {
          const nowMs = Date.now();
          if (document.hidden && !isBookViewerContext()) {
            setTimeout(() => requestAnimationFrame(tick), 400);
            return;
          }
          if (__shiftTurbo || __pageTurboActive) {
            // ターボ中は描画負荷を下げてページ送りを優先
            requestAnimationFrame(tick);
            return;
          }
          if (!plannerBackgroundNeedsTick()) {
            setTimeout(() => requestAnimationFrame(tick), 1000);
            return;
          }
          const plannerApp = document.getElementById('plannerApp');
          const plannerVisible = !!(plannerApp && !plannerApp.classList.contains('hidden'));
          try { window.__ensureSecondAligned && window.__ensureSecondAligned(); } catch (_) { }
          const plannerInterval = (typeof plLoadShowSeconds === 'function' && plLoadShowSeconds()) ? 300 : 900;
          if (plannerVisible && nowMs - __lastPlannerDraw >= plannerInterval) {
            drawPlanner();
            __lastPlannerDraw = nowMs;
          }
          if (nowMs - __lastWatchdogTick >= 800) {
            try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
            __lastWatchdogTick = nowMs;
          }
          const useTimerPatch = !!window.__timerPatchAppliedV2;
          if (!useTimerPatch) {
            try { if (typeof drawTimerArcs === 'function') drawTimerArcs(); } catch (_) { }
            try { nlRenderTimerOverlays && nlRenderTimerOverlays(); } catch (_) { }
          }
          if (nowMs - __lastDigitalTick >= 1000) {
            updateDigital();
            __lastDigitalTick = nowMs;
          }
          requestAnimationFrame(tick);
        }

        // 初期化
        if (typeof TodoUI !== 'undefined' && TodoUI && typeof TodoUI.init === 'function') { try { TodoUI.init(); } catch (_) { } }
        if (typeof PlannerCalendar !== 'undefined' && PlannerCalendar && typeof PlannerCalendar.init === 'function') { try { PlannerCalendar.init(); } catch (_) { } }
        if (typeof OriginalLesson !== 'undefined' && OriginalLesson && typeof OriginalLesson.init === 'function') { try { OriginalLesson.init(); } catch (_) { } }
        initUI(); if (window.__startOverallTicker) window.__startOverallTicker(); if (typeof updateHUD === 'function') updateHUD();
        if ($('studyGenerateCount')) $('studyGenerateCount').onclick = () => generateStudy('count');
        if ($('studyGenerateRange')) $('studyGenerateRange').onclick = () => generateStudy('range');
        if ($('studyForceEnd')) $('studyForceEnd').onclick = () => StudyMgr && StudyMgr.forceEnd && StudyMgr.forceEnd();
        StudyUI.update(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
        try { scheduleStudyWatchdog(); } catch (e) { }

        setCompleteBtnText(); nlRebuildAll(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
        try { scheduleStudyWatchdog(); } catch (e) { }
        updateOverallStudyUI(); // 先に構築しておく（初回）
        setTickStyleFromUI(); applyTickStyleAll();
        requestAnimationFrame(tick);

        // === Responsive: keep bars & hands aligned on resize ===
        (function () {
          const root = document.getElementById('nlRows');
          if (!root || typeof ResizeObserver === 'undefined') return;
          const ro = new ResizeObserver(() => {
            const nowD = (window.__getNow ? window.__getNow() : (window.__getNow ? window.__getNow() : new Date()));
            document.querySelectorAll('.nl-row').forEach(row => {
              // re-render bars
              nlRenderBarsForHour(row);
              // update hands if current
              const isCurrent = row.classList.contains('current');
              const sHand = row.querySelector('.nl-hand.s');
              const mHand = row.querySelector('.nl-hand.m');
              if (isCurrent) {
                if (sHand) sHand.style.left = (nowD.getSeconds() / 60 * 100) + '%';
                if (mHand) mHand.style.left = (nowD.getMinutes() / 60 * 100) + '%';
              }
            });
            nlUpdateETA && nlUpdateETA();
          });
          ro.observe(root);
        })();


        // === ETA seconds toggle ===
        const NL_SEC_KEY = "nl_eta_show_seconds";
        function nlLoadShowSeconds() { try { return localStorage.getItem(NL_SEC_KEY) === '1'; } catch (e) { return false; } }
        function nlSaveShowSeconds(v) { try { localStorage.setItem(NL_SEC_KEY, v ? '1' : '0'); } catch (e) { } }
        (function () {
          const cb = document.getElementById('nlShowSeconds');
          if (cb) { cb.checked = nlLoadShowSeconds(); cb.onchange = () => nlSaveShowSeconds(cb.checked); }
        })();


        // ===== Fullscreen handling =====
        function nlEnterFullscreen() {
          const cont = document.createElement('div'); cont.className = 'nl-fullscreen'; cont.id = 'nlFS';
          const close = document.createElement('button'); close.className = 'nl-fs-close'; close.textContent = '閉じる';
          close.onclick = () => {
            const fs = document.getElementById('nlFS'); if (fs) fs.remove(); nlRebuildAll(); try { scheduleStudyWatchdog && scheduleStudyWatchdog(); } catch (e) { }
            try { scheduleStudyWatchdog(); } catch (e) { }
          };
          cont.appendChild(close);
          document.body.appendChild(cont);
          // Build a fresh current-hour row inside fullscreen
          const nowD = (window.__getNow ? window.__getNow() : (window.__getNow ? window.__getNow() : new Date()));
          const base = new Date(nowD.getFullYear(), nowD.getMonth(), nowD.getDate(), nowD.getHours(), 0, 0, 0);
          const row = nlBuildRow(base, true);
          cont.appendChild(row);
        }
        (function () { const btn = document.getElementById('nlFullscreenBtn'); if (btn) btn.onclick = nlEnterFullscreen; })();


        // === Inject style panel for bars ===
        (function () {
          const rows = document.getElementById('nlRows');
          if (!rows) return;
          if (!document.getElementById('nlStylePanel')) {
            const panel = document.createElement('div');
            panel.id = 'nlStylePanel';
            panel.style.display = 'grid';
            panel.style.gridTemplateColumns = 'repeat(3, minmax(0,1fr))';
            panel.style.gap = '8px';
            panel.style.margin = '8px 0 4px 80px';
            panel.style.alignItems = 'center';
            panel.innerHTML = `
      <div style="display:flex;align-items:center;gap:8px;">
        <label style="font-size:12px;opacity:.8;">透明度</label>
        <input id="nlOpacity" type="range" min="0.2" max="1" step="0.05" value="0.8" style="width:140px;">
        <span id="nlOpacityVal" style="font-size:12px;opacity:.8;">0.80</span>
      </div>
      <div style="display:flex;align-items:center;gap:8px;">
        <label style="font-size:12px;opacity:.8;">見た目</label>
        <select id="nlTheme" style="padding:4px 8px;font-size:12px;">
          <option value="glass">ガラス（高品質）</option>
          <option value="metal">メタル</option>
          <option value="solid">ソリッド</option>
          <option value="gradient" selected>グラデーション</option>
          <option value="neon">ネオン</option>
          <option value="outline">アウトライン</option>
        </select>
      </div>
      <div style="display:flex;align-items:center;gap:8px;">
        <label style="font-size:12px;opacity:.8;">形</label>
        <select id="nlShape" style="padding:4px 8px;font-size:12px;">
          <option value="pill">ピル（丸）</option>
          <option value="rect" selected>角</option>
          <option value="underline">アンダーライン</option>
          <option value="bevel">ベベル</option>
        </select>
      </div>
      <div style="display:flex;align-items:center;gap:8px;">
        <label style="font-size:12px;opacity:.8;">バー高さ</label>
        <input id="nlBarHeight" type="range" min="12" max="120" step="2" value="30" style="width:140px;">
        <span id="nlHeightVal" style="font-size:12px;opacity:.8;">30px</span>
      </div>
      <div style="display:flex;align-items:center;gap:8px;">
        <label style="font-size:12px;opacity:.8;">ゲージデザイン</label>
        <select id="nlGaugeStyle" style="padding:4px 8px;font-size:12px;">
          <option value="standard" selected>通常</option>
          <option value="guide">目安ゲージ風</option>
        </select>
      </div>
    `;
            rows.parentNode.insertBefore(panel, rows.nextSibling);
          }
        })();

        tick();
      })();
    </script>

    <!-- Timer/Stopwatch & Numberline Overlay Patch v2 -->
    <script>
      (function () {
        if (window.__timerPatchAppliedV2) return;
        window.__timerPatchAppliedV2 = true;
        const $ = (id) => document.getElementById(id);
        function triggerTimerSound(key) {
          if (!key) return;
          try { window.SoundMgr && SoundMgr.trigger && SoundMgr.trigger(key); } catch (_) { }
        }
        function resetTimerSoundFlags(t) {
          t._soundFlags = { half: false, last60: false, last10: false, last01: false, complete: false };
        }
        function ensureTimerFlags(t) {
          if (!t._soundFlags) resetTimerSoundFlags(t);
          return t._soundFlags;
        }
        function handleTimerSoundProgress(t) {
          if (!t || t.total <= 0) return;
          const flags = ensureTimerFlags(t);
          const remain = Math.max(0, t.remain || 0);
          if (!flags.half && remain <= t.total / 2) {
            flags.half = true; triggerTimerSound('timer.half');
          }
          if (!flags.last60 && remain <= 60) {
            flags.last60 = true; triggerTimerSound('timer.last60');
          }
          if (!flags.last10 && remain <= 10) {
            flags.last10 = true; triggerTimerSound('timer.last10');
          }
          if (!flags.last01 && remain <= 1) {
            flags.last01 = true; triggerTimerSound('timer.last01');
          }
        }
        function getTimerNowMs() {
          try {
            if (typeof window.__getNow === 'function') return window.__getNow().getTime();
          } catch (_) { }
          return Date.now();
        }
        function getTimerNowSec() { return Math.floor(getTimerNowMs() / 1000); }
        function roundTimerRemainSec(raw) {
          const n = Number(raw || 0);
          if (n >= 0) return Math.ceil(n);
          return -Math.floor(Math.abs(n));
        }
        function alignTimerEndSec(t, nowSec = getTimerNowSec()) {
          if (!t) return;
          const remainSec = roundTimerRemainSec(t.remain);
          t.remain = remainSec;
          t._endSec = nowSec + remainSec;
          t.start = nowSec * 1000;
        }
        if (!window.__timerNowSec) window.__timerNowSec = getTimerNowSec;
        if (!window.__timerRoundRemainSec) window.__timerRoundRemainSec = roundTimerRemainSec;
        if (!window.__alignTimerEndSec) window.__alignTimerEndSec = alignTimerEndSec;

        // Timer finish toast (bottom-right)
        let timerFinishToast = null;
        let timerFinishTitle = null;
        let timerFinishSub = null;
        let timerFinishTime = null;
        let timerFinishMeta = null;
        let timerFinishClose = null;
        let timerFinishStop = null;
        let timerFinishContinue = null;
        let timerFinishTimerId = null;
        let timerFinishTicker = null;
        let timerFlyRefreshTs = 0;

        function fmtClock(sec) {
          const s = Math.max(0, Math.floor(sec || 0));
          const m = Math.floor(s / 60);
          const ss = s % 60;
          return `${String(m).padStart(2, '0')}:${String(ss).padStart(2, '0')}`;
        }

        function fmtSignedClock(sec) {
          const n = Math.floor(sec || 0);
          return `${n < 0 ? '-' : ''}${fmtClock(Math.abs(n))}`;
        }

        function ensureTimerFinishToast() {
          if (timerFinishToast) return;
          timerFinishToast = $('timerFinishToast');
          if (!timerFinishToast) return;
          timerFinishTitle = $('timerFinishTitle');
          timerFinishSub = $('timerFinishSub');
          timerFinishTime = $('timerFinishTime');
          timerFinishMeta = $('timerFinishMeta');
          timerFinishClose = $('timerFinishClose');
          timerFinishStop = $('timerFinishStop');
          timerFinishContinue = $('timerFinishContinue');
          if (timerFinishClose) timerFinishClose.addEventListener('click', () => hideTimerFinishToast());
          if (timerFinishContinue) timerFinishContinue.addEventListener('click', () => hideTimerFinishToast());
          if (timerFinishStop) {
            timerFinishStop.addEventListener('click', () => {
              const idx = (window.timers || []).findIndex(t => t.id === timerFinishTimerId);
              if (idx >= 0) {
                const t = window.timers[idx];
                t.running = false;
                t.remain = 0;
                t.overtime = false;
                t.alerted = true;
                updateTimer(idx);
                renderTimers();
                drawTimerArcs();
                nlRenderTimerOverlays();
              }
              hideTimerFinishToast();
            });
          }
        }

        function updateTimerFinishToast(t) {
          if (!timerFinishToast || !t) return;
          const idx = (window.timers || []).findIndex(x => x.id === t.id);
          const label = idx >= 0 ? `タイマー ${idx + 1}` : 'タイマー';
          if (timerFinishTitle) timerFinishTitle.textContent = 'タイマー終了';
          if (timerFinishSub) timerFinishSub.textContent = `${label} が終了しました`;
          if (timerFinishTime) timerFinishTime.textContent = fmtSignedClock(t.remain || 0);
          const overtime = Math.max(0, Math.floor(-(t.remain || 0)));
          if (timerFinishMeta) timerFinishMeta.textContent = `経過 ${fmtClock(overtime)}`;
        }

        function showTimerFinishToast(t) {
          ensureTimerFinishToast();
          if (!timerFinishToast || !t) return;
          timerFinishTimerId = t.id;
          updateTimerFinishToast(t);
          timerFinishToast.classList.add('show');
          if (timerFinishTicker) clearInterval(timerFinishTicker);
          timerFinishTicker = setInterval(() => {
            const cur = (window.timers || []).find(x => x.id === timerFinishTimerId);
            if (!cur) return;
            updateTimerFinishToast(cur);
          }, 500);
        }

        function hideTimerFinishToast() {
          if (!timerFinishToast) return;
          timerFinishToast.classList.remove('show');
          if (timerFinishTicker) { clearInterval(timerFinishTicker); timerFinishTicker = null; }
        }

        function refreshFlyClockThrottled(force = false) {
          if (typeof refreshPlannerFlyClock !== 'function') return;
          const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
          if (!force && now - timerFlyRefreshTs < 450) return;
          timerFlyRefreshTs = now;
          try { refreshPlannerFlyClock(true); } catch (_) { }
        }
        let timerVizRaf = null;
        function requestTimerVizUpdate(forceFly = false) {
          if (timerVizRaf) return;
          timerVizRaf = requestAnimationFrame(() => {
            timerVizRaf = null;
            drawTimerArcs();
            nlRenderTimerOverlays();
            refreshFlyClockThrottled(forceFly);
          });
        }

        // Globals
        window.timers = window.timers || [];
        window.timers.forEach(t => {
          resetTimerSoundFlags(t);
          if (typeof t.overtime !== 'boolean') t.overtime = false;
        });
        window.sws = window.sws || [];
        window.timerId = window.timerId || 0;
        window.swId = window.swId || 0;
        window.timerKitchenMode = !!window.timerKitchenMode;
        let timerFullscreenId = null;
        const isLockedTimer = (t) => !!(t && (t.locked || t.source === 'lesson'));
        const notifyLockedTimer = () => {
          try { if (typeof showToast === 'function') showToast('授業タイマーは操作できません', 'info'); } catch (_) { }
        };

        // Helpers presence fallbacks
        window.minToAng = window.minToAng || function (min, total) { const t = total || 60; return (min / t) * Math.PI * 2 - Math.PI / 2; };
        window.arcPath = window.arcPath || function (r, a1, a2, sw) {
          const cx = 250, cy = 250;
          const rr1 = r - (sw / 2), rr2 = r + (sw / 2);
          const x1 = cx + rr1 * Math.cos(a1), y1 = cy + rr1 * Math.sin(a1);
          const x2 = cx + rr1 * Math.cos(a2), y2 = cy + rr1 * Math.sin(a2);
          const x3 = cx + rr2 * Math.cos(a2), y3 = cy + rr2 * Math.sin(a2);
          const x4 = cx + rr2 * Math.cos(a1), y4 = cy + rr2 * Math.sin(a1);
          const large = (a2 - a1) % (Math.PI * 2) > Math.PI ? 1 : 0;
          return `M ${x1} ${y1} A ${rr1} ${rr1} 0 ${large} 1 ${x2} ${y2} L ${x3} ${y3} A ${rr2} ${rr2} 0 ${large} 0 ${x4} ${y4} Z`;
        };

        // ============ Stopwatch ============
        function addSW() { window.sws.push({ id: window.swId++, elapsed: 0, running: false, start: 0 }); renderSW(); }
        function renderSW() {
          const root = $('swList'); if (!root) return;
          root.innerHTML = '';
          (window.sws || []).forEach((sw, i) => {
            const div = document.createElement('div'); div.className = 'sw-item';
            const time = document.createElement('div'); time.className = 'sw-time'; time.id = `sw${sw.id}`;
            time.textContent = fmtSW(sw.elapsed);
            const btns = document.createElement('div'); btns.className = 'sw-btns';
            const start = document.createElement('button'); start.textContent = sw.running ? '⏸ 停止' : '▶ 開始'; start.onclick = () => toggleSW(i);
            const reset = document.createElement('button'); reset.className = 'ghost'; reset.textContent = '↻ リセット'; reset.onclick = () => resetSW(i);
            const del = document.createElement('button'); del.className = 'ghost danger'; del.textContent = '🗑️ 削除'; del.onclick = () => { window.sws.splice(i, 1); renderSW(); };
            btns.append(start, reset, del); div.append(time, btns); root.appendChild(div);
          });
        }
        function toggleSW(i) { const sw = window.sws[i]; if (!sw) return; if (sw.running) { sw.running = false; sw.elapsed += (Date.now() - sw.start) / 1000; } else { sw.running = true; sw.start = Date.now(); } renderSW(); }
        function resetSW(i) { const sw = window.sws[i]; if (!sw) return; sw.running = false; sw.elapsed = 0; renderSW(); }
        function fmtSW(sec) { const m = Math.floor(sec / 60), s = Math.floor(sec % 60); return `${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`; }

        // ============ Timer ============
        function addTimer() {
          const now = (window.__getNow ? window.__getNow() : (window.__getNow ? window.__getNow() : (window.__getNow ? window.__getNow() : new Date())));
          const minutes = Math.max(1, parseInt(($('tMinutesInput') || { value: 25 }).value, 10) || 25);
          const color = ($('tColorInput') || { value: '#4da3ff' }).value || '#4da3ff';
          const clockMode = ($('tModeSelect') || { value: 'outer' }).value || 'outer';
          const timer = {
            id: window.timerId++,
            total: minutes * 60, remain: minutes * 60, running: false, start: 0, alerted: false, overtime: false,
            startMin: now.getMinutes(), minutes, gaugeColor: color, clockMode, __hasStarted: false
          };
          resetTimerSoundFlags(timer);
          window.timers.push(timer);
          renderTimers();
        }

        function startTimerUntil() {
          const timeEl = $('tUntilTime'); if (!timeEl) { alert('終了時刻UIの読み込みに失敗しました'); return; }
          const val = String(timeEl.value || ''); if (!val || !/^[0-2]\d:[0-5]\d$/.test(val)) { alert('終了時刻を選んでください'); return; }
          const [hhStr, mmStr] = val.split(':');
          const hh = parseInt(hhStr, 10), mm = parseInt(mmStr, 10);
          const now = (window.__getNow ? window.__getNow() : (window.__getNow ? window.__getNow() : (window.__getNow ? window.__getNow() : new Date()))); const nowAbs = now.getHours() * 60 + now.getMinutes();
          let endAbs = hh * 60 + mm; let diff = endAbs - nowAbs; if (diff <= 0) diff += 1440;
          const color = $('tUntilColor') ? $('tUntilColor').value : '#4da3ff';
          const clockMode = $('tUntilMode') ? $('tUntilMode').value : 'direct';
          const t = {
            id: window.timerId++, total: diff * 60, remain: diff * 60, running: false, start: 0, alerted: false, overtime: false,
            startMin: now.getMinutes(), minutes: diff, gaugeColor: color, clockMode: clockMode, __hasStarted: false
          };
          resetTimerSoundFlags(t);
          window.timers.push(t); renderTimers(); startTimer(window.timers.length - 1);
        }

        function fmtTimerRemain(t) {
          const raw = Number(t.remain || 0);
          const isNeg = raw < 0;
          const abs = Math.abs(raw);
          const rounded = isNeg ? Math.floor(abs) : Math.ceil(abs);
          const m = Math.floor(rounded / 60);
          const s = rounded % 60;
          const sign = (isNeg && rounded > 0) ? '-' : '';
          return `${sign}${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
        }

        function openTimerFullscreen(id) {
          const t = (window.timers || []).find(x => x.id === id);
          if (!t) return;
          timerFullscreenId = id;
          let layer = document.getElementById('timerFullscreen');
          if (!layer) {
            layer = document.createElement('div');
            layer.id = 'timerFullscreen';
            layer.className = 'timer-fullscreen';
            layer.innerHTML = `
        <div class="time" id="fsTime">--:--</div>
        <div class="timer-eta" id="fsEta"></div>
        <div class="fs-bar"><div class="fs-fill" id="fsFill"></div></div>
        <div class="fs-actions">
          <button class="btn primary" id="fsToggle">▶ 開始</button>
          <button class="btn ghost" id="fsClose">閉じる</button>
        </div>
      `;
            layer.addEventListener('click', (e) => { if (e.target === layer) closeTimerFullscreen(); });
            document.body.appendChild(layer);
          }
          const toggle = layer.querySelector('#fsToggle');
          if (toggle) { toggle.onclick = () => { const idx = window.timers.findIndex(x => x.id === id); if (idx >= 0) { window.timers[idx].running ? pauseTimer(idx) : startTimer(idx); } }; }
          const closeBtn = layer.querySelector('#fsClose');
          if (closeBtn) closeBtn.onclick = closeTimerFullscreen;
          updateTimerFullscreen(t);
        }
        function closeTimerFullscreen() {
          timerFullscreenId = null;
          const layer = document.getElementById('timerFullscreen');
          if (layer) layer.remove();
        }
        function updateTimerFullscreen(t) {
          const layer = document.getElementById('timerFullscreen');
          if (!layer || timerFullscreenId == null) return;
          if (!t || t.id !== timerFullscreenId) { closeTimerFullscreen(); return; }
          const timeEl = layer.querySelector('#fsTime');
          const etaEl = layer.querySelector('#fsEta');
          const fillEl = layer.querySelector('#fsFill');
          if (timeEl) timeEl.textContent = fmtTimerRemain(t);
          if (etaEl) {
            const end = new Date(Date.now() + Math.max(0, t.remain) * 1000);
            etaEl.textContent = `終了 ${String(end.getHours()).padStart(2, '0')}:${String(end.getMinutes()).padStart(2, '0')}`;
          }
          if (fillEl) {
            const pct = t.total > 0 ? Math.max(0, Math.min(100, t.remain / t.total * 100)) : 0;
            fillEl.style.width = pct + '%';
            fillEl.style.background = t.gaugeColor || '#4da3ff';
          }
          const toggle = layer.querySelector('#fsToggle');
          if (toggle) toggle.textContent = t.running ? '⏸ 停止' : (t.__hasStarted ? '▶ 再開' : '▶ 開始');
        }

        function renderTimers() {
          const root = $('timerList'); if (!root) return;
          root.classList.toggle('kitchen', !!window.timerKitchenMode);
          root.innerHTML = '';
          window.timers.forEach((t, i) => {
            const div = document.createElement('div'); div.className = 'timer-item-modern' + (window.timerKitchenMode ? ' kitchen' : '');
            const head = document.createElement('div'); head.className = 'timer-head';
            const title = document.createElement('div'); title.className = 'timer-title';
            const controls = document.createElement('div'); controls.className = 'timer-controls';
            const locked = isLockedTimer(t);
            title.textContent = locked ? '授業タイマー' : `タイマー ${i + 1}`;
            const minInput = document.createElement('input'); minInput.type = 'number'; minInput.min = '1'; minInput.max = '720'; minInput.value = t.minutes; minInput.className = 'input'; minInput.style.width = '80px';
            minInput.onchange = (e) => { const v = parseInt(e.target.value, 10); const next = Math.max(1, isNaN(v) ? t.minutes : v); t.minutes = next; t.total = next * 60; if (!t.running) t.remain = t.total; updateTimer(i); };
            const modeSelect = document.createElement('select'); modeSelect.className = 'input'; modeSelect.style.width = '120px'; modeSelect.innerHTML = '<option value="outer">外周</option><option value="direct">直接</option>'; modeSelect.value = t.clockMode || 'outer';
            modeSelect.onchange = (e) => { t.clockMode = e.target.value; drawTimerArcs(); nlRenderTimerOverlays(); };
            const colorInput = document.createElement('input'); colorInput.type = 'color'; colorInput.value = t.gaugeColor || '#4da3ff'; colorInput.className = 'input'; colorInput.style.width = '70px';
            colorInput.onchange = (e) => { t.gaugeColor = e.target.value; updateTimer(i); };
            if (locked) {
              minInput.disabled = true;
              modeSelect.disabled = true;
              colorInput.disabled = true;
              const tip = '授業タイマーは編集できません';
              minInput.title = tip;
              modeSelect.title = tip;
              colorInput.title = tip;
            }
            controls.append(minInput, modeSelect, colorInput);
            head.append(title, controls);

            const display = document.createElement('div'); display.className = 'timer-display-large'; display.id = `t${t.id}`;
            const eta = document.createElement('div'); eta.className = 'timer-eta'; eta.id = `te${t.id}`;
            const bar = document.createElement('div'); bar.className = 'timer-bar'; const fill = document.createElement('div'); fill.className = 'fill'; fill.id = `tf${t.id}`; bar.appendChild(fill);
            const actions = document.createElement('div'); actions.className = 'timer-actions';
            const startBtn = document.createElement('button'); startBtn.className = 'btn primary compact'; startBtn.id = `ts${t.id}`; startBtn.textContent = locked ? '授業中' : (t.running ? '⏸ 停止' : (t.__hasStarted ? '▶ 再開' : '▶ 開始')); startBtn.onclick = () => { if (locked) { notifyLockedTimer(); return; } t.running ? pauseTimer(i) : startTimer(i); };
            const resetBtn = document.createElement('button'); resetBtn.className = 'btn ghost compact'; resetBtn.textContent = '↻ リセット'; resetBtn.onclick = () => { if (locked) { notifyLockedTimer(); return; } resetTimer(i); };
            const fullscreenBtn = document.createElement('button'); fullscreenBtn.className = 'btn ghost compact'; fullscreenBtn.textContent = '⤢ 全画面'; fullscreenBtn.onclick = () => openTimerFullscreen(t.id);
            const delBtn = document.createElement('button'); delBtn.className = 'btn ghost danger compact'; delBtn.textContent = '🗑️ 削除'; delBtn.onclick = () => { if (locked) { notifyLockedTimer(); return; } window.timers.splice(i, 1); if (timerFullscreenId === t.id) closeTimerFullscreen(); renderTimers(); drawTimerArcs(); nlRenderTimerOverlays(); };
            if (locked) {
              startBtn.disabled = true;
              resetBtn.disabled = true;
              delBtn.disabled = true;
              delBtn.style.display = 'none';
            }
            actions.append(startBtn, resetBtn, fullscreenBtn, delBtn);
            const meta = document.createElement('div'); meta.className = 'timer-meta';
            const lessonTag = locked ? '<span class="timer-tag">授業タイマー</span>' : '';
            meta.innerHTML = `<span class="timer-tag">ゲージ: ${t.clockMode === 'outer' ? '外周' : '直接'}</span>${lessonTag}<span class="timer-tag">色: <span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:${t.gaugeColor || '#4da3ff'}"></span></span>`;
            div.append(head, display, eta, bar, actions, meta);
            root.appendChild(div);
            updateTimer(i);
          });
        }

        function startTimer(i) {
          const t = window.timers[i]; if (!t || t.running) return;
          if (isLockedTimer(t)) { notifyLockedTimer(); return; }
          if (t.remain <= 0 && !t.overtime) {
            t.total = t.minutes * 60;
            t.remain = t.total;
            t.alerted = false;
            t.overtime = false;
            resetTimerSoundFlags(t);
            const now = (window.__getNow ? window.__getNow() : (window.__getNow ? window.__getNow() : new Date()));
            t.startMin = now.getMinutes();
          }
          const isFresh = !t.__hasStarted || t.remain === t.total;
          const isResume = t.__hasStarted && t.remain > 0 && t.remain < t.total;
          t.__hasStarted = true;
          t.running = true;
          alignTimerEndSec(t, getTimerNowSec());
          if (isFresh) {
            triggerTimerSound('timer.start');
          } else if (isResume) {
            triggerTimerSound('timer.resume');
          }
          renderTimers();
          requestTimerVizUpdate(true);
        }
        function pauseTimer(i) {
          const t = window.timers[i]; if (!t) return;
          if (isLockedTimer(t)) { notifyLockedTimer(); return; }
          if (t.running) { triggerTimerSound('timer.pause'); }
          const nowSec = getTimerNowSec();
          if (Number.isFinite(t._endSec)) {
            t.remain = t._endSec - nowSec;
          } else {
            t.remain = roundTimerRemainSec(t.remain);
          }
          t._endSec = null;
          t.running = false; renderTimers();
          requestTimerVizUpdate(true);
        }
        function resetTimer(i) {
          const t = window.timers[i]; if (!t) return;
          if (isLockedTimer(t)) { notifyLockedTimer(); return; }
          t.total = t.minutes * 60; t.remain = t.total; t.running = false; t.alerted = false;
          t.overtime = false;
          t.__hasStarted = false;
          t._endSec = null;
          resetTimerSoundFlags(t);
          t.startMin = (window.__getNow ? window.__getNow() : (window.__getNow ? window.__getNow() : new Date())).getMinutes();
          updateTimer(i); renderTimers();
          requestTimerVizUpdate(true);
        }
        function updateTimer(i) {
          const t = window.timers[i]; if (!t) return;
          const el = $('t' + t.id);
          if (el) { el.textContent = fmtTimerRemain(t); }
          const ee = $('te' + t.id);
          if (ee) { const end = new Date(Date.now() + Math.max(0, t.remain) * 1000); ee.textContent = `終了 ${String(end.getHours()).padStart(2, '0')}:${String(end.getMinutes()).padStart(2, '0')}`; }
          const fill = $('tf' + t.id); if (fill) { const pct = t.total > 0 ? Math.max(0, Math.min(50000, t.remain / t.total * 100)) : 0; fill.style.width = pct + '%'; fill.style.background = t.gaugeColor || '#4da3ff'; }
          const startBtn = $('ts' + t.id);
          if (startBtn) {
            if (isLockedTimer(t)) {
              startBtn.textContent = '授業中';
              startBtn.disabled = true;
            } else {
              startBtn.textContent = t.running ? '⏸ 停止' : (t.__hasStarted ? '▶ 再開' : '▶ 開始');
              startBtn.disabled = false;
            }
          }
          updateTimerFullscreen(t);
          const nowTs = Date.now();
          if (!window.__lastTimerViz || nowTs - window.__lastTimerViz > 800) {
            window.__lastTimerViz = nowTs;
            requestTimerVizUpdate();
          }
        }
        function tickTimer() {
          let didTick = false;
          const nowSec = getTimerNowSec();
          (window.timers || []).forEach((t, i) => {
            if (t.running) {
              if (!Number.isFinite(t._endSec)) {
                alignTimerEndSec(t, nowSec);
              }
              t.remain = t._endSec - nowSec;
              handleTimerSoundProgress(t);
              updateTimer(i);
              didTick = true;
              if (t.remain <= 0 && !t.alerted) {
                t.alerted = true;
                t.overtime = true;
                ensureTimerFlags(t).complete = true;
                triggerTimerSound('timer.complete');
                try { notify && notify('⏰ タイマー終了!'); } catch (e) { }
                showTimerFinishToast(t);
                const el = $('t' + t.id); if (el) { el.classList.add('alert'); setTimeout(() => el.classList.remove('alert'), 1500); }
                renderTimers();
              }
            }
          });
          if (didTick) {
            requestTimerVizUpdate();
          }
        }

        // ============ Planner Clock Arcs ============
        function ensureTimerArcGroup() {
          let group = $('timerArcs');
          if (group) return group;
          // try to find planner clock SVG
          let svg = document.querySelector('#planner svg, .planner svg, svg#plannerClock, svg#clock, .clock svg, svg');
          if (!svg || !(svg instanceof SVGElement)) return null;
          group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
          group.setAttribute('id', 'timerArcs');
          group.setAttribute('style', 'pointer-events:none');
          // Place just beneath hands, above other arcs
          const hands = svg.querySelector('#hands');
          if (hands && hands.parentNode) { hands.parentNode.insertBefore(group, hands); } else { svg.appendChild(group); }
          return group;
        }


        function drawTimerArcs() {
          const plannerApp = document.getElementById('plannerApp');
          const plannerHidden = !plannerApp || plannerApp.classList.contains('hidden');
          const fly = document.getElementById('plannerFly');
          const flyVisible = !!(fly && fly.classList.contains('active'));
          if (plannerHidden && !flyVisible) return;
          const group = ensureTimerArcGroup(); if (!group) return;
          const nodes = [];
          const modeSel = $('mode'); const faceMode = modeSel ? modeSel.value : 'hour';
          const now = (window.__getNow ? window.__getNow() : (window.__getNow ? window.__getNow() : new Date()));
          const timers = (window.timers || []).filter(t => t && t.total > 0 && t.remain > 0);
          const baseR = 210, insetBase = 50, insetStep = 16, sw = 6, s0 = -Math.PI / 2;
          const totalMinOnFace = (faceMode === 'day') ? 720 : 60;

          function fullCirclePath(r) { return arcPath(r, s0, s0 + 2 * Math.PI, sw); }
          function addTrack(r) {
            const track = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            track.setAttribute('d', fullCirclePath(r));
            track.setAttribute('stroke', '#00000040');
            track.setAttribute('fill', 'none');
            track.setAttribute('opacity', '0.4');
            track.setAttribute('stroke-linecap', 'round');
            track.setAttribute('stroke-width', String(sw));
            nodes.push(track);
          }
          function addArc(r, a1, a2, color, alpha) {
            const p = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            p.setAttribute('d', arcPath(r, a1, a2, sw));
            p.setAttribute('stroke', color || '#4da3ff');
            p.setAttribute('fill', 'none');
            p.setAttribute('opacity', String(alpha ?? 0.9));
            p.setAttribute('stroke-linecap', 'round');
            p.setAttribute('stroke-width', String(sw));
            nodes.push(p);

            const ph = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            ph.setAttribute('d', arcPath(r, a1, a2, Math.max(1, sw - 3)));
            ph.setAttribute('stroke', '#ffffff');
            ph.setAttribute('fill', 'none');
            ph.setAttribute('opacity', String(Math.max(0, (alpha ?? 0.9) * 0.2)));
            ph.setAttribute('stroke-linecap', 'round');
            ph.setAttribute('stroke-width', String(Math.max(1, sw - 3)));
            nodes.push(ph);
          }

          timers.forEach((t, idx) => {
            const r = baseR - (insetBase + idx * insetStep);
            addTrack(r);

            if (t.clockMode === 'outer') {
              // 一周＝t.total（秒）。残り割合で 12時から短くする
              const total = Math.max(1, t.total);
              const remain = Math.max(0, Math.min(t.remain, total));
              const frac = remain / total;
              if (frac <= 1e-4) return; // 完全非表示
              const a1 = s0;
              const a2 = s0 + 2 * Math.PI * frac;
              addArc(r, a1, a2, (t.gaugeColor || '#4da3ff'), 0.95);
              return;
            }

            // 直接配置：最初の角度を固定。以降動かない。0で非表示
            if (t._anchorTotal !== t.total) { delete t._directAnchorAngle; t._anchorTotal = t.total; }
            if (t._directAnchorAngle == null) {
              const curMin = (faceMode === 'day') ? ((now.getHours() % 12) * 60 + now.getMinutes()) : now.getMinutes();
              t._directAnchorAngle = minToAng(curMin, totalMinOnFace);
            }
            const a1 = t._directAnchorAngle;
            const spanMin = t.total / 60; // 分
            if (spanMin <= 0) return;
            const delta = (spanMin / totalMinOnFace) * 2 * Math.PI;
            const a2 = a1 + delta;
            addArc(r, a1, a2, (t.gaugeColor || '#4da3ff'), 0.75);
          });

          if (nodes.length) {
            group.replaceChildren(...nodes);
          } else {
            group.replaceChildren();
          }
        }


        // ============ Numberline Overlays ============
        function nlRenderTimerOverlays() {
          const nlRoot = document.getElementById('nlRows');
          if (!nlRoot) return;
          const plannerApp = document.getElementById('plannerApp');
          const plannerHidden = !!(plannerApp && plannerApp.classList.contains('hidden'));
          const numberlineTab = nlRoot.closest('.tab-content');
          const numberlineVisible = !!(numberlineTab && numberlineTab.classList.contains('active'));
          const fly = document.getElementById('numberlineFly');
          const flyVisible = !!(fly && fly.classList.contains('active'));
          if ((!numberlineVisible && !flyVisible) || (plannerHidden && !flyVisible)) return;
          // clear
          document.querySelectorAll('.nl-row .nl-timer, .nl-row .nl-timer-outer').forEach(n => n.remove());
          if (!(window.timers && window.timers.length)) return;
          const nowD = (window.__getNow ? window.__getNow() : (window.__getNow ? window.__getNow() : new Date()));
          const rows = Array.from(document.querySelectorAll('.nl-row'));
          rows.forEach(r => { r.__nlStack = 0; r.__nlOuterStack = 0; });
          if (!rows.length) return;

          // Identify current hour row
          const nowHourStart = new Date(nowD.getFullYear(), nowD.getMonth(), nowD.getDate(), nowD.getHours(), 0, 0).getTime();
          let currentRow = null;
          rows.forEach(row => { const ts = parseInt(row.dataset.startTs || '0', 10); if (ts === nowHourStart) currentRow = row; });

          window.timers.forEach(t => {
            const remainSec = Math.max(0, t.remain || 0);
            if (remainSec <= 0) return;
            const end = new Date(nowD.getTime() + remainSec * 1000);

            // direct placement: overlap bars within each hour
            if (t.clockMode !== 'outer') {
              rows.forEach(row => {
                const startTs = parseInt(row.dataset.startTs || '0', 10);
                const hourStart = new Date(startTs);
                const hourEnd = new Date(startTs + 60 * 60000);
                const overlapStart = new Date(Math.max(nowD.getTime(), hourStart.getTime()));
                const overlapEnd = new Date(Math.min(end.getTime(), hourEnd.getTime()));
                if (overlapEnd > overlapStart) {
                  const startMin = (overlapStart - hourStart) / 60000;
                  const endMin = (overlapEnd - hourStart) / 60000;
                  const leftPct = Math.max(0, Math.min(50000, ((startMin + 0.0001) / 60) * 100));
                  const rightPct = Math.max(0, Math.min(50000, ((endMin + 0.0001) / 60) * 100));
                  const widthPct = Math.max(1, rightPct - leftPct);
                  const bar = document.createElement('div');
                  bar.className = 'nl-timer';
                  bar.style.position = 'absolute';
                  bar.style.left = leftPct + '%';
                  bar.style.width = widthPct + '%';
                  bar.style.height = '10px';
                  bar.style.top = '96%'; // もう少し下げる
                  bar.style.transform = 'translateY(-50%)';
                  bar.style.borderRadius = '6px';
                  bar.style.zIndex = '2';
                  bar.style.background = (t.gaugeColor || '#4da3ff') + '80';
                  bar.title = 'タイマー残り';
                  row.__nlStack = (row.__nlStack || 0);
                  bar.style.top = `calc(96% + ${row.__nlStack * 12}px)`;
                  row.__nlStack++;
                  const barsEl = row.querySelector('.nl-bars');
                  if (barsEl) barsEl.appendChild(bar);
                }
              });
            } else {
              // outer mode in numberline: 0-60 full width gauge that shrinks from right, only on current hour row
              if (currentRow) {
                const barsEl = currentRow.querySelector('.nl-bars');
                if (barsEl) {
                  // make container full-width
                  const total = Math.max(1, t.total);
                  const pct = Math.max(0, Math.min(50000, (t.remain / total) * 100));
                  // background track
                  const track = document.createElement('div');
                  track.className = 'nl-timer-outer';
                  track.style.position = 'absolute';
                  track.style.left = '0%';
                  track.style.width = '100%';
                  track.style.height = '10px';
                  track.style.top = '96%'; // もう少し下げる
                  track.style.transform = 'translateY(-50%)';
                  track.style.borderRadius = '6px';
                  track.style.zIndex = '2';
                  track.style.background = '#00000020';
                  // fill from left to right, then we mask right side by width pct
                  const fill = document.createElement('div');
                  fill.style.height = '100%';
                  fill.style.width = pct + '%';
                  fill.style.right = '0';
                  fill.style.left = 'auto';
                  fill.style.transition = 'none'; // 右から減らす（右端固定で幅のみ縮小）
                  fill.style.background = (t.gaugeColor || '#4da3ff') + '99';
                  fill.style.borderRadius = '6px';
                  track.appendChild(fill);
                  // 追加: 残り時間と終了時刻のラベル
                  (function () {
                    try {
                      const label = document.createElement('div');
                      label.className = 'nl-timer-label';
                      label.style.position = 'absolute';
                      label.style.left = '0';
                      label.style.top = '-18px';
                      label.style.fontSize = '12px';
                      label.style.color = 'var(--muted)';
                      label.style.pointerEvents = 'none';
                      const end = new Date(nowD.getTime() + remainSec * 1000);
                      const pad = n => String(n).padStart(2, '0');
                      const hhE = pad(end.getHours());
                      const mmE = pad(end.getMinutes());
                      const remainLabel = fmtTimerRemain(t);
                      label.textContent = `残: ${remainLabel} / 終: ${hhE}:${mmE}`;
                      track.appendChild(label);
                    } catch (e) { }
                  })();
                  currentRow.__nlOuterStack = (currentRow.__nlOuterStack || 0);
                  track.style.top = `calc(96% + ${currentRow.__nlOuterStack * 12}px)`;
                  currentRow.__nlOuterStack++;
                  barsEl.appendChild(track);
                }
              }
            }
          });
        }

        // Expose timer API for other UI (pie menu / HUD)
        window.startTimer = startTimer;
        window.pauseTimer = pauseTimer;
        window.resetTimer = resetTimer;
        window.updateTimer = updateTimer;
        window.renderTimers = renderTimers;
        window.tickTimer = tickTimer;
        window.addTimer = addTimer;
        window.startTimerUntil = startTimerUntil;
        window.drawTimerArcs = drawTimerArcs;
        window.nlRenderTimerOverlays = nlRenderTimerOverlays;
        window.__resetTimerSoundFlags = resetTimerSoundFlags;
        window.__requestTimerVizUpdate = requestTimerVizUpdate;

        // ============ Bindings ============
        function bind() {
          const btnAddTimer = $('tAdd'); if (btnAddTimer) btnAddTimer.onclick = addTimer;
          const btnUntilStart = $('tUntilStart'); if (btnUntilStart) btnUntilStart.onclick = startTimerUntil;
          const kitchenBtn = $('timerKitchenToggle'); if (kitchenBtn) { kitchenBtn.onclick = () => { window.timerKitchenMode = !window.timerKitchenMode; kitchenBtn.classList.toggle('primary', window.timerKitchenMode); kitchenBtn.textContent = window.timerKitchenMode ? '🍳 キッチンモード ON' : '🍳 キッチンモード'; renderTimers(); }; }
          const btnAddSW = $('swAdd'); if (btnAddSW) btnAddSW.onclick = addSW;
          // default until time
          if ($('tUntilTime')) { const d = new Date(Date.now() + 25 * 60000); $('tUntilTime').value = `${String(d.getHours()).padStart(2, '0')}:${String(d.getMinutes()).padStart(2, '0')}`; }
          // loops
          const startAlignedTimerTick = () => {
            const step = () => {
              tickTimer();
              const nowMs = Date.now();
              const nextDelay = 1000 - (nowMs % 1000);
              window.__timerIntV2 = setTimeout(step, nextDelay);
            };
            const nowMs = Date.now();
            const delay = 1000 - (nowMs % 1000);
            window.__timerIntV2 = setTimeout(step, delay);
            window.__timerIntV2Aligned = true;
          };
          if (!window.__timerIntV2) {
            startAlignedTimerTick();
          } else if (!window.__timerIntV2Aligned) {
            clearTimeout(window.__timerIntV2);
            clearInterval(window.__timerIntV2);
            startAlignedTimerTick();
          }
          if (!window.__swIntV2) window.__swIntV2 = setInterval(() => { (window.sws || []).forEach(sw => { if (sw.running) { const sec = sw.elapsed + (Date.now() - sw.start) / 1000; const el = $('sw' + sw.id); if (el) el.textContent = fmtSW(sec); } }); }, 500);
          if (!window.__nlTimerOverlayIntV2) window.__nlTimerOverlayIntV2 = setInterval(nlRenderTimerOverlays, 1000);
          // initial draws
          renderTimers(); renderSW(); drawTimerArcs(); nlRenderTimerOverlays();
        }
        if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', bind); else bind();
      })();
    </script>
    <style data-planner-style="1" media="not all">
      .nl-timer,
      .nl-timer-outer {
        box-shadow: 0 1px 3px rgba(0, 0, 0, .25), inset 0 0 0 1px rgba(255, 255, 255, .2)
      }
    </style>

    <style id="global-visual-effects" data-planner-style="1">
      #globalEffectLayer {
        position: fixed;
        inset: 0;
        pointer-events: none;
        z-index: 100000;
        display: block;
      }

      .fx-overlay {
        position: absolute;
        inset: 0;
        opacity: 0;
        transition: opacity .25s ease, transform .25s ease;
        mix-blend-mode: screen;
      }

      .fx-overlay.show {
        opacity: 1;
      }

      .fx-overlay.fade {
        opacity: 0;
      }

      .fx-flash {
        background: radial-gradient(circle at center, rgba(255, 255, 255, .85), rgba(255, 255, 255, 0));
        animation: fxFlash 720ms ease-out forwards;
      }

      @keyframes fxFlash {
        0% {
          opacity: 0;
        }

        10% {
          opacity: 1;
        }

        100% {
          opacity: 0;
        }
      }

      .fx-bluepulse {
        background: radial-gradient(circle at center, rgba(77, 163, 255, .6), rgba(15, 23, 42, .0));
        filter: blur(2px);
        animation: fxBluePulse 1200ms ease-out forwards;
      }

      @keyframes fxBluePulse {
        0% {
          transform: scale(0.7);
          opacity: 0;
        }

        35% {
          opacity: 0.95;
        }

        100% {
          transform: scale(1.25);
          opacity: 0;
        }
      }

      .fx-aurora {
        background: linear-gradient(125deg, rgba(123, 92, 255, .55), rgba(0, 214, 255, .35), rgba(255, 255, 255, .15));
        background-size: 400% 400%;
        animation: fxAurora 1800ms ease forwards;
      }

      @keyframes fxAurora {
        0% {
          background-position: 0% 50%;
          opacity: 0;
        }

        20% {
          opacity: 0.85;
        }

        100% {
          background-position: 100% 50%;
          opacity: 0;
        }
      }

      .fx-grid {
        background:
          repeating-linear-gradient(90deg, rgba(79, 196, 255, .2) 0 2px, transparent 2px 80px),
          repeating-linear-gradient(0deg, rgba(79, 196, 255, .2) 0 2px, transparent 2px 80px);
        animation: fxGrid 1400ms ease-out forwards;
      }

      @keyframes fxGrid {
        0% {
          opacity: 0;
          transform: scale(1.1);
        }

        25% {
          opacity: .9;
        }

        100% {
          opacity: 0;
          transform: scale(1.4);
        }
      }

      .fx-neon {
        background: radial-gradient(circle at center, rgba(255, 255, 255, .75) 0%, rgba(255, 255, 255, .15) 35%, rgba(0, 0, 0, 0) 65%);
        mix-blend-mode: screen;
        animation: fxNeon 1500ms ease-out forwards;
      }

      @keyframes fxNeon {
        0% {
          opacity: 0;
          transform: scale(0.5);
        }

        30% {
          opacity: .95;
        }

        100% {
          opacity: 0;
          transform: scale(1.3);
        }
      }

      .fx-spark span,
      .fx-confetti span {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 6px;
        height: 6px;
        border-radius: 50%;
        animation-duration: 1.4s;
        animation-fill-mode: forwards;
        transform: translate(-50%, -50%);
      }

      .fx-spark span {
        background: #fff;
        box-shadow: 0 0 12px rgba(255, 255, 255, .9);
        animation-name: fxSpark;
      }

      @keyframes fxSpark {
        0% {
          opacity: 0;
          transform: translate(-50%, -50%) scale(.2);
        }

        10% {
          opacity: 1;
        }

        100% {
          opacity: 0;
          transform: translate(calc(-50% + var(--x, 0)), calc(-50% + var(--y, 0))) scale(.05);
        }
      }

      .fx-confetti span {
        width: 8px;
        height: 14px;
        border-radius: 2px;
        animation-name: fxConfetti;
        transform-origin: center;
      }

      @keyframes fxConfetti {
        0% {
          opacity: 0;
          transform: translate(-50%, -50%) rotate(0deg);
        }

        10% {
          opacity: 1;
        }

        100% {
          opacity: 0;
          transform: translate(calc(-50% + var(--x, 0)), calc(-50% + var(--y, 40vh))) rotate(520deg);
        }
      }

      .fx-ripple::before,
      .fx-ripple::after {
        content: "";
        position: absolute;
        inset: 20%;
        border: 2px solid rgba(255, 255, 255, .6);
        border-radius: 50%;
        animation: fxRipple 1100ms ease-out forwards;
      }

      .fx-ripple::after {
        animation-delay: .15s;
        border-color: rgba(77, 163, 255, .7);
      }

      @keyframes fxRipple {
        0% {
          transform: scale(.6);
          opacity: .9;
        }

        100% {
          transform: scale(1.8);
          opacity: 0;
        }
      }

      .fx-countsingle {
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 900;
        font-size: 96px;
        color: #111;
        letter-spacing: 0.04em;
        mix-blend-mode: normal;
        text-shadow:
          0 0 12px rgba(255, 255, 255, .45),
          0 6px 18px rgba(0, 0, 0, .35);
        animation: fxCountSingle 1.2s ease forwards;
      }

      .fx-countsingle span {
        display: inline-block;
        transform: translateY(6px) scale(.96);
        animation: fxCountSingleSpan 1.2s ease forwards;
      }

      @keyframes fxCountSingle {
        0% {
          opacity: 0;
          transform: translateY(10px) scale(.92);
        }

        20% {
          opacity: 1;
          transform: translateY(-4px) scale(1.02);
        }

        70% {
          opacity: .96;
          transform: translateY(-8px) scale(1);
        }

        100% {
          opacity: 0;
          transform: translateY(-14px) scale(.95);
        }
      }

      .fx-blood {
        background: radial-gradient(circle at center, rgba(132, 12, 12, .85) 0%, rgba(48, 7, 7, .95) 45%, rgba(0, 0, 0, .85) 100%);
        mix-blend-mode: multiply;
        animation: fxBlood 900ms ease-out forwards;
      }

      @keyframes fxBlood {
        0% {
          opacity: 0;
          transform: scale(.92);
        }

        18% {
          opacity: .95;
          transform: scale(1.02);
        }

        70% {
          opacity: .9;
          transform: scale(1.1);
        }

        100% {
          opacity: 0;
          transform: scale(1.25);
        }
      }

      .fx-glitch {
        background:
          linear-gradient(90deg, rgba(255, 255, 255, .35) 0 2%, rgba(0, 0, 0, 0) 2% 6%),
          linear-gradient(0deg, rgba(255, 0, 92, .25) 0 12%, rgba(0, 255, 220, .25) 12% 24%, rgba(0, 0, 0, 0) 24% 100%);
        mix-blend-mode: screen;
        filter: hue-rotate(-12deg) saturate(1.2);
        animation: fxGlitch 900ms steps(4) forwards;
      }

      @keyframes fxGlitch {
        0% {
          opacity: .95;
          transform: translate(0, 0);
        }

        25% {
          opacity: 1;
          transform: translate(-4px, 2px) skewX(1deg);
        }

        50% {
          transform: translate(3px, -3px) skewX(-1deg);
        }

        75% {
          transform: translate(-2px, -1px);
        }

        100% {
          opacity: 0;
          transform: translate(0, 0);
        }
      }

      .fx-vignette {
        background: radial-gradient(ellipse at center, rgba(255, 255, 255, .18) 0%, rgba(20, 24, 38, .05) 30%, rgba(0, 0, 0, .7) 80%);
        animation: fxVignette 1300ms ease forwards;
      }

      @keyframes fxVignette {
        0% {
          opacity: 0;
        }

        20% {
          opacity: .9;
        }

        100% {
          opacity: 0;
        }
      }

      .fx-ghost {
        background: radial-gradient(circle at 40% 40%, rgba(255, 255, 255, .25) 0%, rgba(0, 0, 0, 0) 35%),
          linear-gradient(120deg, rgba(255, 255, 255, .18), rgba(0, 0, 0, 0));
        mix-blend-mode: screen;
        filter: blur(1px);
        animation: fxGhost 1200ms ease forwards;
      }

      @keyframes fxGhost {
        0% {
          opacity: 0;
          transform: translateY(10px) scale(.96);
        }

        25% {
          opacity: .9;
          transform: translateY(-6px) scale(1.02);
        }

        70% {
          opacity: .7;
          transform: translateY(-12px) scale(1);
        }

        100% {
          opacity: 0;
          transform: translateY(-18px) scale(.98);
        }
      }

      .fx-embers span {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 6px;
        height: 10px;
        border-radius: 10px;
        background: linear-gradient(180deg, #ffaf45, #ff5c39);
        box-shadow: 0 0 10px rgba(255, 92, 57, .6);
        animation: fxEmber 1.6s ease-out forwards;
        transform: translate(-50%, -50%);
        mix-blend-mode: screen;
      }

      @keyframes fxEmber {
        0% {
          opacity: 0;
          transform: translate(-50%, -50%) scale(.3);
        }

        15% {
          opacity: 1;
          transform: translate(-50%, -52%) scale(.9);
        }

        100% {
          opacity: 0;
          transform: translate(calc(-50% + var(--x, 0)), calc(-50% - var(--y, 40vh))) scale(.95);
        }
      }

      @keyframes fxCountSingleSpan {
        0% {
          opacity: 0;
          transform: translateY(6px) scale(.96);
        }

        22% {
          opacity: 1;
          transform: translateY(-2px) scale(1.03);
        }

        68% {
          opacity: .98;
          transform: translateY(-8px) scale(1);
        }

        100% {
          opacity: 0;
          transform: translateY(-14px) scale(.95);
        }
      }

      .fx-countfloat {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: center;
        gap: 10px;
        font-weight: 900;
        font-size: 26px;
        color: #f8fafc;
        text-shadow: 0 0 12px rgba(0, 0, 0, .55), 0 0 20px rgba(59, 130, 246, .35);
        filter: drop-shadow(0 8px 14px rgba(0, 0, 0, .35));
        letter-spacing: 0.02em;
      }

      .fx-countfloat span {
        opacity: 0;
        transform: translateY(8px) scale(.96);
        animation: fxCountFloat 1.2s ease forwards;
        animation-delay: var(--delay, 0s);
      }

      @keyframes fxCountFloat {
        0% {
          opacity: 0;
          transform: translateY(8px) scale(.94);
        }

        18% {
          opacity: 1;
          transform: translateY(-4px) scale(1);
        }

        70% {
          opacity: .92;
          transform: translateY(-10px) scale(1);
        }

        100% {
          opacity: 0;
          transform: translateY(-16px) scale(.92);
        }
      }
    </style>

    <script id="visual-effects-engine">
      (() => {
        if (window.VisualFX) return;
        const VisualFX = (function () {
          const OVERLAY_LIFETIME = 4000;
          let cleanupTimer = null;
          const catalog = [
            { id: 'none', label: '(エフェクトなし)', className: '', duration: 0 },
            { id: 'flash', label: 'ホワイトフラッシュ', className: 'fx-flash', duration: 720 },
            { id: 'bluepulse', label: 'ブルーパルス', className: 'fx-bluepulse', duration: 1200 },
            { id: 'aurora', label: 'オーロラスウィープ', className: 'fx-aurora', duration: 1800 },
            { id: 'grid', label: 'シアン・グリッド', className: 'fx-grid', duration: 1400 },
            { id: 'neon', label: 'ネオンリング', className: 'fx-neon', duration: 1500 },
            { id: 'ripple', label: 'リップルパルス', className: 'fx-ripple', duration: 1200 },
            { id: 'spark', label: 'スター・スパーク', build: () => spawnSpark(), duration: 1500 },
            { id: 'confetti', label: 'コンフェッティシャワー', build: () => spawnConfetti(), duration: 2000 },
            { id: 'blood', label: 'ブラッディフラッシュ', className: 'fx-blood', duration: 900 },
            { id: 'glitch', label: 'グリッチブラー', className: 'fx-glitch', duration: 900 },
            { id: 'vignette', label: 'ダークヴィネット', className: 'fx-vignette', duration: 1300 },
            { id: 'ghost', label: 'ゴーストトレイル', className: 'fx-ghost', duration: 1200 },
            { id: 'embers', label: 'エンバー', build: () => spawnEmbers(), duration: 1600 }
          ];
          for (let i = 1; i <= 20; i++) {
            catalog.push({ id: `count-${i}`, label: `カウント ${i}`, build: () => spawnCountSingle(i), duration: 1400 });
          }
          const map = new Map(catalog.map(c => [c.id, c]));

          function ensureLayer() {
            let layer = document.getElementById('globalEffectLayer');
            if (!layer) {
              layer = document.createElement('div');
              layer.id = 'globalEffectLayer';
              layer.setAttribute('aria-hidden', 'true');
              document.body.appendChild(layer);
            }
            if (!cleanupTimer) {
              cleanupTimer = setInterval(() => {
                const now = Date.now();
                Array.from(layer.querySelectorAll('.fx-overlay')).forEach(el => {
                  const born = parseInt(el.dataset.vfxTs || '0', 10);
                  if (born && (now - born) > OVERLAY_LIFETIME) { el.remove(); }
                });
              }, 2000);
            }
            return layer;
          }
          function spawnBase(cls) {
            const el = document.createElement('div');
            el.className = `fx-overlay ${cls || ''}`;
            el.dataset.vfxTs = String(Date.now());
            ensureLayer().appendChild(el);
            return el;
          }
          function spawnSpark() {
            const el = spawnBase('fx-spark');
            for (let i = 0; i < 18; i++) {
              const star = document.createElement('span');
              star.style.setProperty('--x', `${(Math.random() * 2 - 1) * 40}vw`);
              star.style.setProperty('--y', `${(Math.random() * 2 - 1) * 30}vh`);
              star.style.animationDelay = (Math.random() * 0.35).toFixed(2) + 's';
              el.appendChild(star);
            }
            return el;
          }
          function spawnConfetti() {
            const colors = ['#f97316', '#38bdf8', '#f472b6', '#a78bfa', '#34d399', '#facc15'];
            const el = spawnBase('fx-confetti');
            for (let i = 0; i < 26; i++) {
              const piece = document.createElement('span');
              piece.style.background = colors[i % colors.length];
              piece.style.setProperty('--x', `${(Math.random() * 2 - 1) * 60}vw`);
              piece.style.setProperty('--y', `${Math.random() * 30 + 25}vh`);
              piece.style.animationDelay = (Math.random() * 0.35).toFixed(2) + 's';
              el.appendChild(piece);
            }
            return el;
          }
          function spawnEmbers() {
            const el = spawnBase('fx-embers');
            for (let i = 0; i < 26; i++) {
              const ember = document.createElement('span');
              ember.style.setProperty('--x', `${(Math.random() * 2 - 1) * 32}vw`);
              ember.style.setProperty('--y', `${Math.random() * 24 + 26}vh`);
              ember.style.animationDelay = (Math.random() * 0.18).toFixed(2) + 's';
              el.appendChild(ember);
            }
            return el;
          }
          function spawnCountSingle(n) {
            const el = spawnBase('fx-countsingle');
            const s = document.createElement('span');
            s.textContent = n;
            el.appendChild(s);
            return el;
          }
          function spawnCountFloat() {
            const el = spawnBase('fx-countfloat');
            for (let i = 1; i <= 20; i++) {
              const n = document.createElement('span');
              n.textContent = i;
              n.style.setProperty('--delay', `${(i - 1) * 0.03}s`);
              el.appendChild(n);
            }
            return el;
          }
          function play(id) {
            if (!id || id === 'none') return;
            const def = map.get(id);
            if (!def) return;
            const el = def.build ? def.build() : spawnBase(def.className);
            if (!el) return;
            requestAnimationFrame(() => el.classList.add('show'));
            const life = def.duration || 1500;
            if (life > 200) {
              setTimeout(() => el.classList.add('fade'), Math.max(0, life - 250));
            }
            setTimeout(() => { el.remove(); }, life + 350);
          }
          return { catalog, play };
        })();
        window.VisualFX = VisualFX;
      })();
    </script>

    <script id="fix-clock-updater">
      (() => {
        if (window.__clockFixInstalled) return;
        window.__clockFixInstalled = true;
        const $ = s => document.querySelector(s);
        const h = $('#hHand'), m = $('#mHand'), s = $('#sHand');
        const dg = $('#digitalTime');
        const motionNodes = Array.from(document.querySelectorAll('#motion'));
        let motionValue = (motionNodes.find(node => node && node.value)?.value) || 'tick';
        motionNodes.forEach(node => {
          if (!node) return;
          node.value = motionValue;
          node.addEventListener('change', (e) => {
            motionValue = e.target.value || 'tick';
            motionNodes.forEach(other => { if (other && other !== e.target) other.value = motionValue; });
          });
        });
        const motion = () => motionValue === 'smooth';
        let last = -1;
        function pad(n) { return n < 10 ? '0' + n : '' + n; }
        function rot(el, deg) { if (el) el.setAttribute('transform', `rotate(${deg} 250 250)`); }
        function syncNumberlineHands(now) {
          const rows = document.querySelectorAll('.nl-row');
          if (!rows.length) return;
          const hourStart = new Date(now.getFullYear(), now.getMonth(), now.getDate(), now.getHours(), 0, 0, 0).getTime();
          rows.forEach(row => {
            const ts = parseInt(row.dataset.startTs || '0', 10);
            const isCurrent = row.classList.contains('current') || ts === hourStart;
            if (ts === hourStart) { row.classList.add('current'); }
            else if (row.classList.contains('current')) { row.classList.remove('current'); }
            const sHand = row.querySelector('.nl-hand.s');
            const mHand = row.querySelector('.nl-hand.m');
            if (!sHand && !mHand) return;
            if (isCurrent) {
              const ss = now.getSeconds();
              const mm = now.getMinutes();
              if (sHand) sHand.style.left = (ss / 60 * 100) + '%';
              if (mHand) mHand.style.left = (mm / 60 * 100) + '%';
            } else {
              if (sHand) sHand.style.left = '0%';
              if (mHand) mHand.style.left = '0%';
            }
          });
        }
        const shouldRunClockTick = () => {
          if (typeof window.__plannerBackgroundNeedsTick === 'function') {
            return window.__plannerBackgroundNeedsTick();
          }
          return true;
        };
        function tick() {
          if (document.hidden && !isBookViewerContext()) {
            setTimeout(() => requestAnimationFrame(tick), 500);
            return;
          }
          if (!shouldRunClockTick()) {
            setTimeout(() => requestAnimationFrame(tick), 1000);
            return;
          }
          const now = (typeof window.__getNow === 'function')
            ? window.__getNow()
            : new Date();
          const hh = now.getHours() % 12, mm = now.getMinutes(), ss = now.getSeconds(), ms = now.getMilliseconds();
          const sm = motion();
          const sec = sm ? (ss + ms / 1000) : ss;
          const min = sm ? (mm + sec / 60) : mm;
          const hr = sm ? (hh + min / 60) : (hh + mm / 60);
          rot(h, hr * 30); rot(m, min * 6); rot(s, sec * 6);
          syncNumberlineHands(now);
          if (dg && dd && ss !== last) {
            last = ss;
            const wd = ["日", "月", "火", "水", "木", "金", "土"][now.getDay()];
            dg.textContent = `${pad(now.getHours())}:${pad(mm)}:${pad(ss)}`;
            dd.textContent = `${now.getFullYear()}年${now.getMonth() + 1}月${now.getDate()}日（${wd}）`;
          }
          requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);
      })();
    </script>


    <script id="time-scale-engine">
      (() => {
        if (window.__timeScaleInit) return;
        window.__timeScaleInit = true;
        const NativeDate = Date;
        if (!window.__NativeDate) window.__NativeDate = NativeDate;
        if (!window.__nativeNow) window.__nativeNow = () => NativeDate.now();
        if (!window.__getRealNow) window.__getRealNow = () => new NativeDate();
        const DEBUG_TIME_KEY = 'debug-time-config-v1';
        let scale = 1;
        let baseReal = NativeDate.now();
        let baseVirt = baseReal;
        let debugEnabled = false;
        let debugBaseMs = null;
        let statusTimer = null;
        function clampScale(v) { return Math.max(1, Math.min(50000, parseInt(v, 10) || 1)); }
        function getNowMs() {
          return baseVirt + (NativeDate.now() - baseReal) * scale;
        }
        function syncBaseTo(ms) {
          baseVirt = ms;
          baseReal = NativeDate.now();
        }
        function loadDebugConfig() {
          try {
            const raw = localStorage.getItem(DEBUG_TIME_KEY);
            if (raw) {
              const cfg = JSON.parse(raw);
              debugEnabled = !!cfg.enabled;
              debugBaseMs = Number.isFinite(cfg.baseMs) ? cfg.baseMs : null;
            }
          } catch (_) { }
          if (debugEnabled && Number.isFinite(debugBaseMs)) {
            syncBaseTo(debugBaseMs);
          } else {
            debugEnabled = false;
            debugBaseMs = null;
            syncBaseTo(NativeDate.now());
          }
        }
        function saveDebugConfig() {
          const currentMs = debugEnabled ? getNowMs() : debugBaseMs;
          if (Number.isFinite(currentMs)) debugBaseMs = currentMs;
          try {
            localStorage.setItem(DEBUG_TIME_KEY, JSON.stringify({
              enabled: debugEnabled,
              baseMs: debugBaseMs
            }));
          } catch (_) { }
        }
        function notifyTimeChange() {
          try { if (typeof window.__ensureSecondAligned === 'function') window.__ensureSecondAligned(); } catch (_) { }
          try { if (typeof drawPlanner === 'function') drawPlanner(); } catch (_) { }
          try { if (typeof nlRebuildAll === 'function') nlRebuildAll(true); } catch (_) { }
          try { if (typeof updateOverallStudyUI === 'function') updateOverallStudyUI(); } catch (_) { }
          try { if (typeof refreshPlannerFlyClock === 'function') refreshPlannerFlyClock(true); } catch (_) { }
          try { if (typeof renderNumberlineFly === 'function') renderNumberlineFly(); } catch (_) { }
          try {
            if (typeof studyNowMs === 'function') {
              const ms = studyNowMs();
              if (window.ReaderHpBar && typeof ReaderHpBar.update === 'function') ReaderHpBar.update(ms);
              if (window.StudyHpOverlay && typeof StudyHpOverlay.update === 'function') StudyHpOverlay.update(ms);
            }
          } catch (_) { }
        }
        function setDebugEnabled(on) {
          const next = !!on;
          if (!next && debugEnabled) {
            debugBaseMs = getNowMs();
          }
          debugEnabled = next;
          if (debugEnabled) {
            if (!Number.isFinite(debugBaseMs)) debugBaseMs = getNowMs();
            syncBaseTo(debugBaseMs);
          } else {
            syncBaseTo(NativeDate.now());
          }
          saveDebugConfig();
          syncDebugUI();
          notifyTimeChange();
        }
        function setDebugTimeMs(ms) {
          if (!Number.isFinite(ms)) return;
          debugBaseMs = ms;
          debugEnabled = true;
          syncBaseTo(ms);
          saveDebugConfig();
          syncDebugUI();
          notifyTimeChange();
        }
        function setTimeScale(s) {
          s = clampScale(s);
          if (s === scale) return;
          baseVirt = getNowMs();
          baseReal = NativeDate.now();
          scale = s;
          saveDebugConfig();
          syncTimeScaleUI();
        }
        function format2(n) { return String(n).padStart(2, '0'); }
        function formatInputValue(ms) {
          const d = new NativeDate(ms);
          return `${d.getFullYear()}-${format2(d.getMonth() + 1)}-${format2(d.getDate())}T${format2(d.getHours())}:${format2(d.getMinutes())}`;
        }
        function formatStatusValue(ms) {
          const d = new NativeDate(ms);
          return `${d.getFullYear()}/${format2(d.getMonth() + 1)}/${format2(d.getDate())} ${format2(d.getHours())}:${format2(d.getMinutes())}:${format2(d.getSeconds())}`;
        }
        function parseInputValue(value) {
          if (!value) return null;
          const parts = value.split('T');
          if (parts.length < 2) return null;
          const [y, m, d] = parts[0].split('-').map(v => parseInt(v, 10));
          const [hh, mm] = parts[1].split(':').map(v => parseInt(v, 10));
          if (![y, m, d, hh, mm].every(Number.isFinite)) return null;
          return new NativeDate(y, (m - 1), d, hh, mm, 0, 0).getTime();
        }
        function updateDebugStatus() {
          const status = document.getElementById('debugTimeStatus');
          if (!status) return;
          const label = debugEnabled ? '仮想時間' : '現在時刻';
          status.textContent = `${label}: ${formatStatusValue(getNowMs())}`;
        }
        function syncDebugUI() {
          const enable = document.getElementById('debugTimeEnable');
          const controls = document.getElementById('debugTimeControls');
          const input = document.getElementById('debugTimeValue');
          if (enable) enable.checked = debugEnabled;
          if (controls) controls.style.display = debugEnabled ? '' : 'none';
          if (input) {
            input.value = formatInputValue(getNowMs());
          }
          updateDebugStatus();
        }
        function syncTimeScaleUI() {
          const sel = document.getElementById('timeScale');
          if (sel) sel.value = String(scale);
        }
        function bindDebugUI() {
          const enable = document.getElementById('debugTimeEnable');
          const input = document.getElementById('debugTimeValue');
          const apply = document.getElementById('debugTimeApply');
          const reset = document.getElementById('debugTimeReset');
          const fill = document.getElementById('debugTimeFill');
          if (enable) enable.onchange = () => setDebugEnabled(enable.checked);
          if (apply) {
            apply.onclick = () => {
              const ms = parseInputValue(input?.value || '');
              if (ms != null) setDebugTimeMs(ms);
            };
          }
          if (reset) reset.onclick = () => setDebugEnabled(false);
          if (fill) {
            fill.onclick = () => {
              if (input) input.value = formatInputValue(getNowMs());
            };
          }
          if (input && !input.__debugTimeBound) {
            input.__debugTimeBound = true;
            input.addEventListener('keydown', (e) => {
              if (e.key === 'Enter') {
                const ms = parseInputValue(input.value);
                if (ms != null) setDebugTimeMs(ms);
              }
            });
          }
          if (!statusTimer) {
            statusTimer = setInterval(() => {
              if (document.hidden) return;
              updateDebugStatus();
            }, 1000);
          }
          syncDebugUI();
        }
        function bindUI() {
          const sel = document.getElementById('timeScale');
          if (sel) sel.onchange = () => window.__setTimeScale(sel.value);
          syncTimeScaleUI();
          bindDebugUI();
        }
        // Global hooks
        window.__getNow = () => new NativeDate(getNowMs());
        window.__getTimeScale = () => scale;
        window.__setTimeScale = (s) => setTimeScale(s);
        window.__setDebugTimeEnabled = (v) => setDebugEnabled(v);
        window.__setDebugTimeMs = (ms) => setDebugTimeMs(ms);
        window.__getDebugTimeEnabled = () => debugEnabled;
        window.__getDebugTimeMs = () => (debugEnabled ? getNowMs() : NativeDate.now());

        // Override Date to honor virtual time
        (function installVirtualDate() {
          if (window.__virtualDateInstalled) return;
          window.__virtualDateInstalled = true;
          const effectiveNowMs = () => (debugEnabled ? getNowMs() : NativeDate.now());
          function DebugDate(...args) {
            if (!(this instanceof DebugDate)) {
              if (args.length === 0) return new NativeDate(effectiveNowMs()).toString();
              return NativeDate(...args);
            }
            if (args.length === 0) return new NativeDate(effectiveNowMs());
            return new NativeDate(...args);
          }
          DebugDate.now = () => effectiveNowMs();
          DebugDate.parse = NativeDate.parse;
          DebugDate.UTC = NativeDate.UTC;
          DebugDate.prototype = NativeDate.prototype;
          DebugDate.prototype.constructor = DebugDate;
          try { Object.setPrototypeOf(DebugDate, NativeDate); } catch (_) { }
          window.Date = DebugDate;
        })();

        loadDebugConfig();
        document.addEventListener('visibilitychange', () => {
          if (document.hidden && debugEnabled) saveDebugConfig();
        });
        window.addEventListener('beforeunload', () => {
          if (debugEnabled) saveDebugConfig();
        });
        document.addEventListener('DOMContentLoaded', bindUI);
        bindUI();
      })();
    </script>


    <script id="direct-anchor-store">
      (() => {
        if (!window.__directAnchors) {
          try { window.__directAnchors = new WeakMap(); }
          catch (e) { window.__directAnchors = new Map(); } // fallback
        }
      })();
    </script>


    <script>
      // HUDを初期状態で消す＆テキスト空にする
      (() => {
        ['plEta', 'plTimerHUD', 'pomoClockHUD'].forEach(id => {
          const el = document.getElementById(id);
          if (!el) return;
          el.textContent = '';
          el.style.display = 'none';
        });
        if (typeof window.__setInfoVisibility === 'function') { window.__setInfoVisibility(); }
      })();
    </script>

    <script>
      // === Timer HUD (残り時間と終了時刻の数値表示・クリック操作) ===
      (function () {
        if (window.__timerHudInit) return; window.__timerHudInit = true;

        const $ = (id) => document.getElementById(id);
        function pad(n) { return String(n).padStart(2, '0'); }
        function setInfoVisibility(forceShow) {
          const stack = document.getElementById('plannerInfoStack');
          if (!stack) return;
          const eta = document.getElementById('plEta');
          const hud = document.getElementById('plTimerHUD');
          const study = document.getElementById('overallStudyInfo');
          const hasEta = eta && eta.style.display !== 'none' && eta.textContent.trim() !== '';
          const hasHud = hud && hud.style.display !== 'none' && hud.textContent.trim() !== '';
          const hasStudy = study && study.style.display !== 'none';
          const pomo = document.getElementById('pomoClockHUD');
          const hasPomo = pomo && pomo.textContent && pomo.textContent.trim() !== '';
          const on = !!(forceShow || hasEta || hasHud || hasStudy || hasPomo);
          if (on) { stack.classList.add('active'); }
          else { stack.classList.remove('active'); }
          if (eta) eta.style.display = hasEta ? 'block' : 'none';
          if (hud) hud.style.display = hasHud ? 'inline-block' : 'none';
          if (pomo) { pomo.style.display = hasPomo ? 'inline-block' : 'none'; }
        }
        window.__setInfoVisibility = setInfoVisibility;

        // Track which timer to show: prefer the most recently started running timer.
        let activeIndex = -1;
        function chooseActive() {
          // Prefer running timers. If multiple, pick the one with the earliest (closest) end.
          let candidate = -1, bestRem = Infinity;
          (window.timers || []).forEach((t, i) => {
            if (t.running) {
              if (t.remain < bestRem) { bestRem = t.remain; candidate = i; }
            }
          });
          // If none running, show the one that most recently finished (remain<=0) or the last interacted.
          if (candidate === -1) {
            (window.timers || []).forEach((t, i) => {
              if (t.remain <= 0) {
                if (Math.abs(t.remain) < Math.abs(bestRem)) { bestRem = t.remain; candidate = i; }
              }
            });
          }
          if (candidate !== -1) activeIndex = candidate;
        }

        function formatEndFromRemain(remSec) {
          const base = new Date();
          const end = new Date(base.getTime() + Math.max(0, remSec) * 1000);
          return `${pad(end.getHours())}:${pad(end.getMinutes())}`;
        }

        function splitRemain(remainSec) {
          const raw = Number(remainSec || 0);
          const isNeg = raw < 0;
          const abs = Math.abs(raw);
          const rounded = isNeg ? Math.floor(abs) : Math.ceil(abs);
          const mm = Math.floor(rounded / 60);
          const ss = rounded % 60;
          const sign = (isNeg && rounded > 0) ? '-' : '';
          return { sign, mm, ss };
        }
        function getHudRemainSec(t) {
          if (!t) return 0;
          try {
            const nowSec = (window.__timerNowSec ? window.__timerNowSec() : Math.floor(Date.now() / 1000));
            if (Number.isFinite(t._endSec)) return t._endSec - nowSec;
          } catch (_) { }
          return Number(t.remain || 0);
        }

        function hudLabel(t) {
          const remainSec = getHudRemainSec(t);
          const { sign, mm, ss } = splitRemain(remainSec);
          const endStr = formatEndFromRemain(Math.max(0, remainSec));
          const left = `${sign}${pad(mm)}:${pad(ss)}`;
          return `残 ${left} ｜ 終 ${endStr}`;
        }

        function compactLabel(t) {
          const remainSec = getHudRemainSec(t);
          const { sign, mm, ss } = splitRemain(remainSec);
          return `${sign}${pad(mm)}:${pad(ss)}`;
        }

        function applyStyle(el, t, remainSec) {
          el.classList.remove('strong', 'warn', 'danger');
          if (!t) return;
          const val = Number.isFinite(remainSec) ? remainSec : Number(t.remain || 0);
          if (val <= 0) el.classList.add('danger');
          else if (val <= 60) el.classList.add('warn');
          else el.classList.add('strong');
        }

        function updateHUD() {
          const el1 = $('plTimerHUD');
          const el2 = $('nlTimerHUD');
          const viewerTimer = $('viewerTimerClock');
          const viewerTimerText = $('viewerTimerText');
          const viewerTimerStack = $('viewerTimerStack');
          const viewerClockWrapEl = $('viewerClockWrap');
          if (viewerClockWrapEl && !viewerClockWrapEl.__timerBound) {
            viewerClockWrapEl.__timerBound = true;
            viewerClockWrapEl.addEventListener('click', (e) => {
              const chip = e.target?.closest?.('.viewer-timer-item');
              if (!chip) return;
              const timerId = chip.dataset.timerId;
              const idx = (window.timers || []).findIndex(t => String(t?.id) === String(timerId));
              const pieOpen = (typeof window.__isPieMenuOpen === 'function') && window.__isPieMenuOpen();
              if (idx < 0) { if (!pieOpen) onClickHUD(); return; }
              if (pieOpen) {
                if (typeof window.__setPieTimerTarget === 'function') {
                  window.__setPieTimerTarget(timerId);
                }
                return;
              }
              toggleTimerByIndex(idx);
              if (typeof window.__setPieTimerTarget === 'function') {
                window.__setPieTimerTarget(timerId);
              }
            });
          }
          if (!el1 && !el2 && !viewerTimer) return;
          chooseActive();
          const timers = window.timers || [];
          const t = timers[activeIndex];
          if (!t) {
            if (el1) { el1.textContent = ''; el1.style.display = 'none'; }
            if (el2) { el2.textContent = ''; el2.style.display = 'none'; }
            if (viewerTimer) { viewerTimer.classList.add('hidden'); viewerTimer.classList.remove('strong', 'warn', 'danger'); }
            if (viewerTimerStack) { viewerTimerStack.classList.add('hidden'); viewerTimerStack.innerHTML = ''; }
            if (typeof viewerTimerActive !== 'undefined') viewerTimerActive = false;
            if (typeof applyViewerClockVisibility === 'function') applyViewerClockVisibility();
            setInfoVisibility();
            return;
          }
          const remainSec = getHudRemainSec(t);
          const text = hudLabel(t);
          if (el1) { el1.style.display = 'inline-block'; el1.textContent = text; applyStyle(el1, t, remainSec); }
          if (el2) { el2.style.display = 'inline-block'; el2.textContent = text; applyStyle(el2, t, remainSec); }
          if (viewerTimer) {
            if (viewerTimerText) viewerTimerText.textContent = compactLabel(t);
            viewerTimer.classList.remove('hidden');
            viewerTimer.dataset.timerId = t.id;
            viewerTimer.dataset.timerIndex = activeIndex;
            viewerTimer.classList.add('viewer-timer-item');
            const isLesson = t && t.source === 'lesson';
            viewerTimer.classList.toggle('viewer-timer-lesson', isLesson);
            if (isLesson) viewerTimer.title = `授業タイマー: ${t.lessonTitle || t.label || '授業'}`;
            else viewerTimer.removeAttribute('title');
            applyStyle(viewerTimer, t, remainSec);
          }
          if (viewerTimerStack) {
            viewerTimerStack.innerHTML = '';
            const baseEl = viewerTimer || document.getElementById('viewerClock');
            const designCls = baseEl ? Array.from(baseEl.classList).find(cls => cls.startsWith('vc-style-')) : '';
            timers.forEach((timer, idx) => {
              if (!timer || idx === activeIndex) return;
              const timerRemain = getHudRemainSec(timer);
              const chip = document.createElement('div');
              chip.className = 'viewer-clock viewer-timer viewer-timer-item';
              if (designCls) chip.classList.add(designCls);
              chip.dataset.timerId = timer.id;
              chip.dataset.timerIndex = idx;
              if (timer && timer.source === 'lesson') {
                chip.classList.add('viewer-timer-lesson');
                chip.title = `授業タイマー: ${timer.lessonTitle || timer.label || '授業'}`;
              }
              const span = document.createElement('span');
              span.className = 'clock-text';
              span.textContent = compactLabel(timer);
              chip.appendChild(span);
              applyStyle(chip, timer, timerRemain);
              viewerTimerStack.appendChild(chip);
            });
            viewerTimerStack.classList.toggle('hidden', viewerTimerStack.childElementCount === 0);
          }
          if (typeof viewerTimerActive !== 'undefined') viewerTimerActive = timers.length > 0;
          if (typeof applyViewerClockVisibility === 'function') applyViewerClockVisibility();
          setInfoVisibility(true);
        }

        // Click behavior
        function toggleTimerByIndex(idx) {
          const t = (window.timers || [])[idx];
          if (!t) return;
          if (t.locked || t.source === 'lesson') {
            if (typeof showToast === 'function') showToast('授業タイマーは操作できません', 'info');
            return;
          }
          if (t.remain <= 0) {
            // 終了（停止して0に確定）
            t.running = false; t.remain = 0; t.alerted = true;
            if (typeof renderTimers === 'function') renderTimers();
            updateHUD();
            return;
          }
          if (t.running) { if (typeof pauseTimer === 'function') pauseTimer(idx); }
          else { if (typeof startTimer === 'function') startTimer(idx); }
          updateHUD();
        }
        function onClickHUD() {
          chooseActive();
          toggleTimerByIndex(activeIndex);
        }
        ['plTimerHUD', 'nlTimerHUD'].forEach(id => {
          const el = $(id); if (el) { el.addEventListener('click', onClickHUD); }
        });
        // Monkey-patch key functions to keep HUD in sync
        function wrap(name, fn) {
          const orig = window[name];
          window[name] = function () {
            const r = orig && orig.apply(this, arguments);
            try { fn && fn.apply(this, arguments); } catch (e) { }
            return r;
          };
        }
        wrap('startTimer', () => { chooseActive(); updateHUD(); });
        wrap('pauseTimer', () => { updateHUD(); });
        wrap('resetTimer', () => { updateHUD(); });
        wrap('tickTimer', () => { updateHUD(); });
        wrap('renderTimers', () => { updateHUD(); });

        // Hook "〜まで開始" to set focus to that timer
        const untilBtn = $('tUntilStart');
        if (untilBtn) {
          untilBtn.addEventListener('click', () => {
            setTimeout(() => { chooseActive(); updateHUD(); }, 50);
          });
        }

        // Initial paint
        const hasActiveHudTimers = () => Array.isArray(window.timers) && window.timers.length > 0;
        const startHudTickAligned = () => {
          const step = () => {
            if (!document.hidden && hasActiveHudTimers()) updateHUD();
            const nowMs = Date.now();
            const delay = 1000 - (nowMs % 1000);
            window.__timerHudTick = setTimeout(step, delay);
          };
          const nowMs = Date.now();
          const delay = 1000 - (nowMs % 1000);
          window.__timerHudTick = setTimeout(step, delay);
          window.__timerHudTickAligned = true;
        };
        if (!window.__timerHudTick) startHudTickAligned();
        updateHUD();
        setInfoVisibility();
      })();
    </script>


    <!-- PATCH: numberline ETA/HUD position tweaks and label styling -->
    <style id="nl-linear-fixes-20251101" data-planner-style="1" media="not all">
      /* 数直線のETAを見切れない位置に調整 */
      .nl-eta {
        bottom: -18px !important;
      }

      @media (orientation: landscape) {
        .nl-eta {
          font-size: clamp(18px, 2.4vw, 26px) !important;
          padding: 6px 16px !important;
          line-height: 1.1 !important;
          font-weight: 800 !important;
        }
      }

      /* 全体の残り時間HUDを少し下に */
      #nlTimerHUD {
        margin-top: 16px !important;
      }

      /* OUTERトラックのレーベル */
      .nl-timer-label {
        white-space: nowrap;
        text-shadow: 0 1px 2px rgba(0, 0, 0, .35);
      }

      /* 右端固定で痩せるためのfill配置 */
      .nl-outer-fill {
        position: absolute;
        right: 0;
        top: 0;
        bottom: 0;
      }
    </style>

    <style id="planner-pagecomplete-adjust" data-planner-style="1" media="not all">
      #plannerApp .planner-hero-top {
        position: relative;
        z-index: 20;
        pointer-events: auto;
      }

      #plannerApp .planner-hero-top #pageCompleteBtn {
        display: inline-flex !important;
        pointer-events: auto !important;
        z-index: 21;
      }

      #pageCompleteBtn {
        top: -4px !important;
      }

      @media (max-width:540px) {
        #pageCompleteBtn {
          top: -2px !important;
        }
      }
    </style>


    <script>
      // --- injected: place delay counter to the right of remaining time ---
      (function () {
        function arrange() {
          const plannerApp = document.getElementById('plannerApp');
          if (plannerApp && plannerApp.classList.contains('hidden')) return;
          const rts = document.querySelectorAll('.remaining-time, .remain-time, .rest-time');
          rts.forEach(rt => {
            // Find nearest delay counter in the same schedule row
            let root = rt.closest('.schedule-item, .task-row, .timeline-entry, .study-row, .plan-row') || rt.parentElement;
            if (!root) root = rt.parentElement;
            if (!root) return;
            let delay = root.querySelector('.delay-counter, .extension-counter, .lateness, .overrun, .延長カウンター, .延長');
            // Wrap in a row container
            if (rt.parentElement && !rt.parentElement.classList.contains('remaining-time-row')) {
              const wrap = document.createElement('span');
              wrap.className = 'remaining-time-row';
              rt.parentElement.insertBefore(wrap, rt);
              wrap.appendChild(rt);
              if (delay) {
                wrap.appendChild(delay);
              } else {
                const d = document.createElement('span');
                d.className = 'delay-counter';
                wrap.appendChild(d);
              }
            } else if (delay && delay.parentElement !== rt.parentElement) {
              // Move delay next to remaining-time
              rt.parentElement.appendChild(delay);
            }
          });
        }
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', arrange);
        } else {
          arrange();
        }
        // Re-apply on updates if the app fires custom events
        window.addEventListener('延長更新', arrange);
        window.addEventListener('study:update', arrange);
        // Fallback periodic check (lightweight)
        setInterval(arrange, 1500);
      })();
    </script>

    <script>
      // ===== サウンドマネージャ =====
      (function () {
        const LS = "sound_prefs_v1";
        const $ = (sel, root = document) => root.querySelector(sel);
        const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));
        const defaultEvents = [
          { key: "study.extend.start", name: "延長カウンター開始（勉強：最初の延長が発生）" },
          { key: "study.extend.tick", name: "延長中の1分延長ごと（勉強）" },
          { key: "plan.start", name: "予定開始" },
          { key: "plan.end", name: "予定終了" },
          { key: "minute.tick", name: "毎分" },
          { key: "minute.30", name: "毎30分（00/30）" },
          { key: "hour.full", name: "毎正時（00分）" },
          { key: "ui.click", name: "ボタン操作音" },
          { key: "pomodoro.focus", name: "ポモドーロ開始" },
          { key: "pomodoro.break", name: "ポモドーロ休憩" },
          { key: "timer.start", name: "タイマー開始" },
          { key: "timer.resume", name: "タイマー再開" },
          { key: "timer.pause", name: "タイマー一時停止" },
          { key: "timer.half", name: "タイマー残り半分" },
          { key: "timer.last60", name: "タイマー残り60秒" },
          { key: "timer.last10", name: "タイマー残り10秒" },
          { key: "timer.last01", name: "タイマー残り1秒" },
          { key: "timer.complete", name: "タイマー完了" },
          { key: "delay.detected", name: "遅延の発生/継続検知" },
          { key: "deadline.soon", name: "予定終了1分前" },
          { key: "deadline.soon.m02", name: "予定終了2分前" },
          { key: "deadline.soon.m03", name: "予定終了3分前" },
          { key: "deadline.soon.m04", name: "予定終了4分前" },
          { key: "deadline.soon.m05", name: "予定終了5分前" },
          { key: "deadline.soon.m06", name: "予定終了6分前" },
          { key: "deadline.soon.m07", name: "予定終了7分前" },
          { key: "deadline.soon.m08", name: "予定終了8分前" },
          { key: "deadline.soon.m09", name: "予定終了9分前" },
          { key: "deadline.soon.m10", name: "予定終了10分前" },
          { key: "deadline.soon.m11", name: "予定終了11分前" },
          { key: "deadline.soon.m12", name: "予定終了12分前" },
          { key: "deadline.soon.m13", name: "予定終了13分前" },
          { key: "deadline.soon.m14", name: "予定終了14分前" },
          { key: "deadline.soon.m15", name: "予定終了15分前" },
          { key: "deadline.soon.m16", name: "予定終了16分前" },
          { key: "deadline.soon.m17", name: "予定終了17分前" },
          { key: "deadline.soon.m18", name: "予定終了18分前" },
          { key: "deadline.soon.m19", name: "予定終了19分前" },
          { key: "deadline.soon.m20", name: "予定終了20分前" },
        ];
        (function extendDefaultEvents() {
          const pad2 = (n) => String(n).padStart(2, '0');
          defaultEvents.push({ key: "second.tick", name: "毎秒（共通）" });
          for (let s = 0; s < 60; s++) {
            defaultEvents.push({ key: `second.s${pad2(s)}`, name: `${pad2(s)}秒リマインド` });
          }
          for (let h = 0; h < 24; h++) {
            defaultEvents.push({ key: `hour.${pad2(h)}`, name: `${pad2(h)}時ジャスト` });
          }
          [
            { key: "study.session.start", name: "勉強ページ開始" },
            { key: "study.session.mid", name: "勉強ページ折り返し" },
            { key: "study.session.last5", name: "勉強残り5分" },
            { key: "study.session.last1", name: "勉強残り1分" },
            { key: "study.session.done", name: "勉強ページ完了" },
            { key: "study.session.overtime", name: "勉強ページ延長警告" },
          ].forEach(ev => defaultEvents.push(ev));
        })();
        const DEFAULT_VIBE = { enabled: false, target: 'all', strength: 0.8, testPattern: 'tap' };
        const VIBE_PATTERNS = [
          { id: 'none', label: '(振動なし)', steps: [] },
          { id: 'tap', label: 'タップ', steps: [{ d: 120, s: 0.85, w: 0.5 }] },
          { id: 'double', label: 'ダブル', steps: [{ d: 80, s: 0.9, w: 0.6 }, { p: 80 }, { d: 80, s: 0.9, w: 0.6 }] },
          { id: 'triple', label: 'トリプル', steps: [{ d: 60, s: 0.9, w: 0.5 }, { p: 60 }, { d: 60, s: 0.9, w: 0.5 }, { p: 60 }, { d: 60, s: 0.9, w: 0.5 }] },
          { id: 'short-long', label: '短→長', steps: [{ d: 70, s: 0.8, w: 0.4 }, { p: 70 }, { d: 260, s: 0.95, w: 0.6 }] },
          { id: 'long-short', label: '長→短', steps: [{ d: 260, s: 0.95, w: 0.6 }, { p: 80 }, { d: 80, s: 0.8, w: 0.4 }] },
          { id: 'heartbeat', label: '心拍', steps: [{ d: 60, s: 0.8, w: 0.4 }, { p: 40 }, { d: 120, s: 0.95, w: 0.6 }, { p: 180 }] },
          { id: 'alert', label: 'アラート', steps: [{ d: 220, s: 1, w: 0.7 }, { p: 120 }, { d: 220, s: 1, w: 0.7 }] },
          { id: 'rumble', label: 'ランブル', steps: [{ d: 420, s: 0.95, w: 0.95 }] },
          { id: 'buzz', label: 'バズ', steps: [{ d: 40, s: 0.8, w: 0.4 }, { p: 40 }, { d: 40, s: 0.8, w: 0.4 }, { p: 40 }, { d: 40, s: 0.8, w: 0.4 }, { p: 40 }, { d: 40, s: 0.8, w: 0.4 }] },
          { id: 'stutter', label: 'スタッター', steps: [{ d: 40, s: 0.7, w: 0.3 }, { p: 30 }, { d: 40, s: 0.7, w: 0.3 }, { p: 30 }, { d: 40, s: 0.7, w: 0.3 }, { p: 30 }, { d: 40, s: 0.7, w: 0.3 }] },
          { id: 'ramp-up', label: 'ランプアップ', steps: [{ d: 80, s: 0.3, w: 0.2 }, { p: 40 }, { d: 90, s: 0.5, w: 0.3 }, { p: 40 }, { d: 110, s: 0.7, w: 0.5 }, { p: 40 }, { d: 130, s: 0.9, w: 0.7 }] },
          { id: 'ramp-down', label: 'ランプダウン', steps: [{ d: 130, s: 0.9, w: 0.7 }, { p: 40 }, { d: 110, s: 0.7, w: 0.5 }, { p: 40 }, { d: 90, s: 0.5, w: 0.3 }, { p: 40 }, { d: 80, s: 0.3, w: 0.2 }] },
          { id: 'wave', label: 'ウェーブ', steps: [{ d: 90, s: 0.6, w: 0.2 }, { p: 40 }, { d: 90, s: 0.2, w: 0.6 }, { p: 40 }, { d: 90, s: 0.6, w: 0.2 }, { p: 40 }, { d: 90, s: 0.2, w: 0.6 }] },
          { id: 'tick-tock', label: 'チック/トック', steps: [{ d: 70, s: 0.7, w: 0.2 }, { p: 90 }, { d: 70, s: 0.2, w: 0.7 }] },
          { id: 'zigzag', label: 'ジグザグ', steps: [{ d: 60, s: 0.9, w: 0.1 }, { p: 40 }, { d: 60, s: 0.1, w: 0.9 }, { p: 40 }, { d: 60, s: 0.9, w: 0.1 }] }
        ];
        const state = {
          enabled: false,
          ctx: null,
          nodes: {}, // key -> AudioBuffer
          conf: {},  // key -> {vol:0.8, loop:false, dataUrl:null, enabled:true}
          lastTick: { min: -1, hour: -1, halfMin: -1, sec: -1 },
          bgm: { el: null, dataUrl: null, vol: 0.3, loop: true, idbKey: null },
          vibe: { ...DEFAULT_VIBE, _seq: 0 }
        };
        const EVENT_IDB_PREFIX = 'ev:';
        const BGM_IDB_KEY = 'bgm:main';

        function soundDataURLToBlob(dataUrl) {
          if (!dataUrl || typeof dataUrl !== 'string') return null;
          const parts = dataUrl.split(',');
          if (parts.length < 2) return null;
          const mimeMatch = parts[0].match(/:(.*?);/);
          const mime = mimeMatch ? mimeMatch[1] : 'audio/wav';
          const bstr = atob(parts[1]);
          const len = bstr.length;
          const u8 = new Uint8Array(len);
          for (let i = 0; i < len; i++) { u8[i] = bstr.charCodeAt(i); }
          return new Blob([u8], { type: mime });
        }
        function getSoundIDB() {
          return window.__SoundIDB || null;
        }
        async function persistDataUrlToIDB(idbKey, dataUrl) {
          const api = getSoundIDB();
          if (!api || !api.put || !dataUrl || !idbKey) return null;
          try {
            const blob = soundDataURLToBlob(dataUrl);
            if (!blob) return null;
            await api.put(idbKey, blob);
            return idbKey;
          } catch (e) {
            console.warn('persistDataUrlToIDB failed', e);
            return null;
          }
        }
        async function deleteFromIDB(idbKey) {
          const api = getSoundIDB();
          if (!api || !api.del || !idbKey) return;
          try { await api.del(idbKey); } catch (e) { console.warn('deleteFromIDB failed', e); }
        }
        const clamp01 = (v) => Math.min(1, Math.max(0, v));
        function normalizeVibeState(raw) {
          const base = raw || {};
          const target = (typeof base.target === 'string' || typeof base.target === 'number') ? String(base.target) : DEFAULT_VIBE.target;
          return {
            enabled: !!base.enabled,
            target: target || DEFAULT_VIBE.target,
            strength: clamp01(typeof base.strength === 'number' ? base.strength : DEFAULT_VIBE.strength),
            testPattern: base.testPattern || DEFAULT_VIBE.testPattern,
            _seq: 0
          };
        }
        function save() {
          const payload = {
            conf: state.conf,
            bgm: { dataUrl: state.bgm.dataUrl, vol: state.bgm.vol, loop: state.bgm.loop, idbKey: state.bgm.idbKey || null },
            vibe: {
              enabled: !!state.vibe.enabled,
              target: state.vibe.target || 'all',
              strength: clamp01(state.vibe.strength ?? DEFAULT_VIBE.strength),
              testPattern: state.vibe.testPattern || DEFAULT_VIBE.testPattern
            }
          };
          localStorage.setItem(LS, JSON.stringify(payload));
        }
        function ensureEventConfig(key) {
          if (!key) return null;
          if (!state.conf[key]) {
            state.conf[key] = { vol: 0.8, loop: false, dataUrl: null, enabled: false, effectId: 'none', vibeId: 'none', vibeStrength: 0.8 };
          } else {
            if (!('effectId' in state.conf[key])) state.conf[key].effectId = 'none';
            if (!('vibeId' in state.conf[key])) state.conf[key].vibeId = 'none';
            if (typeof state.conf[key].vibeStrength !== 'number') state.conf[key].vibeStrength = 0.8;
          }
          return state.conf[key];
        }
        function load() {
          try {
            const obj = JSON.parse(localStorage.getItem(LS) || '{}');
            state.conf = obj.conf || {};
            state.bgm.dataUrl = obj.bgm && obj.bgm.dataUrl || null;
            state.bgm.vol = obj.bgm && (obj.bgm.vol ?? 0.3);
            state.bgm.loop = obj.bgm && (obj.bgm.loop ?? true);
            state.bgm.idbKey = obj.bgm && obj.bgm.idbKey || null;
            state.vibe = normalizeVibeState(obj.vibe);
          } catch (e) { }
          Object.keys(state.conf || {}).forEach(key => ensureEventConfig(key));
          defaultEvents.forEach(ev => ensureEventConfig(ev.key));
        }
        function unlockAudio() {
          if (state.enabled) return;
          try {
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const o = ctx.createOscillator(); const g = ctx.createGain();
            g.gain.value = 0; o.connect(g); g.connect(ctx.destination);
            o.start(); o.stop(ctx.currentTime + 0.01);
            state.ctx = ctx; state.enabled = true;
          } catch (e) { }
        }
        async function decodeToBuffer(dataUrl) {
          if (!state.ctx) unlockAudio();
          if (!state.ctx || !dataUrl) return null;
          const res = await fetch(dataUrl);
          const arr = await res.arrayBuffer();
          return await state.ctx.decodeAudioData(arr.slice(0));
        }
        async function decodeBlobToBuffer(blob) {
          if (!state.ctx) unlockAudio();
          if (!state.ctx || !blob) return null;
          const arr = await blob.arrayBuffer();
          return await state.ctx.decodeAudioData(arr.slice(0));
        }
        const bufferPromises = {};
        async function ensureBufferForKey(key) {
          if (state.nodes[key]) return state.nodes[key];
          if (bufferPromises[key]) return bufferPromises[key];
          const conf = state.conf[key];
          if (!conf) return null;
          bufferPromises[key] = (async () => {
            let buf = null;
            try {
              if (conf.dataUrl) {
                buf = await decodeToBuffer(conf.dataUrl);
              } else if (conf.idbKey) {
                const api = getSoundIDB();
                if (api && api.get) {
                  const blob = await api.get(conf.idbKey);
                  if (blob) { buf = await decodeBlobToBuffer(blob); }
                }
              }
            } catch (e) {
              console.warn('ensureBufferForKey', e);
              buf = null;
            }
            if (buf) { state.nodes[key] = buf; }
            delete bufferPromises[key];
            return buf;
          })();
          return bufferPromises[key];
        }
        async function setEventSound(key, dataUrl) {
          const conf = ensureEventConfig(key);
          conf.dataUrl = dataUrl; conf.enabled = true;
          save();
          // 先読み
          try { state.nodes[key] = await decodeToBuffer(dataUrl); } catch (e) { }
          // IDBにも保存して次回以降はそちらを参照
          try {
            const newKey = await persistDataUrlToIDB(EVENT_IDB_PREFIX + key, dataUrl);
            if (newKey) {
              conf.idbKey = newKey;
              conf.dataUrl = null;
            } else {
              conf.idbKey = null;
            }
            save();
          } catch (_) {
            conf.idbKey = null;
            save();
          }
        }
        async function clearSoundData(key) {
          const conf = state.conf[key];
          if (!conf) return;
          const oldKey = conf.idbKey;
          conf.dataUrl = null;
          conf.idbKey = null;
          conf.enabled = false;
          delete state.nodes[key];
          save();
          if (oldKey) {
            await deleteFromIDB(oldKey).catch(() => { });
          }
        }
        function runEffectForKey(key) {
          if (!key) return;
          const conf = ensureEventConfig(key);
          runVibrationForKey(key);
          if (!conf || !conf.effectId || conf.effectId === 'none') return;
          if (conf.effectId === 'vibrate' && navigator.vibrate) {
            try { navigator.vibrate([40, 30, 40]); } catch (_) { }
          }
          if (window.VisualFX && typeof VisualFX.play === 'function') {
            try { VisualFX.play(conf.effectId); } catch (_) { }
          }
        }
        async function play(key) {
          try {
            const c = state.conf[key];
            if (!c || !c.enabled) return;
            if (!state.ctx) unlockAudio();
            if (state.ctx) {
              const buf = await ensureBufferForKey(key);
              if (buf) {
                const src = state.ctx.createBufferSource();
                src.buffer = buf;
                src.loop = !!c.loop;
                const gain = state.ctx.createGain();
                gain.gain.value = c.vol ?? 0.8;
                src.connect(gain); gain.connect(state.ctx.destination); src.start(0);
                if (!src.loop) {
                  try {
                    setTimeout(() => { try { src.stop(); } catch (_e) { } }, Math.max(100, (buf.duration || 1) * 1000));
                  } catch (_e) { }
                }
                return src;
              }
            }
            // フォールバック: dataURL を Audio で鳴らす
            if (c.dataUrl) {
              const el = new Audio(c.dataUrl);
              el.volume = c.vol ?? 0.8;
              el.loop = !!c.loop;
              el.play();
              return el;
            }
            // 最終手段: IDB からBlobを取得してAudio再生
            if (c.idbKey) {
              const api = getSoundIDB();
              if (api && api.get) {
                const blob = await api.get(c.idbKey);
                if (blob) {
                  const url = URL.createObjectURL(blob);
                  const el = new Audio(url);
                  el.volume = c.vol ?? 0.8;
                  el.loop = !!c.loop;
                  el.onended = el.onerror = () => { URL.revokeObjectURL(url); };
                  el.play();
                  return el;
                }
              }
            }
          } catch (e) {
            console.warn('play failed', e);
          }
        }
        function fireSound(key) {
          if (!key) return;
          runEffectForKey(key);
          try {
            const res = play(key);
            if (res && typeof res.catch === 'function') {
              res.catch(() => { });
            }
          } catch (_) { }
        }
        function stopAll() {
          try { if (state.ctx) state.ctx.close(); } catch (e) { }
          state.enabled = false; state.ctx = null; state.nodes = {};
        }
        // BGM
        function revokeBgmObjectUrl() {
          if (state.bgm && state.bgm.objUrl) {
            try { URL.revokeObjectURL(state.bgm.objUrl); } catch (_e) { }
            state.bgm.objUrl = null;
          }
        }
        async function getBgmUrl() {
          if (state.bgm.dataUrl) return state.bgm.dataUrl;
          if (state.bgm.idbKey) {
            const api = getSoundIDB();
            if (api && api.get) {
              const blob = await api.get(state.bgm.idbKey);
              if (blob) {
                revokeBgmObjectUrl();
                const url = URL.createObjectURL(blob);
                state.bgm.objUrl = url;
                return url;
              }
            }
          }
          return null;
        }
        async function bgmPlay() {
          if (state.bgm.el) { try { state.bgm.el.pause(); } catch (_e) { } }
          const url = await getBgmUrl();
          if (!url) return;
          const a = new Audio(url); a.loop = !!state.bgm.loop; a.volume = state.bgm.vol ?? 0.3;
          a.play(); state.bgm.el = a;
        }
        function bgmStop() {
          if (state.bgm.el) {
            try { state.bgm.el.pause(); } catch (_e) { }
            state.bgm.el = null;
          }
        }
        async function setBgmSource(dataUrl) {
          revokeBgmObjectUrl();
          state.bgm.dataUrl = dataUrl;
          save();
          try {
            const newKey = await persistDataUrlToIDB(BGM_IDB_KEY, dataUrl);
            if (newKey) {
              state.bgm.idbKey = newKey;
              state.bgm.dataUrl = null;
            } else {
              state.bgm.idbKey = null;
            }
            save();
          } catch (_) {
            state.bgm.idbKey = null;
            save();
          }
        }

        function getEffectCatalog() {
          if (window.VisualFX && Array.isArray(window.VisualFX.catalog) && window.VisualFX.catalog.length) {
            const base = window.VisualFX.catalog.slice();
            if (!base.find(e => e.id === 'vibrate')) base.push({ id: 'vibrate', label: '振動 (デバイス)' });
            return base;
          }
          return [
            { id: 'none', label: '(エフェクトなし)' },
            { id: 'vibrate', label: '振動 (デバイス)' }
          ];
        }
        function populateEffectSelect(select, selected) {
          if (!select) return;
          const list = getEffectCatalog();
          const current = selected || 'none';
          select.innerHTML = '';
          list.forEach(item => {
            const opt = document.createElement('option');
            opt.value = item.id;
            opt.textContent = item.label || item.id;
            if (item.id === current) opt.selected = true;
            select.appendChild(opt);
          });
        }
        function getVibeCatalog() {
          return VIBE_PATTERNS.slice();
        }
        function getVibePattern(id) {
          return VIBE_PATTERNS.find(p => p.id === id) || VIBE_PATTERNS[0];
        }
        function populateVibeSelect(select, selected) {
          if (!select) return;
          const list = getVibeCatalog();
          const current = selected || DEFAULT_VIBE.testPattern;
          select.innerHTML = '';
          list.forEach(item => {
            const opt = document.createElement('option');
            opt.value = item.id;
            opt.textContent = item.label || item.id;
            if (item.id === current) opt.selected = true;
            select.appendChild(opt);
          });
        }
        function getGamepadsSafe() {
          try {
            const pads = navigator.getGamepads ? Array.from(navigator.getGamepads()) : [];
            return pads.filter(Boolean);
          } catch (_) {
            return [];
          }
        }
        function getVibrationActuator(pad) {
          if (!pad) return null;
          if (pad.vibrationActuator) return pad.vibrationActuator;
          if (pad.hapticActuators && pad.hapticActuators.length) return pad.hapticActuators[0];
          return null;
        }
        function listVibrationTargets() {
          return getGamepadsSafe().map(pad => {
            const supported = !!getVibrationActuator(pad);
            let name = (pad.id || `Gamepad ${pad.index + 1}`).trim();
            if (name.length > 36) name = name.slice(0, 36) + '...';
            return { index: pad.index, label: `${pad.index + 1}: ${name}${supported ? '' : ' (振動不可)'}`, supported };
          });
        }
        function updateVibeTargets() {
          const select = $('#vibeTarget');
          if (!select) return;
          const current = state.vibe.target || 'all';
          const targets = listVibrationTargets();
          select.innerHTML = '';
          const allOpt = document.createElement('option');
          allOpt.value = 'all';
          allOpt.textContent = 'すべてのコントローラー';
          select.appendChild(allOpt);
          targets.forEach(t => {
            const opt = document.createElement('option');
            opt.value = String(t.index);
            opt.textContent = t.label;
            select.appendChild(opt);
          });
          if (Array.from(select.options).some(opt => opt.value === current)) {
            select.value = current;
          } else {
            select.value = 'all';
            state.vibe.target = 'all';
            save();
          }
        }
        function updateVibeStatus() {
          const status = $('#vibeStatus');
          if (!status) return;
          if (!navigator.getGamepads) {
            status.textContent = 'Gamepad APIが使えません。ブラウザ/HTTPSの制限を確認してください。';
            return;
          }
          const pads = getGamepadsSafe();
          if (!pads.length) {
            status.textContent = 'コントローラー未接続。接続してから「テスト」を押してください。';
            return;
          }
          const supported = pads.filter(p => getVibrationActuator(p)).length;
          status.textContent = `接続: ${pads.length}台 / 振動対応: ${supported}台`;
        }
        function updateVibeEnableBtn() {
          const btn = $('#vibeEnableBtn');
          if (!btn) return;
          btn.textContent = state.vibe.enabled ? '🎮 振動: ON' : '🎮 振動: OFF';
        }
        function updateVibeStrengthLabel() {
          const range = $('#vibeGlobalStrength');
          const label = $('#vibeGlobalValue');
          if (range) range.value = String(state.vibe.strength ?? DEFAULT_VIBE.strength);
          if (label) label.textContent = `${Math.round((state.vibe.strength ?? DEFAULT_VIBE.strength) * 100)}%`;
        }
        function renderVibePanel() {
          populateVibeSelect($('#vibeTestPattern'), state.vibe.testPattern || DEFAULT_VIBE.testPattern);
          updateVibeTargets();
          updateVibeEnableBtn();
          updateVibeStrengthLabel();
          updateVibeStatus();
        }
        const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));
        async function playActuatorStep(actuator, duration, strong, weak) {
          try {
            if (actuator && typeof actuator.playEffect === 'function') {
              return await actuator.playEffect('dual-rumble', { duration, strongMagnitude: strong, weakMagnitude: weak });
            }
            if (actuator && typeof actuator.pulse === 'function') {
              const strength = Math.max(strong, weak);
              return await actuator.pulse(strength, duration);
            }
          } catch (_) { }
          return null;
        }
        async function playVibePattern(patternId, opts = {}) {
          const pattern = getVibePattern(patternId);
          const steps = pattern && pattern.steps ? pattern.steps : [];
          if (!steps.length) return;
          const pads = getGamepadsSafe();
          if (!pads.length) return;
          const target = state.vibe.target || 'all';
          const filtered = target === 'all'
            ? pads
            : pads.filter(p => String(p.index) === String(target));
          const actuators = filtered.map(getVibrationActuator).filter(Boolean);
          if (!actuators.length) return;
          const token = ++state.vibe._seq;
          const strengthRaw = 1;
          for (const step of steps) {
            if (token !== state.vibe._seq) return;
            const baseDuration = Math.max(0, step.d ?? step.duration ?? step.p ?? step.pause ?? 0);
            const duration = Math.round(baseDuration * 3);
            if (!duration) continue;
            let strong = 1;
            let weak = 1;
            if (strong === 0 && weak === 0) {
              await wait(duration);
              continue;
            }
            await Promise.all(actuators.map(a => playActuatorStep(a, duration, strong, weak)));
            await wait(40);
            await Promise.all(actuators.map(a => playActuatorStep(a, Math.round(duration * 0.7), strong, weak)));
          }
        }
        function runVibrationForKey(key) {
          if (!state.vibe.enabled) return;
          const conf = ensureEventConfig(key);
          if (!conf || !conf.vibeId || conf.vibeId === 'none') return;
          const localStrength = clamp01((conf.vibeStrength ?? 0.8) * (state.vibe.strength ?? DEFAULT_VIBE.strength));
          playVibePattern(conf.vibeId, { strength: localStrength });
        }

        // UI
        function renderUI() {
          const root = $('#soundRoot'); if (!root) return;
          root.innerHTML = '';
          defaultEvents.forEach(ev => {
            const conf = ensureEventConfig(ev.key);
            const row = document.createElement('div');
            row.className = 'row';
            row.style.alignItems = 'center';
            row.style.justifyContent = 'space-between';
            row.style.border = '1px solid var(--ring)'; row.style.borderRadius = '10px'; row.style.padding = '10px';
            row.style.background = 'rgba(255,255,255,.04)';
            const inputId = `file-${ev.key.replace(/[^a-zA-Z0-9_-]/g, '_')}`;
            row.innerHTML = `
        <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap">
          <div style="min-width:220px;font-size:13px;">${ev.name}</div>
          <input type="file" id="${inputId}" accept="audio/*" data-k="${ev.key}">
          <label style="font-size:12px;opacity:.8">音量</label>
          <input type="range" min="0" max="1" step="0.01" value="${conf.vol ?? 0.8}" data-k="${ev.key}" data-role="vol" style="width:120px">
          <label style="font-size:12px;opacity:.8">ループ</label>
          <input type="checkbox" ${conf.loop ? 'checked' : ''} data-k="${ev.key}" data-role="loop">
          <label style="font-size:12px;opacity:.8">有効</label>
          <input type="checkbox" ${conf.enabled ? 'checked' : ''} data-k="${ev.key}" data-role="enabled">
          <label style="font-size:12px;opacity:.8">エフェクト</label>
          <select data-role="effect" data-k="${ev.key}" style="min-width:160px;padding:4px 8px;border-radius:8px;background:rgba(255,255,255,.06);color:var(--fg);border:1px solid var(--ring);"></select>
          <label style="font-size:12px;opacity:.8">振動</label>
          <select data-role="vibe" data-k="${ev.key}" style="min-width:170px;padding:4px 8px;border-radius:8px;background:rgba(255,255,255,.06);color:var(--fg);border:1px solid var(--ring);"></select>
          <label style="font-size:12px;opacity:.8">強さ</label>
          <input type="range" min="0" max="1" step="0.05" value="${conf.vibeStrength ?? 0.8}" data-k="${ev.key}" data-role="vibeStrength" style="width:110px">
        </div>
        <div style="display:flex;gap:8px">
          <button class="btn small" data-act="test" data-k="${ev.key}">テスト</button>
          <button class="btn small ghost" data-act="clear" data-k="${ev.key}">クリア</button>
        </div>`;
            root.appendChild(row);
            populateEffectSelect(row.querySelector('select[data-role="effect"]'), conf.effectId || 'none');
            populateVibeSelect(row.querySelector('select[data-role="vibe"]'), conf.vibeId || 'none');
          });
          renderVibePanel();
        }
        function bindUI() {
          const enableBtn = $('#soundEnableBtn');
          if (enableBtn) enableBtn.onclick = () => { unlockAudio(); };
          const testAll = $('#soundTestAllBtn'); if (testAll) testAll.onclick = () => { defaultEvents.forEach(ev => fireSound(ev.key)); };
          const stopBtn = $('#soundStopAllBtn'); if (stopBtn) stopBtn.onclick = () => { stopAll(); };
          const vibeEnableBtn = $('#vibeEnableBtn');
          if (vibeEnableBtn) vibeEnableBtn.onclick = () => {
            state.vibe.enabled = !state.vibe.enabled;
            updateVibeEnableBtn();
            save();
          };
          const vibeTarget = $('#vibeTarget');
          if (vibeTarget) vibeTarget.onchange = () => {
            state.vibe.target = vibeTarget.value || 'all';
            save();
            updateVibeStatus();
          };
          const vibeStrength = $('#vibeGlobalStrength');
          if (vibeStrength) vibeStrength.oninput = () => {
            state.vibe.strength = clamp01(parseFloat(vibeStrength.value || `${DEFAULT_VIBE.strength}`));
            updateVibeStrengthLabel();
            save();
          };
          const vibeTestPattern = $('#vibeTestPattern');
          if (vibeTestPattern) vibeTestPattern.onchange = () => {
            state.vibe.testPattern = vibeTestPattern.value || DEFAULT_VIBE.testPattern;
            save();
          };
          const vibeTestBtn = $('#vibeTestBtn');
          if (vibeTestBtn) vibeTestBtn.onclick = () => {
            const id = (vibeTestPattern && vibeTestPattern.value) || state.vibe.testPattern || DEFAULT_VIBE.testPattern;
            playVibePattern(id, { strength: state.vibe.strength ?? DEFAULT_VIBE.strength });
          };
          if (!state.vibe._gpBound) {
            state.vibe._gpBound = true;
            window.addEventListener('gamepadconnected', () => { updateVibeTargets(); updateVibeStatus(); });
            window.addEventListener('gamepaddisconnected', () => { updateVibeTargets(); updateVibeStatus(); });
          }

          const exportBtn = $('#soundExportBtn'); if (exportBtn) exportBtn.onclick = () => {
            const blob = new Blob([JSON.stringify({
              conf: state.conf,
              bgm: { dataUrl: state.bgm.dataUrl, vol: state.bgm.vol, loop: state.bgm.loop },
              vibe: { enabled: !!state.vibe.enabled, target: state.vibe.target || 'all', strength: state.vibe.strength ?? DEFAULT_VIBE.strength, testPattern: state.vibe.testPattern || DEFAULT_VIBE.testPattern }
            }, null, 2)], { type: 'application/json' });
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'sound_prefs.json'; a.click();
            setTimeout(() => URL.revokeObjectURL(a.href), 1000);
          };
          const importInput = $('#soundImportInput'); if (importInput) {
            importInput.onchange = async () => {
              const f = importInput.files && importInput.files[0]; if (!f) return;
              const txt = await f.text();
              try {
                const obj = JSON.parse(txt || '{}');
                if (obj.conf) state.conf = obj.conf;
                if (obj.bgm) { state.bgm.dataUrl = obj.bgm.dataUrl || null; state.bgm.vol = obj.bgm.vol ?? 0.3; state.bgm.loop = obj.bgm.loop ?? true; }
                if (obj.vibe) {
                  const prev = state.vibe || {};
                  state.vibe = normalizeVibeState(obj.vibe);
                  state.vibe._gpBound = prev._gpBound;
                  state.vibe._seq = prev._seq || 0;
                }
                save(); renderUI();
              } catch (e) { }
            };
          }
          const root = $('#soundRoot');
          root.addEventListener('change', async (e) => {
            const t = e.target; const key = t.getAttribute('data-k');
            if (!key) return;
            const conf = ensureEventConfig(key);
            if (t.type === 'file') {
              const f = t.files && t.files[0]; if (!f) return;
              const reader = new FileReader();
              reader.onload = async (ev) => { await setEventSound(key, ev.target.result); };
              reader.readAsDataURL(f);
            } else if (t.getAttribute('data-role') === 'vol') {
              conf.vol = parseFloat(t.value || '0.8'); save();
            } else if (t.getAttribute('data-role') === 'loop') {
              conf.loop = !!t.checked; save();
            } else if (t.getAttribute('data-role') === 'enabled') {
              conf.enabled = !!t.checked; save();
            } else if (t.getAttribute('data-role') === 'effect') {
              conf.effectId = t.value || 'none'; save();
            } else if (t.getAttribute('data-role') === 'vibe') {
              conf.vibeId = t.value || 'none'; save();
            } else if (t.getAttribute('data-role') === 'vibeStrength') {
              conf.vibeStrength = clamp01(parseFloat(t.value || '0.8')); save();
            }
          });
          root.addEventListener('click', (e) => {
            const t = e.target; const key = t.getAttribute('data-k'); const act = t.getAttribute('data-act');
            if (act === 'test') { fireSound(key); }
            if (act === 'clear' && key) {
              clearSoundData(key).then(() => renderUI()).catch(() => renderUI());
            }
          });
          // BGM
          const bgmFile = $('#bgmFile'); if (bgmFile) {
            bgmFile.onchange = async () => {
              const f = bgmFile.files && bgmFile.files[0]; if (!f) return;
              const reader = new FileReader();
              reader.onload = ev => { setBgmSource(ev.target.result); };
              reader.readAsDataURL(f);
            };
          }
          const bgmVol = $('#bgmVol'); if (bgmVol) { bgmVol.oninput = () => { state.bgm.vol = parseFloat(bgmVol.value || '0.3'); if (state.bgm.el) state.bgm.el.volume = state.bgm.vol; save(); }; }
          const bgmLoop = $('#bgmLoop'); if (bgmLoop) { bgmLoop.onchange = () => { state.bgm.loop = !!bgmLoop.checked; if (state.bgm.el) state.bgm.el.loop = state.bgm.loop; save(); }; }
          const bPlay = $('#bgmPlay'); if (bPlay) { bPlay.onclick = () => { unlockAudio(); bgmPlay(); }; }
          const bStop = $('#bgmStop'); if (bStop) { bStop.onclick = () => { bgmStop(); }; }

          // UIクリック音
          document.addEventListener('click', (e) => {
            const tag = (e.target.tagName || '').toLowerCase();
            if (tag === 'button' || tag === 'a' || e.target.classList.contains('btn')) {
              fireSound('ui.click');
            }
          }, { capture: true });
        }

        // 分・時刻トリガ
        function timeTick(nowMs) {
          // minute
          const d = new Date(nowMs);
          const pad2 = (n) => String(n).padStart(2, '0');
          if (d.getSeconds() !== state.lastTick.sec) {
            state.lastTick.sec = d.getSeconds();
            fireSound('second.tick');
            fireSound(`second.s${pad2(state.lastTick.sec)}`);
          }
          if (d.getMinutes() !== state.lastTick.min) {
            state.lastTick.min = d.getMinutes();
            fireSound('minute.tick');
            const m = d.getMinutes();
            if (m === 0 || m === 30) { fireSound('minute.30'); }
          }
          if (d.getHours() !== state.lastTick.hour) {
            state.lastTick.hour = d.getHours();
            fireSound(`hour.${pad2(state.lastTick.hour)}`);
            if (d.getMinutes() === 0) fireSound('hour.full');
          }
        }

        // 予定開始/終了フック（外部から利用）
        window.SoundMgr = {
          play, trigger: (k) => fireSound(k), timeTick, unlockAudio,
          __state: state, __load: load, __render: renderUI
        };
        window.__runSoundEffectForKey = runEffectForKey;
        load();
        // タブが開かれたときにUI描画
        document.addEventListener('click', (e) => {
          if (e.target && e.target.classList && e.target.classList.contains('tab')) {
            if (e.target.dataset.tab === 'sound') { setTimeout(() => { renderUI(); bindUI(); }, 0); }
          }
        });
        // 初回も軽く準備
        setTimeout(() => { renderUI(); bindUI(); }, 0);
      })();
    </script>


    <!-- Sound Upgrade: IndexedDB-backed storage and robust playback -->
    <script>
      (function () {
        const LS = 'sound_prefs_v1'; // reuse existing key for metadata

        // --- IndexedDB helper ---
        const DB_NAME = 'planner-sounds';
        const STORE = 'sounds';
        function openDB() {
          return new Promise((resolve, reject) => {
            const req = indexedDB.open(DB_NAME, 1);
            req.onupgradeneeded = (e) => {
              const db = e.target.result;
              if (!db.objectStoreNames.contains(STORE)) {
                db.createObjectStore(STORE, { keyPath: 'key' });
              }
            };
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
          });
        }
        async function idbPut(key, blob) {
          const db = await openDB();
          return new Promise((resolve, reject) => {
            const tx = db.transaction(STORE, 'readwrite');
            tx.objectStore(STORE).put({ key, blob });
            tx.oncomplete = () => resolve(true);
            tx.onabort = tx.onerror = () => reject(tx.error);
          });
        }
        async function idbGet(key) {
          const db = await openDB();
          return new Promise((resolve, reject) => {
            const tx = db.transaction(STORE, 'readonly');
            const req = tx.objectStore(STORE).get(key);
            req.onsuccess = () => resolve(req.result && req.result.blob || null);
            req.onerror = () => reject(req.error);
          });
        }
        async function idbDel(key) {
          const db = await openDB();
          return new Promise((resolve, reject) => {
            const tx = db.transaction(STORE, 'readwrite');
            tx.objectStore(STORE).delete(key);
            tx.oncomplete = () => resolve(true);
            tx.onabort = tx.onerror = () => reject(tx.error);
          });
        }

        window.__SoundIDB = Object.assign(window.__SoundIDB || {}, {
          put: idbPut,
          get: idbGet,
          del: idbDel,
          dataURLtoBlob
        });

        function normalizeVibe(vibe) {
          const base = vibe || {};
          const target = (typeof base.target === 'string' || typeof base.target === 'number') ? String(base.target) : 'all';
          const strength = typeof base.strength === 'number' ? Math.min(1, Math.max(0, base.strength)) : 0.8;
          return { enabled: !!base.enabled, target, strength, testPattern: base.testPattern || 'tap' };
        }
        function saveMeta(conf, bgm, vibe) {
          try {
            const payload = {
              conf,
              bgm: { dataUrl: null, vol: bgm.vol ?? 0.3, loop: !!bgm.loop, idbKey: bgm.idbKey || null },
              vibe: normalizeVibe(vibe || (window.SoundMgr && SoundMgr.__state && SoundMgr.__state.vibe))
            };
            localStorage.setItem(LS, JSON.stringify(payload));
          } catch (e) { console.warn('saveMeta', e); }
        }

        function dataURLtoBlob(dataUrl) {
          const arr = dataUrl.split(',');
          const mime = arr[0].match(/:(.*?);/)[1] || 'audio/wav';
          const bstr = atob(arr[1]);
          let n = bstr.length;
          const u8arr = new Uint8Array(n);
          while (n--) { u8arr[n] = bstr.charCodeAt(n); }
          return new Blob([u8arr], { type: mime });
        }
        function blobToDataUrl(blob) {
          return new Promise((resolve, reject) => {
            try {
              const reader = new FileReader();
              reader.onload = () => resolve(reader.result);
              reader.onerror = () => reject(reader.error);
              reader.readAsDataURL(blob);
            } catch (err) {
              reject(err);
            }
          });
        }

        async function migrateIfNeeded() {
          try {
            if (!window.SoundMgr || !SoundMgr.__state) return;
            const state = SoundMgr.__state;
            const conf = state.conf || {};
            let changed = false;
            for (const k of Object.keys(conf)) {
              const c = conf[k];
              if (c && c.dataUrl && !c.idbKey) {
                // move to IDB
                const blob = dataURLtoBlob(c.dataUrl);
                const key = 'ev:' + k;
                await idbPut(key, blob);
                c.idbKey = key;
                c.dataUrl = null;
                changed = true;
              }
            }
            // BGM migrate
            const bgm = state.bgm || {};
            if (bgm && bgm.dataUrl && !bgm.idbKey) {
              const blob = dataURLtoBlob(bgm.dataUrl);
              const key = 'bgm:main';
              await idbPut(key, blob);
              bgm.idbKey = key;
              bgm.dataUrl = null;
              changed = true;
            }
            if (changed) {
              saveMeta(conf, bgm, state.vibe);
              try { SoundMgr.__render && SoundMgr.__render(); } catch (e) { }
            }
          } catch (e) { console.warn('migrateIfNeeded', e); }
        }

        // --- Override play to use IDB if available ---
        const origPlay = window.SoundMgr && SoundMgr.play;
        async function playUpgraded(key) {
          try {
            try {
              const fxRunner = window.__runSoundEffectForKey;
              if (typeof fxRunner === 'function') { fxRunner(key); }
            } catch (_) { }
            const st = SoundMgr.__state;
            const c = st.conf[key];
            if (!st.enabled || !c || !c.enabled) return;
            // prefer IDB
            if (c.idbKey) {
              if (!st.ctx) { try { SoundMgr.unlockAudio(); } catch (e) { } }
              const blob = await idbGet(c.idbKey);
              if (blob) {
                const arr = await blob.arrayBuffer();
                const buf = await st.ctx.decodeAudioData(arr.slice(0));
                const src = st.ctx.createBufferSource(); src.buffer = buf; src.loop = !!c.loop;
                const gain = st.ctx.createGain(); gain.gain.value = c.vol ?? 0.8;
                src.connect(gain); gain.connect(st.ctx.destination); src.start(0);
                if (!src.loop) { setTimeout(() => { try { src.stop(); } catch (e) { } }, Math.max(100, (buf.duration || 1) * 1000)); }
                return;
              }
            }
            // fallback to original behavior
            if (typeof origPlay === 'function') { return origPlay(key); }
          } catch (e) {
            try { if (typeof origPlay === 'function') return origPlay(key); } catch (_) { }
          }
        }

        // Hook UI file inputs within sound tab to store into IDB directly
        document.addEventListener('change', async (e) => {
          const t = e.target;
          const isSoundInput = t && t.type === 'file' && (t.id === 'bgmFile' || (t.id && t.id.startsWith('file-')) || (t.closest && t.closest('#soundRoot')));
          if (!isSoundInput) return;
          const st = SoundMgr && SoundMgr.__state; if (!st) return;
          const files = t.files || [];
          if (files.length === 0) return;
          const f = files[0];
          const dataKey = t.getAttribute('data-k');
          const readerKey = t.id === 'bgmFile' ? 'bgm:main' : (dataKey ? ('ev:' + dataKey) : null);
          if (!readerKey) return;
          try {
            await idbPut(readerKey, f);
            if (t.id === 'bgmFile') {
              st.bgm.idbKey = readerKey; st.bgm.dataUrl = null;
            } else {
              const k = t.getAttribute('data-k');
              if (!st.conf[k]) st.conf[k] = { effectId: 'none' };
              if (typeof st.conf[k].vol !== 'number') st.conf[k].vol = 0.8;
              if (typeof st.conf[k].loop !== 'boolean') st.conf[k].loop = false;
              if (!('effectId' in st.conf[k])) st.conf[k].effectId = 'none';
              if (!('vibeId' in st.conf[k])) st.conf[k].vibeId = 'none';
              if (typeof st.conf[k].vibeStrength !== 'number') st.conf[k].vibeStrength = 0.8;
              st.conf[k].idbKey = readerKey;
              st.conf[k].dataUrl = null;
              st.conf[k].enabled = true;
            }
            saveMeta(st.conf, st.bgm, st.vibe);
            try { SoundMgr.__render && SoundMgr.__render(); } catch (_) { }
          } catch (err) { console.warn('IDB put failed', err); }
        }, true);

        // Export/Import with IDB blobs
        function download(filename, text) {
          const a = document.createElement('a');
          a.href = URL.createObjectURL(new Blob([text], { type: 'application/json' }));
          a.download = filename; a.click(); setTimeout(() => URL.revokeObjectURL(a.href), 1000);
        }
        async function doExport() {
          const st = SoundMgr.__state; const out = { version: 2, items: [], bgm: null, vibe: normalizeVibe(st.vibe) };
          for (const k of Object.keys(st.conf)) {
            const c = st.conf[k]; if (!c) continue;
            let dataUrl = null, mime = null, name = null;
            if (c.idbKey) {
              const blob = await idbGet(c.idbKey);
              if (blob) {
                mime = blob.type || 'audio/wav'; name = c.name || null;
                dataUrl = await blobToDataUrl(blob);
              }
            } else if (c.dataUrl) { dataUrl = c.dataUrl; }
            out.items.push({
              key: k,
              vol: c.vol ?? 0.8,
              loop: !!c.loop,
              enabled: !!c.enabled,
              effectId: c.effectId || 'none',
              vibeId: c.vibeId || 'none',
              vibeStrength: c.vibeStrength ?? 0.8,
              dataUrl,
              mime,
              name
            });
          }
          // bgm
          if (st.bgm && st.bgm.idbKey) {
            const blob = await idbGet(st.bgm.idbKey);
            if (blob) {
              out.bgm = { vol: st.bgm.vol ?? 0.3, loop: !!st.bgm.loop, dataUrl: await blobToDataUrl(blob) };
            }
          }
          download('sounds-export.json', JSON.stringify(out));
        }
        async function doImport(file) {
          const txt = await file.text();
          const obj = JSON.parse(txt || '{}');
          const st = SoundMgr.__state;
          if (Array.isArray(obj.items)) {
            for (const it of obj.items) {
              if (it.dataUrl) {
                const blob = dataURLtoBlob(it.dataUrl);
                const id = 'ev:' + it.key;
                await idbPut(id, blob);
                const conf = st.conf[it.key] = st.conf[it.key] || {};
                conf.vol = it.vol ?? 0.8;
                conf.loop = !!it.loop;
                conf.enabled = !!it.enabled;
                conf.effectId = it.effectId || conf.effectId || 'none';
                conf.vibeId = it.vibeId || conf.vibeId || 'none';
                conf.vibeStrength = typeof it.vibeStrength === 'number' ? it.vibeStrength : (conf.vibeStrength ?? 0.8);
                conf.idbKey = id;
                conf.dataUrl = null;
              }
            }
          }
          if (obj.bgm && obj.bgm.dataUrl) {
            const b = dataURLtoBlob(obj.bgm.dataUrl);
            await idbPut('bgm:main', b);
            st.bgm.idbKey = 'bgm:main'; st.bgm.dataUrl = null; st.bgm.vol = obj.bgm.vol ?? 0.3; st.bgm.loop = !!obj.bgm.loop;
          }
          if (obj.vibe) {
            const prev = st.vibe || {};
            st.vibe = normalizeVibe(obj.vibe);
            st.vibe._gpBound = prev._gpBound;
            st.vibe._seq = prev._seq || 0;
          }
          saveMeta(st.conf, st.bgm, st.vibe);
          try { SoundMgr.__render && SoundMgr.__render(); } catch (e) { }
        }

        // Wire buttons if present
        window.addEventListener('DOMContentLoaded', () => {
          try {
            // override play
            if (window.SoundMgr) { SoundMgr.play = playUpgraded; SoundMgr.trigger = (k) => playUpgraded(k); }
            // export
            const ex = document.getElementById('soundExportBtn');
            if (ex) { ex.addEventListener('click', () => { doExport(); }); }
            const imp = document.getElementById('soundImportInput');
            if (imp) { imp.addEventListener('change', (e) => { const f = imp.files && imp.files[0]; if (f) doImport(f); }); }
            migrateIfNeeded();
          } catch (e) { console.warn(e); }
        });
      })();
    </script>


    <script>
      // === テスト時の音重複防止パッチ (2025-11-05) ===
      (function () {
        // すべての現在再生中のaudioを停止して解放
        function stopAllAudios() {
          try {
            document.querySelectorAll('audio').forEach(a => {
              try { a.pause(); } catch (_) { }
              try { a.currentTime = 0; } catch (_) { }
            });
            if (window.__bgmAudio) {
              try { window.__bgmAudio.pause(); } catch (_) { }
            }
          } catch (e) { }
        }
        // #soundRoot内の「テスト」クリックを捕捉して重複回避
        let lastClick = 0;
        function onTestCapture(e) {
          const t = e.target;
          // ボタンかつ文言に「テスト」含む or data-act="test"
          const isBtn = t.closest('button, .btn');
          const label = (t.innerText || t.textContent || '').trim();
          const isTest = (t.dataset && t.dataset.act === 'test') || /テスト/.test(label);
          if (!isBtn || !isTest) return;
          const now = Date.now();
          if (now - lastClick < 200) { // 連打デバウンス
            e.stopPropagation();
            e.preventDefault();
            return;
          }
          lastClick = now;
          // 新規再生が始まる前に、既存の再生をすべて止める
          stopAllAudios();
          // ここでは伝播は継続し、既存のハンドラが新しい再生を開始
        }
        function bind() {
          const root = document.getElementById('soundRoot');
          if (root && !root.__noOverlapBound) {
            root.addEventListener('click', onTestCapture, true); // captureで先に止める
            root.__noOverlapBound = true;
          }
        }
        document.addEventListener('DOMContentLoaded', bind);
        setTimeout(bind, 800);
        setTimeout(bind, 2500);
      })();
    </script>


    <script>
      // === テスト時の音重複・多重ハンドラ対策 強化版 (2025-11-05) ===
      (function () {
        // 直前がテストクリックかどうかを示すフラグ
        let __testClickWindow = false;
        let __testClickTimer = null;

        function markTestWindow() {
          __testClickWindow = true;
          clearTimeout(__testClickTimer);
          __testClickTimer = setTimeout(() => { __testClickWindow = false; }, 600);
        }

        // すべての既存audioを停止
        function stopAllAudios(except) {
          try {
            document.querySelectorAll('audio').forEach(a => {
              if (except && a === except) return;
              try { a.pause(); } catch (_) { }
              try { a.currentTime = 0; } catch (_) { }
            });
            if (!except && window.__bgmAudio) {
              try { window.__bgmAudio.pause(); } catch (_) { }
            }
          } catch (e) { }
        }

        // playのモンキーパッチ：テスト窓口中に新規再生されるaudioは他を全停止してから再生
        (function () {
          const proto = window.HTMLMediaElement && HTMLMediaElement.prototype;
          if (!proto || proto.__patchedForTestNoOverlap) return;
          const _play = proto.play;
          proto.play = function () {
            if (__testClickWindow) {
              // テスト中の再生は単一に保つ
              try { stopAllAudios(this); } catch (_) { }
              try {
                // まれに音割れ要因になる過大ゲインを避ける（ブラウザにより無効）
                if (typeof this.volume === 'number' && this.volume > 1) this.volume = 1;
              } catch (_) { }
            }
            return _play.apply(this, arguments);
          };
          proto.__patchedForTestNoOverlap = true;
        })();

        // #soundRoot の「テスト」ボタンをキャプチャ
        let lastClick = 0;
        function onTestCapture(e) {
          const t = e.target;
          const isBtn = t.closest && t.closest('button, .btn');
          const label = (t.innerText || t.textContent || '').trim();
          const isTest = (t.dataset && t.dataset.act === 'test') || /テスト/.test(label);
          if (!isBtn || !isTest) return;
          const now = Date.now();
          // 連打吸収
          if (now - lastClick < 250) {
            e.stopPropagation();
            e.stopImmediatePropagation && e.stopImmediatePropagation();
            e.preventDefault();
            return;
          }
          lastClick = now;
          // 以後しばらくを「テスト窓口」に
          markTestWindow();
          // 既存の再生は先に全部止める（これで多重ハンドラでも重畳しにくい）
          stopAllAudios();
          // ここでは伝播は流し、既存のハンドラが新規再生を開始
        }

        function bind() {
          const root = document.getElementById('soundRoot');
          if (root && !root.__noOverlapV2) {
            root.addEventListener('click', onTestCapture, true);
            root.__noOverlapV2 = true;
          }
        }
        document.addEventListener('DOMContentLoaded', bind);
        setTimeout(bind, 800);
        setTimeout(bind, 2500);
      })();
    </script>


    <script>
      // === テスト再生の安定化・単一化（最優先ガード） (2025-11-05) ===
      (function () {
        // テストクリック後の一定時間は「テスト専用モード」
        let testWindow = false;
        let testWindowTimer = null;
        let activeTestAudio = null; // その瞬間の唯一の再生ターゲット
        let activeSince = 0;

        function enterTestWindow() {
          testWindow = true;
          clearTimeout(testWindowTimer);
          testWindowTimer = setTimeout(() => { testWindow = false; activeTestAudio = null; }, 800);
        }

        // 既存のaudioを可能な限り止める
        function stopAll(except) {
          try {
            document.querySelectorAll('audio').forEach(a => {
              if (except && a === except) return;
              try { a.pause(); } catch (_) { }
              try { a.currentTime = 0; } catch (_) { }
            });
            if (!except && window.__bgmAudio) {
              try { window.__bgmAudio.pause(); } catch (_) { }
            }
          } catch (_) { }
        }

        // play()のパッチ：テストモード中は1本だけ許可
        (function () {
          const P = window.HTMLMediaElement && HTMLMediaElement.prototype;
          if (!P || P.__patchedTestSingletonV3) return;
          const _play = P.play;
          P.play = function () {
            // 常時：過剰音量を抑止
            try { if (typeof this.volume === 'number' && this.volume > 1) this.volume = 1; } catch (_) { }

            if (testWindow) {
              const now = performance.now ? performance.now() : Date.now();
              if (!activeTestAudio) {
                // 最初の1本を採用し、他は無視
                activeTestAudio = this;
                activeSince = now;
                stopAll(this);
                // 再生終了時に解放
                try {
                  this.addEventListener('ended', () => { if (activeTestAudio === this) { activeTestAudio = null; } }, { once: true });
                } catch (_) { }
                return _play.apply(this, arguments);
              } else if (activeTestAudio === this) {
                // 既に選ばれた本人は普通に再生
                return _play.apply(this, arguments);
              } else {
                // 別インスタンスの再生要求は**無視**（Promise互換で即解決）
                try { this.pause(); this.currentTime = 0; } catch (_) { }
                return Promise.resolve();
              }
            }
            // 通常時
            return _play.apply(this, arguments);
          };
          P.__patchedTestSingletonV3 = true;
        })();

        // 「テスト」ボタンのクリックを先取りしてテスト窓口を開く
        function isTestButton(el) {
          if (!el) return false;
          const btn = el.closest && el.closest('button, .btn');
          if (!btn) return false;
          const label = (btn.innerText || btn.textContent || '').trim();
          return (btn.dataset && btn.dataset.act === 'test') || /テスト/.test(label);
        }

        let lastClick = 0;
        function onClickCapture(e) {
          if (!isTestButton(e.target)) return;
          const now = Date.now();
          if (now - lastClick < 220) {
            // 連打吸収
            e.stopPropagation();
            e.stopImmediatePropagation && e.stopImmediatePropagation();
            e.preventDefault();
            return;
          }
          lastClick = now;
          // テスト窓口開始 & 既存音を先に止める
          enterTestWindow();
          stopAll(null);
          // 以降は既存のハンドラへ流す（playパッチが単一化）
        }

        function bind() {
          const root = document.getElementById('soundRoot');
          if (root && !root.__testSingletonBind) {
            root.addEventListener('click', onClickCapture, true); // capture段階
            root.__testSingletonBind = true;
          }
        }
        document.addEventListener('DOMContentLoaded', bind);
        setTimeout(bind, 600);
        setTimeout(bind, 2000);

        function ensurePlannerGuideLabel() {
          let label = plannerDirectState.label;
          if (label && !label.isConnected) { label = null; plannerDirectState.label = null; }
          if (!label) {
            const wrap = document.querySelector('.clock-wrap');
            if (!wrap) return null;
            label = document.createElement('div');
            label.id = 'plannerDirectLabel';
            label.className = 'planner-direct-label';
            wrap.appendChild(label);
            plannerDirectState.label = label;
          }
          return label;
        }

        const Pomodoro = {
          running: false,
          paused: false,
          phase: 'focus',
          cycle: 1,
          focus: 25,
          shortBreak: 5,
          longBreak: 15,
          longEvery: 4,
          remainingMs: 0,
          phaseEnds: 0,
          timer: null
        };
        window.Pomodoro = Pomodoro;

        function readPomodoroConfig() {
          Pomodoro.focus = Math.max(1, parseInt(($('pomoFocus') || { value: 25 }).value, 10) || 25);
          Pomodoro.shortBreak = Math.max(1, parseInt(($('pomoBreak') || { value: 5 }).value, 10) || 5);
          Pomodoro.longBreak = Math.max(1, parseInt(($('pomoLongBreak') || { value: 15 }).value, 10) || 15);
          Pomodoro.longEvery = Math.max(1, parseInt(($('pomoLongEvery') || { value: 4 }).value, 10) || 4);
        }

        function setPomodoroPanelVisible(show) {
          const panel = $('pomoPanel');
          if (panel) { panel.style.display = show ? 'flex' : 'none'; }
        }

        function initPomodoroUI() {
          const toggleBtn = $('pomo');
          const stopBtn = $('pomoStop');
          const panel = $('pomoPanel');
          if (toggleBtn) {
            toggleBtn.addEventListener('click', () => {
              if (!panel) return;
              const open = panel.style.display === 'flex';
              setPomodoroPanelVisible(!open);
              updatePomodoroButtons();
            });
          }
          if (stopBtn) stopBtn.onclick = () => stopPomodoro(true);
          if ($('pomoStartBtn')) $('pomoStartBtn').onclick = startPomodoro;
          if ($('pomoPauseBtn')) $('pomoPauseBtn').onclick = togglePomodoroPause;
          if ($('pomoSkipBtn')) $('pomoSkipBtn').onclick = skipPomodoroPhase;
          updatePomodoroButtons();
          updatePomodoroUI();
        }

        function startPomodoro() {
          readPomodoroConfig();
          Pomodoro.running = true;
          Pomodoro.paused = false;
          Pomodoro.cycle = 1;
          beginPomodoroPhase('focus');
          setPomodoroPanelVisible(true);
          updatePomodoroButtons();
          updatePomodoroUI('ポモドーロ開始');
        }

        function beginPomodoroPhase(type) {
          const minutes = type === 'focus'
            ? Pomodoro.focus
            : (type === 'longBreak' ? Pomodoro.longBreak : Pomodoro.shortBreak);
          Pomodoro.phase = type;
          Pomodoro.remainingMs = minutes * 60000;
          Pomodoro.phaseEnds = Date.now() + Pomodoro.remainingMs;
          if (Pomodoro.timer) { clearInterval(Pomodoro.timer); }
          Pomodoro.timer = setInterval(pomodoroTick, 1000);
          updatePomodoroUI();
        }

        function pomodoroTick() {
          if (!Pomodoro.running || Pomodoro.paused) return;
          const remain = Pomodoro.phaseEnds - Date.now();
          if (remain <= 0) {
            advancePomodoroPhase();
          } else {
            Pomodoro.remainingMs = remain;
            updatePomodoroUI();
          }
        }

        function advancePomodoroPhase() {
          if (!Pomodoro.running) return;
          if (Pomodoro.phase === 'focus') {
            const isLong = Pomodoro.cycle % Pomodoro.longEvery === 0;
            beginPomodoroPhase(isLong ? 'longBreak' : 'break');
          } else {
            Pomodoro.cycle++;
            beginPomodoroPhase('focus');
          }
        }

        function togglePomodoroPause() {
          if (!Pomodoro.running) return;
          const pauseBtn = $('pomoPauseBtn');
          if (!Pomodoro.paused) {
            Pomodoro.paused = true;
            Pomodoro.remainingMs = Math.max(0, Pomodoro.phaseEnds - Date.now());
            if (Pomodoro.timer) { clearInterval(Pomodoro.timer); Pomodoro.timer = null; }
            if (pauseBtn) pauseBtn.textContent = '▶ 再開';
            updatePomodoroUI('一時停止中');
          } else {
            Pomodoro.paused = false;
            Pomodoro.phaseEnds = Date.now() + Pomodoro.remainingMs;
            Pomodoro.timer = setInterval(pomodoroTick, 1000);
            if (pauseBtn) pauseBtn.textContent = '⏸ 一時停止';
            updatePomodoroUI('再開しました');
          }
          updatePomodoroButtons();
        }

        function skipPomodoroPhase() {
          if (!Pomodoro.running) return;
          advancePomodoroPhase();
          updatePomodoroUI('次のフェーズへ移動しました');
        }

        function stopPomodoro(manual) {
          if (Pomodoro.timer) { clearInterval(Pomodoro.timer); Pomodoro.timer = null; }
          Pomodoro.running = false;
          Pomodoro.paused = false;
          Pomodoro.phase = 'focus';
          Pomodoro.remainingMs = 0;
          updatePomodoroButtons();
          updatePomodoroUI(manual ? 'ポモドーロを停止しました' : 'ポモドーロ完了');
          clearPomodoroVisuals();
        }

        function formatPhaseLabel() {
          if (Pomodoro.phase === 'focus') return '集中';
          if (Pomodoro.phase === 'longBreak') return '長休憩';
          return '休憩';
        }

        function updatePomodoroUI(message) {
          const info = $('pomoInfo');
          const status = $('pomoStatus');
          const hud = $('pomoClockHUD');
          const remainingText = Pomodoro.remainingMs > 0 ? formatDuration(Pomodoro.remainingMs) : '--:--';
          if (info) {
            if (!Pomodoro.running) {
              info.textContent = message || '停止中';
            } else {
              info.textContent = `${formatPhaseLabel()} #${Pomodoro.cycle} / 残り ${remainingText}`;
            }
          }
          if (status) {
            if (message && !Pomodoro.running) {
              status.textContent = message;
            } else if (Pomodoro.running) {
              status.textContent = Pomodoro.paused ? '一時停止中' : `${formatPhaseLabel()}を進行中`;
            } else {
              status.textContent = '停止中';
            }
          }
          if (hud) {
            if (Pomodoro.running) {
              hud.style.display = 'inline-block';
              hud.textContent = Pomodoro.paused ? '🍅 一時停止中' : `🍅 ${formatPhaseLabel()} ${remainingText}`;
            } else {
              hud.style.display = 'none';
            }
          }
        }

        function updatePomodoroButtons() {
          const pauseBtn = $('pomoPauseBtn');
          const stopBtn = $('pomoStop');
          if (pauseBtn) {
            pauseBtn.style.display = Pomodoro.running ? 'inline-block' : 'none';
            pauseBtn.textContent = Pomodoro.paused ? '▶ 再開' : '⏸ 一時停止';
          }
          if (stopBtn) {
            stopBtn.style.display = Pomodoro.running ? 'block' : 'none';
          }
          const toggleBtn = $('pomo');
          if (toggleBtn) {
            toggleBtn.textContent = Pomodoro.running ? '🍅 ポモドーロ稼働中' : '🍅 ポモドーロ開始';
            toggleBtn.classList.toggle('active', Pomodoro.running || ($('pomoPanel') && $('pomoPanel').style.display === 'flex'));
          }
        }

        function clearPomodoroVisuals() {
          const hud = $('pomoClockHUD'); if (hud) hud.style.display = 'none';
        }
      })();
    </script>
  </div>

  <!-- Modals -->

  <div class="modal window compact" id="compareModal">
    <div class="box">
      <div class="box-head">
        <h3 style="margin:0">比較する本を選択</h3>
        <button class="mini-menu" data-close aria-label="閉じる">×</button>
      </div>
      <select id="compareSelect" class="input" style="margin-bottom:8px"></select>
      <div class="row space" style="align-items:center">
        <span class="muted" style="font-size:12px">候補を選んでから実行</span>
        <div class="row" style="gap:6px">
          <button class="btn ghost" data-close>閉じる</button>
          <button class="btn primary" id="compareGo">並べて表示</button>
        </div>
      </div>
    </div>
  </div>

  <div class="modal window compact" id="boxSelectModal">
    <div class="box">
      <div class="box-head">
        <h3 style="margin:0">切り取りを保存</h3>
        <button class="mini-menu" data-close aria-label="閉じる">×</button>
      </div>
      <div class="snip-meta" id="snippetSourceHint">元ページ: -</div>
      <div class="snip-preview"><img id="snippetPreviewImg" alt="preview" /></div>
      <div class="row" style="gap:8px;margin-bottom:8px">
        <select id="boxSelect" style="flex:1"></select>
        <button class="btn ghost" id="newBoxBtn">+ 新規</button>
      </div>
      <input class="input" id="snippetName" placeholder="名前（任意）" style="margin-bottom:8px" />
      <textarea class="input" id="snippetNote" placeholder="メモ/コメント（任意）" style="margin-bottom:8px"></textarea>
      <div class="tight-row" id="snippetAnswerArea" style="justify-content:flex-start">
        <label class="row" style="gap:6px"><input type="checkbox" id="snippetAlsoAnswer" /> 解答も追加</label>
        <label class="chip-check"><input type="radio" name="snippetAnswerMode" value="crop" id="snippetAnswerModeCrop"
            checked> 切り取る</label>
        <label class="chip-check"><input type="radio" name="snippetAnswerMode" value="page" id="snippetAnswerModePage">
          全体</label>
      </div>
      <div class="answer-hint" id="snippetAnswerHint">比較中の解答がある時だけ使えます</div>
      <div class="row space" style="margin-top:6px">
        <button class="btn ghost" data-close>キャンセル</button>
        <button class="btn primary" id="assignToBoxBtn">保存</button>
      </div>
    </div>
  </div>

  <div class="modal" id="newBoxModal">
    <div class="box">
      <h3>新しいボックス</h3>
      <input id="newBoxName" class="input" placeholder="ボックス名" />
      <div class="row" style="gap:8px;margin-top:8px">
        <input id="newBoxTags" class="input" placeholder="タグ（カンマ区切り, 任意）" />
      </div>
      <div class="row space" style="margin-top:10px">
        <button class="btn ghost" data-close>閉じる</button>
        <button class="btn primary" id="createBoxBtn">作成</button>
      </div>
    </div>
  </div>

  <div class="modal" id="pageInsertModal">
    <div class="box">
      <h3>ページの追加/挿入</h3>
      <p class="muted">画像を選ぶと現在の位置に挿入します（複数可）。</p>
      <input type="file" id="insertPicker" accept="image/*" multiple class="input" />
      <div class="row space" style="margin-top:10px">
        <button class="btn ghost" data-close>閉じる</button>
        <button class="btn primary" id="insertNowBtn">挿入</button>
      </div>
    </div>
  </div>

  <div id="toast" class="toast hidden"></div>


  <script>
    /** ===== DB ===== */
    const DB_NAME = 'study-ebook-db-v2-2';
    const DB_VER = 5;
    const BOOK_STORE = 'books';
    const BOOK_PAGES_STORE = 'bookPages';
    const BOOK_PAGE_BLOBS = 'bookPageBlobs';
    let db;
    async function ensureStoragePersistence() {
      if (!navigator.storage || !navigator.storage.persist) return;
      try {
        const persisted = await navigator.storage.persisted();
        if (persisted) return;
        const ok = await navigator.storage.persist();
        if (!ok) {
          console.warn('[DB] Storage persistence was denied; data may be evicted on low disk space.');
        } else {
          console.log('[DB] Storage persistence granted.');
        }
      } catch (e) {
        console.warn('[DB] Storage persistence request failed:', e);
      }
    }
    function openDB() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, DB_VER);
        req.onupgradeneeded = (e) => {
          const genId = () => 'id-' + (crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(16).slice(2));
          const db = e.target.result;
          if (!db.objectStoreNames.contains(BOOK_STORE)) {
            const s = db.createObjectStore(BOOK_STORE, { keyPath: 'id' });
            s.createIndex('createdAt', 'createdAt');
            s.createIndex('title', 'title');
            s.createIndex('tags', 'tags', { multiEntry: true });
            s.createIndex('folder', 'folder');
          }
          if (!db.objectStoreNames.contains(BOOK_PAGES_STORE)) {
            db.createObjectStore(BOOK_PAGES_STORE, { keyPath: 'id' });
          }
          if (!db.objectStoreNames.contains(BOOK_PAGE_BLOBS)) {
            db.createObjectStore(BOOK_PAGE_BLOBS, { keyPath: 'id' });
          }
          if (!db.objectStoreNames.contains('boxes')) {
            const b = db.createObjectStore('boxes', { keyPath: 'id' });
            b.createIndex('name', 'name');
            b.createIndex('createdAt', 'createdAt');
            b.createIndex('tags', 'tags', { multiEntry: true });
          }
          if (!db.objectStoreNames.contains('settings')) db.createObjectStore('settings', { keyPath: 'key' });
          // migrate: move pages out of books store into bookPages for lighter listing
          if (e.oldVersion < 4) {
            try {
              const tx = e.target.transaction;
              const booksStore = tx.objectStore(BOOK_STORE);
              const pagesStore = tx.objectStore(BOOK_PAGES_STORE);
              booksStore.openCursor().onsuccess = (ev) => {
                const cursor = ev.target.result;
                if (!cursor) return;
                const book = cursor.value || {};
                const pages = Array.isArray(book.pages) ? book.pages : [];
                const meta = toBookMeta(book, pages);
                pagesStore.put({ id: meta.id, pages });
                cursor.update(meta);
                cursor.continue();
              };
            } catch (err) { }
          }
          // migrate: separate heavy page data into BOOK_PAGE_BLOBS
          if (e.oldVersion < 5) {
            try {
              const tx = e.target.transaction;
              const pagesStore = tx.objectStore(BOOK_PAGES_STORE);
              const blobStore = tx.objectStore(BOOK_PAGE_BLOBS);
              pagesStore.openCursor().onsuccess = (ev) => {
                const cursor = ev.target.result;
                if (!cursor) return;
                const rec = cursor.value || {};
                const bookId = rec.id;
                const pages = Array.isArray(rec.pages) ? rec.pages : [];
                const metaPages = pages.map((p, idx) => {
                  const pid = p.id || genId();
                  blobStore.put({ id: pid, bookId, pageIndex: idx, dataUrl: p.dataUrl || '', backupDataUrl: p._origDataUrl || null });
                  const mp = Object.assign({}, p);
                  mp.id = pid;
                  delete mp.dataUrl;
                  delete mp._origDataUrl;
                  return mp;
                });
                cursor.update({ id: bookId, pages: metaPages });
                cursor.continue();
              };
            } catch (err) { }
          }
        };
        req.onsuccess = async () => {
          db = req.result;
          db.onversionchange = () => {
            console.warn('[DB] Version change detected, closing DB to avoid corruption.');
            try { db.close(); } catch (_) { }
          };
          await ensureStoragePersistence();
          resolve(db);
        };
        req.onerror = () => {
          console.error('[DB] Open failed:', req.error);
          reject(req.error);
        };
        req.onblocked = () => {
          console.warn('[DB] Open blocked (maybe another tab is still using old version).');
        };
      });
    }
    function tx(name, mode = 'readonly') {
      if (!db) {
        console.error('[tx] Database is not available. Returning dummy.');
        // ダミーオブジェクトを返して操作を吸収（エラーは発生しないがデータは保存されない）
        return {
          put: () => ({ onsuccess: null, onerror: null }),
          add: () => ({ onsuccess: null, onerror: null }),
          get: () => ({ onsuccess: null, onerror: null }),
          delete: () => ({ onsuccess: null, onerror: null }),
          openCursor: () => ({ onsuccess: null, onerror: null }),
          getAll: () => ({ onsuccess: null, onerror: null }),
        };
      }
      return db.transaction(name, mode).objectStore(name);
    }
    function uuid() { return 'id-' + crypto.randomUUID() }
    const dbReady = openDB().then(database => {
      console.log('[DB] Opened successfully. Stores:', [...database.objectStoreNames]);
      return database;
    }).catch(err => {
      console.error('[DB] Failed to open database:', err);
      // DBオープン失敗時はユーザーに通知
      setTimeout(() => {
        const msg = 'データベースの初期化に失敗しました。\n\n' +
          'ブラウザを再起動するか、設定から「全データをリセット」を試してください。\n\n' +
          '詳細: ' + (err?.message || err);
        alert(msg);
      }, 100);
      // nullを返してアプリを続行（制限付きで）
      return null;
    });
    try {
      if (typeof window !== 'undefined') window.__dbReady = dbReady;
    } catch (_) { }

    function toBookMeta(book, pages) {
      const meta = Object.assign({}, book);
      meta.id = meta.id || uuid();
      meta.createdAt = meta.createdAt || Date.now();
      meta.tags = Array.isArray(meta.tags) ? meta.tags : [];
      meta.folder = typeof meta.folder === 'string' ? meta.folder : '';
      meta.customStates = Array.isArray(meta.customStates) ? meta.customStates : [];
      meta.bookmarks = Array.isArray(meta.bookmarks) ? meta.bookmarks : [];
      meta.answerBookIds = Array.isArray(meta.answerBookIds) ? meta.answerBookIds : [];
      meta.firstPageNumber = typeof meta.firstPageNumber === 'number' ? meta.firstPageNumber : 1;
      const count = Array.isArray(pages) ? pages.length : (Array.isArray(meta.pages) ? meta.pages.length : 0);
      meta.pageCount = count;
      if (!meta.coverDataUrl && Array.isArray(pages) && pages[0]?.dataUrl) {
        meta.coverDataUrl = pages[0].dataUrl;
      }
      delete meta.pages;
      return meta;
    }
    function bookPagesOf(book) { return Array.isArray(book?.pages) ? book.pages : []; }
    async function getStoredPages(id, fallback) {
      await dbReady;
      return new Promise((res) => {
        if (!id) { console.warn('[getStoredPages] No ID provided'); res(Array.isArray(fallback) ? fallback : []); return; }
        if (!db.objectStoreNames.contains(BOOK_PAGES_STORE)) {
          console.error('[getStoredPages] Store does not exist:', BOOK_PAGES_STORE, 'Available:', [...db.objectStoreNames]);
          res(Array.isArray(fallback) ? fallback : []);
          return;
        }
        const req = tx(BOOK_PAGES_STORE).get(id);
        req.onsuccess = (e) => {
          const val = e.target.result;
          if (val && Array.isArray(val.pages)) {
            if (window.__DEBUG_BOOK_STORE) console.log('[getStoredPages] Found', val.pages.length, 'pages for book:', id);
            res(val.pages);
          }
          else {
            console.warn('[getStoredPages] No pages found for book:', id, 'result:', val);
            res(Array.isArray(fallback) ? fallback : []);
          }
        };
        req.onerror = (e) => { console.error('[getStoredPages] Error:', e.target.error); res(Array.isArray(fallback) ? fallback : []); };
      });
    }

    const Book = {
      async listMeta() { await dbReady; return new Promise((res, rej) => { const out = []; const c = tx(BOOK_STORE).openCursor(); c.onsuccess = e => { const r = e.target.result; if (r) { out.push(r.value); r.continue() } else res(out) }; c.onerror = () => rej(c.error) }) },
      async list() { const metas = await Book.listMeta(); const withPages = await Promise.all(metas.map(async m => ({ ...m, pages: await getStoredPages(m.id) }))); return withPages; },
      async add(b) {
        await dbReady;
        const pages = bookPagesOf(b);
        const meta = toBookMeta(b, pages);
        const { metaPages, blobs } = splitPagesAndBlobs(pages, meta.id);
        console.log('[Book.add] Creating book:', meta.id, 'with', metaPages.length, 'pages and', blobs.filter(r => r.dataUrl).length, 'blobs');
        return new Promise((res, rej) => {
          const t = db.transaction([BOOK_STORE, BOOK_PAGES_STORE, BOOK_PAGE_BLOBS], 'readwrite');
          t.objectStore(BOOK_STORE).add(meta);
          t.objectStore(BOOK_PAGES_STORE).put({ id: meta.id, pages: metaPages });
          const blobStore = t.objectStore(BOOK_PAGE_BLOBS);
          blobs.forEach(rec => { if (rec.dataUrl || rec.backupDataUrl) blobStore.put(rec); });
          t.oncomplete = () => {
            console.log('[Book.add] Successfully saved book:', meta.id, 'pageIds:', metaPages.map(p => p.id));
            const savedBook = Object.assign({}, meta, { pages: metaPages });
            // Generate thumbnails in background (non-blocking)
            setTimeout(() => {
              generateBookThumbnails(meta.id, pages).catch(e => {
                console.warn('[Book.add] Background thumbnail generation failed:', e);
              });
            }, 100);
            res(savedBook);
          };
          t.onerror = (e) => { console.error('[Book.add] Transaction error:', e.target.error); rej(t.error); };
        });
      },
      async put(b) {
        await dbReady;
        if (b && b._ephemeral) {
          // Skip persistence for ephemeral books (e.g.,完了ページビュー用)
          return Promise.resolve(structuredClone(b));
        }
        const pages = bookPagesOf(b);
        const finalPages = pages.length ? pages : await getStoredPages(b?.id);
        console.log('[Book.put] Input pages:', pages.length, 'Final pages:', finalPages.length, 'Book ID:', b?.id);
        const meta = toBookMeta(b, finalPages);
        const { metaPages, blobs } = splitPagesAndBlobs(finalPages, meta.id);
        console.log('[Book.put] Saving book:', meta.id, 'metaPages:', metaPages.length, 'blobs with data:', blobs.filter(r => r.dataUrl).length);
        return new Promise((res, rej) => {
          const t = db.transaction([BOOK_STORE, BOOK_PAGES_STORE, BOOK_PAGE_BLOBS], 'readwrite');
          t.objectStore(BOOK_STORE).put(meta);
          t.objectStore(BOOK_PAGES_STORE).put({ id: meta.id, pages: metaPages });
          const blobStore = t.objectStore(BOOK_PAGE_BLOBS);
          blobs.forEach(rec => { if (rec.dataUrl || rec.backupDataUrl) blobStore.put(rec); });
          t.oncomplete = () => {
            console.log('[Book.put] Successfully saved book:', meta.id);
            res(Object.assign({}, meta, { pages: metaPages }));
          };
          t.onerror = (e) => { console.error('[Book.put] Transaction error:', e.target.error); rej(t.error); };
        });
      },
      async get(id, { withPages = true } = {}) {
        await dbReady;
        return new Promise((res, rej) => {
          const req = tx(BOOK_STORE).get(id);
          req.onsuccess = async (e) => {
            const meta = e.target.result;
            if (!meta) { console.warn('[Book.get] Book not found:', id); res(null); return; }
            if (!withPages) { res(meta); return; }
            const pages = await getStoredPages(meta.id, meta.pages);
            console.log('[Book.get] Retrieved book:', id, 'with', pages.length, 'pages');
            res(Object.assign({}, meta, { pages }));
          };
          req.onerror = () => rej(req.error);
        });
      },
      async del(id) {
        await dbReady;
        // Optimization: fetch page list first to identify blobs to delete, avoiding full table scan
        let pageIds = [];
        try {
          pageIds = await new Promise((resolve) => {
            if (!db.objectStoreNames.contains(BOOK_PAGES_STORE)) return resolve([]);
            const tx = db.transaction([BOOK_PAGES_STORE], 'readonly');
            const req = tx.objectStore(BOOK_PAGES_STORE).get(id);
            req.onsuccess = () => resolve((req.result?.pages || []).map(p => p.id));
            req.onerror = () => resolve([]);
          });
        } catch (e) { console.warn('[Book.del] Failed to pre-fetch pages', e); }

        return new Promise((res, rej) => {
          const stores = [BOOK_STORE, BOOK_PAGES_STORE];
          if (db.objectStoreNames.contains(BOOK_PAGE_BLOBS)) stores.push(BOOK_PAGE_BLOBS);
          const t = db.transaction(stores, 'readwrite');
          t.objectStore(BOOK_STORE).delete(id);
          if (db.objectStoreNames.contains(BOOK_PAGES_STORE)) {
            t.objectStore(BOOK_PAGES_STORE).delete(id);
          }
          if (db.objectStoreNames.contains(BOOK_PAGE_BLOBS)) {
            const blobStore = t.objectStore(BOOK_PAGE_BLOBS);
            // Delete only related blobs if we found page IDs
            if (pageIds.length > 0) {
              pageIds.forEach(pid => {
                if (pid) blobStore.delete(pid);
              });
            } else {
              // Fallback: full scan ONLY if we couldn't find page list
              // This should be rare. Keeping it for safety but logging warning.
              console.warn('[Book.del] Page list missing, performing slow full scan for blobs cleanup.');
              blobStore.openCursor().onsuccess = (e) => {
                const cur = e.target.result;
                if (cur) {
                  if (cur.value?.bookId === id) { cur.delete(); }
                  cur.continue();
                }
              };
            }
          }
          t.oncomplete = () => res(true);
          t.onerror = () => rej(t.error);
        });
      }
    };
    const Box = {
      async list() { await dbReady; return new Promise((res, rej) => { const out = []; const c = tx('boxes').openCursor(); c.onsuccess = e => { const r = e.target.result; if (r) { out.push(r.value); r.continue() } else res(out) }; c.onerror = () => rej(c.error) }) },
      async add(b) { await dbReady; return new Promise((res) => { tx('boxes', 'readwrite').add(b).onsuccess = () => res(b) }) },
      async put(b) { await dbReady; return new Promise((res) => { tx('boxes', 'readwrite').put(b).onsuccess = () => res(b) }) },
      async get(id) { await dbReady; return new Promise((res) => { tx('boxes').get(id).onsuccess = e => res(e.target.result) }) },
      async del(id) { await dbReady; return new Promise((res) => { tx('boxes', 'readwrite').delete(id).onsuccess = () => res(true) }) }
    };
    // expose for helpers that look up via window.*
    window.Book = Book;
    window.Box = Box;

    function loadStoredBool(key, fallback = false) {
      try {
        const raw = localStorage.getItem(key);
        if (raw === null) return fallback;
        return raw === '1';
      } catch (err) {
        return fallback;
      }
    }
    function saveStoredBool(key, value) {
      try { localStorage.setItem(key, value ? '1' : '0'); } catch (err) { }
    }
    function applyPerfMode(on) {
      document.documentElement.classList.toggle('performance-mode', on);
      if (document.body) document.body.classList.toggle('performance-mode', on);
      saveStoredBool(PERF_MODE_KEY, on);
    }
    function loadStoredNumber(key) {
      try {
        const raw = localStorage.getItem(key);
        if (raw === null) return null;
        const num = parseInt(raw, 10);
        return Number.isNaN(num) ? null : num;
      } catch (err) {
        return null;
      }
    }
    function saveStoredNumber(key, value) {
      try { localStorage.setItem(key, String(value)); } catch (err) { }
    }
    function loadStoredJSON(key) {
      try {
        const raw = localStorage.getItem(key);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch (err) {
        return null;
      }
    }
    function saveStoredJSON(key, value) {
      try { localStorage.setItem(key, JSON.stringify(value)); } catch (err) { }
    }
    function loadStoredString(key) {
      try {
        const raw = localStorage.getItem(key);
        if (raw === null || raw === undefined) return null;
        return String(raw);
      } catch (err) {
        return null;
      }
    }
    const normKey = (s) => (s || '').toLowerCase().trim();
    const matchHotkey = (e, hotkey = '') => {
      if (!hotkey) return false;
      const parts = hotkey.toLowerCase().split('+').map(p => p.trim()).filter(Boolean);
      const requireShift = parts.includes('shift');
      const requireCtrl = parts.includes('ctrl') || parts.includes('control') || parts.includes('meta');
      const requireAlt = parts.includes('alt') || parts.includes('option');
      const keyPart = parts.find(p => p && !['shift', 'ctrl', 'control', 'meta', 'alt', 'option'].includes(p));
      if (requireShift !== e.shiftKey) return false;
      if (requireCtrl !== (e.ctrlKey || e.metaKey)) return false;
      if (requireAlt !== e.altKey) return false;
      if (!keyPart) return true;
      return normKey(e.key) === keyPart || normKey(e.code) === keyPart;
    };
    const formatViewerClock = (d = new Date(), cfg = viewerClockConfig) => {
      const showSeconds = cfg.showSeconds !== false;
      const use12 = (cfg.format || '12') === '12';
      let h = d.getHours();
      let hour = use12 ? (h % 12 || 12) : h;
      const pad = (n) => String(n).padStart(2, '0');
      const parts = [pad(hour), pad(d.getMinutes())];
      if (showSeconds) parts.push(pad(d.getSeconds()));
      return parts.join(':');
    };
    let plannerFlyTimer = null;
    let plannerFlyTickHandle = null;
    let plannerFlySnapshotRev = 0;
    let plannerFlySnapshotKey = '';
    const getPlannerFlyTimeKey = (d = new Date()) => {
      const mode = document.getElementById('mode')?.value || 'day';
      const y = d.getFullYear();
      const m = d.getMonth() + 1;
      const day = d.getDate();
      const h = d.getHours();
      const slot = (mode === 'hour') ? h : (h >= 12 ? 12 : 0);
      return `${mode}-${y}-${m}-${day}-${slot}`;
    };
    let numberlineFlyTimer = null;
    const buildPlannerFlyClock = () => {
      if (!plannerFlyBody) return;
      const curRev = NLStore?.__rev || window.__nlRev || 0;
      const timeKey = getPlannerFlyTimeKey();
      plannerFlyBody.innerHTML = '';
      const src = document.querySelector('#plannerApp .planner-clock-area .clock-wrap');
      if (src) {
        const clone = src.cloneNode(true);
        // remove hint and extraneous elements
        clone.querySelector('#hint')?.remove();
        // Prefix IDs inside clone to avoid collisions while keeping defs intact
        const prefix = `fly-${Date.now().toString(36)}`;
        const idMap = new Map();
        clone.querySelectorAll('[id]').forEach((el) => {
          const orig = el.id;
          const prefixed = `${prefix}-${orig}`;
          idMap.set(orig, prefixed);
          el.id = prefixed;
          el.dataset.flyId = orig;
        });
        const attrList = ['fill', 'stroke', 'filter', 'clip-path', 'mask', 'href', 'xlink:href', 'style'];
        clone.querySelectorAll('*').forEach((el) => {
          attrList.forEach((attr) => {
            const val = el.getAttribute(attr);
            if (!val) return;
            let nextVal = val;
            idMap.forEach((newId, oldId) => {
              const re = new RegExp(`url\\(#${oldId}\\)`, 'g');
              nextVal = nextVal.replace(re, `url(#${newId})`);
            });
            idMap.forEach((newId, oldId) => {
              if (attr === 'style') {
                const re = new RegExp(`#${oldId}(?![\\w-])`, 'g');
                nextVal = nextVal.replace(re, `#${newId}`);
              }
            });
            if (nextVal !== val) el.setAttribute(attr, nextVal);
          });
        });
        plannerFlyBody.appendChild(clone);
        plannerFlySnapshotRev = curRev;
        plannerFlySnapshotKey = timeKey;
        return;
      }
      // Fallback: simple text clock
      const fallback = document.createElement('div');
      fallback.textContent = formatViewerClock(new Date());
      fallback.style.fontSize = '24px';
      fallback.style.fontWeight = '700';
      plannerFlyBody.appendChild(fallback);
      plannerFlySnapshotRev = curRev;
      plannerFlySnapshotKey = timeKey;
    };
    const refreshPlannerFlyClock = (force = true) => {
      if (!(plannerFly && plannerFly.classList.contains('active'))) return;
      const curRev = NLStore?.__rev || window.__nlRev || 0;
      const timeKey = getPlannerFlyTimeKey();
      if (!force && plannerFlySnapshotRev === curRev && plannerFlySnapshotKey === timeKey) return;
      buildPlannerFlyClock();
    };
    const renderNumberlineFly = () => {
      if (!numberlineFlyBody) return false;
      const nlRows = document.querySelector('#nlRows');
      const width = Math.max(260, Math.min(1200, flyClockConfig.numberline?.width || DEFAULT_FLY_CLOCK.numberline.width));
      const count = Math.max(1, Math.min(12, flyClockConfig.numberline?.count || DEFAULT_FLY_CLOCK.numberline.count));
      const useSource = !!(nlRows && nlRows.children.length);
      let wrap = numberlineFlyBody.querySelector('.fly-numberline-wrap');
      const needRebuild = !wrap || wrap.dataset.useSource !== String(useSource) || parseInt(wrap.dataset.count || '0', 10) !== count;

      if (needRebuild) {
        numberlineFlyBody.innerHTML = '';
        wrap = document.createElement('div');
        wrap.className = 'fly-numberline-wrap';
        wrap.dataset.useSource = String(useSource);
        wrap.dataset.count = String(count);
        numberlineFlyBody.appendChild(wrap);

        const content = document.createElement('div');
        if (useSource) {
          const clone = nlRows.cloneNode(true);
          clone.querySelectorAll('[id]').forEach(el => el.removeAttribute('id'));
          clone.querySelectorAll('.nl-eta, .nl-eta-line, .nl-eta-wrap, [class*="nl-eta"], .nl-overall, .nl-overall-inline, #nlOverallBadge').forEach(el => el.remove());
          clone.querySelectorAll('.nl-row').forEach(row => {
            row.classList.add('fly-nl-row');
            row.style.gridTemplateColumns = '1fr';
            const badge = row.querySelector('.nl-hourBadge');
            const hourText = badge?.textContent?.trim() || '';
            if (badge) badge.remove();
            const firstLabel = row.querySelector('.nl-ticks .nl-label');
            if (hourText && firstLabel) firstLabel.textContent = hourText;
            const cap = row.querySelector('.nl-cap span:first-child');
            if (cap) cap.textContent = '';
          });
          const children = Array.from(clone.children).slice(0, count);
          const holder = document.createElement('div');
          holder.className = 'fly-numberline-stack';
          children.forEach(ch => holder.appendChild(ch));
          content.appendChild(holder);
        } else {
          for (let i = 0; i < count; i++) {
            const div = document.createElement('div');
            div.className = 'fly-numberline';
            div.innerHTML = `
              <div class="line"><div class="indicator"></div></div>
              <div class="ticks">
                <span>0</span><span>6</span><span>12</span><span>18</span><span>24</span>
              </div>`;
            content.appendChild(div);
          }
        }
        wrap.appendChild(content);

        const handle = document.createElement('div');
        handle.className = 'fly-numberline-resize';
        wrap.appendChild(handle);

        // resize drag
        let resizing = false;
        let startX = 0;
        let startW = width;
        let pointerId = null;
        const onMove = (clientX) => {
          if (!resizing) return;
          const nextW = Math.max(260, Math.min(1200, startW + (clientX - startX)));
          wrap.style.setProperty('--fly-nl-width', `${nextW}px`);
          wrap.style.width = `${nextW}px`;
        };
        const onPointerMove = (e) => { e.preventDefault(); onMove(e.clientX); };
        const stop = () => {
          if (!resizing) return;
          resizing = false;
          if (pointerId !== null) { handle.releasePointerCapture?.(pointerId); pointerId = null; }
          const finalW = parseFloat(wrap.style.getPropertyValue('--fly-nl-width')) || width;
          saveFlyClockConfig({ numberline: Object.assign({}, flyClockConfig.numberline, { width: finalW }) });
          window.removeEventListener('pointermove', onPointerMove);
          window.removeEventListener('pointerup', stop);
        };
        handle.addEventListener('pointerdown', (e) => {
          e.stopPropagation();
          e.preventDefault();
          pointerId = e.pointerId ?? null;
          if (pointerId !== null) handle.setPointerCapture?.(pointerId);
          resizing = true;
          startX = e.clientX;
          startW = parseFloat(wrap.style.getPropertyValue('--fly-nl-width')) || width;
          window.addEventListener('pointermove', onPointerMove);
          window.addEventListener('pointerup', stop);
        });
      } else {
        wrap.dataset.count = String(count);
      }

      // Cleanup even on reuse
      wrap.querySelectorAll('.nl-eta, .nl-eta-line, .nl-eta-wrap, [class*="nl-eta"], .nl-overall, .nl-overall-inline, #nlOverallBadge').forEach(el => el.remove());
      wrap.querySelectorAll('.nl-row').forEach(row => {
        row.classList.add('fly-nl-row');
        row.style.gridTemplateColumns = '1fr';
        const badge = row.querySelector('.nl-hourBadge');
        const hourText = badge?.textContent?.trim() || '';
        if (badge) badge.remove();
        const firstLabel = row.querySelector('.nl-ticks .nl-label');
        if (hourText && firstLabel) firstLabel.textContent = hourText;
        const cap = row.querySelector('.nl-cap span:first-child');
        if (cap) cap.textContent = '';
      });

      wrap.style.setProperty('--fly-nl-width', `${width}px`);
      wrap.style.width = `${width}px`;
      wrap.style.minWidth = '260px';
      wrap.style.maxWidth = '1200px';

      if (!useSource) {
        const now = new Date();
        const minutes = now.getHours() * 60 + now.getMinutes() + now.getSeconds() / 60;
        const percent = Math.max(0, Math.min(100, (minutes / (24 * 60)) * 100));
        wrap.querySelectorAll('.fly-numberline .indicator').forEach(ind => {
          ind.style.left = `${percent}%`;
        });
      }

      if (numberlineFly) {
        numberlineFly.classList.add('no-anim');
        requestAnimationFrame(() => numberlineFly.classList.remove('no-anim'));
      }
      return !useSource;
    };
    const ensureViewerClockFont = () => {
      if (viewerClockFontStyle && viewerClockFontStyle.parentNode) viewerClockFontStyle.remove();
      viewerClockFontStyle = null;
      if (!viewerClockConfig.fontDataUrl) {
        document.documentElement.style.removeProperty('--viewer-clock-font');
        return;
      }
      const style = document.createElement('style');
      style.id = 'viewerClockFontStyle';
      const name = viewerClockConfig.fontName || 'ViewerClockCustom';
      style.textContent = `
        @font-face {
          font-family: '${name}';
          src: url('${viewerClockConfig.fontDataUrl}');
          font-display: swap;
        }
      `;
      document.head.appendChild(style);
      viewerClockFontStyle = style;
      document.documentElement.style.setProperty('--viewer-clock-font', `'${name}', 'SFMono-Regular', 'Menlo', 'Consolas', monospace`);
    };
    const applyViewerClockColors = () => {
      if (!viewerClockEl) return;
      const design = viewerClockConfig.design || DEFAULT_VIEWER_CLOCK.design;
      const isBare = design === 'bare';
      const isGlass = design === 'glass' || design === 'glass-clear';
      const defaultText = isBare ? '#000000' : (isGlass ? '#0b1224' : '#e2e8f0');
      const defaultBorder = isBare ? 'transparent' : (isGlass ? 'rgba(255,255,255,0.32)' : 'rgba(255,255,255,0.12)');
      const text = viewerClockConfig.textColor || defaultText;
      const isLegacyBorder = viewerClockConfig.borderColor === '#222222';
      const border = (!viewerClockConfig.borderColor || (isLegacyBorder && isGlass)) ? defaultBorder : (viewerClockConfig.borderColor || defaultBorder);
      if (viewerClockWrap) {
        viewerClockWrap.style.setProperty('--viewer-clock-text', text);
        viewerClockWrap.style.setProperty('--viewer-clock-border', border);
      }
      viewerClockEl.style.setProperty('--viewer-clock-text', text);
      viewerClockEl.style.setProperty('--viewer-clock-border', border);
      viewerClockEl.style.color = text;
      viewerClockEl.style.borderColor = border;
      if (viewerTimerEl) {
        viewerTimerEl.style.setProperty('--viewer-clock-text', text);
        viewerTimerEl.style.setProperty('--viewer-clock-border', border);
      }
    };
    const applyViewerClockTextScale = () => {
      const baseSize = 16;
      const raw = parseFloat(viewerClockConfig.textScale ?? DEFAULT_VIEWER_CLOCK.textScale);
      const scale = Number.isFinite(raw) ? Math.max(0.7, Math.min(2.2, raw)) : DEFAULT_VIEWER_CLOCK.textScale;
      const target = viewerClockWrap || document.documentElement;
      if (target?.style) {
        target.style.setProperty('--viewer-clock-text-scale', scale);
        target.style.setProperty('--viewer-clock-font-size', `${baseSize}px`);
      }
    };
    const applyViewerClockDesign = () => {
      if (!viewerClockEl) return;
      const design = viewerClockConfig.design || DEFAULT_VIEWER_CLOCK.design;
      const applyDesign = (el, extra = []) => {
        if (!el) return;
        [...el.classList].forEach(cls => { if (cls.startsWith('vc-style-')) el.classList.remove(cls); });
        el.classList.add('viewer-clock', ...extra, `vc-style-${design}`);
      };
      applyDesign(viewerClockEl);
      applyDesign(viewerTimerEl, ['viewer-timer']);
      applyViewerClockColors();
      applyViewerClockTextScale();
    };
    const applyViewerClockVisibility = () => {
      if (!viewerClockWrap) return;
      const showClock = !!viewerClockConfig.visible;
      const showTimer = !!viewerTimerActive;
      const visible = showClock || showTimer;
      viewerClockWrap.classList.toggle('active', visible);
      viewerClockWrap.classList.toggle('clock-hidden', !visible);
      if (viewerClockEl) viewerClockEl.classList.toggle('hidden', !showClock);
      if (!viewerClockWrap.classList.contains('viewer-clock-inline')) {
        viewerClockOverlay?.classList.toggle('hidden', !visible);
      }
      if (showClock) ensureViewerClockTick();
      else stopViewerClockTick();
    };
    const updateViewerClockText = () => {
      if (!viewerClockText) return;
      const now = (window.__getRealNow ? window.__getRealNow() : new Date());
      viewerClockText.textContent = formatViewerClock(now);
    };
    const stopViewerClockTick = () => {
      if (!viewerClockInterval) return;
      clearTimeout(viewerClockInterval);
      clearInterval(viewerClockInterval);
      viewerClockInterval = null;
    };
    const ensureViewerClockTick = () => {
      if (viewerClockInterval) return;
      if (!viewerClockConfig.visible) return;
      const tick = () => {
        updateViewerClockText();
        const nowMs = (window.__nativeNow ? window.__nativeNow() : Date.now());
        const delay = 1000 - (nowMs % 1000);
        viewerClockInterval = setTimeout(tick, delay);
      };
      const nowMs = (window.__nativeNow ? window.__nativeNow() : Date.now());
      const delay = 1000 - (nowMs % 1000);
      viewerClockInterval = setTimeout(tick, delay);
      updateViewerClockText();
    };
    const applyFlyPos = (el, pos, cfg) => {
      if (!el) return;
      const classes = ['fly-pos-top', 'fly-pos-bottom', 'fly-pos-left', 'fly-pos-right'];
      el.classList.remove(...classes);
      const cls = {
        top: 'fly-pos-top',
        bottom: 'fly-pos-bottom',
        left: 'fly-pos-left',
        right: 'fly-pos-right'
      }[pos] || 'fly-pos-right';
      el.classList.add(cls);
      const dx = cfg?.dragX ?? 0;
      const dy = cfg?.dragY ?? 0;
      el.style.setProperty('--fly-drag-x', `${dx}px`);
      el.style.setProperty('--fly-drag-y', `${dy}px`);
      // preset animation offset based on edge
      let ax = 0, ay = 0;
      if (cls === 'fly-pos-top') ay = -180;
      else if (cls === 'fly-pos-bottom') ay = 180;
      else if (cls === 'fly-pos-left') ax = -180;
      else if (cls === 'fly-pos-right') ax = 180;
      el.style.setProperty('--fly-anim-x', `${ax}px`);
      el.style.setProperty('--fly-anim-y', `${ay}px`);
    };
    const saveFlyDrag = (kind, x, y) => {
      const next = { ...flyClockConfig };
      if (!next[kind]) next[kind] = {};
      next[kind].dragX = x;
      next[kind].dragY = y;
      saveFlyClockConfig(next);
      flyClockConfig = next;
    };
    const togglePlannerFly = (force) => {
      if (!plannerFly || !plannerFlyOverlay) return false;
      const next = typeof force === 'boolean' ? force : !plannerFly.classList.contains('active');
      if (plannerFlyTimer) { clearInterval(plannerFlyTimer); plannerFlyTimer = null; }
      if (next) {
        if (plannerFlyTickHandle) { clearTimeout(plannerFlyTickHandle); plannerFlyTickHandle = null; }
        plannerFlyOverlay.classList.remove('hidden');
        plannerFly.classList.remove('anim-enter', 'active', 'no-anim');
        void plannerFly.offsetWidth;
        plannerFly.style.setProperty('--fly-drag-x', `${flyClockConfig.planner?.dragX || 0}px`);
        plannerFly.style.setProperty('--fly-drag-y', `${flyClockConfig.planner?.dragY || 0}px`);
        // 位置はドラッグ時にクランプ済みなので再クランプしない（ズレ防止）
        // start from enter pose, then animate to active
        plannerFly.classList.add('anim-enter');
        void plannerFly.offsetWidth;
        plannerFly.classList.add('active'); // すぐ開始
        plannerFly.classList.remove('anim-enter'); // 旧挙動と同じタイミングで解除
        buildPlannerFlyClock();
        const update = () => {
          const now = new Date();
          const h = now.getHours() % 12;
          const m = now.getMinutes();
          const s = now.getSeconds();
          const hourEl = plannerFlyBody?.querySelector('[data-fly-id="hHand"]');
          const minEl = plannerFlyBody?.querySelector('[data-fly-id="mHand"]');
          const secEl = plannerFlyBody?.querySelector('[data-fly-id="sHand"]');
          const cx = 250, cy = 250;
          if (hourEl) hourEl.setAttribute('transform', `rotate(${(h + m / 60) * 30} ${cx} ${cy})`);
          // minute hand jumps per minute
          if (minEl) minEl.setAttribute('transform', `rotate(${m * 6} ${cx} ${cy})`);
          if (secEl) secEl.setAttribute('transform', `rotate(${s * 6} ${cx} ${cy})`);
        };
        const scheduleTick = () => {
          const now = Date.now();
          const delay = 1000 - (now % 1000);
          plannerFlyTickHandle = setTimeout(() => { update(); scheduleTick(); }, delay);
        };
        update();
        scheduleTick();
        plannerFly.classList.add('active');
      } else {
        plannerFly.classList.remove('anim-enter');
        plannerFly.classList.add('active');
        void plannerFly.offsetWidth;
        plannerFly.classList.remove('active');
        const hideOverlay = () => {
          if (plannerFly.classList.contains('active')) return;
          plannerFlyOverlay.classList.add('hidden');
          plannerFly.removeEventListener('transitionend', hideOverlay);
        };
        plannerFly.addEventListener('transitionend', hideOverlay);
        setTimeout(hideOverlay, 450);
      }
      if (!next && plannerFlyTickHandle) { clearTimeout(plannerFlyTickHandle); plannerFlyTickHandle = null; }
      saveFlyClockConfig({ planner: Object.assign({}, flyClockConfig.planner, { visible: next }) });
      return next;
    };
    const toggleNumberlineFly = (force) => {
      if (!numberlineFly || !numberlineFlyOverlay) return false;
      const next = typeof force === 'boolean' ? force : !numberlineFly.classList.contains('active');
      if (numberlineFlyTimer) { clearInterval(numberlineFlyTimer); numberlineFlyTimer = null; }
      if (next) {
        numberlineFlyOverlay.classList.remove('hidden');
        numberlineFly.classList.remove('anim-enter', 'active', 'no-anim');
        void numberlineFly.offsetWidth;
        numberlineFly.style.setProperty('--fly-drag-x', `${flyClockConfig.numberline?.dragX || 0}px`);
        numberlineFly.style.setProperty('--fly-drag-y', `${flyClockConfig.numberline?.dragY || 0}px`);
        // 位置はドラッグ時にクランプ済みなので再クランプしない（ズレ防止）
        numberlineFly.classList.add('anim-enter');
        void numberlineFly.offsetWidth;
        numberlineFly.classList.add('active'); // すぐ開始
        numberlineFly.classList.remove('anim-enter'); // 旧挙動と同じタイミングで解除
        const tick = () => {
          const keepTick = renderNumberlineFly();
          if (!keepTick && numberlineFlyTimer) { clearInterval(numberlineFlyTimer); numberlineFlyTimer = null; }
          return keepTick;
        };
        const needsTick = tick();
        if (needsTick) numberlineFlyTimer = setInterval(tick, 1000);
        // active already set
      } else {
        numberlineFly.classList.remove('anim-enter');
        numberlineFly.classList.add('active');
        void numberlineFly.offsetWidth;
        numberlineFly.classList.remove('active');
        const hideOverlay = () => {
          if (numberlineFly.classList.contains('active')) return;
          numberlineFlyOverlay.classList.add('hidden');
          numberlineFly.removeEventListener('transitionend', hideOverlay);
        };
        numberlineFly.addEventListener('transitionend', hideOverlay);
        setTimeout(hideOverlay, 450);
      }
      saveFlyClockConfig({ numberline: Object.assign({}, flyClockConfig.numberline, { visible: next }) });
      return next;
    };

    // Fly drag helpers
    const FLY_BOUND_PADDING = -40;
    const FLY_BOUNCE_PX = 8;
    const flyBounceCooldown = new WeakMap();
    const clampFlyAxis = (value, min, max) => {
      if (typeof value !== 'number' || Number.isNaN(value)) value = 0;
      if (min > max) return { value: (min + max) / 2, hit: 0 };
      if (value < min) return { value: min, hit: 1 };
      if (value > max) return { value: max, hit: -1 };
      return { value, hit: 0 };
    };
    const computeFlyBounds = (el) => {
      if (!el) return null;
      const host = el.closest('.stage-host') || document.getElementById('stageHost');
      if (!host) return null;
      const containerRect = host.getBoundingClientRect();
      const rect = el.getBoundingClientRect();
      if (!containerRect || !rect || !containerRect.width || !containerRect.height || !rect.width || !rect.height) return null;
      return { containerRect, rect };
    };
    const clampFlyDelta = (el, bounds, dx, dy) => {
      const info = bounds || computeFlyBounds(el);
      if (!info) return { dx, dy, hitX: 0, hitY: 0 };
      const { containerRect, rect } = info;
      const pad = FLY_BOUND_PADDING;
      const minDx = (containerRect.left + pad) - rect.left;
      const maxDx = (containerRect.right - pad) - rect.right;
      const minDy = (containerRect.top + pad) - rect.top;
      const maxDy = (containerRect.bottom - pad) - rect.bottom;
      const cx = clampFlyAxis(dx, minDx, maxDx);
      const cy = clampFlyAxis(dy, minDy, maxDy);
      return { dx: cx.value, dy: cy.value, hitX: cx.hit, hitY: cy.hit };
    };
    const triggerFlyBounce = (el, dirX = 0, dirY = 0) => {
      if (!el || (!dirX && !dirY)) return;
      const now = performance.now();
      const last = flyBounceCooldown.get(el) || 0;
      if (now - last < 120) return;
      flyBounceCooldown.set(el, now);
      const bx = dirX ? FLY_BOUNCE_PX * dirX : 0;
      const by = dirY ? FLY_BOUNCE_PX * dirY : 0;
      el.style.setProperty('--fly-bounce-x', `${bx}px`);
      el.style.setProperty('--fly-bounce-y', `${by}px`);
      requestAnimationFrame(() => {
        el.style.setProperty('--fly-bounce-x', '0px');
        el.style.setProperty('--fly-bounce-y', '0px');
      });
    };
    const ensureFlyWithinStage = (el, opts = {}) => {
      if (!el) return;
      const bounds = computeFlyBounds(el);
      if (!bounds) return;
      const { dx, dy, hitX, hitY } = clampFlyDelta(el, bounds, 0, 0);
      if (!dx && !dy) return;
      const curX = parseFloat(el.style.getPropertyValue('--fly-drag-x') || '0') || 0;
      const curY = parseFloat(el.style.getPropertyValue('--fly-drag-y') || '0') || 0;
      const nextX = curX + dx;
      const nextY = curY + dy;
      el.style.setProperty('--fly-drag-x', `${nextX}px`);
      el.style.setProperty('--fly-drag-y', `${nextY}px`);
      if (opts.saveKey) saveFlyDrag(opts.saveKey, nextX, nextY);
      if (opts.bounce) triggerFlyBounce(el, hitX, hitY);
    };
    const makeFlyDraggable = (el) => {
      if (!el) return;
      let dragging = false;
      let startX = 0, startY = 0;
      let baseX = 0, baseY = 0;
      let bounds = null;
      let lastHitX = 0, lastHitY = 0;
      const onMove = (clientX, clientY) => {
        if (!dragging) return;
        const rawDx = clientX - startX;
        const rawDy = clientY - startY;
        const { dx, dy, hitX, hitY } = clampFlyDelta(el, bounds, rawDx, rawDy);
        el.style.setProperty('--fly-drag-x', `${baseX + dx}px`);
        el.style.setProperty('--fly-drag-y', `${baseY + dy}px`);
        if (hitX) lastHitX = hitX;
        if (hitY) lastHitY = hitY;
      };
      const onPointerMove = (e) => {
        onMove(e.clientX, e.clientY);
      };
      const onPointerUp = () => {
        dragging = false;
        bounds = null;
        window.removeEventListener('pointermove', onPointerMove);
        window.removeEventListener('pointerup', onPointerUp);
        const rawX = parseFloat(el.style.getPropertyValue('--fly-drag-x') || '0') || 0;
        const rawY = parseFloat(el.style.getPropertyValue('--fly-drag-y') || '0') || 0;
        if (el.id === 'plannerFly') saveFlyDrag('planner', rawX, rawY);
        if (el.id === 'numberlineFly') saveFlyDrag('numberline', rawX, rawY);
        el.classList.remove('anim-enter');
        el.style.setProperty('--fly-bounce-x', '0px');
        el.style.setProperty('--fly-bounce-y', '0px');
        if (lastHitX || lastHitY) triggerFlyBounce(el, lastHitX, lastHitY);
        lastHitX = 0; lastHitY = 0;
      };
      el.addEventListener('pointerdown', (e) => {
        if (e.button !== 0) return;
        e.stopPropagation();
        dragging = true;
        startX = e.clientX;
        startY = e.clientY;
        baseX = parseFloat(el.style.getPropertyValue('--fly-drag-x') || '0') || 0;
        baseY = parseFloat(el.style.getPropertyValue('--fly-drag-y') || '0') || 0;
        bounds = computeFlyBounds(el);
        el.style.setProperty('--fly-bounce-x', '0px');
        el.style.setProperty('--fly-bounce-y', '0px');
        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerup', onPointerUp);
      });
      el.addEventListener('click', (e) => { e.stopPropagation(); });
    };
    const applyViewerClockPosition = (ctx = viewerClockContext) => {
      if (!viewerClockWrap || !ctx) return;
      const pos = viewerClockConfig.position || 'inline-right';
      const posClasses = ['pos-top-right', 'pos-top-left', 'pos-bottom-right', 'pos-bottom-left', 'pos-top', 'pos-bottom', 'pos-left', 'pos-right'];
      viewerClockWrap.classList.remove('viewer-clock-inline', ...posClasses);
      const stageButtonsRight = ctx.stageButtonsRight;
      const pageBadgeEl = ctx.pageBadge;
      const pageTitleEl = ctx.pageTitle;
      if (pos === 'inline-right' && stageButtonsRight) {
        viewerClockWrap.classList.add('viewer-clock-inline');
        if (viewerClockWrap.parentNode !== stageButtonsRight) {
          stageButtonsRight.insertBefore(viewerClockWrap, pageBadgeEl || pageTitleEl?.nextSibling || null);
        } else {
          stageButtonsRight.insertBefore(viewerClockWrap, pageBadgeEl || pageTitleEl?.nextSibling || null);
        }
        viewerClockOverlay?.classList.add('hidden');
      } else {
        if (viewerClockWrap.parentNode !== viewerClockOverlay) {
          viewerClockOverlay?.appendChild(viewerClockWrap);
        }
        const map = {
          'top-right': 'pos-top-right',
          'top-left': 'pos-top-left',
          'bottom-right': 'pos-bottom-right',
          'bottom-left': 'pos-bottom-left',
          'top': 'pos-top',
          'bottom': 'pos-bottom',
          'left': 'pos-left',
          'right': 'pos-right'
        };
        viewerClockWrap.classList.add(map[pos] || 'pos-top-right');
      }
      applyViewerClockVisibility();
    };
    const syncViewerClock = (ctx = viewerClockContext) => {
      applyViewerClockDesign();
      ensureViewerClockTick();
      applyViewerClockPosition(ctx);
      ensureViewerClockFont();
      applyViewerClockColors();
      applyViewerClockVisibility();
    };
    const toggleViewerClock = (force) => {
      const next = typeof force === 'boolean' ? force : !viewerClockConfig.visible;
      saveViewerClockConfig({ visible: next });
      applyViewerClockVisibility();
      return next;
    };
    const cycleViewerClockDesign = () => {
      const designs = ['bare', 'minimal', 'glass', 'glass-clear', 'wood', 'neon', 'lcd', 'ribbon', 'planner', 'numberline', 'water'];
      const curIdx = designs.indexOf(viewerClockConfig.design || 'minimal');
      const nextDesign = designs[(curIdx + 1) % designs.length];
      saveViewerClockConfig({ design: nextDesign, visible: true });
      applyViewerClockDesign();
      applyViewerClockVisibility();
      return nextDesign;
    };
    const toggleNumberlineClock = () => {
      if (viewerClockConfig.design === 'numberline' && viewerClockTempDesign) {
        saveViewerClockConfig({ design: viewerClockTempDesign, visible: false });
        viewerClockTempDesign = null;
      } else {
        viewerClockTempDesign = viewerClockConfig.design || 'minimal';
        saveViewerClockConfig({ design: 'numberline', visible: true });
      }
      applyViewerClockDesign();
      applyViewerClockVisibility();
      return viewerClockConfig.visible;
    };
    function saveStoredString(key, value) {
      try { localStorage.setItem(key, String(value)); } catch (err) { }
    }

    // =========================================================================
    // External Storage System - File System Access API for USB/External drives
    // =========================================================================
    let externalStorageHandle = null;
    const EXTERNAL_STORAGE_MANIFEST = 'study-app-manifest.json';
    const SETTINGS_FS_FILENAME = 'settings.json';
    const DEFAULT_MANIFEST = {
      version: 3,
      exportedAt: '',
      app: 'StudyEbook',
      mode: 'books-only',
      books: [],
      booksCount: 0,
      settingsBackup: null
    };

    // Check if File System Access API is available
    function isFileSystemAccessSupported() {
      return 'showDirectoryPicker' in window;
    }

    // Select external folder
    async function selectExternalStorageFolder() {
      if (!isFileSystemAccessSupported()) {
        showToast && showToast('この機能はChrome/Edgeでのみ利用できます', 'error');
        return null;
      }
      try {
        const handle = await window.showDirectoryPicker({
          mode: 'readwrite',
          startIn: 'documents'
        });
        externalStorageHandle = handle;
        updateExternalStorageUI();
        showToast && showToast(`フォルダを選択しました: ${handle.name}`, 'ok');
        return handle;
      } catch (e) {
        if (e.name !== 'AbortError') {
          console.error('[ExternalStorage] Folder selection failed:', e);
          showToast && showToast('フォルダの選択に失敗しました', 'error');
        }
        return null;
      }
    }

    async function readManifest(appDir) {
      let manifest = { ...DEFAULT_MANIFEST };
      try {
        const manifestFile = await readFileFromDir(appDir, EXTERNAL_STORAGE_MANIFEST);
        if (manifestFile) {
          const parsed = JSON.parse(await manifestFile.text());
          if (parsed && typeof parsed === 'object') manifest = Object.assign(manifest, parsed);
        }
      } catch (e) {
        console.warn('[FS] Failed to read manifest:', e);
      }
      return manifest;
    }

    async function writeManifest(appDir, updater) {
      const current = await readManifest(appDir);
      const next = typeof updater === 'function' ? updater({ ...current }) : { ...current, ...(updater || {}) };
      if (!next.app) next.app = 'StudyEbook';
      if (!next.version) next.version = 3;
      await writeFileToDir(appDir, EXTERNAL_STORAGE_MANIFEST, JSON.stringify(next, null, 2));
      return next;
    }

    function countOriginalLessonItems(data) {
      if (!data || typeof data !== 'object') return 0;
      if (Array.isArray(data?.originalLesson?.lessons)) return data.originalLesson.lessons.length;
      const raw = data?.settings?.ol_lessons_v1;
      if (raw === undefined || raw === null) return 0;
      if (Array.isArray(raw)) return raw.length;
      if (typeof raw === 'string') {
        try {
          const parsed = JSON.parse(raw);
          return Array.isArray(parsed) ? parsed.length : 0;
        } catch (_) {
          return 0;
        }
      }
      if (typeof raw === 'object') return Array.isArray(raw) ? raw.length : 0;
      return 0;
    }

    function parseMissBackupData(raw) {
      if (raw === null || raw === undefined) return null;
      let obj = raw;
      if (typeof obj === 'string') {
        try { obj = JSON.parse(obj); } catch (_) { return null; }
      }
      if (typeof obj === 'string') {
        try { obj = JSON.parse(obj); } catch (_) { return null; }
      }
      if (!obj || typeof obj !== 'object') return null;
      const books = (obj.books && typeof obj.books === 'object') ? obj.books : obj;
      if (!books || typeof books !== 'object') return null;
      return { raw: obj, books };
    }
    function countMissMarks(raw) {
      const parsed = parseMissBackupData(raw);
      if (!parsed) return 0;
      const books = parsed.books;
      let count = 0;
      Object.values(books).forEach((pages) => {
        if (!pages || typeof pages !== 'object') return;
        Object.values(pages).forEach((marks) => {
          if (Array.isArray(marks)) count += marks.length;
        });
      });
      return count;
    }
    async function applyMissBackupToBooks(raw) {
      const parsed = parseMissBackupData(raw);
      if (!parsed || !Book?.get || !Book?.put || !MissStore?.normalizeMark) return { books: 0, pages: 0, marks: 0 };
      const bookIds = Object.keys(parsed.books || {});
      if (!bookIds.length) return { books: 0, pages: 0, marks: 0 };
      let appliedBooks = 0;
      let appliedPages = 0;
      let appliedMarks = 0;
      for (const bookId of bookIds) {
        const pagesMap = parsed.books[bookId];
        if (!pagesMap || typeof pagesMap !== 'object') continue;
        let book = null;
        try { book = await Book.get(bookId); } catch (_) { book = null; }
        if (!book || !Array.isArray(book.pages)) continue;
        let changed = false;
        for (const [pageKey, marksRaw] of Object.entries(pagesMap)) {
          const pageIndex = parseInt(pageKey, 10);
          if (!Number.isFinite(pageIndex)) continue;
          const page = book.pages[pageIndex];
          if (!page) continue;
          const incoming = Array.isArray(marksRaw) ? marksRaw : [];
          if (!incoming.length) continue;
          const normalized = incoming.map(m => MissStore.normalizeMark(m)).filter(Boolean);
          if (!normalized.length) continue;
          const current = Array.isArray(page.missMarks) ? page.missMarks : [];
          if (!Array.isArray(page.missMarks)) page.missMarks = current;
          const merged = new Map();
          current.forEach(m => { if (m && m.id) merged.set(m.id, m); });
          let updated = false;
          normalized.forEach((m) => {
            if (!m?.id) return;
            const prev = merged.get(m.id);
            if (!prev) {
              merged.set(m.id, m);
              updated = true;
              return;
            }
            const prevTs = Number(prev.updatedAt || prev.createdAt || 0);
            const nextTs = Number(m.updatedAt || m.createdAt || 0);
            if (nextTs > prevTs) {
              merged.set(m.id, Object.assign({}, prev, m));
              updated = true;
            }
          });
          if (updated) {
            page.missMarks = Array.from(merged.values());
            changed = true;
          }
          appliedPages += 1;
          appliedMarks += normalized.length;
        }
        if (changed) {
          try { await Book.put(book); appliedBooks++; } catch (_) { }
        }
      }
      return { books: appliedBooks, pages: appliedPages, marks: appliedMarks };
    }
    async function buildMissStorageFromBooks() {
      if (!Book?.list) return null;
      let books = [];
      try { books = await Book.list(); } catch (_) { books = []; }
      if (!books.length) return null;
      const out = {};
      books.forEach((b) => {
        const bookId = b?.id;
        if (!bookId || !Array.isArray(b.pages)) return;
        b.pages.forEach((p, idx) => {
          const marks = Array.isArray(p?.missMarks) ? p.missMarks : [];
          if (!marks.length) return;
          if (!out[bookId]) out[bookId] = {};
          const normalized = (MissStore?.normalizeMark ? marks.map(m => MissStore.normalizeMark(m)).filter(Boolean) : marks.slice());
          if (normalized.length) out[bookId][idx] = normalized;
        });
      });
      if (!Object.keys(out).length) return null;
      return { version: 1, books: out };
    }
    function getMissMarksFromBackup(data) {
      if (!data || typeof data !== 'object') return null;
      if (data.missMarks !== undefined) return data.missMarks;
      return data.settings?.[MISS_STORAGE_KEY];
    }

    function summarizeSettingsCounts(data) {
      const counts = {
        settings: Object.keys(data?.settings || {}).length,
        plannerEvents: (data?.plannerEvents || []).length,
        draws: Object.keys(data?.draws || {}).length,
        todos: (data?.todos || []).length,
        todosArchived: (data?.todosArchived || []).length,
        boxes: (data?.boxes || []).length,
        originalLessons: countOriginalLessonItems(data),
        missMarks: countMissMarks(getMissMarksFromBackup(data))
      };
      return counts;
    }

    // Update UI based on folder selection
    function updateExternalStorageUI() {
      const pathEl = document.getElementById('storageFolderPath');
      const exportBtn = document.getElementById('exportToExternalBtn');
      const importBtn = document.getElementById('importFromExternalBtn');
      const syncBtn = document.getElementById('syncToExternalBtn');
      const bookPath = document.getElementById('bookFsPath');
      const bookBackupBtn = document.getElementById('bookFsBackupBtn');
      const bookRestoreBtn = document.getElementById('bookFsRestoreBtn');
      const bookManageBtn = document.getElementById('bookFsManageBtn');
      const nonBookBackupBtn = document.getElementById('nonBookFsBackupBtn');
      const nonBookRestoreBtn = document.getElementById('nonBookFsRestoreBtn');
      const nonBookManageBtn = document.getElementById('nonBookFsManageBtn');

      if (externalStorageHandle) {
        if (pathEl) pathEl.textContent = `📁 ${externalStorageHandle.name}`;
        if (exportBtn) exportBtn.disabled = false;
        if (importBtn) importBtn.disabled = false;
        if (syncBtn) syncBtn.disabled = false;
        if (bookPath) bookPath.textContent = `📁 ${externalStorageHandle.name}`;
        if (bookBackupBtn) bookBackupBtn.disabled = false;
        if (bookRestoreBtn) bookRestoreBtn.disabled = false;
        if (bookManageBtn) bookManageBtn.disabled = false;
        if (nonBookBackupBtn) nonBookBackupBtn.disabled = false;
        if (nonBookRestoreBtn) nonBookRestoreBtn.disabled = false;
        if (nonBookManageBtn) nonBookManageBtn.disabled = false;
      } else {
        if (pathEl) pathEl.textContent = '（未設定）';
        if (exportBtn) exportBtn.disabled = true;
        if (importBtn) importBtn.disabled = true;
        if (syncBtn) syncBtn.disabled = true;
        if (bookPath) bookPath.textContent = '（未設定）';
        if (bookBackupBtn) bookBackupBtn.disabled = true;
        if (bookRestoreBtn) bookRestoreBtn.disabled = true;
        if (bookManageBtn) bookManageBtn.disabled = true;
        if (nonBookBackupBtn) nonBookBackupBtn.disabled = true;
        if (nonBookRestoreBtn) nonBookRestoreBtn.disabled = true;
        if (nonBookManageBtn) nonBookManageBtn.disabled = true;
      }
    }

    // Show progress
    function showExternalStorageProgress(text, percent) {
      const statusEl = document.getElementById('externalStorageStatus');
      const progressEl = document.getElementById('externalStorageProgress');
      const textEl = document.getElementById('externalStorageStatusText');
      if (statusEl) statusEl.style.display = 'block';
      if (progressEl) progressEl.style.width = `${percent}%`;
      if (textEl) textEl.textContent = text;
    }

    function hideExternalStorageProgress() {
      const statusEl = document.getElementById('externalStorageStatus');
      if (statusEl) statusEl.style.display = 'none';
    }

    // Progress UI (books-only panel)
    function showBookFsProgress(text, percent) {
      const statusEl = document.getElementById('bookFsStatus');
      const progressEl = document.getElementById('bookFsProgress');
      const textEl = document.getElementById('bookFsStatusText');
      if (statusEl) statusEl.style.display = 'block';
      if (progressEl) progressEl.style.width = `${percent}%`;
      if (textEl) textEl.textContent = text;
    }

    // Progress UI (settings/non-book panel)
    function showNonBookFsProgress(text, percent) {
      const statusEl = document.getElementById('nonBookFsStatus');
      const progressEl = document.getElementById('nonBookFsProgress');
      const textEl = document.getElementById('nonBookFsStatusText');
      if (statusEl) statusEl.style.display = 'block';
      if (progressEl) progressEl.style.width = `${percent}%`;
      if (textEl) textEl.textContent = text;
    }

    function hideNonBookFsProgress() {
      const statusEl = document.getElementById('nonBookFsStatus');
      if (statusEl) statusEl.style.display = 'none';
    }

    function hideBookFsProgress() {
      const statusEl = document.getElementById('bookFsStatus');
      if (statusEl) statusEl.style.display = 'none';
    }

    // Write file to directory
    async function writeFileToDir(dirHandle, filename, data) {
      const fileHandle = await dirHandle.getFileHandle(filename, { create: true });
      const writable = await fileHandle.createWritable();
      await writable.write(data);
      await writable.close();
    }

    // Read file from directory
    async function readFileFromDir(dirHandle, filename) {
      try {
        const fileHandle = await dirHandle.getFileHandle(filename);
        const file = await fileHandle.getFile();
        return file;
      } catch (e) {
        return null;
      }
    }

    // Get or create subdirectory
    async function getOrCreateDir(parentHandle, name) {
      return await parentHandle.getDirectoryHandle(name, { create: true });
    }

    async function clearDirectory(dirHandle) {
      if (!dirHandle) return;
      for await (const [name] of dirHandle.entries()) {
        try { await dirHandle.removeEntry(name, { recursive: true }); } catch (e) { console.warn('[BookFS] Failed to clear entry', name, e); }
      }
    }

    // Books-only backup (File System Access API)
    async function exportBooksOnlyToFS() {
      if (!externalStorageHandle) {
        showToast && showToast('先にフォルダを選択してください', 'error');
        return;
      }
      try {
        showBookFsProgress('準備中...', 0);
        const appDir = await getOrCreateDir(externalStorageHandle, 'StudyAppData');
        const booksDir = await getOrCreateDir(appDir, 'books');
        await clearDirectory(booksDir); // 上書きバックアップ: 既存の本を削除
        let books = [];
        try { books = await Book.list(); } catch (e) { console.error('[BookFS] Failed to get books:', e); }
        const booksMeta = [];

        for (let i = 0; i < books.length; i++) {
          const book = books[i];
          const progress = 5 + (i / Math.max(books.length, 1)) * 90;
          showBookFsProgress(`本を保存中: ${book.title || book.id} (${i + 1}/${books.length})`, progress);
          try {
            const bookDir = await getOrCreateDir(booksDir, book.id);
            let fullBook = book;
            if (!book.pages || book.pages.length === 0) fullBook = await Book.get(book.id);
            if (!fullBook || !Array.isArray(fullBook.pages)) throw new Error('pages missing');
            const meta = { ...fullBook, pages: fullBook.pages.map(p => ({ ...p, blob: undefined, dataUrl: undefined })) };
            booksMeta.push({ id: book.id, title: book.title, pageCount: fullBook.pages.length });
            await writeFileToDir(bookDir, 'metadata.json', JSON.stringify(meta, null, 2));
            for (let j = 0; j < fullBook.pages.length; j++) {
              const page = fullBook.pages[j];
              let blob = page.blob;
              if (!blob) {
                const dataUrl = await toPageDataUrl(page);
                if (dataUrl) {
                  try { blob = await fetch(dataUrl).then(r => r.blob()); } catch (e) { console.warn(`[BookFS] Failed to fetch blob for page ${j}:`, e); }
                }
              }
              if (blob) {
                const ext = blob.type?.includes('png') ? 'png' : 'jpg';
                await writeFileToDir(bookDir, `page-${String(j).padStart(4, '0')}.${ext}`, blob);
              }
            }
          } catch (e) {
            console.error(`[BookFS] Failed to export book ${book.id}:`, e);
          }
          if (i % 3 === 0) await new Promise(r => setTimeout(r, 10));
        }

        showBookFsProgress('マニフェストを保存中...', 97);
        await writeManifest(appDir, (m) => {
          const hasSettings = !!m.settingsBackup;
          return {
            ...m,
            version: 3,
            exportedAt: new Date().toISOString(),
            app: 'StudyEbook',
            mode: hasSettings ? 'books+settings' : 'books-only',
            books: booksMeta,
            booksCount: booksMeta.length
          };
        });
        hideBookFsProgress();
        showToast && showToast(`本をバックアップしました（${booksMeta.length}冊）`, 'ok');
      } catch (e) {
        console.error('[BookFS] Export failed:', e);
        hideBookFsProgress();
        showToast && showToast('本のバックアップに失敗しました: ' + e.message, 'error');
      }
    }

    async function importBooksOnlyFromFS(opts = {}) {
      if (!externalStorageHandle) {
        showToast && showToast('先にフォルダを選択してください', 'error');
        return;
      }
      try {
        showBookFsProgress('データを確認中...', 0);
        let appDir;
        try { appDir = await externalStorageHandle.getDirectoryHandle('StudyAppData'); }
        catch (e) { showToast && showToast('StudyAppDataフォルダが見つかりません', 'error'); hideBookFsProgress(); return; }
        const manifestFile = await readFileFromDir(appDir, EXTERNAL_STORAGE_MANIFEST);
        if (!manifestFile) { showToast && showToast('マニフェストファイルが見つかりません', 'error'); hideBookFsProgress(); return; }
        const manifest = JSON.parse(await manifestFile.text());
        const selectedIds = Array.isArray(opts.selectedIds) ? new Set(opts.selectedIds) : null;
        const totalBooks = manifest.booksCount || manifest.books?.length || 0;
        const targetBooks = manifest.books?.filter(b => !selectedIds || selectedIds.has(b.id)) || [];
        if (!targetBooks.length) { hideBookFsProgress(); showToast && showToast('復元対象の本がありません', 'error'); return; }
        if (!confirm(`本だけを復元しますか？\n\n本: ${targetBooks.length}冊（バックアップ全体: ${totalBooks}冊）\n\n※既存の本は上書きされます。`)) { hideBookFsProgress(); return; }

        showBookFsProgress('本を読み込み中...', 5);
        let booksDir; try { booksDir = await appDir.getDirectoryHandle('books'); } catch (_) { booksDir = null; }
        let importedBooks = 0;
        const toDataUrl = (file) => new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = () => reject(reader.error);
          reader.readAsDataURL(file);
        });

        if (booksDir && targetBooks.length) {
          for (let i = 0; i < targetBooks.length; i++) {
            const info = targetBooks[i];
            const progress = 5 + (i / Math.max(targetBooks.length, 1)) * 90;
            showBookFsProgress(`本を復元中: ${info.title || info.id} (${i + 1}/${targetBooks.length})`, progress);
            try {
              const bookDir = await booksDir.getDirectoryHandle(info.id);
              const metaFile = await readFileFromDir(bookDir, 'metadata.json');
              if (!metaFile) continue;
              const meta = JSON.parse(await metaFile.text());
              if (meta.pages) {
                for (let j = 0; j < meta.pages.length; j++) {
                  for (const ext of ['jpg', 'png']) {
                    const imgFile = await readFileFromDir(bookDir, `page-${String(j).padStart(4, '0')}.${ext}`);
                    if (imgFile) { meta.pages[j].dataUrl = await toDataUrl(imgFile); break; }
                  }
                }
              }
              await Book.put(meta);
              importedBooks++;
            } catch (e) {
              console.error(`[BookFS] Failed to import book ${info.id}:`, e);
            }
            if (i % 3 === 0) await new Promise(r => setTimeout(r, 10));
          }
        }
        hideBookFsProgress();
        showToast && showToast(`復元しました（本: ${importedBooks}冊）`, 'ok');
        try { await refresh(); } catch (_) { }
      } catch (e) {
        console.error('[BookFS] Import failed:', e);
        hideBookFsProgress();
        showToast && showToast('本の復元に失敗しました: ' + e.message, 'error');
      }
    }
    async function importBooksOnlyFromFolder(fileList) {
      const rawFiles = Array.from(fileList || []);
      if (!rawFiles.length) { showToast && showToast('フォルダが選択されていません', 'error'); return; }
      try {
        showBookFsProgress('フォルダを解析中...', 2);
        const entries = rawFiles.map(file => {
          const path = (file.webkitRelativePath || file.relativePath || file.name || '').replace(/\\/g, '/');
          return { file, path };
        }).filter(e => e.path);
        if (!entries.length) { hideBookFsProgress(); showToast && showToast('フォルダ内容を読み取れません', 'error'); return; }

        const fileMap = new Map();
        entries.forEach(e => fileMap.set(e.path, e.file));

        let manifest = null;
        const manifestEntry = entries.find(e => e.path.endsWith(EXTERNAL_STORAGE_MANIFEST));
        if (manifestEntry) {
          try { manifest = JSON.parse(await manifestEntry.file.text()); } catch (e) { console.warn('[FolderImport] Manifest parse failed:', e); }
        }

        const metaEntries = entries.filter(e => e.path.endsWith('/metadata.json'));
        const metaById = new Map();
        metaEntries.forEach(e => {
          const parts = e.path.split('/').filter(Boolean);
          if (parts.length < 2) return;
          const bookId = parts[parts.length - 2];
          if (!bookId) return;
          const dirPath = parts.slice(0, parts.length - 1).join('/');
          metaById.set(bookId, { id: bookId, metaPath: e.path, dirPath, title: null });
        });

        let targets = [];
        if (manifest && Array.isArray(manifest.books) && manifest.books.length) {
          targets = manifest.books.map(b => {
            const meta = metaById.get(b.id);
            if (!meta) return null;
            return { ...meta, title: b.title || meta.title };
          }).filter(Boolean);
        } else {
          targets = Array.from(metaById.values());
        }

        if (!targets.length) {
          hideBookFsProgress();
          showToast && showToast('復元できる本が見つかりません', 'error');
          return;
        }
        if (!confirm(`本だけを復元しますか？\n\n本: ${targets.length}冊\n\n※既存の本は上書きされます。`)) { hideBookFsProgress(); return; }

        const toDataUrl = (file) => new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = () => reject(reader.error);
          reader.readAsDataURL(file);
        });

        let imported = 0;
        for (let i = 0; i < targets.length; i++) {
          const info = targets[i];
          const progress = 5 + (i / Math.max(targets.length, 1)) * 90;
          showBookFsProgress(`本を復元中: ${info.title || info.id} (${i + 1}/${targets.length})`, progress);
          try {
            const metaFile = fileMap.get(info.metaPath);
            if (!metaFile) continue;
            const meta = JSON.parse(await metaFile.text());
            if (meta.pages) {
              for (let j = 0; j < meta.pages.length; j++) {
                const name = `page-${String(j).padStart(4, '0')}`;
                const jpgPath = `${info.dirPath}/${name}.jpg`;
                const pngPath = `${info.dirPath}/${name}.png`;
                const imgFile = fileMap.get(pngPath) || fileMap.get(jpgPath);
                if (imgFile) { meta.pages[j].dataUrl = await toDataUrl(imgFile); }
              }
            }
            await Book.put(meta);
            imported++;
          } catch (e) {
            console.error(`[FolderImport] Failed to import book ${info.id}:`, e);
          }
          if (i % 3 === 0) await new Promise(r => setTimeout(r, 10));
        }

        hideBookFsProgress();
        showToast && showToast(`復元しました（本: ${imported}冊）`, 'ok');
        try { await refresh(); } catch (_) { }
      } catch (e) {
        console.error('[FolderImport] Import failed:', e);
        hideBookFsProgress();
        showToast && showToast('フォルダ復元に失敗しました: ' + e.message, 'error');
      }
    }

    async function loadSettingsFromFS() {
      if (!externalStorageHandle) {
        showToast && showToast('先にフォルダを選択してください', 'error');
        return null;
      }
      try {
        const appDir = await getOrCreateDir(externalStorageHandle, 'StudyAppData');
        const file = await readFileFromDir(appDir, SETTINGS_FS_FILENAME);
        if (!file) return { file: null, data: null, appDir };
        const text = await file.text();
        const data = JSON.parse(text);
        return { file, data, appDir };
      } catch (e) {
        console.error('[SettingsFS] load failed:', e);
        showToast && showToast('本以外バックアップの読み込みに失敗しました', 'error');
        return null;
      }
    }

    async function exportSettingsOnlyToFS() {
      if (!externalStorageHandle) {
        showToast && showToast('先にフォルダを選択してください', 'error');
        return;
      }
      const progress = createExportProgressModal();
      try {
        progress.setTitle('本以外をバックアップ中...');
        const { exportData, counts } = await collectSettingsExportPayload(progress);
        progress.setText('フォルダに保存中...');
        progress.setProgress(95);
        const appDir = await getOrCreateDir(externalStorageHandle, 'StudyAppData');
        await writeFileToDir(appDir, SETTINGS_FS_FILENAME, JSON.stringify(exportData, null, 2));
        const settingsCounts = summarizeSettingsCounts(exportData);
        await writeManifest(appDir, (m) => {
          const now = new Date().toISOString();
          const hasBooks = (m.booksCount || (m.books || []).length || 0) > 0;
          return {
            ...m,
            exportedAt: now,
            mode: hasBooks ? 'books+settings' : 'settings-only',
            settingsBackup: { updatedAt: now, counts: settingsCounts }
          };
        });
        progress.setProgress(100);
        progress.setText('完了');
        setTimeout(() => progress.close(), 350);
        showToast && showToast(`本以外をバックアップしました（${counts.join('、') || 'データなし'}）`, 'ok');
      } catch (e) {
        console.error('[SettingsFS] Export failed:', e);
        progress.close();
        showToast && showToast('本以外のバックアップに失敗しました: ' + e.message, 'error');
      }
    }

    async function importSettingsOnlyFromFS(opts = {}) {
      const info = await loadSettingsFromFS();
      if (!info || !info.file) {
        showToast && showToast('設定バックアップが見つかりません', 'error');
        return;
      }
      if (opts.partialInclude && Array.isArray(opts.partialInclude)) {
        try {
          const include = new Set(opts.partialInclude);
          const filtered = {};
          if (include.has('settings')) {
            filtered.settings = info.data?.settings;
            if (info.data?.originalLesson) filtered.originalLesson = info.data.originalLesson;
            if (info.data?.missMarks !== undefined) filtered.missMarks = info.data.missMarks;
          }
          if (include.has('plannerEvents')) filtered.plannerEvents = info.data?.plannerEvents;
          if (include.has('draws')) filtered.draws = info.data?.draws;
          if (include.has('todos')) filtered.todos = info.data?.todos;
          if (include.has('todosArchived')) filtered.todosArchived = info.data?.todosArchived;
          if (include.has('boxes')) filtered.boxes = info.data?.boxes;
          const tmpFile = new File([JSON.stringify(filtered)], 'settings-partial.json', { type: 'application/json' });
          await importSettingsOnly(tmpFile);
          return;
        } catch (e) {
          console.error('[SettingsFS] Partial import failed:', e);
          showToast && showToast('一部復元に失敗しました: ' + e.message, 'error');
          return;
        }
      }
      await importSettingsOnly(info.file);
    }

    async function deleteSettingsBackupFromFS() {
      if (!externalStorageHandle) { showToast && showToast('先にフォルダを選択してください', 'error'); return false; }
      try {
        const appDir = await getOrCreateDir(externalStorageHandle, 'StudyAppData');
        try { await appDir.removeEntry(SETTINGS_FS_FILENAME); } catch (_) { }
        await writeManifest(appDir, (m) => ({ ...m, settingsBackup: null }));
        return true;
      } catch (e) {
        console.error('[SettingsFS] Delete failed:', e);
        showToast && showToast('バックアップの削除に失敗しました', 'error');
        return false;
      }
    }

    function openNonBookFsManager() {
      if (!isFileSystemAccessSupported()) { showToast && showToast('この機能はChrome/Edgeでのみ利用できます', 'error'); return; }
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.style.display = 'flex';
      modal.innerHTML = `<div class="box" style="width:min(640px,94vw);max-height:80vh;overflow:hidden;display:flex;flex-direction:column;">
        <div class="row space" style="align-items:center;margin-bottom:8px;">
          <h3 style="margin:0;">本以外バックアップの編集</h3>
          <div class="row" style="gap:8px;">
            <button class="btn ghost small" data-refresh>再読み込み</button>
            <button class="btn ghost small" data-close>閉じる</button>
          </div>
        </div>
        <div id="nonBookFsInfo" class="muted" style="font-size:12px;margin-bottom:6px;">読み込み中...</div>
        <div class="row" style="gap:10px;flex-wrap:wrap;margin-bottom:6px;">
          <label class="row" style="gap:6px;align-items:center;"><input type="checkbox" data-key="settings" checked>設定</label>
          <label class="row" style="gap:6px;align-items:center;"><input type="checkbox" data-key="plannerEvents" checked>予定</label>
          <label class="row" style="gap:6px;align-items:center;"><input type="checkbox" data-key="draws" checked>描画</label>
          <label class="row" style="gap:6px;align-items:center;"><input type="checkbox" data-key="todos" checked>ToDo</label>
          <label class="row" style="gap:6px;align-items:center;"><input type="checkbox" data-key="todosArchived" checked>ToDo(完了/中断)</label>
          <label class="row" style="gap:6px;align-items:center;"><input type="checkbox" data-key="boxes" checked>ボックス</label>
        </div>
        <div class="row" style="gap:8px;flex-wrap:wrap;">
          <button class="btn small" data-restore>選択を復元</button>
          <button class="btn ghost small danger" data-delete>バックアップを削除</button>
        </div>
      </div>`;
      document.body.appendChild(modal);
      const info = modal.querySelector('#nonBookFsInfo');
      const closeBtn = modal.querySelector('[data-close]');
      const refreshBtn = modal.querySelector('[data-refresh]');
      const restoreBtn = modal.querySelector('[data-restore]');
      const deleteBtn = modal.querySelector('[data-delete]');
      const checkboxes = () => Array.from(modal.querySelectorAll('input[type="checkbox"][data-key]'));

      const load = async () => {
        if (info) info.textContent = '読み込み中...';
        const dataInfo = await loadSettingsFromFS();
        if (!dataInfo || !dataInfo.data) {
          if (info) info.textContent = 'バックアップが見つかりません。フォルダを確認してください。';
          return;
        }
        const counts = summarizeSettingsCounts(dataInfo.data);
        const parts = [];
        if (counts.settings) parts.push(`設定 ${counts.settings}件`);
        if (counts.originalLessons) parts.push(`オリジナル授業 ${counts.originalLessons}件`);
        if (counts.plannerEvents) parts.push(`予定 ${counts.plannerEvents}件`);
        if (counts.draws) parts.push(`描画 ${counts.draws}件`);
        if (counts.missMarks) parts.push(`ミス ${counts.missMarks}件`);
        if (counts.todos || counts.todosArchived) parts.push(`ToDo ${counts.todos + counts.todosArchived}件`);
        if (counts.boxes) parts.push(`ボックス ${counts.boxes}件`);
        if (info) info.textContent = parts.length ? `バックアップ内容: ${parts.join(' / ')}` : 'バックアップは空です';
      };

      closeBtn?.addEventListener('click', () => modal.remove());
      refreshBtn?.addEventListener('click', load);
      restoreBtn?.addEventListener('click', async () => {
        const keys = checkboxes().filter(ch => ch.checked).map(ch => ch.dataset.key);
        if (!keys.length) { showToast && showToast('復元する項目を選択してください', 'error'); return; }
        modal.remove();
        await importSettingsOnlyFromFS({ partialInclude: keys });
      });
      deleteBtn?.addEventListener('click', async () => {
        if (!confirm('バックアップファイル(settings.json)を削除します。よろしいですか？')) return;
        const ok = await deleteSettingsBackupFromFS();
        if (ok) showToast && showToast('バックアップを削除しました', 'ok');
        modal.remove();
      });

      load();
    }

    async function loadBookFsManifest() {
      if (!externalStorageHandle) { showToast && showToast('先にフォルダを選択してください', 'error'); return null; }
      try {
        const appDir = await getOrCreateDir(externalStorageHandle, 'StudyAppData');
        const booksDir = await getOrCreateDir(appDir, 'books');
        let manifest = await readManifest(appDir);
        // If manifest lacks book list, scan directory
        if (!Array.isArray(manifest.books) || manifest.books.length === 0) {
          const books = [];
          for await (const [name, handle] of booksDir.entries()) {
            if (handle.kind === 'directory') {
              const metaFile = await readFileFromDir(handle, 'metadata.json');
              let title = name; let pageCount = 0;
              if (metaFile) {
                try {
                  const meta = JSON.parse(await metaFile.text());
                  title = meta?.title || title;
                  pageCount = Array.isArray(meta?.pages) ? meta.pages.length : (meta?.pageCount || 0);
                } catch (_) { }
              }
              books.push({ id: name, title, pageCount });
            }
          }
          manifest.books = books;
          manifest.booksCount = books.length;
        }
        return { manifest, appDir, booksDir };
      } catch (e) {
        console.error('[BookFS] load manifest failed:', e);
        showToast && showToast('バックアップの読み込みに失敗しました', 'error');
        return null;
      }
    }

    async function deleteBooksFromFS(ids) {
      const info = await loadBookFsManifest();
      if (!info) return false;
      const { booksDir, appDir, manifest } = info;
      let removed = 0;
      for (const id of ids) {
        try { await booksDir.removeEntry(id, { recursive: true }); removed++; } catch (e) { console.warn('[BookFS] delete failed', id, e); }
      }
      if (removed > 0) {
        manifest.books = (manifest.books || []).filter(b => !ids.includes(b.id));
        manifest.booksCount = manifest.books.length;
        await writeFileToDir(appDir, EXTERNAL_STORAGE_MANIFEST, JSON.stringify(manifest, null, 2));
      }
      return removed;
    }

    function openBookFsManager() {
      if (!isFileSystemAccessSupported()) { showToast && showToast('この機能はChrome/Edgeでのみ利用できます', 'error'); return; }
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.style.display = 'flex';
      modal.innerHTML = `<div class="box" style="width:min(720px,96vw);max-height:80vh;overflow:hidden;display:flex;flex-direction:column;">
        <div class="row space" style="align-items:center;margin-bottom:8px;">
          <h3 style="margin:0;">本バックアップの編集</h3>
          <div class="row" style="gap:8px;">
            <button class="btn ghost small" data-refresh>再読み込み</button>
            <button class="btn ghost small" data-close>閉じる</button>
          </div>
        </div>
        <div id="bookFsManagerStatus" class="muted" style="font-size:11px;margin-bottom:8px;">読み込み中...</div>
        <div style="flex:1;overflow:auto;border:1px solid rgba(255,255,255,0.08);border-radius:8px;padding:8px;">
          <table style="width:100%;border-collapse:collapse;font-size:12px;" id="bookFsManagerTable">
            <thead>
              <tr style="border-bottom:1px solid rgba(255,255,255,0.1);text-align:left;">
                <th style="padding:6px;width:32px;"><input type="checkbox" id="bookFsSelectAll" /></th>
                <th style="padding:6px;">タイトル</th>
                <th style="padding:6px;">ID</th>
                <th style="padding:6px;width:80px;">ページ</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
        <div class="row space" style="margin-top:10px;gap:8px;flex-wrap:wrap;">
          <div class="row" style="gap:8px;">
            <button class="btn ghost small danger" data-delete>選択した本をバックアップから削除</button>
            <button class="btn small" data-restore>選択した本を復元</button>
          </div>
          <div class="muted" style="font-size:11px;">※ バックアップから削除してもアプリ内の本は消えません</div>
        </div>
      </div>`;
      document.body.appendChild(modal);
      const tbody = modal.querySelector('tbody');
      const status = modal.querySelector('#bookFsManagerStatus');
      const selectAll = modal.querySelector('#bookFsSelectAll');
      const closeBtn = modal.querySelector('[data-close]');
      const refreshBtn = modal.querySelector('[data-refresh]');
      const deleteBtn = modal.querySelector('[data-delete]');
      const restoreBtn = modal.querySelector('[data-restore]');

      const load = async () => {
        status.textContent = '読み込み中...';
        tbody.innerHTML = '';
        const info = await loadBookFsManifest();
        if (!info) { status.textContent = '読み込みに失敗しました'; return; }
        const books = info.manifest.books || [];
        status.textContent = `バックアップ内: ${books.length}冊`;
        books.forEach(b => {
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td style="padding:6px;"><input type="checkbox" data-id="${b.id}"></td>
            <td style="padding:6px;">${escapeHTML(b.title || '無題')}</td>
            <td style="padding:6px;font-family:monospace;">${escapeHTML(b.id || '')}</td>
            <td style="padding:6px;text-align:right;">${b.pageCount || 0}</td>
          `;
          tbody.appendChild(tr);
        });
        selectAll.checked = false;
      };

      const getSelectedIds = () => Array.from(tbody.querySelectorAll('input[type="checkbox"]:checked')).map(ch => ch.dataset.id);

      selectAll?.addEventListener('change', () => {
        const checked = selectAll.checked;
        tbody.querySelectorAll('input[type="checkbox"]').forEach(ch => { ch.checked = checked; });
      });
      closeBtn?.addEventListener('click', () => modal.remove());
      refreshBtn?.addEventListener('click', load);
      deleteBtn?.addEventListener('click', async () => {
        const ids = getSelectedIds();
        if (!ids.length) { showToast && showToast('削除する本を選択してください', 'error'); return; }
        if (!confirm(`バックアップから ${ids.length} 冊を削除します。よろしいですか？`)) return;
        const removed = await deleteBooksFromFS(ids);
        showToast && showToast(`バックアップから ${removed} 冊削除しました`, 'ok');
        await load();
      });
      restoreBtn?.addEventListener('click', async () => {
        const ids = getSelectedIds();
        if (!ids.length) { showToast && showToast('復元する本を選択してください', 'error'); return; }
        modal.remove();
        await importBooksOnlyFromFS({ selectedIds: ids });
      });

      load();
    }


    // Export all data to external storage
    // Export all data to external storage (books only)
    async function exportToExternalStorage() {
      if (!externalStorageHandle) {
        showToast && showToast('先にフォルダを選択してください', 'error');
        return;
      }

      try {
        showExternalStorageProgress('準備中...', 0);
        const appDir = await getOrCreateDir(externalStorageHandle, 'StudyAppData');

        // Export books only
        showExternalStorageProgress('本の一覧を取得中...', 5);
        const booksDir = await getOrCreateDir(appDir, 'books');
        let books = [];
        try { books = await Book.list(); } catch (e) { console.error('[ExternalStorage] Failed to get books:', e); }
        const booksMeta = [];

        for (let i = 0; i < books.length; i++) {
          const book = books[i];
          const progress = 5 + (i / Math.max(books.length, 1)) * 90;
          showExternalStorageProgress(`本を保存中: ${book.title || book.id} (${i + 1}/${books.length})`, progress);
          try {
            const bookDir = await getOrCreateDir(booksDir, book.id);
            let fullBook = book;
            if (!book.pages || book.pages.length === 0) fullBook = await Book.get(book.id);
            if (!fullBook || !Array.isArray(fullBook.pages)) throw new Error('pages missing');
            const meta = { ...fullBook, pages: fullBook.pages.map(p => ({ ...p, blob: undefined, dataUrl: undefined })) };
            booksMeta.push({ id: book.id, title: book.title, pageCount: fullBook.pages.length });
            await writeFileToDir(bookDir, 'metadata.json', JSON.stringify(meta, null, 2));
            for (let j = 0; j < fullBook.pages.length; j++) {
              const page = fullBook.pages[j];
              let blob = page.blob;
              if (!blob && page.dataUrl) {
                try { blob = await fetch(page.dataUrl).then(r => r.blob()); } catch (e) { console.warn(`[ExternalStorage] Failed to fetch blob for page ${j}:`, e); }
              }
              if (blob) {
                const ext = blob.type?.includes('png') ? 'png' : 'jpg';
                await writeFileToDir(bookDir, `page-${String(j).padStart(4, '0')}.${ext}`, blob);
              }
            }
          } catch (e) {
            console.error(`[ExternalStorage] Failed to export book ${book.id}:`, e);
          }
          if (i % 3 === 0) await new Promise(r => setTimeout(r, 10));
        }

        showExternalStorageProgress('マニフェストを保存中...', 97);
        await writeManifest(appDir, (m) => {
          const hasSettings = !!m.settingsBackup;
          return {
            ...m,
            version: 3,
            exportedAt: new Date().toISOString(),
            app: 'StudyEbook',
            mode: hasSettings ? 'books+settings' : (m.mode || 'books-only'),
            books: booksMeta,
            booksCount: booksMeta.length
          };
        });
        hideExternalStorageProgress();
        showToast && showToast(`外部に保存しました（本: ${booksMeta.length}冊）`, 'ok');
      } catch (e) {
        console.error('[ExternalStorage] Export failed:', e);
        hideExternalStorageProgress();
        showToast && showToast('保存に失敗しました: ' + e.message, 'error');
      }
    }

    // Import books only from external storage
    async function importFromExternalStorage() {
      if (!externalStorageHandle) {
        showToast && showToast('先にフォルダを選択してください', 'error');
        return;
      }
      try {
        showExternalStorageProgress('データを確認中...', 0);
        let appDir;
        try { appDir = await externalStorageHandle.getDirectoryHandle('StudyAppData'); }
        catch (e) { showToast && showToast('StudyAppDataフォルダが見つかりません', 'error'); hideExternalStorageProgress(); return; }
        const manifestFile = await readFileFromDir(appDir, EXTERNAL_STORAGE_MANIFEST);
        if (!manifestFile) { showToast && showToast('マニフェストファイルが見つかりません', 'error'); hideExternalStorageProgress(); return; }
        const manifest = JSON.parse(await manifestFile.text());
        if (!confirm(`外部データ（本のみ）をインポートしますか？

本: ${manifest.booksCount || manifest.books?.length || 0}冊

※既存データは上書きされます`)) { hideExternalStorageProgress(); return; }

        showExternalStorageProgress('本を読み込み中...', 5);
        let booksDir; try { booksDir = await appDir.getDirectoryHandle('books'); } catch (_) { booksDir = null; }
        let importedBooks = 0;
        if (booksDir && manifest.books) {
          for (let i = 0; i < manifest.books.length; i++) {
            const info = manifest.books[i];
            const progress = 5 + (i / manifest.books.length) * 90;
            showExternalStorageProgress(`本を読み込み中: ${info.title || info.id} (${i + 1}/${manifest.books.length})`, progress);
            try {
              const bookDir = await booksDir.getDirectoryHandle(info.id);
              const metaFile = await readFileFromDir(bookDir, 'metadata.json');
              if (!metaFile) continue;
              const meta = JSON.parse(await metaFile.text());
              if (meta.pages) {
                for (let j = 0; j < meta.pages.length; j++) {
                  for (const ext of ['jpg', 'png']) {
                    const imgFile = await readFileFromDir(bookDir, `page-${String(j).padStart(4, '0')}.${ext}`);
                    if (imgFile) { meta.pages[j].blob = imgFile; break; }
                  }
                }
              }
              await Book.put(meta);
              importedBooks++;
            } catch (e) {
              console.error(`[ExternalStorage] Failed to import book ${info.id}:`, e);
            }
            if (i % 3 === 0) await new Promise(r => setTimeout(r, 10));
          }
        }
        hideExternalStorageProgress();
        showToast && showToast(`インポート完了（本: ${importedBooks}冊）。ページを再読み込みしてください。`, 'ok');
      } catch (e) {
        console.error('[ExternalStorage] Import failed:', e);
        hideExternalStorageProgress();
        showToast && showToast('インポートに失敗しました: ' + e.message, 'error');
      }
    }
    async function importFromExternalStorage() {
      if (!externalStorageHandle) {
        showToast && showToast('先にフォルダを選択してください', 'error');
        return;
      }

      try {
        showExternalStorageProgress('データを確認中...', 0);

        // Find app data directory
        let appDir;
        try {
          appDir = await externalStorageHandle.getDirectoryHandle('StudyAppData');
        } catch (e) {
          showToast && showToast('StudyAppDataフォルダが見つかりません', 'error');
          hideExternalStorageProgress();
          return;
        }

        // Check manifest
        const manifestFile = await readFileFromDir(appDir, EXTERNAL_STORAGE_MANIFEST);
        if (!manifestFile) {
          showToast && showToast('マニフェストファイルが見つかりません', 'error');
          hideExternalStorageProgress();
          return;
        }
        const manifest = JSON.parse(await manifestFile.text());
        console.log('[ExternalStorage] Manifest:', manifest);

        // Confirm import
        const plannerCount = manifest.plannerEventsCount || 0;
        if (!confirm(`外部データをインポートしますか？\n\n本: ${manifest.booksCount || manifest.books?.length || 0}冊\nボックス: ${manifest.boxesCount || manifest.boxes?.length || 0}個\n予定: ${plannerCount}件\n設定: ${manifest.settingsCount || 0}件\n\n※既存データは上書きされます`)) {
          hideExternalStorageProgress();
          return;
        }

        // 1. Import settings
        showExternalStorageProgress('設定を読み込み中...', 5);
        const settingsFile = await readFileFromDir(appDir, 'settings.json');
        if (settingsFile) {
          const settings = JSON.parse(await settingsFile.text());
          for (const [key, value] of Object.entries(settings)) {
            localStorage.setItem(key, value);
          }
          console.log('[ExternalStorage] Imported settings:', Object.keys(settings).length, 'items');
        }

        // 2. Import planner data
        showExternalStorageProgress('予定データを読み込み中...', 8);
        try {
          const plannerFile = await readFileFromDir(appDir, 'planner-events.json');
          if (plannerFile) {
            const plannerEvents = JSON.parse(await plannerFile.text());
            if (plannerEvents && plannerEvents.length > 0) {
              // Save to NLStoreDB
              await new Promise((resolve, reject) => {
                const req = indexedDB.open('NLStoreDB', 1);
                req.onupgradeneeded = (e) => {
                  const db = e.target.result;
                  if (!db.objectStoreNames.contains('events')) {
                    db.createObjectStore('events', { keyPath: 'id' });
                  }
                };
                req.onsuccess = (e) => {
                  const db = e.target.result;
                  const tx = db.transaction('events', 'readwrite');
                  const store = tx.objectStore('events');
                  store.clear();
                  plannerEvents.forEach(ev => store.put(ev));
                  tx.oncomplete = () => resolve();
                  tx.onerror = () => reject(tx.error);
                };
                req.onerror = () => reject(req.error);
              });
              console.log('[ExternalStorage] Imported planner events:', plannerEvents.length, 'items');
            }
          }
        } catch (e) {
          console.warn('[ExternalStorage] Failed to import planner data:', e);
        }

        // 3. Import books
        showExternalStorageProgress('本を読み込み中...', 12);
        let booksDir;
        try {
          booksDir = await appDir.getDirectoryHandle('books');
        } catch (e) {
          booksDir = null;
        }

        let importedBooks = 0;
        if (booksDir && manifest.books) {
          for (let i = 0; i < manifest.books.length; i++) {
            const bookInfo = manifest.books[i];
            const progress = 12 + (i / manifest.books.length) * 55;
            showExternalStorageProgress(`本を読み込み中: ${bookInfo.title || bookInfo.id} (${i + 1}/${manifest.books.length})`, progress);

            try {
              const bookDir = await booksDir.getDirectoryHandle(bookInfo.id);
              const metaFile = await readFileFromDir(bookDir, 'metadata.json');
              if (!metaFile) continue;

              const meta = JSON.parse(await metaFile.text());

              // Load page images
              if (meta.pages) {
                for (let j = 0; j < meta.pages.length; j++) {
                  for (const ext of ['jpg', 'png']) {
                    const imgFile = await readFileFromDir(bookDir, `page-${String(j).padStart(4, '0')}.${ext}`);
                    if (imgFile) {
                      meta.pages[j].blob = imgFile;
                      break;
                    }
                  }
                }
              }

              // Save to IndexedDB
              await Book.put(meta);
              importedBooks++;
              console.log('[ExternalStorage] Imported book:', meta.id, meta.title);
            } catch (e) {
              console.error(`[ExternalStorage] Failed to import book ${bookInfo.id}:`, e);
            }

            // Yield to prevent freeze
            if (i % 3 === 0) {
              await new Promise(r => setTimeout(r, 10));
            }
          }
        }

        // 4. Import boxes
        showExternalStorageProgress('ボックスを読み込み中...', 70);
        let boxesDir;
        try {
          boxesDir = await appDir.getDirectoryHandle('boxes');
        } catch (e) {
          boxesDir = null;
        }

        let importedBoxes = 0;
        if (boxesDir && manifest.boxes && window.Box && Box.put) {
          for (let i = 0; i < manifest.boxes.length; i++) {
            const boxInfo = manifest.boxes[i];
            const progress = 70 + (i / manifest.boxes.length) * 25;
            showExternalStorageProgress(`ボックスを読み込み中: ${boxInfo.name || boxInfo.title || boxInfo.id} (${i + 1}/${manifest.boxes.length})`, progress);

            try {
              const boxDir = await boxesDir.getDirectoryHandle(boxInfo.id);
              const metaFile = await readFileFromDir(boxDir, 'metadata.json');
              if (!metaFile) continue;

              const meta = JSON.parse(await metaFile.text());

              // Load snippet images
              if (meta.snippets) {
                for (let j = 0; j < meta.snippets.length; j++) {
                  for (const ext of ['jpg', 'png']) {
                    const imgFile = await readFileFromDir(boxDir, `snippet-${String(j).padStart(4, '0')}.${ext}`);
                    if (imgFile) {
                      meta.snippets[j].blob = imgFile;
                      break;
                    }
                  }
                }
              }

              await Box.put(meta);
              importedBoxes++;
              console.log('[ExternalStorage] Imported box:', meta.id, meta.name);
            } catch (e) {
              console.error(`[ExternalStorage] Failed to import box ${boxInfo.id}:`, e);
            }
          }
        }

        console.log('[ExternalStorage] Import complete:', { books: importedBooks, boxes: importedBoxes });

        hideExternalStorageProgress();
        showToast && showToast(`インポート完了（本: ${importedBooks}冊, ボックス: ${importedBoxes}個）。ページを再読み込みしてください。`, 'ok');

      } catch (e) {
        console.error('[ExternalStorage] Import failed:', e);
        hideExternalStorageProgress();
        showToast && showToast('インポートに失敗しました: ' + e.message, 'error');
      }
    }

    // Sync: export current data to external storage (smart sync)
    async function syncToExternalStorage() {
      // For now, just do a full export (could be optimized later)
      await exportToExternalStorage();
    }

    // Initialize external storage UI
    function initExternalStorageUI() {
      const fsSupported = isFileSystemAccessSupported();
      if (!fsSupported) {
        const panel = document.getElementById('externalStoragePanel');
        if (panel) {
          panel.innerHTML = `
            <h3>📁 外部ストレージ</h3>
            <p class="muted" style="color:var(--error,#ef4444)">
              ⚠️ この機能はChrome/Edgeでのみ利用できます。<br>
              現在のブラウザはFile System Access APIに対応していません。
            </p>
          `;
        }
      }

      const selectBtn = document.getElementById('selectStorageFolderBtn');
      const exportBtn = document.getElementById('exportToExternalBtn');
      const importBtn = document.getElementById('importFromExternalBtn');
      const syncBtn = document.getElementById('syncToExternalBtn');
      const bookSelectBtn = document.getElementById('bookFsSelectBtn');
      const bookBackupBtn = document.getElementById('bookFsBackupBtn');
      const bookRestoreBtn = document.getElementById('bookFsRestoreBtn');
      const bookManageBtn = document.getElementById('bookFsManageBtn');
      const nonBookBackupBtn = document.getElementById('nonBookFsBackupBtn');
      const nonBookRestoreBtn = document.getElementById('nonBookFsRestoreBtn');
      const nonBookManageBtn = document.getElementById('nonBookFsManageBtn');
      const bookFsNotice = document.getElementById('bookFsUnsupportedNotice');
      if (bookFsNotice) bookFsNotice.style.display = fsSupported ? 'none' : 'block';

      if (!fsSupported) {
        const fsButtons = [
          selectBtn, exportBtn, importBtn, syncBtn,
          bookSelectBtn, bookBackupBtn, bookRestoreBtn, bookManageBtn,
          nonBookBackupBtn, nonBookRestoreBtn, nonBookManageBtn
        ];
        fsButtons.forEach(btn => { if (btn) btn.disabled = true; });
        const pathEl = document.getElementById('storageFolderPath');
        if (pathEl) pathEl.textContent = '（非対応）';
        const bookPath = document.getElementById('bookFsPath');
        if (bookPath) bookPath.textContent = '（非対応）';
        return;
      }

      if (selectBtn) selectBtn.onclick = selectExternalStorageFolder;
      if (exportBtn) exportBtn.onclick = exportToExternalStorage;
      if (importBtn) importBtn.onclick = importFromExternalStorage;
      if (syncBtn) syncBtn.onclick = syncToExternalStorage;
      if (bookSelectBtn) bookSelectBtn.onclick = selectExternalStorageFolder;
      if (bookBackupBtn) bookBackupBtn.onclick = exportBooksOnlyToFS;
      if (bookRestoreBtn) bookRestoreBtn.onclick = importBooksOnlyFromFS;
      if (bookManageBtn) bookManageBtn.onclick = openBookFsManager;
      if (nonBookBackupBtn) nonBookBackupBtn.onclick = exportSettingsOnlyToFS;
      if (nonBookRestoreBtn) {
        nonBookRestoreBtn.onclick = () => {
          if (!confirm('本以外バックアップ（フォルダ）を復元しますか？')) return;
          importSettingsOnlyFromFS();
        };
      }
      if (nonBookManageBtn) nonBookManageBtn.onclick = openNonBookFsManager;

      updateExternalStorageUI();
    }

    // =========================================================================
    // Settings Backup System - IndexedDBに設定を定期バックアップし、消えた場合に復元
    // =========================================================================
    const SETTINGS_BACKUP_KEY = '__settings_backup__';
    const SETTINGS_BACKUP_INTERVAL = 30000; // 30秒ごとにバックアップ

    // バックアップ対象のlocalStorageキー（プレフィックスまたは完全一致）
    const BACKUP_KEY_PREFIXES = [
      'performance-mode', 'reader-', 'viewer-', 'planner', 'nl_', 'pl_', 'ol_',
      'study', 'STUDY', 'thumbGrid', 'tap-draw', 'draw-', 'menu-', 'box-',
      'cursor-style', 'library-', 'page-', 'bgm:', 'open-tabs', 'stage', 'sc-'
    ];
    const BACKUP_LARGE_ALLOWLIST = new Set(['sc-completed']);

    function shouldBackupKey(key) {
      if (!key || typeof key !== 'string') return false;
      // Exclude very large data (e.g., images)
      try {
        const val = localStorage.getItem(key);
        if (val && val.length > 100000 && !BACKUP_LARGE_ALLOWLIST.has(key)) return false; // Skip if > 100KB
      } catch (_) { }
      return BACKUP_KEY_PREFIXES.some(prefix => key.startsWith(prefix) || key.includes(prefix));
    }

    async function backupSettingsToIDB() {
      try {
        await dbReady;
        const settings = {};
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (shouldBackupKey(key)) {
            settings[key] = localStorage.getItem(key);
          }
        }
        const t = db.transaction('settings', 'readwrite');
        t.objectStore('settings').put({ key: SETTINGS_BACKUP_KEY, data: settings, timestamp: Date.now() });
        await new Promise((res, rej) => { t.oncomplete = res; t.onerror = rej; });
        console.log('[Settings Backup] Saved', Object.keys(settings).length, 'keys to IndexedDB');
      } catch (err) {
        console.warn('[Settings Backup] Failed:', err);
      }
    }

    async function restoreSettingsFromIDB() {
      try {
        await dbReady;
        return new Promise((res) => {
          const t = db.transaction('settings', 'readonly');
          const req = t.objectStore('settings').get(SETTINGS_BACKUP_KEY);
          req.onsuccess = () => {
            const result = req.result;
            if (result && result.data && typeof result.data === 'object') {
              let restored = 0;
              const restoredKeys = [];
              for (const [key, val] of Object.entries(result.data)) {
                // Only restore if localStorage is missing this key
                if (localStorage.getItem(key) === null && val !== null) {
                  try {
                    localStorage.setItem(key, val);
                    restored++;
                    restoredKeys.push(key);
                  } catch (_) { }
                }
              }
              if (restored > 0) {
                console.log('[Settings Restore] Restored', restored, 'keys from IndexedDB backup');
                showToast(`${restored}件の設定を復元しました`, 'ok');
                try {
                  window.dispatchEvent(new CustomEvent('settings:restored', { detail: { keys: restoredKeys } }));
                } catch (_) { }
              }
              res(restored);
            } else {
              res(0);
            }
          };
          req.onerror = () => res(0);
        });
      } catch (err) {
        console.warn('[Settings Restore] Failed:', err);
        return 0;
      }
    }

    // Export all settings for JSON backup
    function exportAllSettings() {
      const settings = {};
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && !key.startsWith('__')) {
          settings[key] = localStorage.getItem(key);
        }
      }
      return settings;
    }

    // Import settings from JSON backup
    function importAllSettings(settings) {
      if (!settings || typeof settings !== 'object') return 0;
      let count = 0;
      for (const [key, val] of Object.entries(settings)) {
        if (key && val !== null && val !== undefined) {
          try {
            localStorage.setItem(key, val);
            count++;
          } catch (_) { }
        }
      }
      return count;
    }

    // Start periodic backup after DB is ready
    let settingsBackupTimer = null;
    function startSettingsBackup() {
      if (settingsBackupTimer) return;
      settingsBackupTimer = setInterval(backupSettingsToIDB, SETTINGS_BACKUP_INTERVAL);
      // Initial backup after 5 seconds
      setTimeout(backupSettingsToIDB, 5000);
    }

    // Initialize settings backup on load
    dbReady.then(() => {
      restoreSettingsFromIDB();
      startSettingsBackup();
    }).catch(() => { });
    function estimateDataUrlBytes(dataUrl) {
      if (!dataUrl || typeof dataUrl !== 'string') return 0;
      const base64 = dataUrl.split(',')[1] || '';
      return Math.floor(base64.length * 3 / 4);
    }
    function formatBytes(bytes) {
      if (!isFinite(bytes) || bytes <= 0) return '0 B';
      const units = ['B', 'KB', 'MB', 'GB', 'TB'];
      const i = Math.min(units.length - 1, Math.floor(Math.log(bytes) / Math.log(1024)));
      const val = bytes / Math.pow(1024, i);
      return `${val >= 100 ? val.toFixed(0) : val >= 10 ? val.toFixed(1) : val.toFixed(2)} ${units[i]}`;
    }
    function pageCountOf(book) {
      if (!book) return 0;
      if (typeof book.pageCount === 'number') return book.pageCount;
      return Array.isArray(book.pages) ? book.pages.length : 0;
    }
    function bookCoverOf(book) {
      if (!book) return '';
      if (book.coverDataUrl) return book.coverDataUrl;
      return Array.isArray(book.pages) && book.pages[0]?.dataUrl ? book.pages[0].dataUrl : '';
    }
    function splitPagesAndBlobs(pages, bookId) {
      const metaPages = [];
      const blobs = [];
      (pages || []).forEach((p, idx) => {
        const pid = p.id || uuid();
        const mp = Object.assign({}, p);
        mp.id = pid;
        delete mp.dataUrl;
        delete mp._origDataUrl;
        metaPages.push(mp);
        blobs.push({ id: pid, bookId, pageIndex: idx, dataUrl: p.dataUrl || '', backupDataUrl: p._origDataUrl || null });
      });
      return { metaPages, blobs };
    }
    async function toPageDataUrl(page) {
      // Prefer existing dataUrl, otherwise read from BOOK_PAGE_BLOBS
      if (page?.dataUrl) return page.dataUrl;
      if (!page?.id) return '';
      try {
        const rec = await getPageBlob(page.id);
        if (rec?.dataUrl) return rec.dataUrl;
        if (rec?.backupDataUrl) return rec.backupDataUrl;
      } catch (e) {
        console.warn('[BookFS] toPageDataUrl failed for page', page?.id, e);
      }
      return '';
    }
    async function getPageBlob(pageId) {
      await dbReady;
      return new Promise((res) => {
        if (!pageId) { console.warn('[getPageBlob] Missing pageId'); res(null); return; }
        if (!db) { console.error('[getPageBlob] DB not initialized'); res(null); return; }
        if (!db.objectStoreNames.contains(BOOK_PAGE_BLOBS)) {
          console.error('[getPageBlob] Store does not exist:', BOOK_PAGE_BLOBS, 'Available:', [...db.objectStoreNames]);
          res(null);
          return;
        }
        const req = tx(BOOK_PAGE_BLOBS).get(pageId);
        req.onsuccess = (e) => {
          const result = e.target.result;
          if (!result) console.warn('[getPageBlob] No blob found for pageId:', pageId);
          res(result || null);
        };
        req.onerror = (e) => { console.error('[getPageBlob] Error:', e.target.error); res(null); };
      });
    }
    async function putPageBlob(bookId, pageId, dataUrl, backupDataUrl) {
      await dbReady;
      return new Promise((res, rej) => {
        const store = tx(BOOK_PAGE_BLOBS, 'readwrite');
        const rec = { id: pageId, bookId, dataUrl: dataUrl || '', backupDataUrl: backupDataUrl || null };
        const req = store.put(rec);
        req.onsuccess = () => res(rec);
        req.onerror = () => rej(req.error);
      });
    }
    const isPerfModeActive = () => document.documentElement?.classList?.contains('performance-mode');
    const PAGE_DATA_CACHE_LIMIT = 32;
    const PAGE_DATA_CACHE_PERF_LIMIT = 12;
    const getPageDataCacheLimit = () => (isPerfModeActive() ? PAGE_DATA_CACHE_PERF_LIMIT : PAGE_DATA_CACHE_LIMIT);
    const pageDataCache = new Map();
    const ephemeralSourceBookCache = new Map();
    const getEphemeralSourceBook = async (bookId) => {
      if (!bookId || !Book?.get) return null;
      if (ephemeralSourceBookCache.has(bookId)) return ephemeralSourceBookCache.get(bookId);
      const p = Book.get(bookId).catch(() => null);
      ephemeralSourceBookCache.set(bookId, p);
      return p;
    };
    const touchPageCache = (id, dataUrl) => {
      if (!id || !dataUrl) return;
      if (pageDataCache.has(id)) pageDataCache.delete(id);
      pageDataCache.set(id, dataUrl);
      const limit = getPageDataCacheLimit();
      while (pageDataCache.size > limit) {
        const oldest = pageDataCache.keys().next().value;
        pageDataCache.delete(oldest);
      }
    };
    const dropPageCache = (id) => { if (id) pageDataCache.delete(id); };
    async function ensurePageData(book, idx) {
      if (!book || !Array.isArray(book.pages) || !book.pages[idx]) return '';
      const p = book.pages[idx];
      if (p.dataUrl) {
        if (p.id) touchPageCache(p.id, p.dataUrl);
        return p.dataUrl;
      }
      if (p.id && pageDataCache.has(p.id)) {
        const cached = pageDataCache.get(p.id);
        p.dataUrl = cached;
        return cached;
      }
      const blob = await getPageBlob(p.id);
      let url = blob?.dataUrl || '';
      if (!url && book?._ephemeral && p?._sourceBookId && p._sourceBookId !== book.id) {
        try {
          const base = await getEphemeralSourceBook(p._sourceBookId);
          if (base && Array.isArray(base.pages) && base.pages.length) {
            let sourceIndex = Number.isFinite(p._sourcePageIndex) ? p._sourcePageIndex : null;
            if (!Number.isFinite(sourceIndex)) {
              const realPage = Number.isFinite(p._sourcePage) ? p._sourcePage : null;
              if (realPage != null) {
                if (Array.isArray(base.pageNumberMap)) {
                  const found = base.pageNumberMap.indexOf(realPage);
                  if (found >= 0) sourceIndex = found;
                }
                if (!Number.isFinite(sourceIndex)) {
                  const startNumber = Number.isFinite(base.firstPageNumber)
                    ? base.firstPageNumber
                    : parseInt(base.firstPageNumber || '1', 10) || 1;
                  sourceIndex = Math.max(0, Math.min(base.pages.length - 1, realPage - startNumber));
                }
              }
            }
            if (Number.isFinite(sourceIndex)) {
              const baseUrl = await ensurePageData(base, sourceIndex);
              if (baseUrl) {
                url = baseUrl;
                p._sourcePageIndex = sourceIndex;
              }
            }
          }
        } catch (_) { }
      }
      if (!url) {
        console.error('[ensurePageData] Failed to load page data for pageId:', p.id, 'bookId:', book.id, 'pageIndex:', idx);
      }
      p.dataUrl = url;
      if (p.id && url) touchPageCache(p.id, url);
      if (blob?.backupDataUrl) p._origDataUrl = blob.backupDataUrl;
      return url;
    }
    async function materializeBookPages(book, progressCallback = null) {
      if (!book) return null;
      const pages = [];
      const totalPages = (book.pages || []).length;
      const CHUNK_SIZE = 3; // Reduced from 5 - process fewer pages at a time

      for (let i = 0; i < totalPages; i++) {
        const p = book.pages[i];
        let url = null;
        try {
          url = await ensurePageData(book, i);
        } catch (e) {
          console.warn(`[materializeBookPages] Failed to load page ${i}:`, e);
          url = p.dataUrl || null;
        }
        pages.push(Object.assign({}, p, { dataUrl: url }));

        // Report progress if callback provided
        if (progressCallback) {
          progressCallback(i + 1, totalPages);
        }

        // Yield to browser every CHUNK_SIZE pages to prevent freezing
        if ((i + 1) % CHUNK_SIZE === 0) {
          await new Promise(r => setTimeout(r, 5));
        }

        // Near the end (last 10%), yield more often and hint GC
        if (i > totalPages * 0.9) {
          await new Promise(r => setTimeout(r, 20));
        }
      }

      // Final yield before returning large object
      await new Promise(r => setTimeout(r, 50));

      return Object.assign({}, book, { pages });
    }
    function trimPageCache(book, centerIndex, radius = 4) {
      if (!book || !Array.isArray(book.pages)) return;
      const n = book.pages.length;
      const keepEphemeralData = !!book._ephemeral;
      const effectiveRadius = isPerfModeActive() ? Math.min(radius, 4) : radius;
      for (let i = 0; i < n; i++) {
        if (Math.abs(i - centerIndex) > effectiveRadius) {
          if (book.pages[i]) {
            dropPageCache(book.pages[i].id);
            if (!keepEphemeralData) delete book.pages[i].dataUrl;
          }
        }
      }
    }
    // Image preload cache for faster page turns
    const imagePreloadCache = new Map();    // url -> Promise<Image>
    const loadedImageCache = new Map();     // url -> Image (already fully loaded)
    const BASE_PRELOAD_CACHE = 20;
    const BASE_LOADED_CACHE = 16;
    const getPreloadCacheLimit = () => (isPerfModeActive() ? 8 : BASE_PRELOAD_CACHE);
    const getLoadedCacheLimit = () => (isPerfModeActive() ? 8 : BASE_LOADED_CACHE);

    // Check if an image URL is already fully loaded
    function isImageLoaded(url) {
      return loadedImageCache.has(url);
    }

    // Get a preloaded image immediately if available
    function getLoadedImage(url) {
      return loadedImageCache.get(url);
    }

    function preloadImage(url) {
      if (!url || url.startsWith('data:image/gif;base64,R0lGOD')) return Promise.resolve();

      // Return immediately if already loaded
      if (loadedImageCache.has(url)) {
        return Promise.resolve(loadedImageCache.get(url));
      }

      // Return existing promise if currently loading
      if (imagePreloadCache.has(url)) {
        return imagePreloadCache.get(url);
      }

      const promise = new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          // Store in loaded cache for instant access later
          loadedImageCache.set(url, img);
          // Trim loaded cache if too large
          const loadedLimit = getLoadedCacheLimit();
          while (loadedImageCache.size > loadedLimit) {
            const first = loadedImageCache.keys().next().value;
            loadedImageCache.delete(first);
          }
          resolve(img);
        };
        img.onerror = () => resolve(null);
        img.src = url;
      });

      imagePreloadCache.set(url, promise);
      // Trim preload cache if too large
      const preloadLimit = getPreloadCacheLimit();
      while (imagePreloadCache.size > preloadLimit) {
        const first = imagePreloadCache.keys().next().value;
        imagePreloadCache.delete(first);
      }
      return promise;
    }

    // Wait for an image to load (using cache if available)
    async function waitForImageLoad(url, timeout = 150) {
      if (!url || url.startsWith('data:')) return url;
      if (isImageLoaded(url)) return url;

      // Start loading if not already
      const loadPromise = preloadImage(url);

      // Race between load and timeout
      return new Promise((resolve) => {
        let resolved = false;
        const timer = setTimeout(() => {
          if (!resolved) {
            resolved = true;
            resolve(url); // Return URL anyway, browser will show when ready
          }
        }, timeout);

        loadPromise.then(() => {
          if (!resolved) {
            resolved = true;
            clearTimeout(timer);
            resolve(url);
          }
        });
      });
    }
    function prefetchNearby(book, centerIndex, radius = 3) {
      if (!book || !Array.isArray(book.pages)) return;
      if (isPerfModeActive()) return;
      const start = Math.max(0, centerIndex - radius);
      const end = Math.min(book.pages.length - 1, centerIndex + radius);

      // Priority loading: next page first, then prev page, then others
      const priorityOrder = [];
      // Next page (most important for forward navigation)
      if (centerIndex + 1 < book.pages.length) priorityOrder.push(centerIndex + 1);
      // Previous page (for back navigation)
      if (centerIndex - 1 >= 0) priorityOrder.push(centerIndex - 1);
      // Next+1 page (anticipate fast forward)
      if (centerIndex + 2 < book.pages.length) priorityOrder.push(centerIndex + 2);

      // Add remaining pages
      for (let i = start; i <= end; i++) {
        if (i !== centerIndex && !priorityOrder.includes(i)) {
          priorityOrder.push(i);
        }
      }

      // Load high priority pages immediately
      const highPriority = priorityOrder.slice(0, 3);
      highPriority.forEach(i => {
        ensurePageData(book, i).then(url => {
          if (url) preloadImage(url);
        }).catch(() => { });
      });

      // Load remaining pages in idle time
      const lowPriority = priorityOrder.slice(3);
      if (lowPriority.length > 0) {
        const doFetch = () => {
          lowPriority.forEach(i => {
            ensurePageData(book, i).then(url => {
              if (url) preloadImage(url);
            }).catch(() => { });
          });
        };
        if (typeof requestIdleCallback === 'function') {
          requestIdleCallback(doFetch, { timeout: 500 });
        } else {
          setTimeout(doFetch, 50);
        }
      }
    }

    // ===== Pre-generated Thumbnail System =====
    // Thumbnails are generated at book import time and stored permanently
    // This eliminates render-time thumbnail generation for instant grid display
    const PERM_THUMB_WIDTH = 200;  // Thumbnail width in pixels
    const PERM_THUMB_QUALITY = 0.7; // JPEG quality (0.7 = good balance of quality/size)

    // Generate a thumbnail from a dataUrl or blob
    async function generateThumbnail(sourceDataUrl, width = PERM_THUMB_WIDTH) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
          try {
            // Calculate height maintaining aspect ratio
            const height = Math.round(img.height * (width / img.width));
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);
            const thumbDataUrl = canvas.toDataURL('image/jpeg', PERM_THUMB_QUALITY);
            resolve(thumbDataUrl);
          } catch (e) {
            reject(e);
          }
        };
        img.onerror = () => reject(new Error('Failed to load image for thumbnail'));
        img.src = sourceDataUrl;
      });
    }

    // Generate thumbnails for all pages in a book (called after book save)
    async function generateBookThumbnails(bookId, pages, progressCallback = null) {
      console.log(`[Thumbnail] Generating thumbnails for ${pages.length} pages of book ${bookId}`);
      let generated = 0;

      for (let i = 0; i < pages.length; i++) {
        try {
          // Get page data
          const pageDataUrl = pages[i].dataUrl || pages[i].backupDataUrl;
          if (!pageDataUrl) {
            // Try to get from blob store
            const blobData = await getPageBlob(bookId, i);
            if (!blobData) continue;
          }

          const sourceUrl = pageDataUrl || await getPageDataUrl(bookId, i);
          if (!sourceUrl) continue;

          // Check if thumbnail already exists
          const thumbKey = `${bookId}-${i}`;
          const existing = await loadThumbFromIDB(thumbKey);
          if (existing) {
            generated++;
            continue; // Already has thumbnail
          }

          // Generate thumbnail
          const thumbDataUrl = await generateThumbnail(sourceUrl);

          // Save to IndexedDB
          await saveThumbToIDB(thumbKey, thumbDataUrl);
          generated++;

          // Report progress
          if (progressCallback) {
            progressCallback(i + 1, pages.length);
          }

          // Yield to prevent freeze
          if ((i + 1) % 10 === 0) {
            await new Promise(r => setTimeout(r, 5));
          }
        } catch (e) {
          console.warn(`[Thumbnail] Failed to generate for page ${i}:`, e);
        }
      }

      console.log(`[Thumbnail] Generated ${generated}/${pages.length} thumbnails for book ${bookId}`);
      return generated;
    }

    // Get page data URL from blob store
    async function getPageDataUrl(bookId, pageIndex) {
      const blobData = await getPageBlob(bookId, pageIndex);
      if (!blobData) return null;

      // If it's already a data URL string
      if (typeof blobData === 'string') return blobData;

      // If it's a blob, convert to data URL
      if (blobData instanceof Blob) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(blobData);
        });
      }

      // Check for dataUrl property
      if (blobData.dataUrl) return blobData.dataUrl;
      if (blobData.backupDataUrl) return blobData.backupDataUrl;

      return null;
    }

    // Check if book has all thumbnails generated
    async function hasBookThumbnails(bookId, pageCount) {
      try {
        const db = await openThumbIDB();
        const tx = db.transaction(THUMB_IDB_STORE, 'readonly');
        const store = tx.objectStore(THUMB_IDB_STORE);

        // Count thumbnails for this book
        const all = await new Promise((res, rej) => {
          const req = store.getAll();
          req.onsuccess = () => res(req.result);
          req.onerror = () => rej(req.error);
        });

        const prefix = `${bookId}-`;
        const count = all.filter(item => item.key.startsWith(prefix)).length;
        return count >= pageCount;
      } catch (e) {
        return false;
      }
    }

    // Get pre-generated thumbnail for a page (fast path - no rendering)
    async function getPreGeneratedThumb(bookId, pageIndex) {
      const key = `${bookId}-${pageIndex}`;

      // Check memory cache first
      const cached = thumbCache.get(key);
      if (cached) return cached;

      // Check IndexedDB
      const fromIDB = await loadThumbFromIDB(key);
      if (fromIDB) {
        thumbCache.set(key, fromIDB);
        return fromIDB;
      }

      return null;
    }

    // ===== Thumbnail Cache System =====
    // Cache for loaded thumbnails to prevent re-loading on scroll
    const thumbCache = new Map(); // key: `${bookId}-${pageIndex}`, value: dataUrl
    const THUMB_CACHE_MAX = 500; // Maximum cached thumbnails
    function setThumbCacheLimited(key, url) {
      if (!key || !url) return;
      if (thumbCache.has(key)) thumbCache.delete(key);
      thumbCache.set(key, url);
      while (thumbCache.size > THUMB_CACHE_MAX) {
        const oldest = thumbCache.keys().next().value;
        thumbCache.delete(oldest);
      }
    }

    function getThumbCacheKey(book, index) {
      return `${book?.id || 'unknown'}-${index}`;
    }

    function getCachedThumb(book, index) {
      return thumbCache.get(getThumbCacheKey(book, index));
    }

    function setCachedThumb(book, index, url) {
      const key = getThumbCacheKey(book, index);
      setThumbCacheLimited(key, url);
      // Also save to IndexedDB for persistence
      saveThumbToIDB(key, url);
    }

    // ===== IndexedDB Thumbnail Cache for Persistence =====
    const THUMB_IDB_NAME = 'ThumbCacheDB';
    const THUMB_IDB_STORE = 'thumbnails';
    const THUMB_IDB_VERSION = 1;
    const THUMB_IDB_MAX_SIZE = 50 * 1024 * 1024; // 50MB max total size
    let thumbIDB = null;

    async function openThumbIDB() {
      if (thumbIDB) return thumbIDB;
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(THUMB_IDB_NAME, THUMB_IDB_VERSION);
        req.onerror = () => reject(req.error);
        req.onsuccess = () => {
          thumbIDB = req.result;
          resolve(thumbIDB);
        };
        req.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains(THUMB_IDB_STORE)) {
            const store = db.createObjectStore(THUMB_IDB_STORE, { keyPath: 'key' });
            store.createIndex('timestamp', 'timestamp', { unique: false });
          }
        };
      });
    }

    async function saveThumbToIDB(key, dataUrl) {
      try {
        const db = await openThumbIDB();
        const tx = db.transaction(THUMB_IDB_STORE, 'readwrite');
        const store = tx.objectStore(THUMB_IDB_STORE);
        store.put({ key, dataUrl, timestamp: Date.now(), size: dataUrl.length });
        await new Promise((res, rej) => { tx.oncomplete = res; tx.onerror = rej; });
      } catch (e) {
        console.warn('[ThumbIDB] Save failed:', e);
      }
    }

    async function loadThumbFromIDB(key) {
      try {
        const db = await openThumbIDB();
        const tx = db.transaction(THUMB_IDB_STORE, 'readonly');
        const store = tx.objectStore(THUMB_IDB_STORE);
        const result = await new Promise((res, rej) => {
          const req = store.get(key);
          req.onsuccess = () => res(req.result);
          req.onerror = () => rej(req.error);
        });
        return result?.dataUrl || null;
      } catch (e) {
        console.warn('[ThumbIDB] Load failed:', e);
        return null;
      }
    }

    async function loadBookThumbsFromIDB(book) {
      // Load all cached thumbnails for this book into memory cache
      const bookPrefix = `${book?.id || 'unknown'}-`;
      try {
        const db = await openThumbIDB();
        const tx = db.transaction(THUMB_IDB_STORE, 'readonly');
        const store = tx.objectStore(THUMB_IDB_STORE);
        const loaded = await new Promise((res, rej) => {
          const req = store.getAll();
          req.onsuccess = () => res(req.result);
          req.onerror = () => rej(req.error);
        });
        let count = 0;
        for (const item of loaded) {
          if (item.key.startsWith(bookPrefix) && item.dataUrl) {
            setThumbCacheLimited(item.key, item.dataUrl);
            count++;
          }
        }
        if (count > 0) {
          console.log(`[ThumbIDB] Loaded ${count} cached thumbnails for book`);
        }
        return count;
      } catch (e) {
        console.warn('[ThumbIDB] Book load failed:', e);
        return 0;
      }
    }

    async function cleanupThumbIDB() {
      // Remove old entries if over size limit
      try {
        const db = await openThumbIDB();
        const tx = db.transaction(THUMB_IDB_STORE, 'readonly');
        const store = tx.objectStore(THUMB_IDB_STORE);
        const all = await new Promise((res, rej) => {
          const req = store.getAll();
          req.onsuccess = () => res(req.result);
          req.onerror = () => rej(req.error);
        });

        let totalSize = 0;
        for (const item of all) {
          totalSize += item.size || 0;
        }

        if (totalSize > THUMB_IDB_MAX_SIZE) {
          console.log(`[ThumbIDB] Cleaning up (${Math.round(totalSize / 1024 / 1024)}MB)`);
          // Sort by timestamp and delete oldest
          all.sort((a, b) => a.timestamp - b.timestamp);
          const toDelete = [];
          let sizeToFree = totalSize - (THUMB_IDB_MAX_SIZE * 0.7); // Free to 70%
          for (const item of all) {
            if (sizeToFree <= 0) break;
            toDelete.push(item.key);
            sizeToFree -= item.size || 0;
          }

          if (toDelete.length > 0) {
            const delTx = db.transaction(THUMB_IDB_STORE, 'readwrite');
            const delStore = delTx.objectStore(THUMB_IDB_STORE);
            for (const key of toDelete) {
              delStore.delete(key);
            }
            console.log(`[ThumbIDB] Deleted ${toDelete.length} old entries`);
          }
        }
      } catch (e) {
        console.warn('[ThumbIDB] Cleanup failed:', e);
      }
    }

    // Cleanup on load (don't await to not block)
    setTimeout(() => cleanupThumbIDB(), 5000);

    // ===== Canvas Grid Persistent Cache =====
    // Stores rendered canvas as Blob for instant restore after page reload
    const CANVAS_CACHE_DB_NAME = 'CanvasGridCacheDB';
    const CANVAS_CACHE_STORE = 'canvasCache';
    const CANVAS_CACHE_VERSION = 3;  // Incremented to fix restore scaling issues
    let canvasCacheDB = null;

    async function openCanvasCacheDB() {
      if (canvasCacheDB) return canvasCacheDB;
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(CANVAS_CACHE_DB_NAME, CANVAS_CACHE_VERSION);
        req.onerror = () => reject(req.error);
        req.onsuccess = () => {
          canvasCacheDB = req.result;
          resolve(canvasCacheDB);
        };
        req.onupgradeneeded = (e) => {
          const db = e.target.result;
          if (!db.objectStoreNames.contains(CANVAS_CACHE_STORE)) {
            db.createObjectStore(CANVAS_CACHE_STORE, { keyPath: 'bookId' });
          }
        };
      });
    }

    async function saveCanvasToIDB(bookId, canvas, positions, cssWidth, cssHeight, pageCount) {
      if (!bookId || !canvas) return;
      try {
        const db = await openCanvasCacheDB();
        // Convert canvas to Blob - use JPEG for smaller size (PNG is too large)
        const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.85));
        if (!blob) {
          console.warn('[CanvasCache] Failed to create blob');
          return;
        }

        // Get the dpr used during rendering
        const dpr = canvas._dpr || (window.devicePixelRatio || 1);

        const data = {
          bookId,
          blob,
          positions: JSON.stringify(positions),
          cssWidth,
          cssHeight,
          canvasWidth: canvas.width,
          canvasHeight: canvas.height,
          dpr,  // Save device pixel ratio for correct restoration
          pageCount,
          timestamp: Date.now()
        };

        const tx = db.transaction(CANVAS_CACHE_STORE, 'readwrite');
        const store = tx.objectStore(CANVAS_CACHE_STORE);
        store.put(data);

        // Wait for transaction to complete (not just request success)
        await new Promise((resolve, reject) => {
          tx.oncomplete = resolve;
          tx.onerror = () => reject(tx.error);
          tx.onabort = () => reject(new Error('Transaction aborted'));
        });

        console.log(`[CanvasCache] Saved canvas for ${bookId}, ${(blob.size / 1024).toFixed(1)}KB, dpr=${dpr}`);
      } catch (e) {
        console.warn('[CanvasCache] Save failed:', e);
      }
    }

    async function loadCanvasFromIDB(bookId, currentPageCount) {
      if (!bookId) return null;
      try {
        const db = await openCanvasCacheDB();
        const tx = db.transaction(CANVAS_CACHE_STORE, 'readonly');
        const data = await new Promise((resolve, reject) => {
          const req = tx.objectStore(CANVAS_CACHE_STORE).get(bookId);
          req.onsuccess = () => resolve(req.result);
          req.onerror = () => reject(req.error);
        });

        if (!data) {
          console.log(`[CanvasCache] No cache found for ${bookId}`);
          return null;
        }

        // Check if page count matches (book hasn't changed)
        if (data.pageCount !== currentPageCount) {
          console.log(`[CanvasCache] Page count mismatch (cached: ${data.pageCount}, current: ${currentPageCount}), invalidating`);
          deleteCanvasFromIDB(bookId);
          return null;
        }

        console.log(`[CanvasCache] Loaded canvas for ${bookId}, dpr=${data.dpr || 1}`);
        return {
          blob: data.blob,
          positions: JSON.parse(data.positions),
          cssWidth: data.cssWidth,
          cssHeight: data.cssHeight,
          canvasWidth: data.canvasWidth,
          canvasHeight: data.canvasHeight,
          dpr: data.dpr || 1  // Include dpr for correct restoration
        };
      } catch (e) {
        console.warn('[CanvasCache] Load failed:', e);
        return null;
      }
    }

    async function deleteCanvasFromIDB(bookId) {
      try {
        const db = await openCanvasCacheDB();
        const tx = db.transaction(CANVAS_CACHE_STORE, 'readwrite');
        tx.objectStore(CANVAS_CACHE_STORE).delete(bookId);
      } catch (e) { }
    }

    async function restoreCanvasFromCache(canvas, bookId, pageCount) {
      const cached = await loadCanvasFromIDB(bookId, pageCount);
      if (!cached) return false;

      try {
        // Draw blob to canvas
        const img = new Image();
        const url = URL.createObjectURL(cached.blob);

        await new Promise((resolve, reject) => {
          img.onload = resolve;
          img.onerror = reject;
          img.src = url;
        });

        // Verify the image dimensions match the cached canvas dimensions
        // If they don't match, the cache is corrupted and should be invalidated
        if (img.naturalWidth !== cached.canvasWidth || img.naturalHeight !== cached.canvasHeight) {
          console.warn(`[CanvasCache] Image size mismatch: img ${img.naturalWidth}x${img.naturalHeight} vs cached ${cached.canvasWidth}x${cached.canvasHeight}`);
          URL.revokeObjectURL(url);
          deleteCanvasFromIDB(bookId);
          return false;
        }

        // Set canvas dimensions to match the cached image exactly
        canvas.width = img.naturalWidth;
        canvas.height = img.naturalHeight;
        canvas.style.width = cached.cssWidth + 'px';
        canvas.style.height = cached.cssHeight + 'px';
        canvas.style.margin = '0 auto';

        const ctx = canvas.getContext('2d');
        // Reset any existing transforms
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        // Draw the image at its natural size (no scaling)
        ctx.drawImage(img, 0, 0);
        URL.revokeObjectURL(url);

        // Restore cache properties
        canvas._thumbPositions = cached.positions;
        canvas._thumbBookId = bookId;
        canvas._thumbCSSWidth = cached.cssWidth;
        canvas._thumbCSSHeight = cached.cssHeight;
        canvas._dpr = cached.dpr || 1;

        console.log(`[CanvasCache] Restored canvas from IndexedDB, size=${img.naturalWidth}x${img.naturalHeight}, css=${cached.cssWidth}x${cached.cssHeight}, dpr=${cached.dpr}`);
        return true;
      } catch (e) {
        console.warn('[CanvasCache] Restore failed:', e);
        return false;
      }
    }

    // ===== Immediate Loading Mode =====
    // Canvas mode is now the default for better performance
    const IMMEDIATE_LOAD_KEY = 'thumbGrid_immediateLoad';
    let thumbGridImmediateLoad = true; // Default to Canvas mode
    try {
      const stored = localStorage.getItem(IMMEDIATE_LOAD_KEY);
      // Only override if explicitly set to 'false'
      if (stored === 'false') thumbGridImmediateLoad = false;
    } catch (e) { }

    // ===== Full Book Preload System =====
    const PRELOAD_ALL_KEY = 'viewer_preload_all_pages';
    let preloadAllEnabled = false;
    let preloadAllProgress = { active: false, loaded: 0, total: 0 };


    function loadPreloadAllSetting() {
      try { preloadAllEnabled = localStorage.getItem(PRELOAD_ALL_KEY) === 'true'; } catch (e) { }
    }
    function savePreloadAllSetting(val) {
      preloadAllEnabled = !!val;
      try { localStorage.setItem(PRELOAD_ALL_KEY, val ? 'true' : 'false'); } catch (e) { }
    }
    loadPreloadAllSetting();

    async function preloadAllPages(book, onProgress) {
      if (!book || !Array.isArray(book.pages)) return;
      const total = book.pages.length;
      preloadAllProgress = { active: true, loaded: 0, total };

      // Batch load pages to avoid overwhelming the browser
      const batchSize = 5;
      for (let i = 0; i < total; i += batchSize) {
        const batch = [];
        for (let j = i; j < Math.min(i + batchSize, total); j++) {
          batch.push(
            ensurePageData(book, j)
              .then(url => url ? preloadImage(url) : null)
              .then(() => {
                preloadAllProgress.loaded++;
                if (onProgress) onProgress(preloadAllProgress.loaded, total);
              })
              .catch(() => {
                preloadAllProgress.loaded++;
                if (onProgress) onProgress(preloadAllProgress.loaded, total);
              })
          );
        }
        await Promise.all(batch);
        // Yield to main thread
        await new Promise(r => setTimeout(r, 10));
      }
      preloadAllProgress.active = false;
    }

    // ===== Thumbnail Grid Modal =====
    let thumbGridOverlay = null;
    let thumbGridCurrentBook = null;
    let thumbGridCurrentPage = 0;
    let thumbGridFilter = 'all';
    let thumbGridGoToPage = null; // Callback to jump to page

    // Thumbnail grid zoom state
    let thumbGridZoom = parseInt(localStorage.getItem('thumbGridZoom') || '140', 10);
    let thumbGridQuality = localStorage.getItem('thumbGridQuality') || 'auto';
    let thumbGridPinchStartDistance = 0;
    let thumbGridPinchStartZoom = 140;

    function createThumbGridOverlay() {
      if (thumbGridOverlay) return thumbGridOverlay;

      const overlay = document.createElement('div');
      overlay.className = 'thumb-grid-overlay';
      overlay.id = 'thumbGridOverlay';
      overlay.innerHTML = `
        <div class="thumb-grid-header">
          <h2>📖 全ページ一覧</h2>
          <div class="thumb-grid-toolbar">
            <div class="thumb-grid-filter">
              <select id="thumbGridFilter">
                <option value="all">すべて表示</option>
                <option value="fav">★お気に入りのみ</option>
                <option value="weak">×苦手のみ</option>
                <option value="done">✓完了のみ</option>
                <option value="undone">未完了のみ</option>
                <option value="hasMemo">メモありのみ</option>
              </select>
              <input type="text" id="thumbGridSearch" placeholder="メモ検索..." style="width:120px">
            </div>
            <div class="thumb-grid-zoom-control">
              <span style="font-size:11px;opacity:0.7">小</span>
              <input type="range" id="thumbGridZoomSlider" min="80" max="300" value="${thumbGridZoom}" style="width:100px">
              <span style="font-size:11px;opacity:0.7">大</span>
              <span id="thumbGridZoomVal" style="font-size:11px;min-width:35px">${thumbGridZoom}px</span>
            </div>
            <div class="thumb-grid-quality-control">
              <select id="thumbGridQuality" title="画質設定" style="font-size:11px">
                <option value="auto" ${thumbGridQuality === 'auto' ? 'selected' : ''}>自動</option>
                <option value="high" ${thumbGridQuality === 'high' ? 'selected' : ''}>高画質</option>
                <option value="medium" ${thumbGridQuality === 'medium' ? 'selected' : ''}>中画質</option>
                <option value="low" ${thumbGridQuality === 'low' ? 'selected' : ''}>軽量</option>
              </select>
            </div>
            <label style="display:flex;align-items:center;gap:4px;font-size:11px;cursor:pointer" title="スクロールが遅い場合はオンにしてください。全サムネイルをCanvasに描画します。">
              <input type="checkbox" id="thumbGridImmediateCheck" ${thumbGridImmediateLoad ? 'checked' : ''} />
              Canvas描画
            </label>
            <button class="btn small" id="thumbGridPreloadBtn">全ページ先読み</button>
            <button class="btn small" id="thumbGridGenBtn" title="サムネイルを事前生成して次回から高速表示">サムネ生成</button>
            <button class="thumb-grid-close" id="thumbGridClose">×</button>
          </div>
        </div>
        <div class="thumb-grid-body">
          <!-- Canvas loading progress (non-blocking, in header style) -->
          <div id="thumbGridCanvasLoadBar" style="display:none;position:absolute;top:0;left:0;right:0;height:4px;background:rgba(255,255,255,0.1);z-index:15;">
            <div id="thumbGridCanvasLoadProgress" style="width:0%;height:100%;background:linear-gradient(90deg,#4ade80,#22d3ee);transition:width 0.1s;"></div>
          </div>
          <div id="thumbGridCanvasLoadInfo" style="display:none;position:absolute;top:8px;right:16px;background:rgba(0,0,0,0.7);color:#fff;padding:4px 12px;border-radius:12px;font-size:12px;z-index:15;">
            <span id="thumbGridCanvasLoadCount">0/0</span>
            <button id="thumbGridLoadingCancel" style="margin-left:8px;padding:2px 8px;background:#ef4444;color:#fff;border:none;border-radius:4px;cursor:pointer;font-size:11px;">中止</button>
          </div>
          <div class="thumb-grid-container" id="thumbGridContainer" style="--thumb-size:${thumbGridZoom}px"></div>
          <!-- Canvas mode: single canvas for all thumbnails -->
          <canvas id="thumbGridCanvas" style="display:none;cursor:pointer;" width="800" height="600"></canvas>
        </div>
        <div class="thumb-grid-footer" style="padding:4px 8px;">
          <div class="thumb-grid-preload-bar" id="thumbGridPreloadBar" style="display:none">
            <div class="bar" id="thumbGridPreloadProgress" style="width:0%"></div>
          </div>
        </div>
      `;

      document.body.appendChild(overlay);
      thumbGridOverlay = overlay;

      // Zoom slider handler
      const zoomSlider = document.getElementById('thumbGridZoomSlider');
      const zoomVal = document.getElementById('thumbGridZoomVal');
      const container = document.getElementById('thumbGridContainer');

      const applyZoom = (val) => {
        thumbGridZoom = Math.max(80, Math.min(300, val));
        if (container) container.style.setProperty('--thumb-size', thumbGridZoom + 'px');
        if (zoomSlider) zoomSlider.value = thumbGridZoom;
        if (zoomVal) zoomVal.textContent = thumbGridZoom + 'px';
        localStorage.setItem('thumbGridZoom', String(thumbGridZoom));
      };

      if (zoomSlider) {
        zoomSlider.oninput = () => {
          applyZoom(parseInt(zoomSlider.value, 10));
          // In Canvas mode, need to re-render with new size
          if (thumbGridImmediateLoad) {
            // Cancel any ongoing loading
            if (canvasLoadAbort) {
              canvasLoadAbort.abort();
              canvasLoadAbort = null;
            }
            // Invalidate canvas cache so it will re-render
            const canvas = document.getElementById('thumbGridCanvas');
            if (canvas) {
              canvas._thumbBook = null;
              canvas._thumbPositions = null;
              canvas.onclick = null;
            }
            // Debounce to avoid too many re-renders
            clearTimeout(zoomSlider._canvasDebounce);
            zoomSlider._canvasDebounce = setTimeout(() => {
              // Ensure we're still in canvas mode
              thumbGridImmediateLoad = true;
              const checkEl = document.getElementById('thumbGridImmediateCheck');
              if (checkEl) checkEl.checked = true;
              renderThumbGrid();
            }, 300);
          }
        };
      }

      // Quality setting handler
      const qualitySelect = document.getElementById('thumbGridQuality');
      if (qualitySelect) {
        qualitySelect.onchange = () => {
          thumbGridQuality = qualitySelect.value;
          localStorage.setItem('thumbGridQuality', thumbGridQuality);
          renderThumbGrid();
        };
      }

      // Ctrl + wheel zoom (PC)
      const body = overlay.querySelector('.thumb-grid-body');
      let wheelDebounce = null;
      body?.addEventListener('wheel', (e) => {
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          const delta = e.deltaY > 0 ? -15 : 15;
          applyZoom(thumbGridZoom + delta);
          // In Canvas mode, re-render after wheel stops
          if (thumbGridImmediateLoad) {
            clearTimeout(wheelDebounce);
            wheelDebounce = setTimeout(() => renderThumbGrid(), 300);
          }
        }
      }, { passive: false });

      // Pinch zoom disabled - use browser zoom instead
      // Users can now use browser's native pinch-to-zoom
      /* 
      let pinchActive = false;
      let pinchDebounce = null;
      body?.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
          pinchActive = true;
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          thumbGridPinchStartDistance = Math.sqrt(dx * dx + dy * dy);
          thumbGridPinchStartZoom = thumbGridZoom;
          e.preventDefault();
        }
      }, { passive: false });

      body?.addEventListener('touchmove', (e) => {
        if (pinchActive && e.touches.length === 2) {
          const dx = e.touches[0].clientX - e.touches[1].clientX;
          const dy = e.touches[0].clientY - e.touches[1].clientY;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const scale = dist / thumbGridPinchStartDistance;
          applyZoom(Math.round(thumbGridPinchStartZoom * scale));
          e.preventDefault();
        }
      }, { passive: false });

      body?.addEventListener('touchend', () => {
        if (pinchActive) {
          pinchActive = false;
          if (thumbGridImmediateLoad) {
            clearTimeout(pinchDebounce);
            pinchDebounce = setTimeout(() => renderThumbGrid(), 200);
          }
        }
      });
      */

      // Event handlers
      document.getElementById('thumbGridClose').onclick = closeThumbGrid;
      overlay.onclick = (e) => { if (e.target === overlay) closeThumbGrid(); };
      document.getElementById('thumbGridFilter').onchange = (e) => {
        const newFilter = e.target.value;
        const oldFilter = thumbGridFilter;
        thumbGridFilter = newFilter;

        const canvas = document.getElementById('thumbGridCanvas');
        const container = document.getElementById('thumbGridContainer');
        const book = thumbGridCurrentBook;

        // If switching back to 'all' and we have valid canvas cache, just update borders
        const bookId = book?.id || book?.title || '';
        const cachedBookId = canvas?._thumbBookId || '';
        if (newFilter === 'all' && thumbGridImmediateLoad &&
          canvas && cachedBookId === bookId && bookId !== '' && canvas._thumbPositions?.length > 0) {
          // Show canvas, hide container
          if (container) container.style.display = 'none';
          // Restore CSS size
          if (canvas._thumbCSSWidth && canvas._thumbCSSHeight) {
            canvas.style.width = canvas._thumbCSSWidth + 'px';
            canvas.style.height = canvas._thumbCSSHeight + 'px';
            canvas.style.margin = '0 auto';
          }
          canvas.style.display = 'block';
          canvas._thumbBook = book; // Update reference
          // Just redraw borders (instant)
          redrawCanvasStatusBorders(book, canvas);
          return;
        }

        // Otherwise need to re-filter/re-render
        renderThumbGrid();
      };
      document.getElementById('thumbGridSearch').oninput = () => renderThumbGrid();
      const immediateCheck = document.getElementById('thumbGridImmediateCheck');
      if (immediateCheck) {
        immediateCheck.onchange = () => {
          thumbGridImmediateLoad = immediateCheck.checked;
          try { localStorage.setItem(IMMEDIATE_LOAD_KEY, thumbGridImmediateLoad ? 'true' : 'false'); } catch (e) { }

          const container = document.getElementById('thumbGridContainer');
          const canvas = document.getElementById('thumbGridCanvas');
          const book = thumbGridCurrentBook;

          if (thumbGridImmediateLoad) {
            // Switching TO Canvas mode
            const bookId = book?.id || book?.title || '';
            const cachedBookId = canvas?._thumbBookId || '';
            const canvasHasData = canvas && cachedBookId === bookId && bookId !== '' && canvas._thumbPositions?.length > 0;
            // Only use cache if filter is 'all' (canvas was rendered with all pages)
            if (canvasHasData && thumbGridFilter === 'all') {
              // Reuse cached canvas - just redraw borders
              if (container) container.style.display = 'none';
              // Restore CSS size
              if (canvas._thumbCSSWidth && canvas._thumbCSSHeight) {
                canvas.style.width = canvas._thumbCSSWidth + 'px';
                canvas.style.height = canvas._thumbCSSHeight + 'px';
                canvas.style.margin = '0 auto';
              }
              if (canvas) canvas.style.display = 'block';
              canvas._thumbBook = book; // Update reference
              redrawCanvasStatusBorders(book, canvas);
              return; // Skip re-render
            }
            // No cache - clear old canvas data and render fresh
            if (canvas) {
              canvas._thumbBook = null;
              canvas._thumbBookId = null;
              canvas._thumbPositions = null;
            }
          } else {
            // Switching TO DOM mode - clear container first
            if (container) container.innerHTML = '';
            if (canvas) canvas.style.display = 'none';
          }

          // Always render when switching modes (unless cached canvas was reused)
          renderThumbGrid();
        };
      }
      document.getElementById('thumbGridPreloadBtn').onclick = startGridPreload;

      // Thumbnail generation button handler
      document.getElementById('thumbGridGenBtn').onclick = async () => {
        const book = thumbGridCurrentBook;
        if (!book || !book.pages) {
          showToast('本が選択されていません', 'error');
          return;
        }

        const btn = document.getElementById('thumbGridGenBtn');
        const originalText = btn.textContent;
        btn.disabled = true;
        btn.textContent = '生成中...';

        try {
          const pages = book.pages;
          let generated = 0;

          for (let i = 0; i < pages.length; i++) {
            btn.textContent = `${i + 1}/${pages.length}`;

            // Check if already exists
            const thumbKey = `${book.id}-${i}`;
            const existing = await loadThumbFromIDB(thumbKey);
            if (existing) {
              generated++;
              continue;
            }

            // Get source image
            const sourceUrl = await ensurePageData(book, i);
            if (!sourceUrl) continue;

            // Generate thumbnail
            try {
              const thumbDataUrl = await generateThumbnail(sourceUrl);
              await saveThumbToIDB(thumbKey, thumbDataUrl);
              generated++;
            } catch (e) {
              console.warn(`[ThumbGen] Failed page ${i}:`, e);
            }

            // Yield
            if ((i + 1) % 5 === 0) {
              await new Promise(r => setTimeout(r, 10));
            }
          }

          showToast(`サムネイル生成完了: ${generated}/${pages.length}`, 'ok');
        } catch (e) {
          console.error('[ThumbGen] Error:', e);
          showToast('サムネイル生成に失敗: ' + e.message, 'error');
        } finally {
          btn.disabled = false;
          btn.textContent = originalText;
        }
      };

      // Keyboard handler
      const keyHandler = (e) => {
        if (!overlay.classList.contains('open')) return;
        if (e.key === 'Escape') { closeThumbGrid(); e.preventDefault(); }
      };
      document.addEventListener('keydown', keyHandler);

      return overlay;
    }

    function openThumbGrid(book, currentPage, goToPageFn) {
      thumbGridCurrentBook = book;
      thumbGridCurrentPage = currentPage;
      thumbGridGoToPage = goToPageFn;
      thumbGridFilter = 'all';

      // Preload cached thumbnails from IndexedDB (non-blocking)
      loadBookThumbsFromIDB(book).catch(() => { });

      const overlay = createThumbGridOverlay();
      const filterEl = document.getElementById('thumbGridFilter');
      const searchEl = document.getElementById('thumbGridSearch');
      const container = document.getElementById('thumbGridContainer');
      const canvas = document.getElementById('thumbGridCanvas');

      if (filterEl) filterEl.value = 'all';
      if (searchEl) searchEl.value = '';

      // Check if we have valid canvas cache for this book (use ID, not reference)
      const bookId = book?.id || book?.title || '';
      const cachedBookId = canvas?._thumbBookId || '';
      const pageCount = book?.pages?.length || 0;
      const canvasHasValidCache = thumbGridImmediateLoad && canvas &&
        cachedBookId === bookId && bookId !== '' && canvas._thumbPositions?.length > 0;

      console.log('[ThumbGrid] Opening grid:', {
        bookId,
        cachedBookId,
        pageCount,
        thumbGridImmediateLoad,
        hasCanvas: !!canvas,
        hasPositions: canvas?._thumbPositions?.length || 0,
        canvasHasValidCache
      });

      if (canvasHasValidCache) {
        // Use cached canvas - just redraw status borders (instant!)
        if (container) container.style.display = 'none';

        // Restore cached CSS size (important - prevents size mismatch)
        if (canvas._thumbCSSWidth && canvas._thumbCSSHeight) {
          canvas.style.width = canvas._thumbCSSWidth + 'px';
          canvas.style.height = canvas._thumbCSSHeight + 'px';
          canvas.style.margin = '0 auto';
        }
        canvas.style.display = 'block';
        overlay.classList.add('open');

        // Update book reference for status lookups
        canvas._thumbBook = book;

        // Redraw only status borders with current state
        redrawCanvasStatusBorders(book, canvas);

        // Scroll to current page
        const canvasBody = container?.closest('.thumb-grid-body');
        if (canvasBody && thumbGridCurrentPage !== null && thumbGridCurrentPage >= 0) {
          setTimeout(() => {
            const currentPos = canvas._thumbPositions.find(p => p.index === thumbGridCurrentPage);
            if (currentPos) {
              const scrollY = Math.max(0, currentPos.y - (canvasBody.clientHeight / 2) + (currentPos.h / 2));
              canvasBody.scrollTop = scrollY;
            }
          }, 50);
        }
      } else if (thumbGridImmediateLoad && bookId) {
        // Try to restore from IndexedDB (after page reload)
        if (container) container.style.display = 'none';
        if (canvas) canvas.style.display = 'none';
        overlay.classList.add('open');

        // Show loading state
        const progressInfo = document.getElementById('thumbGridProgress');
        if (progressInfo) {
          progressInfo.textContent = 'キャッシュを確認中...';
          progressInfo.style.display = 'block';
        }

        restoreCanvasFromCache(canvas, bookId, pageCount).then(restored => {
          if (restored && canvas) {
            // Successfully restored from IndexedDB
            canvas._thumbBook = book;
            canvas.style.display = 'block';

            // Setup click handler
            canvas.onclick = (e) => {
              const rect = canvas.getBoundingClientRect();
              const clickX = e.clientX - rect.left;
              const clickY = e.clientY - rect.top;
              for (const pos of canvas._thumbPositions) {
                if (clickX >= pos.x && clickX < pos.x + pos.w &&
                  clickY >= pos.y && clickY < pos.y + pos.h) {
                  if (thumbGridGoToPage) {
                    thumbGridGoToPage(pos.index);
                    closeThumbGrid();
                  }
                  break;
                }
              }
            };

            // Redraw status borders
            redrawCanvasStatusBorders(book, canvas);

            // Scroll to current page
            const canvasBody = container?.closest('.thumb-grid-body');
            if (canvasBody && thumbGridCurrentPage !== null && thumbGridCurrentPage >= 0) {
              setTimeout(() => {
                const currentPos = canvas._thumbPositions.find(p => p.index === thumbGridCurrentPage);
                if (currentPos) {
                  const scrollY = Math.max(0, currentPos.y - (canvasBody.clientHeight / 2) + (currentPos.h / 2));
                  canvasBody.scrollTop = scrollY;
                }
              }, 50);
            }

            if (progressInfo) progressInfo.style.display = 'none';
            console.log('[ThumbGrid] Restored from IndexedDB cache');
          } else {
            // No IndexedDB cache - render fresh
            if (container) container.style.display = '';
            if (progressInfo) progressInfo.style.display = 'none';
            renderThumbGrid();
          }
        }).catch(() => {
          // Error restoring - render fresh
          if (container) container.style.display = '';
          if (progressInfo) progressInfo.style.display = 'none';
          renderThumbGrid();
        });
      } else {
        // No valid cache - need full render
        if (canvas && cachedBookId !== bookId) {
          canvas._thumbBook = null;
          canvas._thumbBookId = null;
          canvas._thumbPositions = null;
          canvas.onclick = null;
        }
        if (container) container.style.display = '';
        if (canvas) canvas.style.display = 'none';
        overlay.classList.add('open');
        renderThumbGrid();
      }
    }

    function closeThumbGrid() {
      if (thumbGridOverlay) {
        thumbGridOverlay.classList.remove('open');

        // Hide canvas but preserve data for Canvas mode
        const container = document.getElementById('thumbGridContainer');
        const canvas = document.getElementById('thumbGridCanvas');
        if (container) container.style.display = 'none';
        if (canvas) canvas.style.display = 'none';
        // Note: Don't clear canvas._thumbPositions or canvas.onclick to preserve for reopen
      }
      if (canvasLoadAbort) {
        canvasLoadAbort.abort();
        canvasLoadAbort = null;
      }
      if (thumbGridCurrentBook && Number.isFinite(thumbGridCurrentPage)) {
        try { trimPageCache(thumbGridCurrentBook, thumbGridCurrentPage, 8); } catch (_) { }
      }
      thumbGridCurrentBook = null;
      thumbGridGoToPage = null;
    }

    async function renderThumbGrid() {
      const container = document.getElementById('thumbGridContainer');
      const canvas = document.getElementById('thumbGridCanvas');

      if (!container || !thumbGridCurrentBook) return;

      const book = thumbGridCurrentBook;
      const pages = book.pages || [];
      const searchEl = document.getElementById('thumbGridSearch');
      const searchTerm = (searchEl?.value || '').toLowerCase().trim();

      // Always start with container visible for DOM mode
      // Canvas mode will hide it after loadAllThumbnailsImmediate starts
      container.style.display = '';
      if (canvas) canvas.style.display = 'none';

      container.innerHTML = '';
      let count = 0;

      const frag = document.createDocumentFragment();

      // Determine thumbnail quality
      const qualityFactor = {
        'high': 1.0,
        'medium': 0.6,
        'low': 0.3,
        'auto': thumbGridZoom < 120 ? 0.4 : (thumbGridZoom < 180 ? 0.7 : 1.0)
      }[thumbGridQuality] || 0.7;

      // Track items for immediate loading
      const itemsToLoad = [];

      // Intersection observer for lazy loading (only used if not immediate mode)
      let observer = null;
      if (!thumbGridImmediateLoad) {
        observer = new IntersectionObserver((entries, obs) => {
          entries.forEach(ent => {
            if (ent.isIntersecting) {
              const img = ent.target;
              const idx = parseInt(img.dataset.pageIndex, 10);
              if (!isNaN(idx)) {
                loadThumbnailWithCache(book, idx, img, qualityFactor);
              }
              obs.unobserve(img);
            }
          });
        }, { rootMargin: '800px 0px', threshold: 0 }); // Increased from 200px to 800px for better preloading
      }

      for (let i = 0; i < pages.length; i++) {
        const p = pages[i];
        const state = p.state || {};
        const memo = p.memo || '';

        // Apply filters
        if (thumbGridFilter === 'fav' && !state.fav) continue;
        if (thumbGridFilter === 'weak' && !state.weak) continue;
        if (thumbGridFilter === 'done' && !state.done) continue;
        if (thumbGridFilter === 'undone' && state.done) continue;
        if (thumbGridFilter === 'hasMemo' && !memo) continue;
        if (searchTerm && !memo.toLowerCase().includes(searchTerm)) continue;

        count++;

        const item = document.createElement('div');
        item.className = 'thumb-grid-item';
        if (i === thumbGridCurrentPage) item.classList.add('current');
        if (state.fav) item.classList.add('fav');
        if (state.weak) item.classList.add('weak');
        if (state.done) item.classList.add('done');

        const pageNum = (book.firstPageNumber || 1) + i;

        // Create thumbnail
        const img = document.createElement('img');
        img.alt = `ページ ${pageNum}`;
        img.dataset.pageIndex = i;

        // Check cache first
        const cachedUrl = getCachedThumb(book, i);
        if (cachedUrl) {
          img.src = cachedUrl;
        }

        if (thumbGridImmediateLoad) {
          // Canvas mode: ALL pages must be added to itemsToLoad for drawing
          // Even cached pages need to be drawn on canvas
          itemsToLoad.push({ img, index: i, cachedUrl: cachedUrl || null });
        } else if (!cachedUrl) {
          // DOM mode without cache: Use intersection observer for lazy loading
          observer.observe(img);
        }

        // Badge
        const badge = document.createElement('div');
        badge.className = 'thumb-grid-badge';

        const pageLabel = document.createElement('span');
        pageLabel.className = 'thumb-grid-page';
        pageLabel.textContent = `P.${pageNum}`;

        const statusArea = document.createElement('div');
        statusArea.className = 'thumb-grid-status';
        if (state.fav) { const s = document.createElement('span'); s.textContent = '★'; statusArea.appendChild(s); }
        if (state.weak) { const s = document.createElement('span'); s.textContent = '×'; statusArea.appendChild(s); }
        if (state.done) { const s = document.createElement('span'); s.textContent = '✓'; statusArea.appendChild(s); }
        if (memo) { const s = document.createElement('span'); s.textContent = '📝'; statusArea.appendChild(s); }

        badge.appendChild(pageLabel);
        badge.appendChild(statusArea);

        item.appendChild(img);
        item.appendChild(badge);

        // Click to jump
        item.onclick = () => {
          if (thumbGridGoToPage) {
            thumbGridGoToPage(i);
            closeThumbGrid();
          }
        };

        frag.appendChild(item);
      }

      container.appendChild(frag);

      // Immediate loading mode: load all images in batches
      if (thumbGridImmediateLoad && itemsToLoad.length > 0) {
        loadAllThumbnailsImmediate(book, itemsToLoad, qualityFactor);
      }

      // Canvas mode: Always scroll to current page after grid is rendered
      // This ensures scrolling works on every open, not just the first time
      if (thumbGridImmediateLoad) {
        const canvasBody = container?.closest('.thumb-grid-body');
        const canvasEl = document.getElementById('thumbGridCanvas');
        if (canvasBody && canvasEl && thumbGridCurrentPage !== null && thumbGridCurrentPage >= 0) {
          // Wait for canvas layout, then scroll
          setTimeout(() => {
            // Calculate scroll position based on grid layout
            const thumbSize = thumbGridZoom || 140;
            const gap = 16;
            const containerWidth = Math.max(200, canvasBody.clientWidth - 40);
            const cols = Math.max(1, Math.floor((containerWidth + gap) / (thumbSize + gap)));
            const cellHeight = Math.round(thumbSize * 1.33);

            // Find index of current page in visible items
            let currentIdx = -1;
            for (let i = 0; i < pages.length; i++) {
              const state = pages[i].state || {};
              const filter = thumbGridFilter;
              const search = thumbGridSearchQuery;
              let visible = filter === 'all' ||
                (filter === 'fav' && state.fav) ||
                (filter === 'weak' && state.weak) ||
                (filter === 'done' && state.done);
              if (search) {
                const pageNum = (book.firstPageNumber || 1) + i;
                visible = visible && String(pageNum).includes(search);
              }
              if (visible) {
                if (i === thumbGridCurrentPage) {
                  currentIdx++;
                  break;
                }
                currentIdx++;
              }
            }

            if (currentIdx >= 0) {
              const row = Math.floor(currentIdx / cols);
              const estimatedY = row * (cellHeight + gap);
              const scrollY = Math.max(0, estimatedY - (canvasBody.clientHeight / 2) + (cellHeight / 2));
              console.log('[Canvas] renderThumbGrid scroll - page:', thumbGridCurrentPage, 'idx:', currentIdx, 'scrollY:', scrollY);
              canvasBody.scrollTop = scrollY;
            }
          }, 200);
        }
      }
    }

    // Helper function to get schedule status for a page in canvas mode
    // Returns: { isScheduled, isDone, isPaused, isScheduleCurrent }
    function getPageScheduleStatus(book, pageIndex) {
      const result = { isScheduled: false, isDone: false, isPaused: false, isScheduleCurrent: false };
      if (!book) return result;

      // Get page number (accounting for firstPageNumber)
      const pageNum = (book.firstPageNumber || 1) + pageIndex;

      // Try to find the matching ToDo for this book
      try {
        const todos = typeof todoList === 'function' ? todoList() : [];
        const bookId = book.id || book.title;

        for (const todo of todos) {
          // Match by bookId or bookTitle
          if (todo.bookId === bookId || todo.bookTitle === book.title) {
            // Check if page is done
            if (Array.isArray(todo.completedPages) && todo.completedPages.includes(pageNum)) {
              result.isDone = true;
            }
          }
        }

        // Check NLStore for scheduled pages
        if (typeof NLStore !== 'undefined' && Array.isArray(NLStore.events)) {
          for (const ev of NLStore.events) {
            if (ev && ev.pageNumber === pageNum &&
              (ev.bookId === bookId || ev.bookTitle === book.title)) {
              result.isScheduled = true;
              break;
            }
          }
        }

        // Check paused list
        if (typeof loadPausedList === 'function') {
          const paused = loadPausedList();
          for (const ent of paused) {
            for (const ev of (ent.events || [])) {
              if (ev && ev.pageNumber === pageNum &&
                (ev.bookId === bookId || ev.bookTitle === book.title)) {
                result.isPaused = true;
                break;
              }
            }
            if (result.isPaused) break;
          }
        }

        // Check if this is the current schedule page (StudyMgr)
        if (typeof StudyMgr !== 'undefined' && StudyMgr.active) {
          const ctx = StudyMgr.currentAndNext(Date.now());
          if (ctx && ctx.curIdx >= 0 && ctx.events[ctx.curIdx]) {
            const curEv = ctx.events[ctx.curIdx];
            if (curEv.pageNumber === pageNum &&
              (curEv.bookId === bookId || curEv.bookTitle === book.title)) {
              result.isScheduleCurrent = true;
            }
          }
        }
      } catch (e) {
        console.warn('[getPageScheduleStatus] Error:', e);
      }

      return result;
    }

    function createTaskChip(task, dateStr, variant = 'month') {
      const chip = document.createElement('div');
      chip.className = variant === 'month' ? 'sc-task-chip' : 'sc-h-task';
      chip.classList.add(task.type || 'other');
      chip.dataset.todoId = task.todoId || '';
      chip.dataset.date = dateStr || '';
      chip.dataset.pages = Array.isArray(task.pages) ? task.pages.join(',') : '';
      const title = document.createElement('span');
      title.className = 'sc-chip-title';
      title.textContent = task.todo.title || 'タスク';

      const metaParts = [];
      if (task.pages?.length) metaParts.push(`${task.pages.length}P`);
      if (task.duration) metaParts.push(`${task.duration}分`);
      const meta = document.createElement('span');
      meta.className = 'sc-chip-meta';
      meta.textContent = metaParts.join(' / ') || (task.type === 'due' ? '期限' : '');

      const tag = document.createElement('span');
      tag.className = 'sc-chip-tag';
      tag.textContent = task.type === 'scheduled' ? '配分' : task.type === 'due' ? '期限' : task.type === 'break' ? '休憩' : '予定';

      chip.appendChild(tag);
      chip.appendChild(title);
      if (meta.textContent) chip.appendChild(meta);

      const isDraggable = (task.type === 'scheduled' || task.type === 'due') && task.todoId && dateStr;
      if (isDraggable) {
        chip.draggable = true;
        chip.dataset.todoId = task.todoId;
        chip.dataset.date = dateStr;
        chip.addEventListener('dragstart', (e) => {
          e.dataTransfer.effectAllowed = 'move';
          if (task.type === 'due') {
            e.dataTransfer.setData('text/plain', JSON.stringify({ type: 'due', todoId: task.todoId, fromDate: dateStr }));
          } else {
            e.dataTransfer.setData('text/plain', JSON.stringify({ todoId: task.todoId, fromDate: dateStr, pages: task.pages || [] }));
          }
        });

        if (task.type === 'scheduled') {
          const close = document.createElement('button');
          close.className = 'sc-chip-delete';
          close.type = 'button';
          close.textContent = '×';
          close.title = '削除';
          close.onclick = (ev) => { ev.stopPropagation(); removeTaskFromDate(task.todoId, dateStr); };
          chip.appendChild(close);
        }
      }

      const openInfo = (ev) => {
        if (task.type === 'scheduled') {
          const pages = Array.isArray(task.pages) ? task.pages : [];
          const fn = (typeof showChipInfo === 'function') ? showChipInfo : (typeof window.__scShowChipInfo === 'function' ? window.__scShowChipInfo : null);
          if (fn) fn(ev, { todoId: task.todoId, date: dateStr, pages, todo: task.todo });
        }
      };
      tag.addEventListener('click', openInfo);
      chip.addEventListener('contextmenu', (ev) => { ev.preventDefault(); openInfo(ev); });
      chip.addEventListener('click', (ev) => { if (ev.button === 0) openInfo(ev); });

      return chip;
    }

    // CANVAS MODE: Draw all thumbnails onto a single canvas
    // Global abort controller for cancelling canvas loading
    let canvasLoadAbort = null;

    async function loadAllThumbnailsImmediate(book, items, qualityFactor) {
      // Non-blocking progress elements
      const progressBar = document.getElementById('thumbGridCanvasLoadBar');
      const progressFill = document.getElementById('thumbGridCanvasLoadProgress');
      const progressInfo = document.getElementById('thumbGridCanvasLoadInfo');
      const progressCount = document.getElementById('thumbGridCanvasLoadCount');
      const cancelBtn = document.getElementById('thumbGridLoadingCancel');
      const container = document.getElementById('thumbGridContainer');
      const canvas = document.getElementById('thumbGridCanvas');
      const body = container?.closest('.thumb-grid-body');

      if (!canvas || !body) {
        console.warn('[Canvas Mode] Canvas or body not found');
        return;
      }

      // Setup abort controller for cancellation
      if (canvasLoadAbort) canvasLoadAbort.abort();
      canvasLoadAbort = new AbortController();
      const signal = canvasLoadAbort.signal;

      // Cancel button handler - switch to DOM mode
      const cancelLoading = () => {
        canvasLoadAbort?.abort();
        // Hide progress UI
        if (progressBar) progressBar.style.display = 'none';
        if (progressInfo) progressInfo.style.display = 'none';
        // Switch to DOM mode
        thumbGridImmediateLoad = false;
        const checkEl = document.getElementById('thumbGridImmediateCheck');
        if (checkEl) checkEl.checked = false;
        try { localStorage.setItem(IMMEDIATE_LOAD_KEY, 'false'); } catch (e) { }
        // Show container, hide canvas
        if (canvas) canvas.style.display = 'none';
        if (container) container.style.display = '';
        // Re-render in DOM mode
        renderThumbGrid();
      };

      if (cancelBtn) {
        cancelBtn.onclick = cancelLoading;
      }

      // Show non-blocking progress UI
      if (progressBar) progressBar.style.display = 'block';
      if (progressInfo) progressInfo.style.display = 'block';

      // Hide DOM container, show canvas
      if (container) container.style.display = 'none';
      canvas.style.display = 'block';

      // Wait for layout to stabilize before calculating dimensions
      await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));

      // Grid layout settings
      const thumbSize = thumbGridZoom || 140;
      const gap = 16;
      const containerWidth = Math.max(200, body.clientWidth - 40); // padding, min 200px
      const cols = Math.max(1, Math.floor((containerWidth + gap) / (thumbSize + gap)));
      const rows = Math.ceil(items.length / cols);
      const cellWidth = thumbSize;
      const cellHeight = Math.round(thumbSize * 1.33); // 3:4 aspect

      // HiDPI/Retina support: use device pixel ratio for sharper rendering
      const dpr = window.devicePixelRatio || 1;

      // Set canvas size (CSS size = logical, canvas size = physical)
      const canvasWidth = cols * cellWidth + (cols - 1) * gap;
      const canvasHeight = rows * cellHeight + (rows - 1) * gap;
      canvas.width = canvasWidth * dpr;
      canvas.height = canvasHeight * dpr;
      canvas.style.width = canvasWidth + 'px';
      canvas.style.height = canvasHeight + 'px';
      canvas.style.margin = '0 auto';
      canvas.style.display = 'block';
      // Store CSS size for cache reuse
      canvas._thumbCSSWidth = canvasWidth;
      canvas._thumbCSSHeight = canvasHeight;

      // Calculate and set initial scroll position to current page BEFORE rendering
      // This way users see their current page area immediately
      // Use setTimeout to ensure canvas layout is fully applied
      const scrollToCurrentPage = () => {
        if (thumbGridCurrentPage !== null && thumbGridCurrentPage >= 0) {
          // Find the index of current page in filtered items
          let currentItemIdx = items.findIndex(item => item.index === thumbGridCurrentPage);
          console.log('[Canvas] Scrolling to page', thumbGridCurrentPage, 'itemIdx:', currentItemIdx, 'cols:', cols);
          if (currentItemIdx >= 0) {
            const currentRow = Math.floor(currentItemIdx / cols);
            const estimatedY = currentRow * (cellHeight + gap);
            // Scroll to center the current page in view
            const scrollY = Math.max(0, estimatedY - (body.clientHeight / 2) + (cellHeight / 2));
            console.log('[Canvas] Scroll Y:', scrollY, 'row:', currentRow, 'body height:', body.clientHeight);
            body.scrollTop = scrollY;
          }
        }
      };
      // Execute scroll after a short delay to ensure layout is ready
      setTimeout(scrollToCurrentPage, 150);

      const ctx = canvas.getContext('2d');
      // Scale context for HiDPI
      ctx.scale(dpr, dpr);
      ctx.fillStyle = '#1a1a2e';
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);

      // Store dpr for click handling
      canvas._dpr = dpr;

      const total = items.length;
      let loaded = 0;

      const updateProgress = () => {
        const pct = Math.round((loaded / total) * 100);
        if (progressCount) progressCount.textContent = `${loaded}/${total}`;
        if (progressFill) progressFill.style.width = `${pct}%`;
      };
      updateProgress();

      // Store positions for click detection
      const positions = [];

      // Load and draw images in batches
      const batchSize = 20;
      for (let i = 0; i < items.length; i += batchSize) {
        // Check if cancelled
        if (signal.aborted) {
          console.log('[Canvas] Loading cancelled');
          return;
        }

        const batch = items.slice(i, Math.min(i + batchSize, items.length));

        await Promise.all(batch.map(async (item, batchIdx) => {
          if (signal.aborted) return;

          const itemIdx = i + batchIdx;
          const row = Math.floor(itemIdx / cols);
          const col = itemIdx % cols;
          const x = col * (cellWidth + gap);
          const y = row * (cellHeight + gap);

          // Store position for click detection
          positions[itemIdx] = { x, y, w: cellWidth, h: cellHeight, index: item.index };

          try {
            // Fast path: Try pre-generated thumbnail first (no rendering needed)
            let url = await getPreGeneratedThumb(book?.id, item.index);

            // Fallback: use memory cache or load from source
            if (!url) {
              url = item.cachedUrl || getCachedThumb(book, item.index);
            }
            if (!url) {
              // Load from source and generate thumbnail on-the-fly (slow path)
              const sourceUrl = await ensurePageData(book, item.index);
              if (sourceUrl) {
                // Generate thumbnail for future use
                try {
                  url = await generateThumbnail(sourceUrl);
                  await saveThumbToIDB(`${book?.id}-${item.index}`, url);
                } catch (e) {
                  url = sourceUrl; // Use full image as fallback
                }
                if (url) setCachedThumb(book, item.index, url);
              }
            }

            if (url && !signal.aborted) {
              // Create image and draw to canvas
              const img = new Image();
              await new Promise((resolve) => {
                img.onload = () => {
                  if (signal.aborted) { resolve(); return; }

                  // Draw with contain fit (no cropping, image fully visible)
                  const imgRatio = img.width / img.height;
                  const cellRatio = cellWidth / cellHeight;
                  let dx = x, dy = y, dw = cellWidth, dh = cellHeight;

                  // Contain mode: fit entire image within cell, add padding if needed
                  if (imgRatio > cellRatio) {
                    // Image is wider - fit to width, center vertically
                    dh = cellWidth / imgRatio;
                    dy = y + (cellHeight - dh) / 2;
                  } else {
                    // Image is taller - fit to height, center horizontally  
                    dw = cellHeight * imgRatio;
                    dx = x + (cellWidth - dw) / 2;
                  }

                  // Background (fill entire cell)
                  ctx.fillStyle = 'rgba(30, 30, 46, 1)';
                  ctx.fillRect(x, y, cellWidth, cellHeight);

                  // Image (draw entire image, no cropping)
                  ctx.drawImage(img, 0, 0, img.width, img.height, dx, dy, dw, dh);

                  // Get page status
                  const isCurrentPage = item.index === thumbGridCurrentPage;
                  const schedStatus = getPageScheduleStatus(book, item.index);
                  const pageNum = (book.firstPageNumber || 1) + item.index;

                  // Color definitions (priority order for single border)
                  // Red = current viewing page
                  // Purple = current schedule page
                  // Green = done
                  // Blue = scheduled
                  // Yellow = paused
                  const COLORS = {
                    current: { main: '#ff4444', glow: '#ff0000' },       // Red - current viewing page
                    scheduleCurrent: { main: '#aa55ff', glow: '#9933ff' }, // Purple - schedule current
                    done: { main: '#44cc44', glow: '#22aa22' },          // Green - completed
                    scheduled: { main: '#4488ff', glow: '#2266dd' },     // Blue - scheduled
                    paused: { main: '#ffcc00', glow: '#ddaa00' }         // Yellow - paused
                  };

                  // Collect all active states for combined display
                  const activeStates = [];
                  if (isCurrentPage) activeStates.push('current');
                  if (schedStatus.isScheduleCurrent) activeStates.push('scheduleCurrent');
                  if (schedStatus.isDone) activeStates.push('done');
                  if (schedStatus.isScheduled) activeStates.push('scheduled');
                  if (schedStatus.isPaused) activeStates.push('paused');

                  // Draw border based on states
                  if (activeStates.length > 0) {
                    if (activeStates.length === 1) {
                      // Single state - full glow border
                      const color = COLORS[activeStates[0]];
                      ctx.save();
                      ctx.shadowColor = color.glow;
                      ctx.shadowBlur = 12;
                      ctx.strokeStyle = color.main;
                      ctx.lineWidth = 4;
                      ctx.strokeRect(x + 2, y + 2, cellWidth - 4, cellHeight - 4);
                      ctx.restore();
                    } else {
                      // Multiple states - draw segmented border (corners for each state)
                      const borderWidth = 5;
                      const cornerSize = Math.min(cellWidth, cellHeight) * 0.35;

                      // Draw each state in different corners/edges
                      activeStates.forEach((state, idx) => {
                        const color = COLORS[state];
                        ctx.save();
                        ctx.shadowColor = color.glow;
                        ctx.shadowBlur = 8;
                        ctx.strokeStyle = color.main;
                        ctx.lineWidth = borderWidth;
                        ctx.beginPath();

                        if (idx === 0) {
                          // Top-left corner (L shape)
                          ctx.moveTo(x + borderWidth / 2, y + cornerSize);
                          ctx.lineTo(x + borderWidth / 2, y + borderWidth / 2);
                          ctx.lineTo(x + cornerSize, y + borderWidth / 2);
                        } else if (idx === 1) {
                          // Top-right corner
                          ctx.moveTo(x + cellWidth - cornerSize, y + borderWidth / 2);
                          ctx.lineTo(x + cellWidth - borderWidth / 2, y + borderWidth / 2);
                          ctx.lineTo(x + cellWidth - borderWidth / 2, y + cornerSize);
                        } else if (idx === 2) {
                          // Bottom-right corner
                          ctx.moveTo(x + cellWidth - borderWidth / 2, y + cellHeight - cornerSize);
                          ctx.lineTo(x + cellWidth - borderWidth / 2, y + cellHeight - borderWidth / 2);
                          ctx.lineTo(x + cellWidth - cornerSize, y + cellHeight - borderWidth / 2);
                        } else if (idx === 3) {
                          // Bottom-left corner
                          ctx.moveTo(x + cornerSize, y + cellHeight - borderWidth / 2);
                          ctx.lineTo(x + borderWidth / 2, y + cellHeight - borderWidth / 2);
                          ctx.lineTo(x + borderWidth / 2, y + cellHeight - cornerSize);
                        } else {
                          // Additional: top edge
                          ctx.moveTo(x + cornerSize, y + borderWidth / 2);
                          ctx.lineTo(x + cellWidth - cornerSize, y + borderWidth / 2);
                        }
                        ctx.stroke();
                        ctx.restore();
                      });
                    }
                  } else {
                    // No special state - default thin border
                    ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, y, cellWidth, cellHeight);
                  }

                  // Page number label with primary state color
                  const primaryState = activeStates[0];
                  const labelColor = primaryState ? COLORS[primaryState].main : 'rgba(0,0,0,0.6)';
                  const labelHeight = activeStates.length > 0 ? 24 : 20;

                  ctx.fillStyle = primaryState ? labelColor : 'rgba(0,0,0,0.6)';
                  ctx.globalAlpha = primaryState ? 0.9 : 1;
                  ctx.fillRect(x, y + cellHeight - labelHeight, cellWidth, labelHeight);
                  ctx.globalAlpha = 1;

                  ctx.fillStyle = '#fff';
                  ctx.font = activeStates.length > 0 ? 'bold 13px sans-serif' : '12px sans-serif';
                  ctx.textAlign = 'center';
                  ctx.fillText(`P.${pageNum}`, x + cellWidth / 2, y + cellHeight - (labelHeight > 20 ? 7 : 6));

                  resolve();
                };
                img.onerror = resolve;
                img.src = url;
              });
            }
          } catch (e) {
            console.warn('[Canvas] Failed to draw', item.index, e);
          }

          loaded++;
          updateProgress();
        }));

        // Small delay to keep UI responsive
        await new Promise(r => setTimeout(r, 5));
      }

      // Store positions for click handling
      canvas._thumbPositions = positions;
      canvas._thumbBook = book;
      canvas._thumbBookId = book?.id || book?.title || '';

      // Click handler (uses CSS coordinates, not canvas pixels)
      canvas.onclick = (e) => {
        const rect = canvas.getBoundingClientRect();
        // Use CSS coordinates (positions are stored in CSS space)
        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;

        for (const pos of positions) {
          if (clickX >= pos.x && clickX < pos.x + pos.w &&
            clickY >= pos.y && clickY < pos.y + pos.h) {
            if (thumbGridGoToPage) {
              thumbGridGoToPage(pos.index);
              closeThumbGrid();
            }
            break;
          }
        }
      };

      // Hide progress UI
      if (progressBar) progressBar.style.display = 'none';
      if (progressInfo) progressInfo.style.display = 'none';

      // Scroll to current page position
      if (thumbGridCurrentPage !== null && positions.length > 0) {
        const currentPos = positions.find(p => p.index === thumbGridCurrentPage);
        if (currentPos && body) {
          // Calculate scroll position to center the current page
          const scrollY = Math.max(0, currentPos.y - (body.clientHeight / 2) + (currentPos.h / 2));
          body.scrollTop = scrollY;
        }
      }

      // Save canvas to IndexedDB for persistence across page reloads
      // Only save if filter is 'all' (full grid)
      if (thumbGridFilter === 'all' && canvas._thumbBookId && canvas._thumbCSSWidth && canvas._thumbCSSHeight) {
        const pageCount = book?.pages?.length || 0;
        saveCanvasToIDB(
          canvas._thumbBookId,
          canvas,
          positions,
          canvas._thumbCSSWidth,
          canvas._thumbCSSHeight,
          pageCount
        ).catch(e => console.warn('[CanvasCache] Save failed:', e));
      }
    }

    // Redraw only status borders on cached canvas (fast update)
    function redrawCanvasStatusBorders(book, canvas) {
      if (!canvas || !canvas._thumbPositions || !canvas._thumbBook || canvas._thumbBook !== book) {
        return false; // No valid cache
      }

      const positions = canvas._thumbPositions;
      const ctx = canvas.getContext('2d');
      const dpr = canvas._dpr || 1;

      // Calculate cell dimensions from first position
      if (positions.length === 0) return false;
      const cellWidth = positions[0].w;
      const cellHeight = positions[0].h;

      // Color definitions
      const COLORS = {
        current: { main: '#ff4444', glow: '#ff0000' },       // Red
        scheduleCurrent: { main: '#aa55ff', glow: '#9933ff' }, // Purple
        done: { main: '#44cc44', glow: '#22aa22' },          // Green
        scheduled: { main: '#4488ff', glow: '#2266dd' },     // Blue
        paused: { main: '#ffcc00', glow: '#ddaa00' }         // Yellow
      };

      // Clear just the border areas and redraw them
      for (const pos of positions) {
        const { x, y, w, h, index } = pos;

        // Get current status
        const isCurrentPage = index === thumbGridCurrentPage;
        const schedStatus = getPageScheduleStatus(book, index);
        const pageNum = (book.firstPageNumber || 1) + index;

        // Collect active states
        const activeStates = [];
        if (isCurrentPage) activeStates.push('current');
        if (schedStatus.isScheduleCurrent) activeStates.push('scheduleCurrent');
        if (schedStatus.isDone) activeStates.push('done');
        if (schedStatus.isScheduled) activeStates.push('scheduled');
        if (schedStatus.isPaused) activeStates.push('paused');

        // Clear border area including shadow overflow (shadowBlur is 12, so need extra margin)
        ctx.save();
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // Reset scale for correct coordinates

        // Clear with extra margin for glow/shadow (16px to account for shadowBlur 12)
        const glowMargin = 16;
        const borderClear = 16; // Wider clear area

        // Clear entire border area with glow margin
        // Top edge + glow above
        ctx.clearRect(x - glowMargin, y - glowMargin, w + glowMargin * 2, borderClear + glowMargin);
        // Right edge + glow right
        ctx.clearRect(x + w - borderClear, y - glowMargin, borderClear + glowMargin, h + glowMargin * 2);
        // Bottom edge + glow below (includes label)
        ctx.clearRect(x - glowMargin, y + h - 26, w + glowMargin * 2, 26 + glowMargin);
        // Left edge + glow left
        ctx.clearRect(x - glowMargin, y - glowMargin, borderClear + glowMargin, h + glowMargin * 2);

        // Redraw background for cleared areas
        ctx.fillStyle = '#1a1a2e'; // Canvas background color
        ctx.fillRect(x - glowMargin, y - glowMargin, w + glowMargin * 2, borderClear + glowMargin);
        ctx.fillRect(x + w - borderClear, y - glowMargin, borderClear + glowMargin, h + glowMargin * 2);
        ctx.fillRect(x - glowMargin, y + h - 26, w + glowMargin * 2, 26 + glowMargin);
        ctx.fillRect(x - glowMargin, y - glowMargin, borderClear + glowMargin, h + glowMargin * 2);

        // Draw borders
        if (activeStates.length > 0) {
          if (activeStates.length === 1) {
            const color = COLORS[activeStates[0]];
            ctx.shadowColor = color.glow;
            ctx.shadowBlur = 12;
            ctx.strokeStyle = color.main;
            ctx.lineWidth = 4;
            ctx.strokeRect(x + 2, y + 2, w - 4, h - 4);
            ctx.shadowBlur = 0;
          } else {
            const borderWidth = 5;
            const cornerSize = Math.min(w, h) * 0.35;

            activeStates.forEach((state, idx) => {
              const color = COLORS[state];
              ctx.shadowColor = color.glow;
              ctx.shadowBlur = 8;
              ctx.strokeStyle = color.main;
              ctx.lineWidth = borderWidth;
              ctx.beginPath();

              if (idx === 0) {
                ctx.moveTo(x + borderWidth / 2, y + cornerSize);
                ctx.lineTo(x + borderWidth / 2, y + borderWidth / 2);
                ctx.lineTo(x + cornerSize, y + borderWidth / 2);
              } else if (idx === 1) {
                ctx.moveTo(x + w - cornerSize, y + borderWidth / 2);
                ctx.lineTo(x + w - borderWidth / 2, y + borderWidth / 2);
                ctx.lineTo(x + w - borderWidth / 2, y + cornerSize);
              } else if (idx === 2) {
                ctx.moveTo(x + w - borderWidth / 2, y + h - cornerSize);
                ctx.lineTo(x + w - borderWidth / 2, y + h - borderWidth / 2);
                ctx.lineTo(x + w - cornerSize, y + h - borderWidth / 2);
              } else if (idx === 3) {
                ctx.moveTo(x + cornerSize, y + h - borderWidth / 2);
                ctx.lineTo(x + borderWidth / 2, y + h - borderWidth / 2);
                ctx.lineTo(x + borderWidth / 2, y + h - cornerSize);
              }
              ctx.stroke();
              ctx.shadowBlur = 0;
            });
          }
        } else {
          ctx.strokeStyle = 'rgba(255,255,255,0.1)';
          ctx.lineWidth = 1;
          ctx.strokeRect(x, y, w, h);
        }

        // Redraw label
        const primaryState = activeStates[0];
        const labelColor = primaryState ? COLORS[primaryState].main : 'rgba(0,0,0,0.6)';
        const labelHeight = activeStates.length > 0 ? 24 : 20;

        ctx.fillStyle = primaryState ? labelColor : 'rgba(0,0,0,0.6)';
        ctx.globalAlpha = primaryState ? 0.9 : 1;
        ctx.fillRect(x, y + h - labelHeight, w, labelHeight);
        ctx.globalAlpha = 1;

        ctx.fillStyle = '#fff';
        ctx.font = activeStates.length > 0 ? 'bold 13px sans-serif' : '12px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(`P.${pageNum}`, x + w / 2, y + h - (labelHeight > 20 ? 7 : 6));

        ctx.restore();
      }

      console.log('[Canvas] Redrew status borders for', positions.length, 'items');
      return true;
    }
    async function loadThumbnailWithCacheComplete(book, index, img, qualityFactor) {
      return new Promise(async (resolve) => {
        try {
          // Check cache first
          const cached = getCachedThumb(book, index);
          if (cached) {
            // Wait for cached image to render
            await waitForImageLoad(img, cached);
            resolve();
            return;
          }

          let url = await ensurePageData(book, index);
          if (!url) { resolve(); return; }

          // For low quality mode, downsample the image
          if (qualityFactor < 1.0 && url.startsWith('data:image')) {
            const resizedUrl = await resizeThumbnail(url, qualityFactor);
            if (resizedUrl) url = resizedUrl;
          }

          // Store in cache
          setCachedThumb(book, index, url);

          // Wait for image to fully load and render
          await waitForImageLoad(img, url);
          resolve();
        } catch (e) {
          console.warn('[loadThumbnailWithCacheComplete] Failed', index, e);
          resolve();
        }
      });
    }

    // Helper: wait for an image to fully load
    function waitForImageLoad(img, url) {
      return new Promise((resolve) => {
        if (img.complete && img.src === url) {
          resolve();
          return;
        }
        img.onload = () => resolve();
        img.onerror = () => resolve();
        img.src = url;
      });
    }

    // Load thumbnail with caching (for lazy loading mode)
    async function loadThumbnailWithCache(book, index, img, qualityFactor) {
      try {
        // Check cache first
        const cached = getCachedThumb(book, index);
        if (cached) {
          img.src = cached;
          return;
        }

        let url = await ensurePageData(book, index);
        if (!url) return;

        // For low quality mode, downsample the image
        if (qualityFactor < 1.0 && url.startsWith('data:image')) {
          const resizedUrl = await resizeThumbnail(url, qualityFactor);
          if (resizedUrl) url = resizedUrl;
        }

        // Store in cache
        setCachedThumb(book, index, url);
        img.src = url;
      } catch (e) {
        console.warn('[loadThumbnailWithCache] Failed to load page', index, e);
      }
    }

    // Load thumbnail with quality factor
    async function loadThumbnail(book, index, img, qualityFactor) {
      try {
        let url = await ensurePageData(book, index);
        if (!url) return;

        // For low quality mode, downsample the image
        if (qualityFactor < 1.0 && url.startsWith('data:image')) {
          const resizedUrl = await resizeThumbnail(url, qualityFactor);
          if (resizedUrl) url = resizedUrl;
        }

        img.src = url;
      } catch (e) {
        console.warn('[loadThumbnail] Failed to load page', index, e);
      }
    }

    // Resize image for lightweight mode
    async function resizeThumbnail(dataUrl, factor) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const maxDim = Math.round(300 * factor);
          let w = img.width, h = img.height;
          if (w > h && w > maxDim) {
            h = Math.round(h * maxDim / w);
            w = maxDim;
          } else if (h > maxDim) {
            w = Math.round(w * maxDim / h);
            h = maxDim;
          }
          try {
            const canvas = document.createElement('canvas');
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, w, h);
            resolve(canvas.toDataURL('image/webp', 0.6));
          } catch (e) {
            resolve(dataUrl);
          }
        };
        img.onerror = () => resolve(dataUrl);
        img.src = dataUrl;
      });
    }

    function startGridPreload() {
      if (!thumbGridCurrentBook || preloadAllProgress.active) return;

      const bar = document.getElementById('thumbGridPreloadBar');
      const progress = document.getElementById('thumbGridPreloadProgress');
      const btn = document.getElementById('thumbGridPreloadBtn');

      if (bar) bar.style.display = 'block';
      if (btn) { btn.disabled = true; btn.textContent = '読み込み中...'; }

      preloadAllPages(thumbGridCurrentBook, (loaded, total) => {
        const pct = Math.round((loaded / total) * 100);
        if (progress) progress.style.width = `${pct}%`;
        if (btn) btn.textContent = `${loaded}/${total}`;
      }).then(() => {
        if (bar) bar.style.display = 'none';
        if (btn) { btn.disabled = false; btn.textContent = '完了!'; }
        setTimeout(() => {
          if (btn) btn.textContent = '全ページ先読み';
        }, 2000);
      });
    }

    // Expose to global for menu action
    window.__openThumbGrid = openThumbGrid;
    window.__closeThumbGrid = closeThumbGrid;
    window.__preloadAllPages = preloadAllPages;
    window.__preloadAllEnabled = () => preloadAllEnabled;
    window.__setPreloadAllEnabled = savePreloadAllSetting;

    function initOptimizeControls() {
      const scaleInput = document.getElementById('optimizeScale');
      const scaleVal = document.getElementById('optimizeScaleVal');
      const preview = document.getElementById('optimizePreview');
      const bookSelect = document.getElementById('optimizeBookSelect');
      const setLabel = (v) => { if (scaleVal) scaleVal.textContent = `${Math.round(v * 100)}%`; };
      let previewCache = { id: null, bytes: null };
      const refreshBooks = async () => {
        if (!bookSelect) return;
        const sel = bookSelect.value;
        bookSelect.innerHTML = '<option value=\"\">すべての本</option>';
        previewCache = { id: null, bytes: null };
        try {
          const books = await Book.listMeta();
          books.forEach(b => {
            const opt = document.createElement('option');
            opt.value = b.id; opt.textContent = b.title || '無題';
            bookSelect.appendChild(opt);
          });
          if (sel) bookSelect.value = sel;
        } catch (e) { }
      };
      const previewEstimate = async () => {
        if (!preview || !scaleInput) return;
        preview.textContent = '計算中…';
        try {
          const scale = parseFloat(scaleInput.value) || 0.6;
          const targetId = bookSelect?.value || '';
          let currentBytes = (previewCache.id === targetId && typeof previewCache.bytes === 'number') ? previewCache.bytes : null;
          if (currentBytes === null) {
            let targetBooks = [];
            if (targetId) {
              const one = await Book.get(targetId);
              if (one) targetBooks = [one];
            } else {
              targetBooks = await Book.list();
            }
            if (!targetBooks.length) { preview.textContent = '対象の本がありません'; return; }
            let bytes = 0;
            for (const b of targetBooks) {
              const pages = b.pages || [];
              bytes += estimateDataUrlBytes(b.coverDataUrl);
              for (let i = 0; i < pages.length; i++) {
                const url = await ensurePageData(b, i);
                bytes += estimateDataUrlBytes(url);
              }
            }
            currentBytes = bytes;
            previewCache = { id: targetId, bytes: currentBytes };
          }
          const estimated = currentBytes * Math.pow(scale, 2) * 0.72;
          const reduction = currentBytes > 0 ? (1 - estimated / currentBytes) * 100 : 0;
          preview.textContent = `現状: ${formatBytes(currentBytes)} → 推定: ${formatBytes(estimated)} (約${reduction.toFixed(1)}%削減)`;
        } catch (e) {
          preview.textContent = '計算に失敗しました';
        }
      };
      if (scaleInput) {
        setLabel(parseFloat(scaleInput.value) || 0.6);
        scaleInput.addEventListener('input', () => { setLabel(parseFloat(scaleInput.value) || 0.6); previewEstimate(); });
      }
      bookSelect?.addEventListener('change', previewEstimate);
      if (preview) { preview.textContent = '対象を選んでスライダーを動かすと概算を表示します'; }
      refreshBooks();
    }
    function loadRecentBoxes() {
      const arr = loadStoredJSON(BOX_RECENT_KEY);
      return Array.isArray(arr) ? arr.filter(Boolean) : [];
    }
    function bumpRecentBox(boxId) {
      if (!boxId) return;
      const cur = loadRecentBoxes().filter(id => id !== boxId);
      cur.unshift(boxId);
      saveStoredJSON(BOX_RECENT_KEY, cur.slice(0, 50));
    }

    const LIBRARY_SHOW_ANSWERS_KEY = 'library-show-answers';
    const LAST_PAGE_KEY_PREFIX = 'viewer-last-page:';
    const LAST_COMPARE_KEY_PREFIX = 'viewer-last-compare:';
    const LAST_COMPARE_WINDOW_KEY_PREFIX = 'viewer-last-compare-window:';
    const ANSWER_PAGE_MAP_PREFIX = 'answer-page-map:';
    const LAST_BOX_VIEW_KEY = 'viewer-last-box-view';
    const PERF_MODE_KEY = 'performance-mode';
    const PAGE_TURBO_NORMAL_PPS_KEY = 'page-turbo-normal-pps';
    const PAGE_TURBO_SHIFT_PPS_KEY = 'page-turbo-shift-pps';
    const VIEWER_CONTROLS_BOTTOM_KEY = 'viewer-controls-bottom';
    const BOX_RECENT_KEY = 'box-recent-order';
    const OPEN_TABS_STORAGE_KEY = 'open-tabs-v1';
    const BOOK_TONE_KEY = 'viewer-book-tone';
    const AUTO_TONE_KEY = 'viewer-auto-tone';
    const TAP_DRAW_KEY = 'tap-draw-always';
    const DEFAULT_TONE_CONFIG = { mode: 'orig', light: '#000000', dark: '#00ff00' };
    const KEY_NAV_CONFIG_KEY = 'viewer-key-nav-config';
    const PAGE_ANIM_KEY = 'viewer-page-anim';
    const ACTIVE_PAN_DECAY_DEFAULT = 0.992;
    const ACTIVE_ZOOM_DECAY_DEFAULT = 0.99;
    const PAGE_PROGRESS_STORAGE_KEY = 'page-progress-marks-v1';
    const KEY_ACTION_DEFS = [
      { id: 'toggleSpread', label: '見開き切替', placeholder: '例: V', run: () => { const btn = document.getElementById('spreadToggle'); if (btn) { btn.click(); return true; } return false; } },
      { id: 'toggleCompare', label: '比較ON/OFF', placeholder: '例: C', run: () => { const end = document.getElementById('compareEnd'); if (end && !end.classList.contains('hidden')) { end.click(); return true; } const start = document.getElementById('compareStart'); if (start) { start.click(); return true; } return false; } },
      { id: 'toggleSlice', label: 'ハーフ表示', placeholder: '例: H', run: () => clickViewerControl('sliceViewBtn') },
      { id: 'toggleZoomLock', label: 'ズームロック', placeholder: '例: Z', run: () => clickViewerControl('zoomLockBtn') },
      { id: 'togglePanLock', label: '移動ロック', placeholder: '例: X', run: () => clickViewerControl('panLockBtn') },
      { id: 'fitContain', label: 'フィット（全体）', placeholder: '例: F', run: () => clickViewerControl('fitContain') },
      { id: 'fitWidth', label: '幅フィット', placeholder: '例: W', run: () => clickViewerControl('fitWidth') },
      { id: 'toggleSelect', label: '切り取りモード', placeholder: '例: T', run: () => clickViewerControl('selectQuickBtn') || clickViewerControl('selectBtn') },
      { id: 'toggleMemoPanel', label: 'メモ欄トグル', placeholder: '例: M', run: () => clickViewerControl('memoToggle') },
      { id: 'toggleMemoWindow', label: 'ミニメモ', placeholder: '例: U', run: () => clickViewerControl('memoMiniBtn') },
      { id: 'toggleMissPanel', label: 'ミスパネル', placeholder: '例: Shift+Y', run: () => clickViewerControl('missQuickBtn') || clickViewerControl('missBtn') },
      { id: 'spawnMissAtCursor', label: 'ミス追加（カーソル）', placeholder: '例: Y', run: () => { if (typeof window.__openMissSpawnMenu === 'function') return window.__openMissSpawnMenu(); return false; } },
      { id: 'toggleMenu', label: 'メニュー開閉', placeholder: '例: ;', run: () => clickViewerControl('bookMenuBtn') || clickViewerControl('stageMenuBtn') },
      { id: 'pageList', label: 'ページ一覧', placeholder: '例: L', run: () => clickViewerControl('pageListBtn') },
      { id: 'pageComplete', label: 'ページ完了', placeholder: '例: P', run: () => { if (typeof StudyMgr?.completePageNow === 'function') { StudyMgr.completePageNow(); return true; } return clickViewerControl('stDone'); } },
      {
        id: 'jumpFocus', label: 'ページ入力にフォーカス', placeholder: '例: J', run: () => {
          try {
            if (typeof window.__startCompareBadgeEdit === 'function' && typeof compareWindowOpen !== 'undefined' && compareWindowOpen) {
              window.__startCompareBadgeEdit();
              return true;
            }
            if (typeof focusPageJumpInput === 'function') { focusPageJumpInput(); return true; }
          } catch (_) { }
          const input = document.getElementById('jumpInput') || document.getElementById('compareWindowPageBadge');
          if (!input) return false;
          input.focus();
          if (input.select) input.select();
          input.click?.();
          return true;
        }
      },
      { id: 'toggleMainMode', label: 'メイン/通常切替', placeholder: '例: Shift+M', run: () => { if (typeof window.__toggleMainMode === 'function') return window.__toggleMainMode(); const btn = document.getElementById('mainModeBtn'); if (btn) { btn.click(); return true; } return false; } },
      { id: 'openBook', label: '本を開く', placeholder: '例: B', run: () => { if (typeof showTab === 'function') { showTab('library'); const s = document.getElementById('searchInput'); if (s) { s.focus(); s.select?.(); } return true; } return false; } },
      { id: 'openPlanner', label: 'プランナータブへ', placeholder: '例: P', run: () => { if (typeof showTab === 'function') { showTab('planner'); return true; } return false; } },
      { id: 'toggleDrawMode', label: 'ドローモード切替', placeholder: '例: X', run: () => { const btn = document.getElementById('drawToggleBtn'); if (btn) { btn.click(); return true; } return false; } },
      { id: 'drawSettings', label: 'ドロー設定', placeholder: '例: D', run: () => { const btn = document.getElementById('drawSettingsBtn'); if (btn) { btn.click(); return true; } return false; } },
      { id: 'drawSelect', label: 'ドロー選択', placeholder: '例: S', run: () => { const btn = document.getElementById('drawSelectBtn'); if (btn) { btn.click(); return true; } return false; } },
      { id: 'drawUndo', label: 'ドロー元に戻す', placeholder: '例: Ctrl+Z', run: () => { if (typeof drawUndo === 'function') drawUndo(); } },
      { id: 'drawRedo', label: 'ドローやり直し', placeholder: '例: Ctrl+Shift+Z', run: () => { if (typeof drawRedo === 'function') drawRedo(); } },
      { id: 'drawReset', label: 'ドローリセット', placeholder: '例: Ctrl+Backspace', run: () => { if (typeof resetDrawPage === 'function') resetDrawPage(); } },
      { id: 'drawHold', label: 'R押し描画', placeholder: '例: R', run: null },
      { id: 'togglePenEraser', label: 'ペン/消しゴム切替', placeholder: '例: E', run: () => { if (typeof setDrawTool === 'function') setDrawTool(drawTool === 'pen' ? 'eraser' : 'pen'); } },
      { id: 'setPen', label: 'ペンにする', placeholder: '例: P', run: () => { if (typeof setDrawTool === 'function') setDrawTool('pen'); } },
      { id: 'setEraser', label: '消しゴムにする', placeholder: '例: Q', run: () => { if (typeof setDrawTool === 'function') setDrawTool('eraser'); } },
      { id: 'pageFillDown', label: '完了目安:下に伸ばす', placeholder: '例: G', run: () => { if (typeof handlePageProgressFill === 'function') handlePageProgressFill('down'); } },
      { id: 'pageFillUp', label: '完了目安:上に伸ばす', placeholder: '例: Shift+G', run: () => { if (typeof handlePageProgressFill === 'function') handlePageProgressFill('up'); } },
      { id: 'toggleViewerClock', label: '時計表示トグル', placeholder: '例: Shift+C', run: () => { if (typeof toggleViewerClock === 'function') { toggleViewerClock(); return true; } return false; } },
      { id: 'toggleNumberlineClock', label: '数直線時計トグル', placeholder: '例: Alt+C', run: () => { if (typeof toggleNumberlineClock === 'function') { toggleNumberlineClock(); return true; } return false; } },
      { id: 'flyPlannerClock', label: 'プランナー時計フライイン', placeholder: '例: Shift+P', run: () => { if (typeof togglePlannerFly === 'function') { togglePlannerFly(); return true; } return false; } },
      { id: 'flyNumberlineClock', label: '数直線フライイン', placeholder: '例: Shift+N', run: () => { if (typeof toggleNumberlineFly === 'function') { toggleNumberlineFly(); return true; } return false; } }
    ];
    const createDefaultActionBindings = () => {
      const map = {};
      KEY_ACTION_DEFS.forEach(def => { map[def.id] = []; });
      map.toggleDrawMode = ['x', 'X'];
      map.drawHold = ['r', 'R'];
      map.drawSettings = ['d', 'D'];
      map.drawSelect = ['s', 'S'];
      map.drawUndo = ['Ctrl+Z', 'Meta+Z'];
      map.drawRedo = ['Ctrl+Shift+Z', 'Meta+Shift+Z'];
      map.drawReset = ['Ctrl+Backspace', 'Meta+Backspace'];
      map.togglePenEraser = ['e', 'E'];
      map.setPen = ['p', 'P'];
      map.setEraser = ['q', 'Q'];
      map.openBook = ['b', 'B'];
      map.pageList = [];
      map.pageComplete = [];
      map.pageFillDown = [];
      map.pageFillUp = [];
      map.toggleViewerClock = [];
      map.toggleNumberlineClock = [];
      map.flyPlannerClock = [];
      map.flyNumberlineClock = [];
      return map;
    };
    const mergeActionBindings = (source = {}) => {
      const base = (source && source.actionBindings) ? source.actionBindings : source;
      const merged = {};
      KEY_ACTION_DEFS.forEach(def => {
        const list = base && Array.isArray(base[def.id]) ? base[def.id] : [];
        merged[def.id] = [...list];
      });
      Object.entries(base || {}).forEach(([k, v]) => {
        if (!merged[k] && Array.isArray(v)) merged[k] = [...v];
      });
      return merged;
    };
    const DEFAULT_KEY_NAV_CONFIG = {
      panStep: 65,
      zoomStep: 1.115,
      panDecay: 0.925,
      zoomDecay: 0.921,
      holdMs: 140,
      bookClamp: false,
      panLeftKeys: [],
      panRightKeys: [],
      panUpKeys: [],
      panDownKeys: [],
      zoomInKeys: [],
      zoomOutKeys: [],
      zoomInCodes: [],
      zoomOutCodes: [],
      resetKeys: [],
      resetCodes: [],
      pageNextKeys: [],
      pagePrevKeys: [],
      pageNextCodes: [],
      pagePrevCodes: [],
      answerToggleKeys: ['k', 'K'],
      answerToggleCodes: ['KeyK'],
      studyMenuKeys: [],
      studyMenuCodes: [],
      actionBindings: createDefaultActionBindings()
    };
    const VIEWER_CLOCK_KEY = 'viewer-clock-config';
    const DEFAULT_VIEWER_CLOCK = {
      position: 'inline-right',
      design: 'glass-clear',
      format: '12',
      showSeconds: true,
      visible: true,
      toggleKey: '',
      textScale: 1.3,
      textColor: '#000000',
      borderColor: '#222222',
      fontDataUrl: '',
      fontName: ''
    };
    const FLY_CLOCK_KEY = 'viewer-fly-clock-config';
    const DEFAULT_FLY_CLOCK = {
      planner: { key: 'Shift+P', position: 'right', visible: false, dragX: 0, dragY: 0 },
      numberline: { key: 'Shift+N', position: 'left', visible: false, count: 2, width: 480, dragX: 0, dragY: 0 }
    };
    const storedViewerClock = loadStoredJSON(VIEWER_CLOCK_KEY) || {};
    const storedFlyClock = loadStoredJSON(FLY_CLOCK_KEY) || {};
    let viewerClockConfig = Object.assign({}, DEFAULT_VIEWER_CLOCK, storedViewerClock);
    let flyClockConfig = Object.assign({}, DEFAULT_FLY_CLOCK, storedFlyClock);
    let viewerClockOverlay = null, viewerClockWrap = null, viewerClockEl = null, viewerClockText = null, viewerClockFontStyle = null;
    let viewerTimerEl = null, viewerTimerText = null, viewerTimerActive = false;
    let viewerClockInterval = null;
    let viewerClockContext = null;
    let viewerClockInlineParent = null;
    let viewerClockTempDesign = null;
    let plannerFlyOverlay = null, plannerFly = null, plannerFlyBody = null;
    let numberlineFlyOverlay = null, numberlineFly = null, numberlineFlyBody = null;
    const saveViewerClockConfig = (next = {}) => {
      viewerClockConfig = Object.assign({}, viewerClockConfig, next);
      saveStoredJSON(VIEWER_CLOCK_KEY, viewerClockConfig);
    };
    const saveFlyClockConfig = (next = {}) => {
      flyClockConfig = Object.assign({}, flyClockConfig, next);
      saveStoredJSON(FLY_CLOCK_KEY, flyClockConfig);
    };
    window.addEventListener('planner:nl-updated', () => {
      try { refreshPlannerFlyClock(false); } catch (_) { }
    });
    const normalizeViewerClockDefaults = () => {
      let changed = false;
      const legacyDesign = storedViewerClock.design === undefined || storedViewerClock.design === 'minimal';
      const untouchedColors = (!storedViewerClock.textColor || storedViewerClock.textColor === '#000000') &&
        (!storedViewerClock.borderColor || storedViewerClock.borderColor === '#222222');
      if (legacyDesign && untouchedColors) {
        viewerClockConfig.design = DEFAULT_VIEWER_CLOCK.design;
        changed = true;
      }
      if (changed) saveViewerClockConfig(viewerClockConfig);
    };
    normalizeViewerClockDefaults();
    let pageProgressMarks = loadStoredJSON(PAGE_PROGRESS_STORAGE_KEY) || {};
    const savePageProgressMarks = () => { try { saveStoredJSON(PAGE_PROGRESS_STORAGE_KEY, pageProgressMarks); } catch (_) { } };
    function handlePageProgressFill(direction) {
      if (typeof window.__pageProgressFillHandler === 'function') {
        return window.__pageProgressFillHandler(direction);
      }
      return false;
    }
    const clampInertiaGlobal = (v) => {
      const n = parseFloat(v);
      if (!isFinite(n)) return DEFAULT_KEY_NAV_CONFIG.panDecay;
      return Math.max(0.9, Math.min(0.9995, n));
    };
    const VIEWER_RESET_ZOOM_ONLY_KEY = 'viewer-reset-zoom-only';
    let zoomResetOnly = loadStoredBool(VIEWER_RESET_ZOOM_ONLY_KEY, false);
    function setZoomResetOnly(v) {
      zoomResetOnly = !!v;
      saveStoredBool(VIEWER_RESET_ZOOM_ONLY_KEY, zoomResetOnly);
      syncZoomResetOnlyToggle();
    }
    function migrateKeyNavConfig(cfg) {
      const next = Object.assign({}, cfg);
      const oldUp = ['e', 'E'];
      if (Array.isArray(next.panUpKeys) && next.panUpKeys.length && next.panUpKeys.every(k => oldUp.includes(k))) {
        next.panUpKeys = ['w', 'W'];
      }
      // Revert accidental faster defaults
      if (next.panStep === 90) next.panStep = DEFAULT_KEY_NAV_CONFIG.panStep;
      if (Math.abs((next.zoomStep || 0) - 1.14) < 0.0001) next.zoomStep = DEFAULT_KEY_NAV_CONFIG.zoomStep;
      next.actionBindings = mergeActionBindings(next.actionBindings || {});
      return next;
    }
    let keyNavConfig = (() => migrateKeyNavConfig(Object.assign({}, DEFAULT_KEY_NAV_CONFIG, loadStoredJSON(KEY_NAV_CONFIG_KEY) || {})))();
    keyNavConfig.panDecay = clampInertiaGlobal(keyNavConfig.panDecay ?? DEFAULT_KEY_NAV_CONFIG.panDecay);
    keyNavConfig.zoomDecay = clampInertiaGlobal(keyNavConfig.zoomDecay ?? DEFAULT_KEY_NAV_CONFIG.zoomDecay);
    function setKeyNavConfig(next) {
      keyNavConfig = migrateKeyNavConfig(Object.assign({}, DEFAULT_KEY_NAV_CONFIG, keyNavConfig, next));
      keyNavConfig.panDecay = clampInertiaGlobal(keyNavConfig.panDecay ?? DEFAULT_KEY_NAV_CONFIG.panDecay);
      keyNavConfig.zoomDecay = clampInertiaGlobal(keyNavConfig.zoomDecay ?? DEFAULT_KEY_NAV_CONFIG.zoomDecay);
      saveStoredJSON(KEY_NAV_CONFIG_KEY, keyNavConfig);
    }
    const PAGE_ANIM_OPTIONS = ['none'];
    const PAGE_ANIM_MIGRATION_KEY = 'page-anim-migrated-v2';
    const PAGE_ANIM_USER_KEY = 'page-anim-user-set';
    function loadPageAnimMode() {
      saveStoredString(PAGE_ANIM_KEY, 'none');
      saveStoredBool(PAGE_ANIM_MIGRATION_KEY, true);
      return 'none';
    }
    function setPageAnimMode(mode, { fromUser = false } = {}) {
      pageAnimMode = 'none';
      saveStoredString(PAGE_ANIM_KEY, pageAnimMode);
      if (fromUser) saveStoredBool(PAGE_ANIM_USER_KEY, true);
    }
    let pageAnimMode = loadPageAnimMode();
    setPageAnimMode(pageAnimMode, { fromUser: false }); // ensure persisted/default is applied on boot without marking user-set
    const PAGE_SPEED_DEFAULT_NORMAL = 6; // pages/sec
    const PAGE_SPEED_DEFAULT_SHIFT = 10; // pages/sec
    const clampPageSpeed = (v, fallback) => {
      const n = parseFloat(v);
      if (!Number.isFinite(n)) return fallback;
      return Math.max(2, Math.min(20, n));
    };
    let pageTurboNormalPps = clampPageSpeed(loadStoredNumber(PAGE_TURBO_NORMAL_PPS_KEY), PAGE_SPEED_DEFAULT_NORMAL);
    let pageTurboShiftPps = clampPageSpeed(loadStoredNumber(PAGE_TURBO_SHIFT_PPS_KEY), PAGE_SPEED_DEFAULT_SHIFT);
    const PAGE_HOLD_INITIAL_DELAY = 160;
    const PAGE_HOLD_SHIFT_INITIAL_DELAY = 90;
    const PAGE_HOLD_ACCEL_WINDOW = 1400;
    const PAGE_HOLD_SHIFT_ACCEL_WINDOW = 700;
    function getPageTurboConfig(shift) {
      const pps = shift ? pageTurboShiftPps : pageTurboNormalPps;
      const base = Math.max(35, Math.round(1000 / Math.max(2, pps)));
      const minRatio = shift ? 0.25 : 0.7;
      const min = Math.max(20, Math.round(base * minRatio));
      return {
        initialDelay: shift ? PAGE_HOLD_SHIFT_INITIAL_DELAY : PAGE_HOLD_INITIAL_DELAY,
        accelWindow: shift ? PAGE_HOLD_SHIFT_ACCEL_WINDOW : PAGE_HOLD_ACCEL_WINDOW,
        base,
        min
      };
    }
    let viewerControlsBottom = loadStoredBool(VIEWER_CONTROLS_BOTTOM_KEY, false);
    function applyViewerControlsPosition(next) {
      viewerControlsBottom = (typeof next === 'boolean') ? next : viewerControlsBottom;
      if (document?.body) {
        document.body.classList.toggle('viewer-controls-bottom', viewerControlsBottom);
      }
      saveStoredBool(VIEWER_CONTROLS_BOTTOM_KEY, viewerControlsBottom);
    }
    const viewerMemory = {
      book: { id: null, closed: true, ref: null, page: 0 },
      box: { id: null, closed: true }
    };
    const perfModeEnabled = loadStoredBool(PERF_MODE_KEY, false);
    applyPerfMode(perfModeEnabled);
    applyViewerControlsPosition(viewerControlsBottom);
    const openTabsState = [];
    let activeOpenTabId = null;
    const openTabKey = (type, id) => `${type}:${id}`;
    function persistOpenTabs() {
      try {
        localStorage.setItem(OPEN_TABS_STORAGE_KEY, JSON.stringify({
          openTabs: openTabsState,
          active: activeOpenTabId
        }));
      } catch (err) { }
    }
    function loadOpenTabsFromStorage() {
      try {
        const raw = localStorage.getItem(OPEN_TABS_STORAGE_KEY);
        if (!raw) return null;
        const obj = JSON.parse(raw);
        if (!obj || !Array.isArray(obj.openTabs)) return null;
        return {
          openTabs: obj.openTabs.filter(t => t && t.type && t.id),
          active: obj.active || null
        };
      } catch (err) {
        return null;
      }
    }
    function renderOpenTabs() {
      const wrap = document.getElementById('openTabs');
      if (!wrap) return;
      wrap.innerHTML = '';
      openTabsState.forEach(tab => {
        const el = document.createElement('div');
        el.className = 'tab open-tab' + (tab.key === activeOpenTabId ? ' active' : '');
        el.dataset.key = tab.key;
        const label = document.createElement('span');
        label.className = 'label';
        const defaultTitle = tab.type === 'book' ? '本' : tab.type === 'box' ? 'ボックス' : '完了';
        label.textContent = (window.escapeHTML ? escapeHTML : String)(tab.title || defaultTitle);
        const close = document.createElement('button');
        close.className = 'close';
        close.textContent = '×';
        close.title = '閉じる';
        close.addEventListener('click', (e) => { e.stopPropagation(); closeOpenTab(tab.key); });
        el.addEventListener('click', () => handleOpenTabClick(tab.key));
        el.appendChild(label);
        el.appendChild(close);
        wrap.appendChild(el);
      });
      persistOpenTabs();
    }
    function ensureOpenTab(type, id, title) {
      const key = openTabKey(type, id);
      const existing = openTabsState.find(t => t.key === key);
      if (existing) {
        existing.title = title || existing.title;
      } else {
        openTabsState.push({ key, type, id, title: title || (type === 'book' ? '本' : 'ボックス') });
      }
      activeOpenTabId = key;
      renderOpenTabs();
    }
    async function handleOpenTabClick(key) {
      const tab = openTabsState.find(t => t.key === key);
      if (!tab) return;
      activeOpenTabId = key;
      renderOpenTabs();
      persistOpenTabs();
      if (tab.type === 'book') {
        if (state.activeTab !== 'library') showTab('library', { preserveOpenTab: true });
        const book = await Book.get(tab.id);
        if (book) { mountBookViewer(book); }
        else { showToast && showToast('本が見つかりません', 'error'); closeOpenTab(key); }
      } else if (tab.type === 'box') {
        if (state.activeTab !== 'boxes') showTab('boxes', { preserveOpenTab: true });
        const box = await Box.get(tab.id);
        if (box) { mountBoxViewer(box); }
        else { showToast && showToast('ボックスが見つかりません', 'error'); closeOpenTab(key); }
      } else if (tab.type === 'completed') {
        const raw = tab.id || '';
        let dateStr = new Date().toISOString().slice(0, 10);
        let hintBook = null;
        let hintPage = null;
        if (raw.includes('|')) {
          const parts = raw.split('|');
          hintBook = parts[0] || null;
          dateStr = parts[1] || dateStr;
          hintPage = parts[2] ? parseInt(parts[2], 10) : null;
        } else if (raw.startsWith('completed-')) {
          dateStr = raw.replace(/^completed-/, '') || dateStr;
        } else if (raw) {
          dateStr = raw;
        }
        showTab('home', { preserveOpenTab: true });
        openCompletedViewer(hintBook, { date: dateStr, bookId: hintBook, page: hintPage });
      }
    }
    async function closeOpenTab(key) {
      const idx = openTabsState.findIndex(t => t.key === key);
      if (idx < 0) return;
      const closed = openTabsState[idx];
      const wasActive = openTabsState[idx].key === activeOpenTabId;
      openTabsState.splice(idx, 1);
      if (closed?.type === 'completed') { teardownCompletedKeyHandler(); }
      persistOpenTabs();
      if (wasActive) {
        try { window.__persistActiveDrawDoc?.(); } catch (_) { }
        if (closed?.type === 'completed' && window.__completedKeyHandler) {
          document.removeEventListener('keydown', window.__completedKeyHandler);
          window.__completedKeyHandler = null;
        }
        const fallback = openTabsState[idx] || openTabsState[idx - 1] || openTabsState[openTabsState.length - 1];
        if (fallback) {
          activeOpenTabId = fallback.key;
          renderOpenTabs();
          await handleOpenTabClick(fallback.key);
        } else {
          activeOpenTabId = null;
          const viewerEl = document.getElementById('viewerView');
          if (viewerEl) { viewerEl.innerHTML = ''; viewerEl.classList.add('hidden'); }
          document.body.classList.remove('reading');
          state.viewerContext = null;
          const fallbackTabId = closed?.type === 'box' ? 'boxes' : (closed?.type === 'completed' ? 'library' : 'library');
          showTab(fallbackTabId);
          window.__persistActiveDrawDoc = null;
        }
      } else {
        renderOpenTabs();
      }
    }
    async function restoreOpenTabs() {
      const stored = loadOpenTabsFromStorage();
      if (!stored || !stored.openTabs.length) return false;
      const normalized = stored.openTabs.map(t => {
        const key = t.key || openTabKey(t.type, t.id);
        let title = t.title;
        if (!title) title = (t.type === 'box') ? 'ボックス' : (t.type === 'completed' ? '完了ページ' : '本');
        return { key, type: t.type, id: t.id, title };
      }).filter(t => t.type === 'book' || t.type === 'box' || t.type === 'completed');
      if (!normalized.length) return false;
      openTabsState.splice(0, openTabsState.length, ...normalized);
      activeOpenTabId = normalized.some(t => t.key === stored.active) ? stored.active : (normalized[0]?.key || null);
      renderOpenTabs();
      persistOpenTabs();
      // avoid auto-opening heavy viewers on初回起動; user can再開タブをクリックで復元
      return true;
    }

    function getLastPageIndex(bookId) {
      if (!bookId) return 0;
      const saved = loadStoredNumber(LAST_PAGE_KEY_PREFIX + bookId);
      return saved === null ? 0 : saved;
    }
    function setLastPageIndex(bookId, index) {
      if (!bookId) return;
      saveStoredNumber(LAST_PAGE_KEY_PREFIX + bookId, index);
    }
    function getLastCompareIndex(baseId, targetId) {
      if (!baseId || !targetId) return null;
      return loadStoredNumber(`${LAST_COMPARE_KEY_PREFIX}${baseId}:${targetId}`);
    }
    function setLastCompareIndex(baseId, targetId, index) {
      if (!baseId || !targetId) return;
      saveStoredNumber(`${LAST_COMPARE_KEY_PREFIX}${baseId}:${targetId}`, index);
    }
    function getLastCompareWindowIndex(baseId, targetId) {
      if (!baseId || !targetId) return null;
      return loadStoredNumber(`${LAST_COMPARE_WINDOW_KEY_PREFIX}${baseId}:${targetId}`);
    }
    function setLastCompareWindowIndex(baseId, targetId, index) {
      if (!baseId || !targetId) return;
      saveStoredNumber(`${LAST_COMPARE_WINDOW_KEY_PREFIX}${baseId}:${targetId}`, index);
    }
    const VIEWER_POSE_KEY_PREFIX = 'viewer-pose-';
    const VIEWER_POSE_PERSIST_ENABLED = false; // disable pan/zoom persistence
    function loadViewerPose(bookId) {
      if (!bookId) return null;
      if (!VIEWER_POSE_PERSIST_ENABLED) return null;
      return loadStoredJSON(VIEWER_POSE_KEY_PREFIX + bookId);
    }
    function saveViewerPose(bookId, pose) {
      if (!bookId) return;
      if (!VIEWER_POSE_PERSIST_ENABLED) return;
      saveStoredJSON(VIEWER_POSE_KEY_PREFIX + bookId, pose);
    }
    async function analyzeStorageUsage() {
      const out = document.getElementById('storageStats');
      if (out) { out.textContent = '計測中…'; }
      try {
        const books = await Book.list();
        const boxes = await Box.list();
        let appTotal = 0;
        let booksTotal = 0;
        let boxesTotal = 0;
        const bookRows = [];
        for (const b of books) {
          const pages = b.pages || [];
          const coverBytes = estimateDataUrlBytes(b.coverDataUrl);
          let pageBytes = 0;
          for (let i = 0; i < pages.length; i++) {
            const url = await ensurePageData(b, i);
            pageBytes += estimateDataUrlBytes(url);
          }
          const bytes = coverBytes + pageBytes;
          booksTotal += bytes;
          bookRows.push({ id: b.id, title: b.title || '無題', bytes, count: pages.length });
        }
        bookRows.sort((a, b) => b.bytes - a.bytes);
        const boxRows = boxes.map(box => {
          const sn = box.snippets || [];
          const coverBytes = estimateDataUrlBytes(box.coverDataUrl);
          const snippetBytes = sn.reduce((sum, s) => {
            let acc = sum + estimateDataUrlBytes(s.dataUrl);
            if (s.answer?.dataUrl) acc += estimateDataUrlBytes(s.answer.dataUrl);
            return acc;
          }, 0);
          const bytes = coverBytes + snippetBytes;
          boxesTotal += bytes;
          return { id: box.id, title: box.name || '無題ボックス', bytes, count: sn.length };
        }).sort((a, b) => b.bytes - a.bytes);
        appTotal = booksTotal + boxesTotal;
        const html = [
          `<div class="row space" style="font-weight:bold"><span>アプリ全体</span><span>${formatBytes(appTotal)}</span></div>`,
          `<div class="row space"><span>本 (合計)</span><span>${formatBytes(booksTotal)}</span></div>`,
          ...bookRows.map(r => `<div class="row space" style="padding-left:8px"><span>${escapeHTML(r.title)} (${r.count}p)</span><span>${formatBytes(r.bytes)}</span></div>`),
          `<div class="row space" style="margin-top:6px"><span>ボックス (合計)</span><span>${formatBytes(boxesTotal)}</span></div>`,
          ...boxRows.map(r => `<div class="row space" style="padding-left:8px"><span>${escapeHTML(r.title)} (${r.count}件)</span><span>${formatBytes(r.bytes)}</span></div>`)
        ].join('');
        if (out) { out.innerHTML = html || '<div class="muted">データがありません</div>'; }
      } catch (e) {
        if (out) { out.textContent = '計測に失敗しました'; }
      }
    }
    async function optimizeThumbnailsLossy() {
      const scaleInput = document.getElementById('optimizeScale');
      const bookSelect = document.getElementById('optimizeBookSelect');
      const scale = parseFloat(scaleInput?.value) || 0.6;
      const targetId = bookSelect?.value || '';
      const targetLabel = targetId ? '指定の本' : 'すべての本';
      if (!confirm(`解像度を${Math.round(scale * 100)}%に下げて上書きします（元データは保持しません）。対象: ${targetLabel}`)) return;
      const out = document.getElementById('storageStats');
      if (out) { out.textContent = '圧縮中…'; }
      try {
        const books = await Book.list();
        const scaleQual = Math.min(0.9, Math.max(0.3, scale));
        const targets = targetId ? books.filter(b => b.id === targetId) : books;
        for (const b of targets) {
          let changed = false;
          for (let i = 0; i < (b.pages || []).length; i++) {
            const p = b.pages[i];
            const original = await ensurePageData(b, i);
            if (!original) continue;
            const img = new Image();
            await new Promise((res, rej) => {
              img.onload = res; img.onerror = rej; img.src = p.dataUrl;
            });
            const w = Math.max(1, Math.floor(img.naturalWidth * scale));
            const h = Math.max(1, Math.floor(img.naturalHeight * scale));
            const canvas = document.createElement('canvas');
            canvas.width = w; canvas.height = h;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, w, h);
            const compressed = canvas.toDataURL('image/jpeg', scaleQual);
            if (!p._origDataUrl) p._origDataUrl = original;
            p.dataUrl = compressed;
            changed = true;
          }
          if (changed && window.Book && Book.put) await Book.put(b);
        }
        if (out) { out.textContent = '圧縮が完了しました。使用量を再計測してください。'; }
        showToast && showToast('プレビュー解像度を下げました', 'ok');
      } catch (e) {
        if (out) { out.textContent = '圧縮に失敗しました'; }
      }
    }
    async function restoreThumbnailsFromBackup() {
      if (!confirm('プレビューを元画像に戻しますか？（圧縮前のデータを `_origDataUrl` から復元します）')) return;
      const out = document.getElementById('storageStats');
      if (out) { out.textContent = '復元中…'; }
      try {
        const books = await Book.list();
        for (const b of books) {
          let changed = false;
          for (let i = 0; i < (b.pages || []).length; i++) {
            const p = b.pages[i];
            const blob = await getPageBlob(p.id);
            const backup = blob?.backupDataUrl || p._origDataUrl;
            if (backup) {
              p.dataUrl = backup;
              delete p._origDataUrl;
              changed = true;
            }
          }
          if (changed && window.Book && Book.put) await Book.put(b);
        }
        if (out) { out.textContent = '元画像に戻しました。使用量を再計測してください。'; }
        showToast && showToast('プレビューを元画像に戻しました', 'ok');
      } catch (e) {
        if (out) { out.textContent = '復元に失敗しました'; }
      }
    }
    function loadAnswerPageMap(baseId, targetId) {
      if (!baseId || !targetId) return {};
      return loadStoredJSON(`${ANSWER_PAGE_MAP_PREFIX}${baseId}:${targetId}`) || {};
    }
    function saveAnswerPageMap(baseId, targetId, map) {
      if (!baseId || !targetId) return;
      saveStoredJSON(`${ANSWER_PAGE_MAP_PREFIX}${baseId}:${targetId}`, map || {});
    }
    function setAnswerPageMapping(baseId, targetId, realPage, answerIndex) {
      if (!baseId || !targetId || typeof realPage !== 'number') return;
      const map = loadAnswerPageMap(baseId, targetId);
      map[realPage] = answerIndex;
      saveAnswerPageMap(baseId, targetId, map);
    }
    function getAnswerPageMapping(baseId, targetId, realPage) {
      if (!baseId || !targetId || typeof realPage !== 'number') return null;
      const map = loadAnswerPageMap(baseId, targetId);
      return (map && typeof map[realPage] === 'number') ? map[realPage] : null;
    }
    function currentAnswerBaseId() {
      // For completed-page viewer, use the original book id so answer mappings are shared
      const currBook = (typeof book !== 'undefined' && book) ? book : (viewerMemory?.book?.ref || null);
      const currPage = (typeof page !== 'undefined' && Number.isFinite(page))
        ? page
        : (Number.isFinite(viewerMemory?.book?.page) ? viewerMemory.book.page : null);
      try {
        if (state?.viewerContext === 'completed' && Array.isArray(currBook?.pages) && Number.isFinite(currPage)) {
          const meta = currBook.pages[currPage];
          if (meta && meta._sourceBookId) return meta._sourceBookId;
        }
      } catch (_) { }
      return currBook?.id || viewerMemory?.book?.id || null;
    }
    function getLastBoxView() {
      const obj = loadStoredJSON(LAST_BOX_VIEW_KEY);
      if (!obj || !obj.boxId) return null;
      return obj;
    }
    function setLastBoxView(boxId, index) {
      if (!boxId) return;
      saveStoredJSON(LAST_BOX_VIEW_KEY, { boxId, index });
    }
    function collectHiddenAnswerIds(books) {
      const set = new Set();
      (books || []).forEach(b => {
        const links = Array.isArray(b.answerBookIds) ? b.answerBookIds : [];
        links.forEach(id => { if (id && id !== b.id) set.add(id); });
      });
      return set;
    }

    /** ===== State & Utils ===== */
    const state = {
      view: 'library',
      viewMode: 'grid',
      sort: '-createdAt',
      tagFilter: null,
      folderFilter: null,
      search: '',
      showAnswers: loadStoredBool(LIBRARY_SHOW_ANSWERS_KEY, false),
      activeTab: 'home',
      viewerContext: null // 'book' | 'box' | 'completed'
    };
    const isBookViewerContext = () => state.viewerContext === 'book' || state.viewerContext === 'completed';
    let hiddenAnswerIdsCache = new Set();
    let currentMode = 'single';
    let compareHideBtn = null;
    let compareRightHidden = false;
    let homeAutoTimer = null;
    let homeHoverLock = false;
    let homeCompletedDate = null;
    let homeReviewMode = false;
    const homeReviewState = {
      rangeMode: 'all',
      anchor: '',
      start: '',
      end: '',
      recentDays: 7,
      bookId: '',
      sort: 'newest',
      kind: 'completed',
      search: '',
      pageFilter: '',
      completeDate: '',
      pageMapBookId: '',
      pageMapOpen: false
    };
    let homeReviewRefreshTimer = null;
    const MISS_TYPES = [
      { id: 'important', label: '重要', short: '要', color: '#ef4444' },
      { id: 'hard', label: '難', short: '難', color: '#f59e0b' },
      { id: 'note', label: '注', short: '注', color: '#f97316' },
      { id: 'careless', label: '凡ミス', short: '凡', color: '#3b82f6' },
      { id: 'lack', label: '理解不足', short: '不', color: '#22c55e' },
      { id: 'remember', label: '覚える', short: '覚', color: '#a855f7' },
      { id: 'question', label: '？', short: '？', color: '#06b6d4' }
    ];
    const MISS_STORAGE_KEY = 'study-miss-marks-v1';
    const MISS_TYPE_MAP = MISS_TYPES.reduce((acc, t) => { acc[t.id] = t; return acc; }, {});
    const MISS_TYPE_IDS = MISS_TYPES.map(t => t.id);
    const MissStore = (() => {
      const STORAGE_KEY = MISS_STORAGE_KEY;
      const STORAGE_VERSION = 1;
      let storageCache = null;
      let storageSaveTimer = null;
      const clamp01 = (v) => Math.max(0, Math.min(1, v || 0));
      const safeNum = (v, fallback = 0.5) => (Number.isFinite(v) ? v : fallback);
      const loadStorage = () => {
        if (storageCache) return storageCache;
        const raw = loadStoredJSON(STORAGE_KEY);
        if (raw && typeof raw === 'object') {
          if (raw.version === STORAGE_VERSION && raw.books && typeof raw.books === 'object') {
            storageCache = raw;
            return storageCache;
          }
          if (raw.books && typeof raw.books === 'object') {
            storageCache = { version: STORAGE_VERSION, books: raw.books };
            return storageCache;
          }
          storageCache = { version: STORAGE_VERSION, books: raw };
          return storageCache;
        }
        storageCache = { version: STORAGE_VERSION, books: {} };
        return storageCache;
      };
      const scheduleStorageSave = (immediate = false) => {
        if (!storageCache) return;
        const commit = () => {
          storageSaveTimer = null;
          saveStoredJSON(STORAGE_KEY, storageCache);
        };
        if (immediate) {
          if (storageSaveTimer) { clearTimeout(storageSaveTimer); storageSaveTimer = null; }
          commit();
          return;
        }
        if (storageSaveTimer) return;
        storageSaveTimer = setTimeout(commit, 120);
      };
      const readStoredPageMarks = (bookId, pageIndex) => {
        if (!bookId || !Number.isFinite(pageIndex)) return [];
        const store = loadStorage();
        const bookKey = String(bookId);
        const pageKey = String(pageIndex);
        const page = store.books?.[bookKey]?.[pageKey];
        return Array.isArray(page) ? page : [];
      };
      const writeStoredPageMarks = (bookId, pageIndex, marks, { immediate = false } = {}) => {
        if (!bookId || !Number.isFinite(pageIndex)) return;
        const store = loadStorage();
        const bookKey = String(bookId);
        const pageKey = String(pageIndex);
        if (!store.books) store.books = {};
        if (!marks || !marks.length) {
          if (store.books[bookKey]) {
            delete store.books[bookKey][pageKey];
            if (Object.keys(store.books[bookKey]).length === 0) delete store.books[bookKey];
          }
        } else {
          if (!store.books[bookKey]) store.books[bookKey] = {};
          store.books[bookKey][pageKey] = marks;
        }
        scheduleStorageSave(immediate);
      };
      const normalizeMark = (mark = {}) => {
        if (!mark || typeof mark !== 'object') return null;
        const type = MISS_TYPE_MAP[mark.type] ? mark.type : 'important';
        const x = clamp01(safeNum(mark.x ?? mark.rx ?? mark.xRatio, 0.5));
        const y = clamp01(safeNum(mark.y ?? mark.ry ?? mark.yRatio, 0.5));
        const createdAt = Number.isFinite(mark.createdAt) ? mark.createdAt : Date.now();
        const updatedAt = Number.isFinite(mark.updatedAt) ? mark.updatedAt : createdAt;
        const checks = Number.isFinite(mark.checks)
          ? mark.checks
          : (Number.isFinite(mark.points) ? mark.points : 0);
        const name = String(mark.name || '').trim();
        const reason = String(mark.reason || mark.memo || '').trim();
        const rawExplain = String(mark.explain || '').trim();
        const rawCommentary = String(mark.commentary || '').trim();
        const explain = rawExplain && rawCommentary && rawExplain !== rawCommentary
          ? `${rawExplain}\n${rawCommentary}`
          : (rawExplain || rawCommentary);
        return { id: mark.id || uuid(), type, x, y, createdAt, updatedAt, checks, name, reason, explain };
      };
      const normalizeMarks = (list) => (Array.isArray(list) ? list.map(m => normalizeMark(m)).filter(Boolean) : []);
      const ensurePage = (page, opts = {}) => {
        if (!page) return [];
        if (!Array.isArray(page.missMarks)) page.missMarks = [];
        let dirty = false;
        let next = normalizeMarks(page.missMarks);
        if (next.length !== page.missMarks.length) dirty = true;
        const bookId = opts.bookId;
        const pageIndex = opts.pageIndex;
        if (bookId && Number.isFinite(pageIndex)) {
          const storedRaw = readStoredPageMarks(bookId, pageIndex);
          const stored = normalizeMarks(storedRaw);
          if (stored.length || next.length) {
            const merged = new Map();
            next.forEach(m => merged.set(m.id, m));
            const storedMap = new Map();
            stored.forEach(m => storedMap.set(m.id, m));
            let storageDirty = false;
            next.forEach(m => {
              const st = storedMap.get(m.id);
              if (!st) { storageDirty = true; return; }
              const curTs = Number(m.updatedAt || m.createdAt || 0);
              const stTs = Number(st.updatedAt || st.createdAt || 0);
              if (curTs > stTs) storageDirty = true;
            });
            stored.forEach(m => {
              const cur = merged.get(m.id);
              if (!cur) {
                merged.set(m.id, m);
                dirty = true;
                return;
              }
              const curTs = Number(cur.updatedAt || cur.createdAt || 0);
              const stTs = Number(m.updatedAt || m.createdAt || 0);
              if (stTs > curTs) {
                merged.set(m.id, Object.assign({}, cur, m));
                dirty = true;
              }
            });
            if (dirty) next = Array.from(merged.values());
            if (storageDirty) writeStoredPageMarks(bookId, pageIndex, next);
          }
        }
        if (dirty) page.missMarks = next;
        return page.missMarks;
      };
      const realPageOf = (book, idx) => {
        if (!book) return null;
        if (Array.isArray(book.pageNumberMap)) {
          const val = book.pageNumberMap[idx];
          if (Number.isFinite(val)) return val;
        }
        const base = Number.isFinite(book.firstPageNumber) ? book.firstPageNumber : 1;
        return base + idx;
      };
      const listMarksForBook = (book) => {
        const out = [];
        if (!book?.pages) return out;
        book.pages.forEach((p, idx) => {
          const marks = ensurePage(p, { bookId: book.id, pageIndex: idx });
          marks.forEach(mark => {
            out.push({
              ...mark,
              bookId: book.id,
              bookTitle: book.title || '本',
              pageIndex: idx,
              realPage: realPageOf(book, idx)
            });
          });
        });
        return out;
      };
      const listMarksForBooks = (books) => {
        const out = [];
        (books || []).forEach(book => { out.push(...listMarksForBook(book)); });
        return out;
      };
      const addMark = (book, pageIndex, data = {}) => {
        if (!book?.pages || !Number.isFinite(pageIndex)) return null;
        const page = book.pages[pageIndex];
        const mark = normalizeMark({ ...data, id: uuid(), createdAt: Date.now(), updatedAt: Date.now() });
        const marks = ensurePage(page, { bookId: book.id, pageIndex });
        marks.push(mark);
        page.missMarks = marks;
        writeStoredPageMarks(book.id, pageIndex, marks, { immediate: true });
        return mark;
      };
      const updateMark = (book, pageIndex, markId, patch = {}) => {
        if (!book?.pages || !Number.isFinite(pageIndex) || !markId) return null;
        const page = book.pages[pageIndex];
        const marks = ensurePage(page, { bookId: book.id, pageIndex });
        const target = marks.find(m => m.id === markId);
        if (!target) return null;
        Object.assign(target, patch);
        target.updatedAt = Date.now();
        target.type = MISS_TYPE_MAP[target.type] ? target.type : 'important';
        target.x = clamp01(safeNum(target.x, 0.5));
        target.y = clamp01(safeNum(target.y, 0.5));
        target.checks = Number.isFinite(target.checks) ? target.checks : 0;
        target.name = String(target.name || '').trim();
        target.reason = String(target.reason || '').trim();
        target.explain = String(target.explain || '').trim();
        if ('commentary' in target) delete target.commentary;
        writeStoredPageMarks(book.id, pageIndex, marks, { immediate: true });
        return target;
      };
      const removeMark = (book, pageIndex, markId) => {
        if (!book?.pages || !Number.isFinite(pageIndex) || !markId) return false;
        const page = book.pages[pageIndex];
        const marks = ensurePage(page, { bookId: book.id, pageIndex });
        const idx = marks.findIndex(m => m.id === markId);
        if (idx < 0) return false;
        marks.splice(idx, 1);
        writeStoredPageMarks(book.id, pageIndex, marks, { immediate: true });
        return true;
      };
      const saveTimers = new Map();
      const queueSave = (book, { immediate = false } = {}) => {
        if (!book?.id || book._ephemeral || !Book?.put) return;
        const delay = immediate ? 0 : 300;
        const prev = saveTimers.get(book.id);
        if (prev) clearTimeout(prev);
        const timer = setTimeout(() => {
          saveTimers.delete(book.id);
          try { Book.put(book); } catch (e) { console.warn('[MissStore] save failed', e); }
        }, delay);
        saveTimers.set(book.id, timer);
      };
      const emitUpdate = (bookId) => {
        try { window.dispatchEvent(new CustomEvent('miss-marks-updated', { detail: { bookId } })); } catch (_) { }
      };
      try {
        window.addEventListener('settings:restored', () => { storageCache = null; });
      } catch (_) { }
      return {
        types: MISS_TYPES,
        typeMap: MISS_TYPE_MAP,
        typeIds: MISS_TYPE_IDS,
        ensurePage,
        normalizeMark,
        realPageOf,
        listMarksForBook,
        listMarksForBooks,
        addMark,
        updateMark,
        removeMark,
        queueSave,
        emitUpdate
      };
    })();
    window.MissStore = MissStore;
    async function jumpToMissMarker({ bookId, pageIndex, missId, x, y } = {}) {
      const targetBookId = bookId || null;
      if (!targetBookId || typeof Book?.get !== 'function' || typeof mountBookViewer !== 'function') {
        showToast && showToast('本を開けませんでした', 'error');
        return false;
      }
      const waitForViewerReady = async () => {
        for (let i = 0; i < 16; i++) {
          await new Promise(res => setTimeout(res, i === 0 ? 16 : 80));
          if (document.getElementById('jumpInput') && window.__viewerJumpToMiss) return true;
        }
        return false;
      };
      const jumpInsideViewer = (realPage) => {
        const jump = document.getElementById('jumpInput');
        const btn = document.getElementById('jumpGo');
        if (!jump || !btn) return false;
        jump.value = String(realPage);
        btn.click();
        return true;
      };
      const openBook = async () => {
        try {
          const book = await Book.get(targetBookId);
          if (!book) return false;
          const res = mountBookViewer(book, { startPage: Number.isFinite(pageIndex) ? pageIndex : 0 });
          if (res && typeof res.then === 'function') await res;
          await waitForViewerReady();
          return true;
        } catch (e) {
          console.warn('[jumpToMissMarker] open failed', e);
          return false;
        }
      };
      const currentBookId = viewerMemory?.book?.id || null;
      const readingReady = document.body?.classList.contains('reading') && document.getElementById('jumpInput');
      if (currentBookId && String(currentBookId) === String(targetBookId) && readingReady) {
        const bookRef = viewerMemory?.book?.ref || null;
        const realPage = Number.isFinite(pageIndex) ? MissStore.realPageOf(bookRef, pageIndex) : null;
        if (Number.isFinite(realPage)) jumpInsideViewer(realPage);
        await waitForViewerReady();
      } else {
        const ok = await openBook();
        if (!ok) { showToast && showToast('本を開けませんでした', 'error'); return false; }
      }
      if (window.__viewerJumpToMiss) {
        window.__viewerJumpToMiss({ x, y, missId });
      }
      return true;
    }
    window.__jumpToMissMarker = jumpToMissMarker;
    window.addEventListener('miss-marks-updated', () => {
      try { if (window.StudyActionMenu?.isOpen?.()) window.StudyActionMenu.render(false); } catch (_) { }
      try { if (homeReviewMode) renderHomeView(true); } catch (_) { }
    });
    const homeFormatDate = (d) => {
      if (!(d instanceof Date) || isNaN(d)) return '';
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      return `${y}-${m}-${day}`;
    };
    const homeParseDate = (str) => (str ? new Date(`${str}T00:00:00`) : new Date(NaN));
    const homeClampToToday = (str) => {
      const todayStr = homeFormatDate(new Date());
      if (!str) return todayStr;
      const d = homeParseDate(str);
      if (!(d instanceof Date) || isNaN(d)) return todayStr;
      const max = homeParseDate(todayStr);
      if (d > max) return todayStr;
      return homeFormatDate(d);
    };
    const homeParsePageNumber = (v) => {
      const n = typeof v === 'string' ? parseInt(v, 10) : Number(v);
      return Number.isFinite(n) ? n : null;
    };
    const homeParsePageList = (input) => {
      const raw = String(input || '').trim();
      if (!raw) return [];
      const cleaned = raw.replace(/[ＰｐP]/g, '');
      const tokens = cleaned.split(/[\s,、]+/).map(t => t.trim()).filter(Boolean);
      const pages = new Set();
      const addRange = (start, end) => {
        const s = Math.min(start, end);
        const e = Math.max(start, end);
        for (let i = s; i <= e; i++) pages.add(i);
      };
      tokens.forEach(token => {
        const rangeMatch = token.match(/^(\d+)\s*(?:-|\~|〜|\.\.)\s*(\d+)$/);
        if (rangeMatch) {
          const s = homeParsePageNumber(rangeMatch[1]);
          const e = homeParsePageNumber(rangeMatch[2]);
          if (Number.isFinite(s) && Number.isFinite(e)) addRange(s, e);
          return;
        }
        const num = homeParsePageNumber(token);
        if (Number.isFinite(num)) pages.add(num);
      });
      return Array.from(pages).sort((a, b) => a - b);
    };
    const homeRealPageOf = (book, idx) => {
      if (!book) return idx + 1;
      if (window.MissStore?.realPageOf) return MissStore.realPageOf(book, idx);
      if (Array.isArray(book.pageNumberMap)) {
        const val = book.pageNumberMap[idx];
        if (Number.isFinite(val)) return val;
      }
      const base = Number.isFinite(book.firstPageNumber) ? book.firstPageNumber : 1;
      return base + idx;
    };
    const scheduleHomeReviewRefresh = () => {
      if (homeReviewRefreshTimer) return;
      homeReviewRefreshTimer = setTimeout(() => {
        homeReviewRefreshTimer = null;
        renderHomeView(true);
      }, 120);
    };
    const setHomeCompletedDate = (str) => {
      homeCompletedDate = homeClampToToday(str);
      renderHomeView(true);
    };
    const setHomeReviewMode = (next) => {
      homeReviewMode = !!next;
      const home = document.getElementById('homeView');
      if (home) home.classList.toggle('home-review-mode', homeReviewMode);
      renderHomeView(true);
    };
    const MENU_ACTIONS_KEY = 'viewer-menu-actions';
    const DEFAULT_MENU_ACTIONS = ['toggleSpread', 'compareToggle', 'toggleSelect', 'insert', 'resetView', 'clearAllDraw', 'toggleHideRight', 'compareWindowToggle', 'linkedAnswerCompareQuick', 'linkedAnswerWindowQuick', 'thumbGrid', 'preloadAllToggle'];
    const BOX_MENU_ACTIONS = ['resetView', 'toggleZoomLock', 'togglePanLock', 'toggleSliceView', 'fitContain', 'fitWidth', 'prevPage', 'nextPage', 'menuJump', 'toggleMemoPanel', 'toggleMemoWindow', 'toggleFav', 'toggleWeak', 'toggleDone', 'multiToggle', 'multiAll', 'multiNone', 'multiDelete', 'multiState'];
    const MENU_REQUIRED_ACTIONS = ['compareWindowToggle', 'linkedAnswerCompareQuick', 'linkedAnswerWindowQuick'];
    const safePrimaryAnswerId = () => { try { return (typeof primaryAnswerId === 'function') ? primaryAnswerId() : null; } catch (e) { return null; } };
    const safeTriggerPrimaryAnswer = (mode) => { try { if (typeof triggerPrimaryAnswer === 'function') triggerPrimaryAnswer(mode); } catch (e) { } };
    function viewerRoot() { return document.getElementById('viewerView'); }
    function viewerControl(id) { return viewerRoot()?.querySelector(`#${id}`); }
    function clickViewerControl(id) {
      const el = viewerControl(id);
      el?.click();
      return Boolean(el);
    }
    function focusViewerControl(id) {
      const el = viewerControl(id);
      if (!el) return false;
      el.focus?.();
      el.select?.();
      return true;
    }
    const menuActionDefs = {
      toggleSpread: { id: 'toggleSpread', label: '見開き', onClick: () => clickViewerControl('spreadToggle') },
      compareToggle: { id: 'compareToggle', label: '比較ON', onClick: () => { if (currentMode === 'compare') { clickViewerControl('compareEnd'); } else { clickViewerControl('compareStart'); } }, updateButton: (btn) => { btn.textContent = currentMode === 'compare' ? '比較OFF' : '比較ON'; } },
      toggleSelect: { id: 'toggleSelect', label: '切り取り', onClick: () => clickViewerControl('selectBtn') },
      insert: { id: 'insert', label: '挿入', onClick: () => clickViewerControl('insertBtn') },
      replacePage: { id: 'replacePage', label: '差し替え', onClick: () => clickViewerControl('replaceBtn') },
      deletePage: { id: 'deletePage', label: 'ページ削除', onClick: () => clickViewerControl('deletePageBtn') },
      resetView: { id: 'resetView', label: '表示リセット', onClick: () => window.__viewerResetView?.({ toast: true }) },
      clearAllDraw: { id: 'clearAllDraw', label: '線データ全削除', onClick: () => { try { clearAllDrawData && clearAllDrawData(); } catch (_) { } }, updateButton: (btn) => { btn.disabled = !viewerMemory?.book?.id; } },
      toggleHideRight: { id: 'toggleHideRight', label: '右側隠す', onClick: () => compareHideBtn?.click(), updateButton: (btn) => { btn.disabled = (currentMode !== 'compare'); btn.textContent = compareRightHidden ? '右側表示' : '右側隠す'; } },
      compareWindowToggle: { id: 'compareWindowToggle', label: '比較ウィンドウ', onClick: () => clickViewerControl('compareWindowBtn'), updateButton: (btn) => { const open = document.getElementById('compareWindow')?.classList.contains('open'); btn.textContent = open ? '比較ウィンドウOFF' : '比較ウィンドウON'; } },
      compareWindowPrev: { id: 'compareWindowPrev', label: '比較ウィンドウ前', onClick: () => clickViewerControl('compareWindowPrev'), updateButton: (btn) => { const open = document.getElementById('compareWindow')?.classList.contains('open'); const target = viewerControl('compareWindowPrev'); btn.disabled = !open || !target || target.disabled; } },
      compareWindowNext: { id: 'compareWindowNext', label: '比較ウィンドウ次', onClick: () => clickViewerControl('compareWindowNext'), updateButton: (btn) => { const open = document.getElementById('compareWindow')?.classList.contains('open'); const target = viewerControl('compareWindowNext'); btn.disabled = !open || !target || target.disabled; } },
      compareWindowSelect: { id: 'compareWindowSelect', label: '比較ウィンドウ選択', onClick: () => openComparePicker?.('window'), updateButton: (btn) => { btn.disabled = false; btn.textContent = '比較ウィンドウ選択'; } },
      compareWindowSync: { id: 'compareWindowSync', label: '比較ウィンドウ透明', onClick: () => clickViewerControl('compareWindowSync'), updateButton: (btn) => { const el = viewerControl('compareWindowSync'); btn.disabled = !el; const active = el?.classList.contains('active'); btn.textContent = active ? '透明ON' : '透明'; } },
      compareWindowJump: { id: 'compareWindowJump', label: '比較ウィンドウ入力', onClick: () => clickViewerControl('compareWindowRegister'), updateButton: (btn) => { btn.disabled = false; } },
      prevPage: { id: 'prevPage', label: '前ページ', onClick: () => clickViewerControl('prevBtn') },
      nextPage: { id: 'nextPage', label: '次ページ', onClick: () => clickViewerControl('nextBtn') },
      jumpFocus: { id: 'jumpFocus', label: 'ページ入力', onClick: () => { try { focusPageJumpInput && focusPageJumpInput(); return true; } catch (_) { return focusViewerControl('jumpInput'); } } },
      menuJump: {
        id: 'menuJump',
        label: 'クイック移動',
        render: () => {
          const wrap = document.createElement('div');
          wrap.className = 'quick-field';
          const input = document.createElement('input');
          input.type = 'number';
          input.placeholder = 'ページ番号';
          input.min = '1';
          const btn = document.createElement('button');
          btn.className = 'btn small';
          btn.textContent = '移動';
          const commit = () => {
            const value = parseInt(input.value, 10);
            if (Number.isNaN(value)) return;
            const jumpInput = viewerControl('jumpInput');
            const jumpGo = viewerControl('jumpGo');
            if (jumpInput) jumpInput.value = value;
            if (jumpGo) { jumpGo.click(); }
            input.value = '';
          };
          btn.onclick = (e) => { e.stopPropagation(); commit(); };
          input.addEventListener('keydown', (e) => {
            e.stopPropagation();
            if (e.key === 'Enter') { e.preventDefault(); commit(); }
          });
          wrap.appendChild(input);
          wrap.appendChild(btn);
          return { element: wrap, control: input };
        }
      },
      openBookMenu: { id: 'openBookMenu', label: 'メニューを開く', onClick: () => clickViewerControl('bookMenuBtn') },
      openStageMenu: { id: 'openStageMenu', label: 'ステージ操作', onClick: () => clickViewerControl('stageMenuBtn') },
      toggleMemoPanel: { id: 'toggleMemoPanel', label: 'メモ欄', onClick: () => clickViewerControl('memoToggle'), updateButton: (btn) => { const memoBtn = viewerControl('memoToggle'); btn.textContent = memoBtn?.textContent?.trim() || 'メモ欄'; } },
      toggleMemoWindow: { id: 'toggleMemoWindow', label: 'ミニメモ', onClick: () => clickViewerControl('memoMiniBtn'), updateButton: (btn) => { const open = document.getElementById('memoWindow')?.classList.contains('open'); btn.textContent = open ? 'ミニメモを閉じる' : 'ミニメモを開く'; } },
      focusMemo: { id: 'focusMemo', label: 'メモを書く', onClick: () => focusViewerControl('pageMemo') },
      linkedAnswerQuick: {
        id: 'linkedAnswerQuick',
        label: '解答クイック',
        render: () => {
          const wrap = document.createElement('div');
          wrap.className = 'quick-field';
          wrap.style.gap = '6px';
          const select = document.createElement('select');
          select.className = 'input';
          select.style.minWidth = '160px';
          const btnCompare = document.createElement('button');
          btnCompare.className = 'btn small';
          btnCompare.textContent = '並べて比較';
          const btnWindow = document.createElement('button');
          btnWindow.className = 'btn small ghost';
          btnWindow.textContent = '解答ウィンドウ';
          const refreshOptions = () => {
            select.innerHTML = '';
            const chips = [...document.querySelectorAll('#linkedAnswerQuick .answer-chip')];
            if (!chips.length) {
              const opt = document.createElement('option'); opt.value = ''; opt.textContent = '解答なし';
              select.appendChild(opt); select.disabled = true; btnCompare.disabled = true; btnWindow.disabled = true;
              return;
            }
            select.disabled = false; btnCompare.disabled = false; btnWindow.disabled = false;
            chips.forEach(ch => {
              const opt = document.createElement('option');
              opt.value = ch.dataset.answer || '';
              opt.textContent = ch.querySelector('strong')?.textContent || '解答';
              select.appendChild(opt);
            });
          };
          const triggerAction = (action) => {
            const val = select.value;
            if (!val) return;
            const chip = document.querySelector(`#linkedAnswerQuick .answer-chip[data-answer="${val}"]`);
            const btn = chip?.querySelector(`button[data-action="${action}"]`);
            btn?.click();
          };
          btnCompare.onclick = (e) => { e.stopPropagation(); triggerAction('split'); };
          btnWindow.onclick = (e) => { e.stopPropagation(); triggerAction('window'); };
          wrap.appendChild(select);
          wrap.appendChild(btnCompare);
          wrap.appendChild(btnWindow);
          refreshOptions();
          wrap.__refreshLinkedAnswers = refreshOptions;
          return { element: wrap, control: select };
        },
        updateButton: (el) => {
          if (el?.__refreshLinkedAnswers) { el.__refreshLinkedAnswers(); }
        }
      },
      linkedAnswerCompareQuick: { id: 'linkedAnswerCompareQuick', label: '解答比較(先頭)', onClick: () => safeTriggerPrimaryAnswer('compare'), updateButton: (btn) => { const ok = safePrimaryAnswerId() != null; btn.disabled = !ok; } },
      linkedAnswerWindowQuick: { id: 'linkedAnswerWindowQuick', label: '解答ウィンドウ(先頭)', onClick: () => safeTriggerPrimaryAnswer('window'), updateButton: (btn) => { const ok = safePrimaryAnswerId() != null; btn.disabled = !ok; } },
      toggleFav: { id: 'toggleFav', label: '★お気に入り', onClick: () => clickViewerControl('stFav'), updateButton: (btn) => { const chk = viewerControl('stFav'); if (!chk) { btn.disabled = true; return; } btn.disabled = false; btn.textContent = chk.checked ? '★お気に入りOFF' : '★お気に入りON'; } },
      toggleWeak: { id: 'toggleWeak', label: '×苦手', onClick: () => clickViewerControl('stWeak'), updateButton: (btn) => { const chk = viewerControl('stWeak'); if (!chk) { btn.disabled = true; return; } btn.disabled = false; btn.textContent = chk.checked ? '×苦手OFF' : '×苦手ON'; } },
      toggleDone: { id: 'toggleDone', label: '✓完了', onClick: () => clickViewerControl('stDone'), updateButton: (btn) => { const chk = viewerControl('stDone'); if (!chk) { btn.disabled = true; return; } btn.disabled = false; btn.textContent = chk.checked ? '✓完了解除' : '✓完了ON'; } },
      toggleZoomLock: { id: 'toggleZoomLock', label: 'ズームロック', onClick: () => clickViewerControl('zoomLockBtn'), updateButton: (btn) => { const locked = viewerControl('zoomLockBtn')?.classList.contains('active'); btn.textContent = locked ? 'ズーム解除' : 'ズームロック'; } },
      togglePanLock: { id: 'togglePanLock', label: '移動ロック', onClick: () => clickViewerControl('panLockBtn'), updateButton: (btn) => { const locked = viewerControl('panLockBtn')?.classList.contains('active'); btn.textContent = locked ? '移動解除' : '移動ロック'; } },
      toggleSliceView: { id: 'toggleSliceView', label: 'ハーフ表示', onClick: () => clickViewerControl('sliceViewBtn'), updateButton: (btn) => { const active = viewerControl('sliceViewBtn')?.classList.contains('active'); btn.textContent = active ? 'ハーフ解除' : 'ハーフ表示'; } },
      fitContain: { id: 'fitContain', label: 'フィット', onClick: () => clickViewerControl('fitContain') },
      fitWidth: { id: 'fitWidth', label: '幅フィット', onClick: () => clickViewerControl('fitWidth') },
      flipScrub: {
        id: 'flipScrub',
        label: 'めくりゲージ',
        render: () => {
          const wrap = document.createElement('div');
          wrap.className = 'quick-slider';
          const slider = document.createElement('input');
          slider.type = 'range';
          slider.min = '1';
          slider.step = '1';
          slider.value = '1';
          slider.addEventListener('input', () => {
            const scrub = document.getElementById('scrubRange');
            if (!scrub) return;
            scrub.value = slider.value;
            scrub.dispatchEvent(new Event('input', { bubbles: true }));
          });
          wrap.appendChild(slider);
          return { element: wrap, control: slider };
        },
        updateButton: (slider) => {
          const scrub = document.getElementById('scrubRange');
          if (!slider || !scrub) return;
          const maxValue = scrub.getAttribute('max') || scrub.max || scrub.value || '1';
          slider.max = maxValue;
          slider.value = scrub.value || slider.value || '1';
        }
      },
      flipPlay: { id: 'flipPlay', label: 'めくり開始', onClick: () => clickViewerControl('flipPlay') },
      flipStop: { id: 'flipStop', label: 'めくり停止', onClick: () => clickViewerControl('flipStop') },
      floatPrev: { id: 'floatPrev', label: 'フロート前', onClick: () => clickViewerControl('fPrev') },
      floatNext: { id: 'floatNext', label: 'フロート次', onClick: () => clickViewerControl('fNext') },
      floatJump: { id: 'floatJump', label: 'フロート入力', onClick: () => focusViewerControl('fJump') },
      floatGo: { id: 'floatGo', label: 'フロート移動', onClick: () => clickViewerControl('fGo') },
      floatSelect: { id: 'floatSelect', label: 'フロート選択', onClick: () => clickViewerControl('fSelect') },
      multiToggle: { id: 'multiToggle', label: '複数選択ON/OFF', onClick: () => clickViewerControl('multiToggle') },
      multiAll: { id: 'multiAll', label: 'すべて選択', onClick: () => clickViewerControl('multiAll') },
      multiNone: { id: 'multiNone', label: '選択解除', onClick: () => clickViewerControl('multiNone') },
      multiMove: { id: 'multiMove', label: '選択を移動', onClick: () => clickViewerControl('multiMove') },
      multiCopy: { id: 'multiCopy', label: '選択をコピー', onClick: () => clickViewerControl('multiCopy') },
      multiDelete: { id: 'multiDelete', label: '選択を削除', onClick: () => clickViewerControl('multiDelete') },
      multiState: { id: 'multiState', label: '選択の状態', onClick: () => clickViewerControl('multiSet') },
      multiNewBook: { id: 'multiNewBook', label: '選択から新本', onClick: () => clickViewerControl('multiNewBook') },
      thumbGrid: {
        id: 'thumbGrid',
        label: '📖 全ページ一覧',
        onClick: () => {
          if (viewerMemory?.book && typeof window.__openThumbGrid === 'function') {
            const goTo = (idx) => {
              const jumpInput = viewerControl('jumpInput');
              const jumpGo = viewerControl('jumpGo');
              const firstPage = viewerMemory.book.firstPageNumber || 1;
              if (jumpInput) jumpInput.value = String(firstPage + idx);
              if (jumpGo) jumpGo.click();
            };
            window.__openThumbGrid(viewerMemory.book, viewerMemory.page || 0, goTo);
          }
        }
      },
      preloadAllToggle: {
        id: 'preloadAllToggle',
        label: '全ページ先読み',
        onClick: () => {
          if (viewerMemory?.book && typeof window.__preloadAllPages === 'function') {
            window.__preloadAllPages(viewerMemory.book, (loaded, total) => {
              if (typeof showToast === 'function' && loaded === total) {
                showToast(`全${total}ページの先読み完了`, 'ok');
              }
            });
          }
        }
      }
    };
    let menuActionConfig = [];
    function loadMenuActionConfig() {
      try {
        const raw = localStorage.getItem(MENU_ACTIONS_KEY);
        if (raw) {
          const arr = JSON.parse(raw);
          if (Array.isArray(arr)) {
            menuActionConfig = arr.filter(id => menuActionDefs[id]);
            MENU_REQUIRED_ACTIONS.forEach(id => { if (menuActionDefs[id] && !menuActionConfig.includes(id)) menuActionConfig.push(id); });
            return;
          }
        }
      } catch (err) { console.warn('menu action config load failed', err); }
      menuActionConfig = [...DEFAULT_MENU_ACTIONS];
      MENU_REQUIRED_ACTIONS.forEach(id => { if (menuActionDefs[id] && !menuActionConfig.includes(id)) menuActionConfig.push(id); });
    }
    function saveMenuActionConfig() {
      try { localStorage.setItem(MENU_ACTIONS_KEY, JSON.stringify(menuActionConfig)); } catch (err) { }
    }
    loadMenuActionConfig();
    let menuActionsContainerRef = null;
    let menuActionSettingsRef = null;
    // key navigation settings DOM refs
    const keyNavForm = {
      panStep: document.getElementById('keyPanStep'),
      panStepVal: document.getElementById('keyPanStepVal'),
      panStepReset: document.getElementById('keyPanStepReset'),
      zoomStep: document.getElementById('keyZoomStep'),
      zoomStepVal: document.getElementById('keyZoomStepVal'),
      zoomStepReset: document.getElementById('keyZoomStepReset'),
      panDecay: document.getElementById('keyPanDecay'),
      panDecayVal: document.getElementById('keyPanDecayVal'),
      panDecayReset: document.getElementById('keyPanDecayReset'),
      zoomDecay: document.getElementById('keyZoomDecay'),
      zoomDecayVal: document.getElementById('keyZoomDecayVal'),
      zoomDecayReset: document.getElementById('keyZoomDecayReset'),
      holdMs: document.getElementById('keyHoldMs'),
      left: document.getElementById('keyLeftKeys'),
      right: document.getElementById('keyRightKeys'),
      up: document.getElementById('keyUpKeys'),
      down: document.getElementById('keyDownKeys'),
      zin: document.getElementById('keyZoomInKeys'),
      zout: document.getElementById('keyZoomOutKeys'),
      pageNext: document.getElementById('keyPageNextKeys'),
      pagePrev: document.getElementById('keyPagePrevKeys'),
      reset: document.getElementById('keyResetKeys'),
      studyMenu: document.getElementById('keyStudyMenuKeys'),
      resetZoomOnlyToggle: document.getElementById('resetZoomOnlyToggle'),
      leftCapture: document.getElementById('keyLeftCapture'),
      rightCapture: document.getElementById('keyRightCapture'),
      upCapture: document.getElementById('keyUpCapture'),
      downCapture: document.getElementById('keyDownCapture'),
      zinCapture: document.getElementById('keyZoomInCapture'),
      zoutCapture: document.getElementById('keyZoomOutCapture'),
      pageNextCapture: document.getElementById('keyPageNextCapture'),
      pagePrevCapture: document.getElementById('keyPagePrevCapture'),
      resetCapture: document.getElementById('keyResetCapture'),
      studyMenuCapture: document.getElementById('keyStudyMenuCapture'),
      answerToggle: document.getElementById('keyAnswerToggle'),
      answerToggleCapture: document.getElementById('keyAnswerToggleCapture'),
      clamp: document.getElementById('keyClamp'),
      save: document.getElementById('keyNavSave'),
      resetDefaults: document.getElementById('keyNavResetDefaults')
    };
    const viewerClockForm = {
      position: document.getElementById('viewerClockPosition'),
      visible: document.getElementById('viewerClockVisible'),
      format: document.getElementById('viewerClockFormat'),
      seconds: document.getElementById('viewerClockSeconds'),
      design: document.getElementById('viewerClockDesign'),
      toggleKey: document.getElementById('viewerClockToggleKey'),
      toggleCapture: document.getElementById('viewerClockToggleCapture'),
      fontUpload: document.getElementById('viewerClockFontUpload'),
      fontLabel: document.getElementById('viewerClockFontLabel'),
      textColor: document.getElementById('viewerClockTextColor'),
      borderColor: document.getElementById('viewerClockBorderColor'),
      textScale: document.getElementById('viewerClockTextScale'),
      textScaleVal: document.getElementById('viewerClockTextScaleVal')
    };
    const flyClockForm = {
      plannerKey: document.getElementById('flyPlannerKey'),
      plannerKeyCapture: document.getElementById('flyPlannerKeyCapture'),
      plannerPos: document.getElementById('flyPlannerPos'),
      numberlineKey: document.getElementById('flyNumberlineKey'),
      numberlineKeyCapture: document.getElementById('flyNumberlineKeyCapture'),
      numberlinePos: document.getElementById('flyNumberlinePos'),
      numberlineCount: document.getElementById('flyNumberlineCount')
    };
    const parseList = (val) => { return (val || '').split(',').map(s => s.trim()).filter(Boolean); };
    const keyActionInputs = new Map();
    const initKeyActionInputs = () => {
      const host = document.getElementById('keyActionExtras');
      if (!host) return;
      host.innerHTML = '';
      keyActionInputs.clear();
      KEY_ACTION_DEFS.forEach(def => {
        const wrap = document.createElement('label');
        wrap.style.display = 'block';
        wrap.dataset.action = def.id;
        const title = document.createElement('div');
        title.textContent = def.label;
        const row = document.createElement('div');
        row.className = 'row';
        row.style.gap = '6px';
        const input = document.createElement('input');
        input.className = 'input';
        input.placeholder = def.placeholder || '';
        input.autocomplete = 'off';
        input.id = `keyAction_${def.id}`;
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'mini-menu';
        btn.textContent = '設定';
        row.appendChild(input);
        row.appendChild(btn);
        wrap.appendChild(title);
        wrap.appendChild(row);
        host.appendChild(wrap);
        keyActionInputs.set(def.id, { input, capture: btn });
        wireKeyCapture(btn, input);
      });
    };
    const getActionBinding = (id) => {
      const cur = keyNavConfig.actionBindings || {};
      const fallback = DEFAULT_KEY_NAV_CONFIG.actionBindings || {};
      const list = Array.isArray(cur?.[id]) ? cur[id] : (Array.isArray(fallback?.[id]) ? fallback[id] : []);
      return list;
    };
    const syncKeyActionInputs = () => {
      keyActionInputs.forEach(({ input }, id) => {
        if (!input) return;
        input.value = getActionBinding(id).join(', ');
      });
    };
    const collectActionBindings = () => {
      const merged = mergeActionBindings(keyNavConfig.actionBindings || {});
      keyActionInputs.forEach(({ input }, id) => {
        merged[id] = parseList(input?.value);
      });
      return merged;
    };
    const wireKeyCapture = (button, input) => {
      if (!button || !input) return;
      const stopHint = () => {
        button.disabled = false;
        button.textContent = '設定';
      };
      const startCapture = () => {
        button.disabled = true;
        button.textContent = '入力待ち…';
        input.focus();
        input.select?.();
        const handler = (e) => {
          e.preventDefault();
          const keyName = e.key === ' ' ? 'Space' : e.key;
          input.value = keyName;
          cleanup();
        };
        const cleanup = () => {
          input.removeEventListener('keydown', handler, true);
          input.removeEventListener('blur', cleanup, true);
          stopHint();
        };
        input.addEventListener('keydown', handler, true);
        input.addEventListener('blur', cleanup, true);
      };
      button.addEventListener('click', (e) => { e.preventDefault(); startCapture(); });
    };
    const syncViewerClockSettings = () => {
      if (!viewerClockForm.position) return;
      viewerClockForm.position.value = viewerClockConfig.position || DEFAULT_VIEWER_CLOCK.position;
      viewerClockForm.visible.checked = viewerClockConfig.visible !== false;
      viewerClockForm.format.value = viewerClockConfig.format || DEFAULT_VIEWER_CLOCK.format;
      viewerClockForm.seconds.checked = viewerClockConfig.showSeconds !== false;
      viewerClockForm.design.value = viewerClockConfig.design || DEFAULT_VIEWER_CLOCK.design;
      viewerClockForm.toggleKey.value = viewerClockConfig.toggleKey || '';
      if (viewerClockForm.fontLabel) viewerClockForm.fontLabel.textContent = viewerClockConfig.fontName || '標準フォント';
      if (viewerClockForm.textColor) viewerClockForm.textColor.value = viewerClockConfig.textColor || DEFAULT_VIEWER_CLOCK.textColor;
      if (viewerClockForm.borderColor) viewerClockForm.borderColor.value = viewerClockConfig.borderColor || DEFAULT_VIEWER_CLOCK.borderColor;
      if (viewerClockForm.textScale) {
        const raw = parseFloat(viewerClockConfig.textScale ?? DEFAULT_VIEWER_CLOCK.textScale);
        const scale = Number.isFinite(raw) ? Math.max(0.7, Math.min(2.2, raw)) : DEFAULT_VIEWER_CLOCK.textScale;
        viewerClockForm.textScale.value = scale;
        if (viewerClockForm.textScaleVal) {
          viewerClockForm.textScaleVal.textContent = `${Math.round(16 * scale)}px`;
        }
      }
      ensureViewerClockFont();
      applyViewerClockTextScale();
    };
    const syncFlyClockSettings = () => {
      if (!flyClockForm.plannerKey) return;
      flyClockForm.plannerKey.value = flyClockConfig.planner?.key || DEFAULT_FLY_CLOCK.planner.key;
      flyClockForm.plannerPos.value = flyClockConfig.planner?.position || DEFAULT_FLY_CLOCK.planner.position;
      flyClockForm.numberlineKey.value = flyClockConfig.numberline?.key || DEFAULT_FLY_CLOCK.numberline.key;
      flyClockForm.numberlinePos.value = flyClockConfig.numberline?.position || DEFAULT_FLY_CLOCK.numberline.position;
      if (flyClockForm.numberlineCount) flyClockForm.numberlineCount.value = flyClockConfig.numberline?.count || DEFAULT_FLY_CLOCK.numberline.count;
    };
    const updateViewerClockConfigAndApply = (next = {}) => {
      saveViewerClockConfig(next);
      syncViewerClockSettings();
      syncViewerClock(viewerClockContext);
    };
    const updateFlyClockConfig = (path, val) => {
      if (!path) return;
      const next = { ...flyClockConfig };
      const [key, prop] = path.split('.');
      if (!next[key]) next[key] = {};
      next[key][prop] = val;
      saveFlyClockConfig(next);
      flyClockConfig = next;
      applyFlyPos(plannerFly, flyClockConfig.planner?.position || 'right', flyClockConfig.planner);
      applyFlyPos(numberlineFly, flyClockConfig.numberline?.position || 'left', flyClockConfig.numberline);
      syncFlyClockSettings();
    };
    if (viewerClockForm.position) {
      viewerClockForm.position.addEventListener('change', (e) => updateViewerClockConfigAndApply({ position: e.target.value }));
    }
    if (viewerClockForm.visible) {
      viewerClockForm.visible.addEventListener('change', (e) => updateViewerClockConfigAndApply({ visible: e.target.checked }));
    }
    if (viewerClockForm.format) {
      viewerClockForm.format.addEventListener('change', (e) => updateViewerClockConfigAndApply({ format: e.target.value }));
    }
    if (viewerClockForm.seconds) {
      viewerClockForm.seconds.addEventListener('change', (e) => updateViewerClockConfigAndApply({ showSeconds: e.target.checked }));
    }
    if (viewerClockForm.design) {
      viewerClockForm.design.addEventListener('change', (e) => updateViewerClockConfigAndApply({ design: e.target.value, visible: true }));
    }
    if (viewerClockForm.textColor) {
      viewerClockForm.textColor.addEventListener('input', (e) => updateViewerClockConfigAndApply({ textColor: e.target.value }));
    }
    if (viewerClockForm.borderColor) {
      viewerClockForm.borderColor.addEventListener('input', (e) => updateViewerClockConfigAndApply({ borderColor: e.target.value }));
    }
    if (viewerClockForm.textScale) {
      viewerClockForm.textScale.addEventListener('input', (e) => {
        const raw = parseFloat(e.target.value);
        const scale = Number.isFinite(raw) ? Math.max(0.7, Math.min(2.2, raw)) : DEFAULT_VIEWER_CLOCK.textScale;
        updateViewerClockConfigAndApply({ textScale: scale });
      });
    }
    if (viewerClockForm.toggleCapture && viewerClockForm.toggleKey) {
      wireKeyCapture(viewerClockForm.toggleCapture, viewerClockForm.toggleKey);
      viewerClockForm.toggleKey.addEventListener('input', (e) => updateViewerClockConfigAndApply({ toggleKey: e.target.value }));
    }
    if (viewerClockForm.fontUpload) {
      viewerClockForm.fontUpload.addEventListener('change', (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = () => {
          const dataUrl = reader.result;
          const name = file.name.replace(/\.[^.]+$/, '') || 'ClockFont';
          updateViewerClockConfigAndApply({ fontDataUrl: dataUrl, fontName: name });
          ensureViewerClockFont();
        };
        reader.readAsDataURL(file);
      });
    }
    syncViewerClockSettings();
    // Fly clock settings
    if (flyClockForm.plannerPos) {
      flyClockForm.plannerPos.addEventListener('change', (e) => updateFlyClockConfig('planner.position', e.target.value));
    }
    if (flyClockForm.numberlinePos) {
      flyClockForm.numberlinePos.addEventListener('change', (e) => updateFlyClockConfig('numberline.position', e.target.value));
    }
    if (flyClockForm.numberlineCount) {
      flyClockForm.numberlineCount.addEventListener('input', (e) => {
        const v = Math.max(1, Math.min(12, parseInt(e.target.value || '1', 10)));
        e.target.value = v;
        updateFlyClockConfig('numberline.count', v);
        renderNumberlineFly();
      });
    }
    if (flyClockForm.plannerKeyCapture && flyClockForm.plannerKey) {
      wireKeyCapture(flyClockForm.plannerKeyCapture, flyClockForm.plannerKey);
      flyClockForm.plannerKey.addEventListener('input', (e) => updateFlyClockConfig('planner.key', e.target.value));
    }
    if (flyClockForm.numberlineKeyCapture && flyClockForm.numberlineKey) {
      wireKeyCapture(flyClockForm.numberlineKeyCapture, flyClockForm.numberlineKey);
      flyClockForm.numberlineKey.addEventListener('input', (e) => updateFlyClockConfig('numberline.key', e.target.value));
    }
    syncFlyClockSettings();
    ['left', 'right', 'up', 'down', 'zin', 'zout', 'pageNext', 'pagePrev', 'reset'].forEach(k => {
      wireKeyCapture(keyNavForm[`${k}Capture`], keyNavForm[k]);
    });
    wireKeyCapture(keyNavForm.answerToggleCapture, keyNavForm.answerToggle);
    wireKeyCapture(keyNavForm.studyMenuCapture, keyNavForm.studyMenu);
    function renderKeyNavSettingsPanel() {
      if (!keyNavForm.panStep) return;
      keyNavForm.panStep.value = keyNavConfig.panStep || DEFAULT_KEY_NAV_CONFIG.panStep;
      keyNavForm.zoomStep.value = keyNavConfig.zoomStep || DEFAULT_KEY_NAV_CONFIG.zoomStep;
      if (keyNavForm.panDecay) keyNavForm.panDecay.value = clampInertiaGlobal(keyNavConfig.panDecay || DEFAULT_KEY_NAV_CONFIG.panDecay);
      if (keyNavForm.zoomDecay) keyNavForm.zoomDecay.value = clampInertiaGlobal(keyNavConfig.zoomDecay || DEFAULT_KEY_NAV_CONFIG.zoomDecay);
      keyNavForm.holdMs.value = keyNavConfig.holdMs || DEFAULT_KEY_NAV_CONFIG.holdMs;
      keyNavForm.left.value = Array.isArray(keyNavConfig.panLeftKeys) ? keyNavConfig.panLeftKeys.join(', ') : (DEFAULT_KEY_NAV_CONFIG.panLeftKeys.join(', '));
      keyNavForm.right.value = Array.isArray(keyNavConfig.panRightKeys) ? keyNavConfig.panRightKeys.join(', ') : (DEFAULT_KEY_NAV_CONFIG.panRightKeys.join(', '));
      keyNavForm.up.value = Array.isArray(keyNavConfig.panUpKeys) ? keyNavConfig.panUpKeys.join(', ') : (DEFAULT_KEY_NAV_CONFIG.panUpKeys.join(', '));
      keyNavForm.down.value = Array.isArray(keyNavConfig.panDownKeys) ? keyNavConfig.panDownKeys.join(', ') : (DEFAULT_KEY_NAV_CONFIG.panDownKeys.join(', '));
      keyNavForm.zin.value = Array.isArray(keyNavConfig.zoomInKeys) ? keyNavConfig.zoomInKeys.join(', ') : (DEFAULT_KEY_NAV_CONFIG.zoomInKeys.join(', '));
      keyNavForm.zout.value = Array.isArray(keyNavConfig.zoomOutKeys) ? keyNavConfig.zoomOutKeys.join(', ') : (DEFAULT_KEY_NAV_CONFIG.zoomOutKeys.join(', '));
      keyNavForm.pageNext.value = Array.isArray(keyNavConfig.pageNextKeys) ? keyNavConfig.pageNextKeys.join(', ') : (DEFAULT_KEY_NAV_CONFIG.pageNextKeys.join(', '));
      keyNavForm.pagePrev.value = Array.isArray(keyNavConfig.pagePrevKeys) ? keyNavConfig.pagePrevKeys.join(', ') : (DEFAULT_KEY_NAV_CONFIG.pagePrevKeys.join(', '));
      keyNavForm.reset.value = Array.isArray(keyNavConfig.resetKeys) ? keyNavConfig.resetKeys.join(', ') : (DEFAULT_KEY_NAV_CONFIG.resetKeys.join(', '));
      if (keyNavForm.answerToggle) keyNavForm.answerToggle.value = Array.isArray(keyNavConfig.answerToggleKeys) ? keyNavConfig.answerToggleKeys.join(', ') : (DEFAULT_KEY_NAV_CONFIG.answerToggleKeys.join(', '));
      if (keyNavForm.studyMenu) keyNavForm.studyMenu.value = Array.isArray(keyNavConfig.studyMenuKeys) ? keyNavConfig.studyMenuKeys.join(', ') : (DEFAULT_KEY_NAV_CONFIG.studyMenuKeys.join(', '));
      if (keyNavForm.resetZoomOnlyToggle) keyNavForm.resetZoomOnlyToggle.checked = !!zoomResetOnly;
      keyNavForm.clamp.checked = !!keyNavConfig.bookClamp;
      syncKeyActionInputs();
      if (keyNavForm.panStepVal) { keyNavForm.panStepVal.textContent = `${keyNavForm.panStep.value}px/step`; }
      if (keyNavForm.zoomStepVal) { keyNavForm.zoomStepVal.textContent = `x${parseFloat(keyNavForm.zoomStep.value || DEFAULT_KEY_NAV_CONFIG.zoomStep).toFixed(3)}`; }
      if (keyNavForm.panDecayVal && keyNavForm.panDecay) { keyNavForm.panDecayVal.textContent = `${parseFloat(keyNavForm.panDecay.value || DEFAULT_KEY_NAV_CONFIG.panDecay).toFixed(3)}`; }
      if (keyNavForm.zoomDecayVal && keyNavForm.zoomDecay) { keyNavForm.zoomDecayVal.textContent = `${parseFloat(keyNavForm.zoomDecay.value || DEFAULT_KEY_NAV_CONFIG.zoomDecay).toFixed(3)}`; }
    }
    initKeyActionInputs();
    renderKeyNavSettingsPanel();
    const handleSpeedLabelUpdate = () => {
      if (keyNavForm.panStepVal && keyNavForm.panStep) {
        keyNavForm.panStepVal.textContent = `${keyNavForm.panStep.value}px/step`;
      }
      if (keyNavForm.zoomStepVal && keyNavForm.zoomStep) {
        keyNavForm.zoomStepVal.textContent = `x${parseFloat(keyNavForm.zoomStep.value || DEFAULT_KEY_NAV_CONFIG.zoomStep).toFixed(3)}`;
      }
      if (keyNavForm.panDecayVal && keyNavForm.panDecay) {
        keyNavForm.panDecayVal.textContent = `${parseFloat(keyNavForm.panDecay.value || DEFAULT_KEY_NAV_CONFIG.panDecay).toFixed(3)}`;
      }
      if (keyNavForm.zoomDecayVal && keyNavForm.zoomDecay) {
        keyNavForm.zoomDecayVal.textContent = `${parseFloat(keyNavForm.zoomDecay.value || DEFAULT_KEY_NAV_CONFIG.zoomDecay).toFixed(3)}`;
      }
    };
    keyNavForm.panStep?.addEventListener('input', handleSpeedLabelUpdate);
    keyNavForm.zoomStep?.addEventListener('input', handleSpeedLabelUpdate);
    keyNavForm.panDecay?.addEventListener('input', handleSpeedLabelUpdate);
    keyNavForm.zoomDecay?.addEventListener('input', handleSpeedLabelUpdate);
    keyNavForm.resetZoomOnlyToggle?.addEventListener('change', () => setZoomResetOnly(!!keyNavForm.resetZoomOnlyToggle.checked));
    if (keyNavForm.save) {
      keyNavForm.save.onclick = (e) => {
        e.preventDefault();
        const next = {
          panStep: Math.max(10, parseInt(keyNavForm.panStep.value, 10) || DEFAULT_KEY_NAV_CONFIG.panStep),
          zoomStep: Math.max(1.01, parseFloat(keyNavForm.zoomStep.value) || DEFAULT_KEY_NAV_CONFIG.zoomStep),
          panDecay: clampInertiaGlobal(parseFloat(keyNavForm.panDecay?.value) || DEFAULT_KEY_NAV_CONFIG.panDecay),
          zoomDecay: clampInertiaGlobal(parseFloat(keyNavForm.zoomDecay?.value) || DEFAULT_KEY_NAV_CONFIG.zoomDecay),
          holdMs: Math.max(40, parseInt(keyNavForm.holdMs.value, 10) || DEFAULT_KEY_NAV_CONFIG.holdMs),
          bookClamp: !!keyNavForm.clamp.checked,
          panLeftKeys: parseList(keyNavForm.left.value),
          panRightKeys: parseList(keyNavForm.right.value),
          panUpKeys: parseList(keyNavForm.up.value),
          panDownKeys: parseList(keyNavForm.down.value),
          zoomInKeys: parseList(keyNavForm.zin.value),
          zoomOutKeys: parseList(keyNavForm.zout.value),
          pageNextKeys: parseList(keyNavForm.pageNext.value),
          pagePrevKeys: parseList(keyNavForm.pagePrev.value),
          resetKeys: parseList(keyNavForm.reset.value),
          answerToggleKeys: parseList(keyNavForm.answerToggle?.value),
          studyMenuKeys: parseList(keyNavForm.studyMenu?.value),
          actionBindings: collectActionBindings(),
          // 明示的にコードのデフォルトを無効化（カスタムのみ使用）
          zoomInCodes: [],
          zoomOutCodes: [],
          pageNextCodes: [],
          pagePrevCodes: [],
          resetCodes: [],
          answerToggleCodes: [],
          studyMenuCodes: []
        };
        setKeyNavConfig(next);
        refreshZoomBounds();
        applyViewTransform();
        renderKeyNavSettingsPanel();
        showToast && showToast('キー操作設定を保存しました', 'ok');
      };
    }
    if (keyNavForm.resetDefaults) {
      keyNavForm.resetDefaults.onclick = (e) => {
        e.preventDefault();
        setKeyNavConfig(Object.assign({}, DEFAULT_KEY_NAV_CONFIG));
        refreshZoomBounds();
        applyViewTransform();
        renderKeyNavSettingsPanel();
        setZoomResetOnly(false);
        showToast && showToast('キー操作設定を初期化しました', 'ok');
      };
    }
    // speed sliders quick reset
    if (keyNavForm.panStepReset && keyNavForm.panStep) {
      keyNavForm.panStepReset.onclick = () => {
        keyNavForm.panStep.value = DEFAULT_KEY_NAV_CONFIG.panStep;
        if (keyNavForm.panStepVal) keyNavForm.panStepVal.textContent = `${DEFAULT_KEY_NAV_CONFIG.panStep}px/step`;
      };
    }
    if (keyNavForm.zoomStepReset && keyNavForm.zoomStep) {
      keyNavForm.zoomStepReset.onclick = () => {
        keyNavForm.zoomStep.value = DEFAULT_KEY_NAV_CONFIG.zoomStep;
        if (keyNavForm.zoomStepVal) keyNavForm.zoomStepVal.textContent = `x${DEFAULT_KEY_NAV_CONFIG.zoomStep.toFixed(3)}`;
      };
    }
    if (keyNavForm.panDecayReset && keyNavForm.panDecay) {
      keyNavForm.panDecayReset.onclick = () => {
        keyNavForm.panDecay.value = DEFAULT_KEY_NAV_CONFIG.panDecay;
        if (keyNavForm.panDecayVal) keyNavForm.panDecayVal.textContent = `${DEFAULT_KEY_NAV_CONFIG.panDecay.toFixed(3)}`;
      };
    }
    if (keyNavForm.zoomDecayReset && keyNavForm.zoomDecay) {
      keyNavForm.zoomDecayReset.onclick = () => {
        keyNavForm.zoomDecay.value = DEFAULT_KEY_NAV_CONFIG.zoomDecay;
        if (keyNavForm.zoomDecayVal) keyNavForm.zoomDecayVal.textContent = `${DEFAULT_KEY_NAV_CONFIG.zoomDecay.toFixed(3)}`;
      };
    }
    function updateQuickActionButtons() {
      const config = state.viewerContext === 'box' ? BOX_MENU_ACTIONS : menuActionConfig;
      if (!config.length) return;
      config.forEach(id => {
        const def = menuActionDefs[id];
        if (def?.updateButton && def.element) {
          def.updateButton(def.element);
        }
      });
    }
    function renderMenuButtons() {
      if (!menuActionsContainerRef) return;
      menuActionsContainerRef.innerHTML = '';
      Object.values(menuActionDefs).forEach(def => {
        if (def) def.element = null;
      });
      const config = state.viewerContext === 'box' ? BOX_MENU_ACTIONS : menuActionConfig;
      const list = config.length ? config : DEFAULT_MENU_ACTIONS;
      list.forEach(id => {
        const def = menuActionDefs[id];
        if (!def) return;
        if (typeof def.render === 'function') {
          const res = def.render();
          let root = null;
          let ref = null;
          if (res && typeof res === 'object' && res.element) {
            root = res.element;
            ref = res.control || res.element;
          } else if (res instanceof HTMLElement) {
            root = res;
            ref = res;
          }
          if (!root) return;
          menuActionsContainerRef.appendChild(root);
          def.element = ref;
          return;
        }
        const btn = document.createElement('button');
        btn.className = 'btn small';
        btn.textContent = def.label;
        btn.dataset.action = id;
        btn.onclick = (e) => {
          e.stopPropagation();
          def.onClick?.();
          updateQuickActionButtons();
        };
        menuActionsContainerRef.appendChild(btn);
        def.element = btn;
      });
      updateQuickActionButtons();
    }
    function renderMenuActionSettings() {
      if (!menuActionSettingsRef) return;
      menuActionSettingsRef.innerHTML = '';
      Object.values(menuActionDefs).forEach(def => {
        const row = document.createElement('label');
        row.className = 'row';
        row.style.gap = '8px';
        row.style.marginBottom = '6px';
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = menuActionConfig.includes(def.id);
        checkbox.onchange = () => toggleMenuAction(def.id, checkbox.checked);
        const span = document.createElement('span');
        span.textContent = def.label;
        row.appendChild(checkbox);
        row.appendChild(span);
        menuActionSettingsRef.appendChild(row);
      });
    }
    function toggleMenuAction(id, enabled) {
      if (enabled) {
        if (!menuActionConfig.includes(id)) menuActionConfig.push(id);
      } else {
        menuActionConfig = menuActionConfig.filter(x => x !== id);
      }
      saveMenuActionConfig();
      renderMenuButtons();
      renderMenuActionSettings();
    }
    function initMenuActionSettings() {
      menuActionSettingsRef = document.getElementById('menuActionSettings');
      renderMenuActionSettings();
    }
    let toastTimer = null;
    function showToast(msg, type = '') {
      const t = document.getElementById('toast');
      if (!t) return;
      t.textContent = msg;
      t.classList.remove('hidden');
      t.style.borderColor = type === 'error' ? 'var(--danger)' : type === 'ok' ? 'var(--ok)' : '#2a394f';
      if (toastTimer) clearTimeout(toastTimer);
      toastTimer = setTimeout(() => { t.classList.add('hidden'); toastTimer = null; }, 1600);
    }
    function groupBy(arr, fn) { const m = {}; arr.forEach(x => { const k = fn(x); (m[k] = m[k] || []).push(x) }); return m }
    function escapeHTML(str) { return (str || '').replace(/[&<>"]/g, s => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", "\"": "&quot;" }[s])) }
    function fileToDataURL(f) { return new Promise((res, rej) => { const r = new FileReader(); r.onload = () => res(r.result); r.onerror = rej; r.readAsDataURL(f) }) }
    /** ===== Library ===== */
    function renderLibrary(books) {
      const { viewMode, sort, tagFilter, folderFilter, search } = state;
      let list = [...books];
      if (tagFilter) list = list.filter(b => (b.tags || []).includes(tagFilter));
      if (folderFilter) list = list.filter(b => (b.folder || '') === folderFilter);
      if (search) { const q = search.toLowerCase(); list = list.filter(b => (b.title || '').toLowerCase().includes(q) || (b.tags || []).some(t => t.toLowerCase().includes(q))) }
      list.sort((a, b) => sort === '-createdAt' ? (b.createdAt || 0) - (a.createdAt || 0) : sort === 'title' ? (a.title || '').localeCompare(b.title || '') : pageCountOf(b) - pageCountOf(a));

      const grid = document.getElementById('libraryGrid');
      const shelf = document.getElementById('libraryShelf');
      const listEl = document.getElementById('libraryList');
      grid.classList.add('hidden'); shelf.classList.add('hidden'); listEl.classList.add('hidden');

      if (viewMode === 'grid') {
        grid.innerHTML = '';
        list.forEach(b => grid.appendChild(bookCard(b)));
        grid.classList.remove('hidden');
      } else if (viewMode === 'list') {
        listEl.innerHTML = '';
        list.forEach(b => {
          const it = document.createElement('div'); it.className = 'item';
          it.innerHTML = `<div class="row space" style="width:100%">
        <div class="row" style="gap:10px">
          <span class="pill">${pageCountOf(b)}p</span>
          <strong>${escapeHTML(b.title || '無題')}</strong>
          <span class="muted">${(b.tags || []).join(', ')}</span>
        </div>
        <div class="row" style="gap:6px">
          <button class="btn small" data-open="${b.id}">開く</button>
          <button class="btn small ghost" data-edit="${b.id}">編集</button>
          <button class="btn small" data-dup="${b.id}">複製</button>
          <button class="btn small danger" data-del="${b.id}">削除</button>
        </div>
      </div>`;
          listEl.appendChild(it);
        });
        listEl.classList.remove('hidden');
      } else {
        shelf.innerHTML = '';
        const groups = groupBy(list, b => b.folder || '未分類');
        Object.entries(groups).forEach(([fold, arr]) => {
          const box = document.createElement('div'); box.className = 'card';
          box.innerHTML = `<div class="meta"><div class="row space"><strong>${escapeHTML(fold)}</strong><span class="muted">${arr.length}冊</span></div></div>`;
          const sub = document.createElement('div'); sub.className = 'grid'; sub.style.padding = '0 12px 12px';
          arr.forEach(b => sub.appendChild(bookCard(b)));
          const wrap = document.createElement('div'); wrap.appendChild(box); wrap.appendChild(sub); shelf.appendChild(wrap);
        });
        shelf.classList.remove('hidden');
      }
    }
    function bookCard(b) {
      const c = document.createElement('div'); c.className = 'card';
      const th = bookCoverOf(b);
      c.innerHTML = `<div class="thumb">${th ? `<img src="${th}" alt="thumb" loading="lazy" decoding="async"/>` : '<div class="muted">No Image</div>'}</div>
    <div class="meta">
      <p class="title">${escapeHTML(b.title || '無題')}</p>
      <div class="row space">
        <span class="muted">${(b.tags || []).slice(0, 3).join(' ・ ')}</span>
        <span class="pill">${pageCountOf(b)}p</span>
      </div>
      <div class="row" style="gap:6px;margin-top:8px">
        <button class="btn small" data-open="${b.id}">開く</button>
        <button class="btn small ghost" data-edit="${b.id}">編集</button>
        <button class="btn small" data-dup="${b.id}">複製</button>
        <button class="btn small danger" data-del="${b.id}">削除</button>
      </div>
    </div>`;
      return c;
    }

    /** ===== Boxes (強化) ===== */
    async function renderBoxes() {
      let boxes = await Box.list();
      const q = (document.getElementById('boxSearch').value || '').toLowerCase();
      const onlyWeak = document.getElementById('onlyWeakBox').checked;
      const sort = document.getElementById('boxSort').value;

      // enrich stats
      boxes.forEach(b => {
        b.tags = b.tags || [];
        const weak = (b.snippets || []).filter(s => s.weak).length;
        b._weak = weak;
        b._items = (b.snippets || []).length;
        b._thumb = b.coverDataUrl || b.snippets?.[0]?.dataUrl || '';
      });
      // filter
      if (q) {
        boxes = boxes.filter(b => (b.name || '').toLowerCase().includes(q)
          || b.tags.some(t => t.toLowerCase().includes(q))
          || (b.snippets || []).some(s => (s.name || '').toLowerCase().includes(q) || (s.note || '').toLowerCase().includes(q)));
      }
      if (onlyWeak) { boxes = boxes.filter(b => b._weak > 0); }
      // sort
      boxes.sort((a, b) => {
        if (sort === 'name') return (a.name || '').localeCompare(b.name || '');
        if (sort === '-items') return (b._items) - (a._items);
        if (sort === '-weak') return (b._weak) - (a._weak);
        return (b.createdAt || 0) - (a.createdAt || 0);
      });

      const grid = document.getElementById('boxGrid');
      const empty = document.getElementById('boxEmpty');
      grid.innerHTML = '';
      if (!boxes.length) { empty.classList.remove('hidden'); return }
      empty.classList.add('hidden');

      boxes.forEach(x => {
        const c = document.createElement('div'); c.className = 'card';
        c.innerHTML = `<div class="thumb">${x._thumb ? `<img src="${x._thumb}" alt="thumb"/>` : '<div class="muted">No Image</div>'}</div>
    <div class="meta">
      <p class="title">${escapeHTML(x.name || '無題ボックス')}</p>
      <div class="row space">
        <span class="muted">${x._items} 件 ・ 苦手 ${x._weak}</span>
        <div class="row" style="gap:6px">
          <button class="btn small" data-open-box="${x.id}">開く</button>
          <button class="btn small ghost" data-edit-box="${x.id}">編集</button>
          <button class="btn small danger" data-del-box="${x.id}">削除</button>
        </div>
      </div>
      <div class="row" style="gap:6px;margin-top:6px">${(x.tags || []).map(t => `<span class='chip'>${escapeHTML(t)}</span>`).join('')}</div>
    </div>`;
        grid.appendChild(c);
      });
    }

    function editBoxMeta(box) {
      const m = document.createElement('div'); m.className = 'modal'; m.style.display = 'flex';
      const b = document.createElement('div'); b.className = 'box';
      b.innerHTML = `<h3>ボックスを編集</h3>
    <label>名前</label><input id="bxn" class="input" value="${escapeHTML(box.name || '')}" style="margin-bottom:8px"/>
    <label>タグ</label><input id="bxt" class="input" value="${escapeHTML((box.tags || []).join(', '))}" style="margin-bottom:8px"/>
    <label>サムネイル（任意）</label>
    <div class="row" style="gap:8px;align-items:center;margin-bottom:8px">
      <input type="file" id="bxthumb" accept="image/*" />
      <div class="snip-preview" style="max-width:120px;min-width:90px;"><img id="bxthumbPreview" src="${box.coverDataUrl || box.snippets?.[0]?.dataUrl || ''}" alt="thumb"/></div>
    </div>
    <div class="row space">
      <button class="btn ghost" data-close>閉じる</button>
      <div class="row" style="gap:8px">
        <button class="btn ghost" id="exportThisBox">このボックスをエクスポート</button>
        <button class="btn primary" data-save>保存</button>
      </div>
    </div>`;
      m.appendChild(b); document.body.appendChild(m);
      b.querySelector('[data-close]').onclick = () => m.remove();
      const fileInput = b.querySelector('#bxthumb');
      const preview = b.querySelector('#bxthumbPreview');
      if (fileInput) {
        fileInput.onchange = async () => {
          const f = fileInput.files?.[0];
          if (!f) { return; }
          const url = await fileToDataURL(f);
          preview.src = url;
          box.coverDataUrl = url;
        };
      }
      b.querySelector('#exportThisBox').onclick = () => exportSingleBox(box);
      b.querySelector('[data-save]').onclick = async () => {
        box.name = b.querySelector('#bxn').value.trim() || '無題ボックス';
        box.tags = b.querySelector('#bxt').value.split(',').map(s => s.trim()).filter(Boolean);
        await Box.put(box); m.remove(); renderBoxes(); showToast('更新しました', 'ok');
      };
    }

    /** ===== Viewer (Book) ===== */
    function mountBookViewer(book, opts = {}) {
      if (!book) {
        console.error('[mountBookViewer] Called with null/undefined book');
        showToast('本のデータを読み込めませんでした', 'error');
        return;
      }
      if (!Array.isArray(book.pages)) {
        console.error('[mountBookViewer] Book has no pages array:', book.id);
        showToast('本のページデータがありません', 'error');
        return;
      }
      console.log('[mountBookViewer] Opening book:', book.id, 'with', book.pages.length, 'pages');
      state.view = 'viewer';
      state.viewerContext = 'book';
      state.activeTab = 'library';
      // track last opened for home「最近使った本」
      if (!book._ephemeral) {
        (async () => {
          try {
            book.lastOpened = Date.now();
            await Book.put(book);
          } catch (e) {
            console.warn('[mountBookViewer] Failed to update lastOpened', e);
          }
        })();
      }
      viewerMemory.book.id = book.id;
      viewerMemory.book.closed = false;
      viewerMemory.book.ref = book;
      const tabType = book._openTabType || 'book';
      const tabId = book._openTabId || book.id;
      const tabTitle = book._openTabTitle || book.title || '無題';
      ensureOpenTab(tabType, tabId, tabTitle);
      const host = document.getElementById('viewerView'); host.innerHTML = ''; host.classList.remove('hidden');
      // ensure library list is hidden while閲覧中
      const libraryEl = document.getElementById('libraryView');
      const boxesEl = document.getElementById('boxesView');
      libraryEl?.classList.add('hidden');
      boxesEl?.classList.add('hidden');
      document.body.classList.add('reading');
      try { StudyHpOverlay.update(Date.now()); } catch (e) { }
      try { ReaderHpBar.update(Date.now()); } catch (e) { }
      if (typeof book.firstPageNumber !== 'number') book.firstPageNumber = 1;
      book.pages.forEach(p => {
        p.state = p.state || { fav: false, weak: false, done: false, extra: [] };
        if (!Array.isArray(p.state.extra)) p.state.extra = [];
        p.memo = p.memo || '';
        if (!Array.isArray(p.missMarks)) p.missMarks = [];
      });
      book.customStates = book.customStates || []; // {id,name,color}
      book.bookmarks = Array.isArray(book.bookmarks) ? book.bookmarks : [];

      const wrap = document.createElement('div'); wrap.className = 'viewer';
      wrap.innerHTML = `
    <div id="stageHost" class="stage-host">
      <div class="draw-toolbar hidden" id="drawToolbar">
        <button class="mini-menu" id="drawToolBtn" aria-label="ペン/消しゴム切替"><span class="icon">✏️</span></button>
        <button class="mini-menu" id="drawEraserModeBtn" aria-label="消しゴムモード切替"><span class="icon">🧽</span></button>
        <button class="mini-menu" id="drawSelectBtn" aria-label="選択モード"><span class="icon">⧉</span></button>
        <button class="mini-menu" id="drawSettingsBtn" aria-label="ドロー設定"><span class="icon">⚙</span></button>
        <button class="mini-menu" id="drawUndoBtn" aria-label="取り消し"><span class="icon">↶</span></button>
        <button class="mini-menu" id="drawRedoBtn" aria-label="やり直し"><span class="icon">↷</span></button>
        <button class="mini-menu" id="drawResetBtn" aria-label="リセット"><span class="icon">⟲</span></button>
      </div>
      <div class="draw-settings-panel" id="drawSettingsPanel" aria-label="ドロー設定パネル">
        <h4>ドロー設定</h4>
        <div class="row">
          <label for="drawBrush">ブラシ</label>
          <select id="drawBrush" class="input" style="flex:1">
            <option value="simple">シンプル</option>
            <option value="smooth">スムーズ</option>
            <option value="pencil">鉛筆</option>
            <option value="soft">ふわふわ</option>
            <option value="marker">マーカー</option>
            <option value="calligraphy">カリグラフィ</option>
          </select>
        </div>
        <div class="row">
          <label for="drawWidth">太さ</label>
          <input type="range" id="drawWidth" min="1" max="40" step="0.5">
          <input type="number" id="drawWidthVal" class="input" style="width:70px" min="1" max="200" step="0.5">
        </div>
        <div class="row">
          <label for="drawEraserWidth">消し幅</label>
          <input type="range" id="drawEraserWidth" min="2" max="200" step="0.5">
          <input type="number" id="drawEraserWidthVal" class="input" style="width:70px" min="2" max="200" step="0.5">
        </div>
        <div class="row">
          <label for="drawOpacity">不透明度</label>
          <input type="range" id="drawOpacity" min="0.1" max="1" step="0.05">
          <input type="number" id="drawOpacityVal" class="input" style="width:70px" min="0.05" max="1" step="0.05">
        </div>
        <div class="row">
          <label for="drawColor">色</label>
          <input type="color" id="drawColor" value="#000000" style="flex:1; min-width:80px">
        </div>
        <div class="row color-grid" id="drawColorGrid"></div>
        <div class="row" style="justify-content:space-between">
          <label><input type="checkbox" id="drawShadow"> 影</label>
          <label><input type="checkbox" id="drawGlow"> 光</label>
        </div>
        <h4 style="margin:12px 0 6px;">テキスト</h4>
        <div class="row">
          <label for="drawTextSize">文字サイズ</label>
          <input type="range" id="drawTextSize" min="8" max="120" step="1">
          <span id="drawTextSizeVal" class="muted" style="min-width:48px;text-align:right"></span>
        </div>
        <div class="row">
          <label for="drawTextFont">フォント</label>
          <select id="drawTextFont" class="input" style="flex:1">
            <option value="system-ui, sans-serif">サンセリフ</option>
            <option value="\"Times New Roman\", serif">セリフ</option>
            <option value="\"Courier New\", monospace">等幅</option>
            <option value="\"Comic Sans MS\", \"Comic Neue\", cursive">手書き</option>
          </select>
        </div>
        <div class="row">
          <button class="mini-menu ghost" id="drawFontUploadBtn" type="button" style="width:100%">フォント追加（ttf/otf）</button>
          <input type="file" id="drawFontUpload" accept=".ttf,.otf,.woff,.woff2" class="hidden">
        </div>
        <div class="row text-color-slots" id="drawTextColorSlots" style="margin-bottom:12px"></div>
        <h4 style="margin:0 0 6px;">図形・スタンプ（試験）</h4>
        <div class="row">
          <label for="drawShape">図形</label>
          <select id="drawShape" class="input" style="flex:1">
            <option value="free">フリーハンド</option>
            <option value="line">直線</option>
            <option value="rectangle">長方形</option>
            <option value="ellipse">円/楕円</option>
          </select>
        </div>
        <div class="row">
          <label for="drawStamp">スタンプ</label>
          <select id="drawStamp" class="input" style="flex:1">
            <option value="">なし</option>
          </select>
        </div>
        <div class="row" style="margin-top:4px">
          <button class="mini-menu ghost" id="drawStampSave" type="button" style="width:100%">選択→スタンプ登録</button>
        </div>
        <h4 style="margin-top:12px;">レイヤー</h4>
        <div class="layer-list" id="drawLayerList"></div>
        <div class="layer-actions">
          <button class="mini-menu ghost" id="drawLayerAdd" type="button">＋追加</button>
          <button class="mini-menu ghost" id="drawLayerDelete" type="button">－削除</button>
          <button class="mini-menu ghost" id="drawLayerUp" type="button">↑</button>
          <button class="mini-menu ghost" id="drawLayerDown" type="button">↓</button>
        </div>
      </div>
      <div class="miss-panel" id="missPanel" aria-label="ミス目印パネル">
        <h4>ミス目印</h4>
        <div class="miss-palette" id="missPalette">
          <button class="miss-chip" data-type="important" style="--miss-color:#ef4444;">要</button>
          <button class="miss-chip" data-type="hard" style="--miss-color:#f59e0b;">難</button>
          <button class="miss-chip" data-type="note" style="--miss-color:#f97316;">注</button>
          <button class="miss-chip" data-type="careless" style="--miss-color:#3b82f6;">凡</button>
          <button class="miss-chip" data-type="lack" style="--miss-color:#22c55e;">不</button>
          <button class="miss-chip" data-type="remember" style="--miss-color:#a855f7;">覚</button>
          <button class="miss-chip" data-type="question" style="--miss-color:#06b6d4;">？</button>
        </div>
        <div class="miss-hint">ドラッグ</div>
      </div>
      <div class="draw-size-preview" id="drawSizePreview"></div>
      <div class="draw-selection-box" id="drawSelectionBox"></div>
      <canvas id="drawSelectOverlay" class="draw-select-overlay"></canvas>
      <div class="stage-buttons left">
        <button class="mini-menu" id="stageMenuBtn" aria-label="メニュー">☰</button>
        <button class="mini-menu hidden" id="zoomLockBtn" aria-label="ズームロック">🔒ズ</button>
        <button class="mini-menu hidden" id="panLockBtn" aria-label="移動ロック">🔒移</button>
        <button class="mini-menu" id="sliceViewBtn" aria-label="ハーフ表示">半切</button>
        <button class="mini-menu" id="studyQuickBtn" aria-label="勉強予定">予定</button>
        <button class="mini-menu" id="answerQuickBtn" aria-label="解答ウィンドウ">解答</button>
        <button class="mini-menu" id="missQuickBtn" aria-label="ミス">ミス</button>
        <button class="mini-menu draw-toggle" id="drawToggleBtn" aria-label="ドローモード"><span class="draw-icon" aria-hidden="true"></span></button>
      </div>
      <div class="stage-buttons right">
        <button class="mini-menu" id="pageListBtn" aria-label="ページ一覧">一覧</button>
        <div class="page-title" id="pageBookTitle"></div>
        <div class="page-badge" id="pageBadge"></div>
      </div>
      <!-- single pane (default) -->
      <div class="stage" id="stageSingle">
        <div class="stage-inner">
          <div class="page-layer" id="pageLayer">
            <img id="pageImgBack" alt="page" draggable="false" decoding="async" class="page-buffer back"/>
            <img id="pageImg" alt="page" draggable="false" decoding="async" class="page-buffer front"/>
            <canvas id="drawCanvas" class="draw-layer"></canvas>
            <div class="miss-layer" id="missLayer"></div>
          </div>
          <canvas id="cropCanvas" class="crop hidden"></canvas>
          <div class="interaction-hint" id="interactionHint">ホイール＝ズーム / ドラッグ＝移動</div>
          <div class="stage-arrows">
            <button class="stage-arrow" id="stagePrevArrow" aria-label="前のページ">‹</button>
            <button class="stage-arrow" id="stageNextArrow" aria-label="次のページ">›</button>
          </div>
      <div class="floatbar hidden" id="floatbar"></div>
        </div>
      </div>
      <!-- dual pane for spread/compare -->
      <div class="dual hidden" id="stageDual">
        <div class="pane" id="paneLeft">
          <img id="imgLeft" alt="left" draggable="false" decoding="async"/>
          <div class="pane-badge" id="badgeLeft"></div>
          <canvas class="crop hidden" id="cropCanvasLeft"></canvas>
          <div class="pane-arrows">
            <button class="pane-arrow" id="paneLeftPrevArrow" aria-label="左ページを戻す">‹</button>
            <button class="pane-arrow" id="paneLeftNextArrow" aria-label="左ページを進める">›</button>
          </div>
          <div class="pane-controls">
            <button class="btn small" id="leftPrev">←</button>
            <button class="btn small" id="leftNext">→</button>
            <input class="input" id="leftJump" placeholder="p" style="width:80px"/>
            <button class="btn small" id="leftGo">移動</button>
          </div>
        </div>
        <div class="pane-divider" id="paneDivider" role="separator" aria-orientation="vertical"></div>
        <div class="pane" id="paneRight">
          <img id="imgRight" alt="right" draggable="false" decoding="async"/>
          <div class="pane-badge" id="badgeRight"></div>
          <canvas class="crop hidden" id="cropCanvasRight"></canvas>
          <div class="pane-arrows">
            <button class="pane-arrow" id="paneRightPrevArrow" aria-label="右ページを戻す">‹</button>
            <button class="pane-arrow" id="paneRightNextArrow" aria-label="右ページを進める">›</button>
          </div>
          <div class="pane-controls">
            <button class="btn small" id="rightPrev">←</button>
            <button class="btn small" id="rightNext">→</button>
            <input class="input" id="rightJump" placeholder="p" style="width:80px"/>
            <button class="btn small" id="rightGo">移動</button>
          </div>
        </div>
      </div>
      <div class="viewer-clock-overlay hidden" id="viewerClockOverlay">
        <div class="viewer-clock-wrap pos-top-right" id="viewerClockWrap">
          <div class="viewer-clock vc-style-minimal" id="viewerClock">
            <span class="clock-text" id="viewerClockText">--:--</span>
          </div>
          <div class="viewer-clock vc-style-minimal viewer-timer hidden" id="viewerTimerClock" aria-live="polite">
            <span class="clock-text" id="viewerTimerText">--:--</span>
          </div>
          <div class="viewer-timer-stack hidden" id="viewerTimerStack"></div>
        </div>
      </div>
      <div class="fly-clock-overlay hidden" id="plannerFlyOverlay">
        <div class="fly-clock fly-pos-right" id="plannerFly">
          <div class="fly-body" id="plannerFlyBody"></div>
        </div>
      </div>
      <div class="fly-clock-overlay hidden" id="numberlineFlyOverlay">
        <div class="fly-clock fly-pos-left" id="numberlineFly">
          <div class="fly-body" id="numberlineFlyBody"></div>
        </div>
      </div>
      <div class="pie-menu hidden" id="pieMenu" aria-label="タイマー パイメニュー">
        <div class="pie-shell" id="pieTimerShell">
          <button class="pie-close" id="pieClose" aria-label="閉じる">×</button>
          <div class="pie-dial" id="pieDial" aria-label="タイマー時間ダイヤル">
            <div class="pie-dial-ring" id="pieDialRing"></div>
            <div class="pie-dial-ticks" id="pieDialTicks"></div>
            <div class="pie-dial-indicator"></div>
            <div class="pie-dial-center">
              <div class="pie-mode-label" id="pieModeLabel">TIMER</div>
              <div class="pie-time" id="pieTimeValue">25:00</div>
              <div class="pie-sub" id="pieTimeSub">25分</div>
              <button class="pie-primary" id="piePrimary">開始</button>
            </div>
          </div>
          <div class="pie-actions" id="pieActions"></div>
          <div class="pie-hint" id="pieHint">↑/→ 長押しで増える ・ ↓/← 長押しで減る</div>
        </div>
      </div>
      <div class="miss-pie-menu hidden" id="missPieMenu" aria-label="ミス操作パイメニュー">
        <div class="miss-pie-ring">
          <div class="miss-pie-split" style="--angle: 0deg;">
            <button class="miss-pie-split-btn up" data-miss-action="confirm">+1</button>
            <button class="miss-pie-split-btn down" data-miss-action="decrement">-1</button>
          </div>
          <button class="miss-pie-btn" data-miss-action="reason" style="--angle: 60deg;">理由</button>
          <button class="miss-pie-btn" data-miss-action="rename" style="--angle: 120deg;">名前</button>
          <button class="miss-pie-btn" data-miss-action="type" style="--angle: 180deg;">種類</button>
          <button class="miss-pie-btn" data-miss-action="move" style="--angle: 240deg;">移動</button>
          <button class="miss-pie-btn" data-miss-action="delete" style="--angle: 300deg;">削除</button>
        </div>
      </div>
      <div class="miss-pie-menu hidden" id="missSpawnMenu" aria-label="ミス追加パイメニュー">
        <div class="miss-pie-ring">
          <button class="miss-pie-btn miss-spawn-btn" data-miss-spawn="important" style="--angle: 0deg; --miss-color:#ef4444;">要</button>
          <button class="miss-pie-btn miss-spawn-btn" data-miss-spawn="hard" style="--angle: 51deg; --miss-color:#f59e0b;">難</button>
          <button class="miss-pie-btn miss-spawn-btn" data-miss-spawn="note" style="--angle: 103deg; --miss-color:#f97316;">注</button>
          <button class="miss-pie-btn miss-spawn-btn" data-miss-spawn="careless" style="--angle: 154deg; --miss-color:#3b82f6;">凡</button>
          <button class="miss-pie-btn miss-spawn-btn" data-miss-spawn="lack" style="--angle: 206deg; --miss-color:#22c55e;">不</button>
          <button class="miss-pie-btn miss-spawn-btn" data-miss-spawn="remember" style="--angle: 257deg; --miss-color:#a855f7;">覚</button>
          <button class="miss-pie-btn miss-spawn-btn" data-miss-spawn="question" style="--angle: 309deg; --miss-color:#06b6d4;">？</button>
        </div>
        <div class="miss-spawn-lock" aria-hidden="true">
          <span class="lock-ring"></span>
          <span class="lock-ring ring-2"></span>
          <span class="lock-cross cross-x"></span>
          <span class="lock-cross cross-y"></span>
          <span class="lock-dot"></span>
        </div>
      </div>
      <div class="miss-type-picker" id="missTypePicker" aria-label="ミス種類変更">
        <button class="miss-chip" data-type="important" style="--miss-color:#ef4444;">要</button>
        <button class="miss-chip" data-type="hard" style="--miss-color:#f59e0b;">難</button>
        <button class="miss-chip" data-type="note" style="--miss-color:#f97316;">注</button>
        <button class="miss-chip" data-type="careless" style="--miss-color:#3b82f6;">凡</button>
        <button class="miss-chip" data-type="lack" style="--miss-color:#22c55e;">不</button>
        <button class="miss-chip" data-type="remember" style="--miss-color:#a855f7;">覚</button>
        <button class="miss-chip" data-type="question" style="--miss-color:#06b6d4;">？</button>
      </div>
      <div class="miss-edit-popover" id="missEditPopover" aria-label="ミス編集">
        <label for="missEditName">名前</label>
        <input id="missEditName" class="input" />
        <label for="missEditReason" style="margin-top:6px;">理由メモ</label>
        <textarea id="missEditReason" class="input" rows="3"></textarea>
        <label for="missEditExplain" style="margin-top:6px;">説明/解説</label>
        <textarea id="missEditExplain" class="input" rows="3"></textarea>
        <div class="miss-edit-actions">
          <button class="mini-menu ghost" type="button" data-miss-edit="close">閉じる</button>
          <button class="mini-menu" type="button" data-miss-edit="save">保存</button>
        </div>
      </div>
      <div class="miss-message-box hidden" id="missMessageBox" aria-live="polite">
        <div class="miss-message-header">
          <div class="miss-message-title" id="missMessageTitle">理由</div>
          <div class="miss-message-actions">
            <button class="mini-menu ghost" type="button" data-miss-message="next">次へ</button>
            <button class="mini-menu ghost" type="button" data-miss-message="close">閉じる</button>
          </div>
        </div>
        <div class="miss-message-body" id="missMessageBody" contenteditable="true" role="textbox" aria-multiline="true"></div>
      </div>
    </div>
    <div class="book-menu compact" id="bookMenuPanel">
      <div class="menu-header" id="menuDragHandle">
        <span></span>
        <button id="menuCloseBtn" aria-label="閉じる">×</button>
      </div>
      <div class="menu-body">
        <div class="menu-actions" id="menuActions"></div>
      </div>
    </div>
    <div class="memo-window" id="memoWindow">
      <div class="memo-header" id="memoWindowDrag">
        <span>ページメモ</span>
        <button id="memoWindowClose" aria-label="閉じる">×</button>
      </div>
      <textarea id="memoWindowInput" placeholder="このページのメモ"></textarea>
    </div>
    <div class="compare-window" id="compareWindow">
      <div class="compare-header" id="compareWindowDrag">
        <span class="compare-title" id="compareWindowTitle">比較ウィンドウ</span>
        <div class="compare-quick">
        <button class="mini-menu" id="compareWindowZoomLock" aria-label="ズームロック">🔓ズ</button>
        <button class="mini-menu" id="compareWindowSlice" aria-label="半切表示">半切</button>
        <button class="mini-menu" id="compareWindowSync" aria-label="透明切替">透明</button>
        <button class="mini-menu" id="compareWindowRegister" aria-label="解答ページを登録">登録</button>
        <button class="mini-menu" id="compareWindowClose" aria-label="閉じる">×</button>
        </div>
      </div>
      <div class="compare-body">
        <div class="compare-stage" id="compareWindowStage">
          <span class="compare-placeholder" id="compareWindowPlaceholder">ここに比較ページが表示されます</span>
          <img id="compareWindowImg" alt="比較ウィンドウ" draggable="false"/>
          <canvas class="crop hidden" id="cropCanvasCompareWindow"></canvas>
          <div class="compare-page-badge" id="compareWindowPageBadge"></div>
          <div class="stage-arrows compare-arrows">
            <button class="stage-arrow" id="compareWindowPrev" aria-label="前のページ">‹</button>
            <button class="stage-arrow" id="compareWindowNext" aria-label="次のページ">›</button>
          </div>
        </div>
      </div>
    </div>
    <div class="control-resizer" id="controlResizer" role="separator" aria-label="右パネル幅を変更"></div>
    <div class="control">
      <div class="row space">
        <div>
          <h3 style="margin:0">${escapeHTML(book.title || '無題')}</h3>
          <span class="muted">${book.pages.length}p ・ 開始 ${book.firstPageNumber || 1}p</span>
        </div>
        <div class="row" style="gap:6px">
          <button class="btn small ghost" id="bookMenuBtn">☰ メニュー</button>
        </div>
      </div>
      <div class="statebar">
        <label class="row" style="gap:6px"><input type="checkbox" id="stFav"> ★お気に入り</label>
        <label class="row" style="gap:6px"><input type="checkbox" id="stWeak"> ×苦手</label>
        <label class="row" style="gap:6px"><input type="checkbox" id="stDone"> ✓完了</label>
        <div id="customStateArea" class="row" style="gap:6px;flex-wrap:wrap"></div>
        <button class="btn small ghost" id="addState">+ 状態を作成</button>
      </div>
      <div class="memo-panel">
        <button class="btn small ghost" id="memoToggle">メモ欄を開く</button>
        <div class="memo-body hidden" id="memoBody">
          <textarea id="pageMemo" class="input" placeholder="このページのメモ"></textarea>
        </div>
      </div>
      <div class="toolbar" style="margin:8px 0">
        <select id="filterSelect" class="input" style="max-width:180px">
          <option value="all">すべて表示</option>
          <option value="fav">★のみ</option>
          <option value="weak">×のみ</option>
          <option value="undone">未完了のみ</option>
          <option value="done">完了のみ</option>
          <option value="hasMemo">メモありのみ</option>
        </select>
        <select id="customFilter" class="input" style="max-width:180px">
          <option value="">カスタム状態（任意）</option>
        </select>
        <button class="btn" id="prevBtn">← 前へ</button>
        <button class="btn" id="nextBtn">次へ →</button>
        <input class="input" id="jumpInput" placeholder="ページ番号" style="width:120px"/>
        <button class="btn" id="jumpGo">移動</button>
        <button class="btn ghost" id="fitContain">フィット</button>
        <button class="btn ghost" id="fitWidth">幅フィット</button>
        <button class="btn" id="spreadToggle">見開き 1↔2</button>
        <button class="btn ghost" id="compareStart">比較</button>
        <button class="btn danger hidden" id="compareEnd">比較終了</button>
        <button class="btn ghost hidden" id="compareHideBtn">右側隠す</button>
        <button class="btn ghost" id="compareWindowBtn">比較ウィンドウ</button>
        <button class="btn hidden" id="selectBtn">切り取り</button>
        <button class="btn" id="missBtn">ミス</button>
        <button class="btn ghost" id="insertBtn">+ 挿入</button>
        <button class="btn ghost" id="replaceBtn">差し替え</button>
        <button class="btn danger ghost" id="deletePageBtn">ページ削除</button>
        <input type="file" id="replacePicker" accept="image/*" class="hidden"/>
      </div>
      <div class="toolbar" id="toneControlBar" style="flex-wrap:wrap;align-items:center;gap:8px">
        <span class="muted">色変換</span>
        <select id="tonePreset" class="input" style="max-width:180px">
          <option value="orig">オリジナル</option>
          <option value="paper">白→紙</option>
          <option value="canvas">白→布/クラフト</option>
          <option value="metal">白→鉄/メタル</option>
          <option value="water">白→水面(ゆらぎ)</option>
          <option value="invert">反転</option>
          <option value="green">白→黒 / 黒→緑</option>
          <option value="red">白→黒 / 黒→赤</option>
          <option value="custom">カスタム</option>
        </select>
        <div class="row" id="toneCustomRow" style="gap:6px;flex-wrap:wrap">
          <label class="row" style="gap:4px;align-items:center"><span class="muted">白→</span><input type="color" id="toneLight" value="#000000" style="width:46px;height:32px;padding:0;border:none;background:transparent"></label>
          <label class="row" style="gap:4px;align-items:center"><span class="muted">黒→</span><input type="color" id="toneDark" value="#00ff00" style="width:46px;height:32px;padding:0;border:none;background:transparent"></label>
          <button class="btn small ghost" id="toneApply">反映</button>
        </div>
      </div>
      <div class="linked-answer-bar hidden" id="linkedAnswerBar">
        <div class="linked-answer-chips" id="linkedAnswerQuick"></div>
        <div class="row" id="linkedAnswerActions" style="gap:6px;flex-wrap:wrap;margin-top:6px">
          <button class="btn small" id="linkedAnswerCompareBtn">解答↔</button>
          <button class="btn small ghost" id="linkedAnswerWindowBtn">解答ウィンドウ</button>
        </div>
      </div>
      <div class="linked-answer-manage" id="answerLinkManage">
        <select class="input" id="answerLinkSelect"></select>
        <button class="btn small" id="answerLinkAdd">+ 紐付け</button>
      </div>
      <div class="toolbar" style="margin-bottom:6px;flex-wrap:wrap">
        <button class="btn small" id="multiToggle">□ 複数選択</button>
        <button class="btn small ghost" id="multiAll">すべて選択</button>
        <button class="btn small ghost" id="multiNone">選択解除</button>
        <button class="btn small" id="multiMove">選択を移動</button>
        <button class="btn small" id="multiCopy">選択をコピー</button>
        <button class="btn small" id="multiNewBook">選択から新しい本</button>
        <button class="btn small danger" id="multiDelete">選択を削除</button>
        <button class="btn small" id="multiSet">選択の状態を変更</button>
      </div>
      <div class="toolbar" style="align-items:center">
        <span class="muted">めくりまくり</span>
        <input type="range" id="flipSpeed" min="1" max="20" value="8" />
        <button class="btn" id="flipPlay">▶︎ 再生</button>
        <button class="btn ghost" id="flipStop">停止</button>
        <input type="range" id="scrubRange" min="1" max="${book.pages.length}" value="1" style="flex:1" />
      </div>
      <div class="hr" style="height:1px;background:#1d2738;margin:8px 0"></div>
      <div class="list" id="thumbList" style="flex:1"></div>
      <div class="hr" style="height:1px;background:#1d2738;margin:8px 0"></div>
      <div class="row space">
        <button class="btn ghost" id="backLib">← ライブラリに戻る</button>
        <div class="muted">実ページ起点: <span id="realStart">${book.firstPageNumber}</span></div>
      </div>
    </div>`;
      host.appendChild(wrap);
      try { ReaderHpBar.update(studyNowMs()); } catch (e) { }

      const img = document.getElementById('pageImg');
      const imgBack = document.getElementById('pageImgBack');
      let imgFrontActive = true; // Track which buffer is currently showing
      const pageLayer = document.getElementById('pageLayer');
      const drawCanvas = document.getElementById('drawCanvas');
      const drawCtx = drawCanvas?.getContext('2d');
      const cropSingle = document.getElementById('cropCanvas');
      const cropLeft = document.getElementById('cropCanvasLeft');
      const cropRight = document.getElementById('cropCanvasRight');
      const cropCompareWindow = document.getElementById('cropCanvasCompareWindow');
      const stageHost = document.getElementById('stageHost');
      const stage = document.getElementById('stageSingle');
      const stageDual = document.getElementById('stageDual');
      const controlResizer = document.getElementById('controlResizer');
      const stagePrevArrow = document.getElementById('stagePrevArrow');
      const stageNextArrow = document.getElementById('stageNextArrow');
      const stageArrows = stage?.querySelector('.stage-arrows');
      const paneLeftPrevArrow = document.getElementById('paneLeftPrevArrow');
      const paneLeftNextArrow = document.getElementById('paneLeftNextArrow');
      const paneRightPrevArrow = document.getElementById('paneRightPrevArrow');
      const paneRightNextArrow = document.getElementById('paneRightNextArrow');
      const stageMenuBtn = document.getElementById('stageMenuBtn');
      const zoomLockBtn = document.getElementById('zoomLockBtn');
      const panLockBtn = document.getElementById('panLockBtn');
      const sliceViewBtn = document.getElementById('sliceViewBtn');
      const pageListBtn = document.getElementById('pageListBtn');
      const drawToggleBtn = document.getElementById('drawToggleBtn');
      const drawToolbar = document.getElementById('drawToolbar');
      const drawToolBtn = document.getElementById('drawToolBtn');
      const drawEraserModeBtn = document.getElementById('drawEraserModeBtn');
      const drawSettingsBtn = document.getElementById('drawSettingsBtn');
      const drawUndoBtn = document.getElementById('drawUndoBtn');
      const drawRedoBtn = document.getElementById('drawRedoBtn');
      const drawResetBtn = document.getElementById('drawResetBtn');
      const drawSelectBtn = document.getElementById('drawSelectBtn');
      const drawSettingsPanel = document.getElementById('drawSettingsPanel');
      const drawBrushSelect = document.getElementById('drawBrush');
      const drawWidthInput = document.getElementById('drawWidth');
      const drawWidthVal = document.getElementById('drawWidthVal');
      const drawEraserWidthInput = document.getElementById('drawEraserWidth');
      const drawEraserWidthVal = document.getElementById('drawEraserWidthVal');
      const drawOpacityInput = document.getElementById('drawOpacity');
      const drawOpacityVal = document.getElementById('drawOpacityVal');
      const drawColorInput = document.getElementById('drawColor');
      const drawColorGrid = document.getElementById('drawColorGrid');
      const drawTextSizeInput = document.getElementById('drawTextSize');
      const drawTextSizeVal = document.getElementById('drawTextSizeVal');
      const drawTextFontSelect = document.getElementById('drawTextFont');
      const drawTextColorSlots = document.getElementById('drawTextColorSlots');
      const drawFontUpload = document.getElementById('drawFontUpload');
      const drawFontUploadBtn = document.getElementById('drawFontUploadBtn');
      const drawShapeSelect = document.getElementById('drawShape');
      const drawStampSelect = document.getElementById('drawStamp');
      const drawStampSave = document.getElementById('drawStampSave');
      const drawShadowInput = document.getElementById('drawShadow');
      const drawGlowInput = document.getElementById('drawGlow');
      const drawLayerList = document.getElementById('drawLayerList');
      const drawLayerAdd = document.getElementById('drawLayerAdd');
      const drawLayerDelete = document.getElementById('drawLayerDelete');
      const drawLayerUp = document.getElementById('drawLayerUp');
      const drawLayerDown = document.getElementById('drawLayerDown');
      const drawSizePreview = document.getElementById('drawSizePreview');
      const drawSelectionBox = document.getElementById('drawSelectionBox');
      const drawSelectOverlay = document.getElementById('drawSelectOverlay');
      const missLayer = document.getElementById('missLayer');
      const missPanel = document.getElementById('missPanel');
      const missQuickBtn = document.getElementById('missQuickBtn');
      const missBtn = document.getElementById('missBtn');
      const missPalette = document.getElementById('missPalette');
      const missPieMenu = document.getElementById('missPieMenu');
      const missSpawnMenu = document.getElementById('missSpawnMenu');
      const missTypePicker = document.getElementById('missTypePicker');
      const missEditPopover = document.getElementById('missEditPopover');
      const missEditNameInput = document.getElementById('missEditName');
      const missEditReasonInput = document.getElementById('missEditReason');
      const missEditExplainInput = document.getElementById('missEditExplain');
      const missMessageBox = document.getElementById('missMessageBox');
      const missMessageTitle = document.getElementById('missMessageTitle');
      const missMessageBody = document.getElementById('missMessageBody');
      const pageProgressOverlay = document.createElement('div');
      pageProgressOverlay.id = 'pageProgressOverlay';
      pageProgressOverlay.className = 'page-progress-overlay';
      const pageProgressFill = document.createElement('div');
      pageProgressFill.className = 'page-progress-fill';
      const pageProgressEffect = document.createElement('div');
      pageProgressEffect.className = 'page-progress-effect';
      pageProgressOverlay.appendChild(pageProgressFill);
      pageProgressOverlay.appendChild(pageProgressEffect);
      pageLayer?.appendChild(pageProgressOverlay);
      const tapDrawToggle = document.getElementById('tapDrawToggle');
      const selectionActions = document.createElement('div');
      selectionActions.className = 'selection-actions';
      selectionActions.innerHTML = `
        <button class="mini-menu" data-act="dup">複製</button>
        <button class="mini-menu" data-act="scale-up">拡大</button>
        <button class="mini-menu" data-act="scale-down">縮小</button>
        <button class="mini-menu danger" data-act="delete">削除</button>
      `;
      if (drawSelectionBox) drawSelectionBox.appendChild(selectionActions);
      selectionActions?.addEventListener('click', (e) => {
        const btn = e.target?.closest?.('button[data-act]');
        const act = btn?.dataset?.act;
        if (!act) return;
        e.stopPropagation();
        if (act === 'dup') duplicateSelectionStroke();
        if (act === 'scale-up') scaleSelectedStroke(1.1);
        if (act === 'scale-down') scaleSelectedStroke(0.9);
        if (act === 'delete') deleteSelectionStroke();
      });
      const interactionHint = document.getElementById('interactionHint');
      const pageBadge = document.getElementById('pageBadge');
      const pageBookTitle = document.getElementById('pageBookTitle');
      viewerClockOverlay = document.getElementById('viewerClockOverlay');
      viewerClockWrap = document.getElementById('viewerClockWrap');
      viewerClockEl = document.getElementById('viewerClock');
      viewerClockText = document.getElementById('viewerClockText');
      viewerTimerEl = document.getElementById('viewerTimerClock');
      viewerTimerText = document.getElementById('viewerTimerText');
      plannerFlyOverlay = document.getElementById('plannerFlyOverlay');
      plannerFly = document.getElementById('plannerFly');
      plannerFlyBody = document.getElementById('plannerFlyBody');
      numberlineFlyOverlay = document.getElementById('numberlineFlyOverlay');
      numberlineFly = document.getElementById('numberlineFly');
      numberlineFlyBody = document.getElementById('numberlineFlyBody');
      viewerClockContext = {
        stageButtonsRight: stage?.querySelector('.stage-buttons.right'),
        pageBadge,
        pageTitle: pageBookTitle
      };
      syncViewerClock(viewerClockContext);
      applyFlyPos(plannerFly, flyClockConfig.planner?.position || 'right', flyClockConfig.planner);
      applyFlyPos(numberlineFly, flyClockConfig.numberline?.position || 'left', flyClockConfig.numberline);
      if (flyClockConfig.planner?.visible) togglePlannerFly(true);
      if (flyClockConfig.numberline?.visible) toggleNumberlineFly(true);
      makeFlyDraggable(plannerFly);
      makeFlyDraggable(numberlineFly);
      const shouldShowPageTitle = () => state.viewerContext === 'completed' || (book?._openTabType === 'completed');
      const setPageTitle = (title) => {
        if (!pageBookTitle) return;
        if (title && shouldShowPageTitle()) {
          pageBookTitle.textContent = title;
          pageBookTitle.classList.remove('hidden');
        } else {
          pageBookTitle.textContent = '';
          pageBookTitle.classList.add('hidden');
        }
      };
      const syncCompletedPageLink = () => {
        if (!pageBookTitle) return;
        if (!shouldShowPageTitle()) {
          pageBookTitle.style.cursor = '';
          pageBookTitle.removeAttribute('title');
          pageBookTitle.onclick = null;
          return;
        }
        const meta = Array.isArray(book?.pages) ? book.pages[page] : null;
        const srcBookId = meta?._sourceBookId;
        const srcPage = Number.isFinite(meta?._sourcePage) ? meta._sourcePage : null;
        const srcIndex = Number.isFinite(meta?._sourcePageIndex) ? meta._sourcePageIndex : null;
        if (!srcBookId || (srcPage === null && !Number.isFinite(srcIndex))) {
          pageBookTitle.style.cursor = '';
          pageBookTitle.removeAttribute('title');
          pageBookTitle.onclick = null;
          return;
        }
        pageBookTitle.style.cursor = 'pointer';
        pageBookTitle.title = '本体のページを開く';
        pageBookTitle.onclick = async (e) => {
          e.stopPropagation();
          try {
            const srcBook = await Book.get(srcBookId);
            if (!srcBook) { showToast && showToast('本が見つかりません', 'error'); return; }
            let targetIndex = Number.isFinite(srcIndex) ? srcIndex : null;
            if (!Number.isFinite(targetIndex) && srcPage !== null) {
              if (Array.isArray(srcBook.pageNumberMap)) {
                const found = srcBook.pageNumberMap.indexOf(srcPage);
                if (found >= 0) targetIndex = found;
              }
              if (!Number.isFinite(targetIndex)) {
                const startNumber = Number.isFinite(srcBook.firstPageNumber)
                  ? srcBook.firstPageNumber
                  : parseInt(srcBook.firstPageNumber || '1', 10) || 1;
                targetIndex = Math.max(0, Math.min(srcBook.pages.length - 1, srcPage - startNumber));
              }
            }
            showTab && showTab('library', { preserveOpenTab: true });
            mountBookViewer(srcBook, { startPage: Number.isFinite(targetIndex) ? targetIndex : 0 });
          } catch (_) {
            showToast && showToast('本を開けませんでした', 'error');
          }
        };
      };
      const floatbar = document.getElementById('floatbar');
      const scrub = document.getElementById('scrubRange');
      const memoEl = document.getElementById('pageMemo');
      const memoToggle = document.getElementById('memoToggle');
      const memoBody = document.getElementById('memoBody');
      const stFav = document.getElementById('stFav');
      const stWeak = document.getElementById('stWeak');
      const stDone = document.getElementById('stDone');
      const customArea = document.getElementById('customStateArea');
      const customFilter = document.getElementById('customFilter');
      const bookMenuBtn = document.getElementById('bookMenuBtn');
      const bookMenuPanel = document.getElementById('bookMenuPanel');
      const menuDragHandle = document.getElementById('menuDragHandle');
      const menuCloseBtn = document.getElementById('menuCloseBtn');
      compareHideBtn = document.getElementById('compareHideBtn');
      const paneLeft = document.getElementById('paneLeft');
      const paneRight = document.getElementById('paneRight');
      const imgLeft = document.getElementById('imgLeft');
      const imgRight = document.getElementById('imgRight');
      const badgeLeft = document.getElementById('badgeLeft');
      const badgeRight = document.getElementById('badgeRight');
      const paneDivider = document.getElementById('paneDivider');
      const compareWindow = document.getElementById('compareWindow');
      const compareWindowTitle = document.getElementById('compareWindowTitle');
      const compareWindowImg = document.getElementById('compareWindowImg');
      const compareWindowStage = document.getElementById('compareWindowStage');
      const compareWindowPlaceholder = document.getElementById('compareWindowPlaceholder');
      const compareWindowPrev = document.getElementById('compareWindowPrev');
      const compareWindowNext = document.getElementById('compareWindowNext');
      const compareWindowClose = document.getElementById('compareWindowClose');
      const compareWindowDrag = document.getElementById('compareWindowDrag');
      const compareWindowPageBadge = document.getElementById('compareWindowPageBadge');
      const compareWindowRegister = document.getElementById('compareWindowRegister');
      const compareWindowBtn = document.getElementById('compareWindowBtn');
      const compareWindowSync = document.getElementById('compareWindowSync');
      const compareWindowSlice = document.getElementById('compareWindowSlice');
      const compareArrows = compareWindowStage?.querySelector('.stage-arrows');
      const tonePreset = document.getElementById('tonePreset');
      const toneLight = document.getElementById('toneLight');
      const toneDark = document.getElementById('toneDark');
      const toneApply = document.getElementById('toneApply');
      const toneCustomRow = document.getElementById('toneCustomRow');
      const toneFuncs = {
        r: document.getElementById('bookToneR'),
        g: document.getElementById('bookToneG'),
        b: document.getElementById('bookToneB')
      };
      if (compareWindowImg) {
        compareWindowImg.addEventListener('load', () => {
          markCompareMetricsDirty();
          refreshCompareZoomBounds();
          resetCompareView();
        });
      }
      const toneFilterByMode = {
        paper: 'url(#bookTonePaper)',
        canvas: 'url(#bookToneCanvas)',
        metal: 'url(#bookToneMetal)',
        water: 'url(#bookToneWater)'
      };
      const compareWindowZoomLock = document.getElementById('compareWindowZoomLock');
      const answerQuickBtn = document.getElementById('answerQuickBtn');
      const studyQuickBtn = document.getElementById('studyQuickBtn');
      const selectQuickBtn = document.getElementById('selectQuickBtn');
      const memoWindow = document.getElementById('memoWindow');
      const memoWindowInput = document.getElementById('memoWindowInput');
      const memoWindowClose = document.getElementById('memoWindowClose');
      const memoWindowDrag = document.getElementById('memoWindowDrag');
      const snippetPreview = document.getElementById('snippetPreviewImg');
      const snippetSourceHint = document.getElementById('snippetSourceHint');
      const snippetAnswerHint = document.getElementById('snippetAnswerHint');
      const linkedAnswerBar = document.getElementById('linkedAnswerBar');
      const linkedAnswerQuick = document.getElementById('linkedAnswerQuick');
      const linkedAnswerActions = document.getElementById('linkedAnswerActions');
      const linkedAnswerCompareBtn = document.getElementById('linkedAnswerCompareBtn');
      const linkedAnswerWindowBtn = document.getElementById('linkedAnswerWindowBtn');
      const answerLinkSelect = document.getElementById('answerLinkSelect');
      const answerLinkAdd = document.getElementById('answerLinkAdd');
      const savedPose = loadViewerPose(book.id) || null;
      let pendingPose = savedPose;
      try { reapplyStageToDom(); } catch (_) { }
      const selectionSurfaces = {
        single: { key: 'single', container: stage, img: img, canvas: cropSingle },
        left: { key: 'left', container: paneLeft, img: imgLeft, canvas: cropLeft },
        right: { key: 'right', container: paneRight, img: imgRight, canvas: cropRight },
        compareWindow: { key: 'compareWindow', container: compareWindowStage, img: compareWindowImg, canvas: cropCompareWindow }
      };
      const VIEWER_STATE_KEYS = {
        zoomLock: 'viewer-zoom-lock',
        panLock: 'viewer-pan-lock',
        sliceView: 'viewer-slice-view'
      };
      const COMPARE_STATE_KEYS = {
        zoomLock: 'compare-window-zoom-lock',
        panLock: 'compare-window-pan-lock'
      };
      const startPageOpt = Number.isFinite(opts.startPage) ? opts.startPage : null;
      const forceInitialPage = !!opts.forceStartPage || !!book._forceInitialPage;
      const initialPage = startPageOpt !== null
        ? startPageOpt
        : (Number.isFinite(book._initialPage) ? book._initialPage : 0);
      const maxPageIndex = Math.max(0, (book.pages?.length || 1) - 1);
      let page = Math.max(0, Math.min(maxPageIndex, initialPage));
      viewerMemory.book.page = page;
      let selecting = false, dragging = false, startX = 0, startY = 0, rectImg = null, rectContainer = null, boxRect = null;
      let activeSelectionSurface = selectionSurfaces.single;
      let selectionMeta = null;
      let pendingSelectionMeta = null;
      let pendingAnswerCrop = null;
      // spread/compare state
      let mode = 'single'; // 'single' | 'spread' | 'compare'
      let rightBook = null;
      let leftIndex = 0; // for dual views we use leftIndex always equals current 'page'
      let rightIndex = 1; // spread: right = left+1 ; compare: right book index
      let compareWindowBook = null;
      let compareWindowIndex = 0;
      let compareWindowOpen = false;
      let compareWindowMinimized = false;
      let compareWindowTransparent = loadStoredBool('viewer-compare-window-transparent', false);
      let compareWindowPos = loadStoredJSON('viewer-compare-window-pos');
      let compareZoom = 1;
      let comparePan = { x: 0, y: 0 };
      const compareTransparentCache = new Map();
      const COMPARE_TRANSPARENT_CACHE_MAX = 12;
      const touchCompareTransparentCache = (key, val) => {
        if (!key) return;
        if (compareTransparentCache.has(key)) compareTransparentCache.delete(key);
        compareTransparentCache.set(key, val);
        while (compareTransparentCache.size > COMPARE_TRANSPARENT_CACHE_MAX) {
          const oldest = compareTransparentCache.keys().next().value;
          compareTransparentCache.delete(oldest);
        }
      };
      const getCompareTransparentCache = (key) => {
        if (!key || !compareTransparentCache.has(key)) return null;
        const val = compareTransparentCache.get(key);
        compareTransparentCache.delete(key);
        compareTransparentCache.set(key, val);
        return val;
      };
      const clearCompareTransparentCache = () => compareTransparentCache.clear();
      let bookToneConfig = Object.assign({}, DEFAULT_TONE_CONFIG, loadStoredJSON(BOOK_TONE_KEY) || {});
      let toneOverrideConfig = null;
      const normalizeAutoToneConfig = (cfg = {}) => ({ enabled: !!cfg.enabled, mode: cfg.mode || 'red' });
      let autoToneConfig = normalizeAutoToneConfig(loadStoredJSON(AUTO_TONE_KEY) || {});
      const saveAutoToneConfig = (next = autoToneConfig) => {
        autoToneConfig = normalizeAutoToneConfig(next || {});
        try { saveStoredJSON(AUTO_TONE_KEY, autoToneConfig); } catch (_) { }
      };
      const refreshAutoToneConfig = () => {
        autoToneConfig = normalizeAutoToneConfig(loadStoredJSON(AUTO_TONE_KEY) || autoToneConfig || {});
        applyAutoToneIfNeeded();
      };
      window.__refreshAutoToneConfig = refreshAutoToneConfig;
      const pendingRightBookId = savedPose?.rightBookId || null;
      const pendingCompareWindowBookId = savedPose?.compareWindow?.bookId || null;
      async function transformTransparentBlue(src) {
        return new Promise((resolve, reject) => {
          const imgEl = new Image();
          imgEl.onload = () => {
            const w = imgEl.naturalWidth || imgEl.width;
            const h = imgEl.naturalHeight || imgEl.height;
            if (!w || !h) return reject(new Error('empty image'));
            const c = document.createElement('canvas');
            c.width = w; c.height = h;
            const ctx = c.getContext('2d');
            ctx.drawImage(imgEl, 0, 0, w, h);
            const data = ctx.getImageData(0, 0, w, h);
            const arr = data.data;
            for (let i = 0; i < arr.length; i += 4) {
              const r = arr[i], g = arr[i + 1], b = arr[i + 2], a = arr[i + 3];
              const lum = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255; // 0=black 1=white
              if (lum >= 0.9) { // ほぼ白 → 完全透明
                arr[i] = 0; arr[i + 1] = 0; arr[i + 2] = 255; arr[i + 3] = 0;
                continue;
              }
              const strength = Math.max(0, 1 - Math.pow(lum, 1.2)); // dark keeps opacity, light fades gently
              const alpha = strength * (a / 255);
              arr[i] = Math.round(32 * strength);
              arr[i + 1] = Math.round(32 * strength);
              arr[i + 2] = 255;
              arr[i + 3] = Math.max(0, Math.min(255, Math.round(alpha * 255)));
            }
            ctx.putImageData(data, 0, 0);
            resolve(c.toDataURL('image/png'));
          };
          imgEl.onerror = reject;
          imgEl.src = src;
        });
      }
      async function renderTransparentCompareImage(rawSrc) {
        if (!compareWindowImg || !rawSrc) return;
        try {
          const cached = getCompareTransparentCache(rawSrc);
          if (cached) { compareWindowImg.src = cached; return; }
          const out = await transformTransparentBlue(rawSrc);
          touchCompareTransparentCache(rawSrc, out);
          compareWindowImg.src = out;
        } catch (e) {
          compareWindowImg.src = rawSrc;
        }
      }
      const parseHexColor = (val) => {
        const m = (val || '').trim().match(/^#?([0-9a-f]{3}|[0-9a-f]{6})$/i);
        if (!m) return { r: 0, g: 0, b: 0 };
        let hex = m[1];
        if (hex.length === 3) { hex = hex.split('').map(ch => ch + ch).join(''); }
        const n = parseInt(hex, 16);
        return { r: (n >> 16) & 255, g: (n >> 8) & 255, b: n & 255 };
      };
      const getActiveToneConfig = () => toneOverrideConfig || bookToneConfig;
      const setToneColors = (shadowColor, highlightColor) => {
        const s = parseHexColor(shadowColor);
        const h = parseHexColor(highlightColor);
        ['r', 'g', 'b'].forEach((ch) => {
          const func = toneFuncs[ch];
          if (!func) return;
          const sVal = s[ch] / 255;
          const hVal = h[ch] / 255;
          const slope = Math.max(-2, Math.min(2, hVal - sVal)); // allow negative slope for dark->bright mapping
          const intercept = Math.max(0, Math.min(1, sVal));
          func.setAttribute('slope', slope.toFixed(4));
          func.setAttribute('intercept', intercept.toFixed(4));
        });
      };
      const setPageFilter = (val) => {
        document.documentElement.style.setProperty('--page-filter', val || 'none');
      };
      const syncToneUI = () => {
        if (tonePreset) tonePreset.value = bookToneConfig.mode || 'orig';
        if (toneLight) toneLight.value = (bookToneConfig.light || '#000000');
        if (toneDark) toneDark.value = (bookToneConfig.dark || '#00ff00');
        if (toneCustomRow) toneCustomRow.classList.toggle('hidden', (tonePreset?.value || 'orig') !== 'custom');
      };
      const tonePresetConfig = (mode) => {
        const preset = (mode || '').trim() || 'orig';
        if (preset === 'custom') {
          return { mode: 'custom', light: bookToneConfig.light || '#000000', dark: bookToneConfig.dark || '#00ff00' };
        }
        if (preset === 'green') return { mode: 'green', light: '#000000', dark: '#00ff00' };
        if (preset === 'red') return { mode: 'red', light: '#000000', dark: '#ff0000' };
        return { mode: preset };
      };
      const sameToneConfig = (a, b) => {
        if (!a && !b) return true;
        if (!a || !b) return false;
        return (a.mode === b.mode) && (a.light === b.light) && (a.dark === b.dark);
      };
      const setToneOverride = (cfg = null) => {
        const next = cfg ? Object.assign({}, DEFAULT_TONE_CONFIG, cfg) : null;
        if (sameToneConfig(toneOverrideConfig, next)) return;
        toneOverrideConfig = next;
        applyToneFilter();
      };
      const applyToneFilter = () => {
        const cfg = getActiveToneConfig();
        const mode = cfg.mode || 'orig';
        if (mode === 'orig') { setPageFilter('none'); return; }
        if (mode === 'invert') { setPageFilter('invert(1)'); return; }
        const mappedFilter = toneFilterByMode[mode];
        if (mappedFilter) {
          setPageFilter(mappedFilter);
          return;
        }
        let light = cfg.light || '#000000';
        let dark = cfg.dark || '#00ff00';
        if (mode === 'green') { light = '#000000'; dark = '#00ff00'; }
        if (mode === 'red') { light = '#000000'; dark = '#ff0000'; }
        setToneColors(dark, light);
        setPageFilter('url(#bookToneFilter)');
      };
      const saveToneConfig = () => {
        try { saveStoredJSON(BOOK_TONE_KEY, bookToneConfig); } catch (e) { }
      };
      const updateToneConfig = (next = {}) => {
        bookToneConfig = Object.assign({}, DEFAULT_TONE_CONFIG, bookToneConfig, next);
        saveToneConfig();
        syncToneUI();
        applyToneFilter();
        applyAutoToneIfNeeded();
      };
      syncToneUI();
      applyToneFilter();
      function applyAutoToneIfNeeded() {
        if (autoToneConfig.enabled && compareWindowOpen && compareWindowTransparent) {
          setToneOverride(tonePresetConfig(autoToneConfig.mode));
        } else {
          setToneOverride(null);
        }
      }
      function setCompareWindowImage(rawSrc) {
        if (!compareWindowImg) return;
        compareWindowImg.dataset.rawSrc = rawSrc || '';
        if (!rawSrc) { compareWindowImg.removeAttribute('src'); return; }
        if (compareWindowTransparent) { renderTransparentCompareImage(rawSrc); }
        else { compareWindowImg.src = rawSrc; }
      }
      function syncCompareWindowImage() {
        if (!compareWindowImg) return;
        const raw = compareWindowImg.dataset.rawSrc || '';
        if (!raw) { compareWindowImg.removeAttribute('src'); return; }
        if (compareWindowTransparent) { renderTransparentCompareImage(raw); }
        else { compareWindowImg.src = raw; }
      }
      let compareNeedsReset = false;
      let compareZoomLocked = loadStoredBool(COMPARE_STATE_KEYS.zoomLock, false);
      let comparePanLocked = loadStoredBool(COMPARE_STATE_KEYS.panLock, false);
      let compareBadgeEditing = false;
      let compareBadgeEditClosedAt = 0;
      let pageBadgeEditing = false;
      let pageBadgeEditClosedAt = 0;
      const COMPARE_ZOOM_MIN = 0.4;
      const COMPARE_ZOOM_MAX = 6;
      let controlWidth = parseFloat(localStorage.getItem('viewer-control-width') || '340') || 340;
      let lastViewState = null; // keep track of what was shown for flip animation
      book.answerBookIds = Array.from(new Set(Array.isArray(book.answerBookIds) ? book.answerBookIds.filter(id => id && id !== book.id) : []));
      if (book.pages?.length) {
        const savedPage = getLastPageIndex(book.id);
        const skipSavedPage = forceInitialPage || startPageOpt !== null;
        if (!skipSavedPage && typeof savedPage === 'number') {
          page = clamp(savedPage, 0, book.pages.length - 1);
        }
      }
      if (savedPose) {
        if (typeof savedPose.page === 'number' && book.pages?.length) {
          page = clamp(savedPose.page, 0, book.pages.length - 1);
        }
        if (savedPose.mode) { mode = savedPose.mode; }
        if (typeof savedPose.rightIndex === 'number') { rightIndex = savedPose.rightIndex; }
        if (typeof savedPose.leftIndex === 'number') { leftIndex = savedPose.leftIndex; }
        if (typeof savedPose.compareRightHidden === 'boolean') { compareRightHidden = savedPose.compareRightHidden; }
        if (typeof savedPose.controlWidth === 'number') { controlWidth = clamp(savedPose.controlWidth, 240, Math.max(280, controlWidth)); }
        if (savedPose.compareWindow) {
          compareWindowOpen = !!savedPose.compareWindow.open;
          compareWindowMinimized = !!savedPose.compareWindow.minimized;
          compareWindowTransparent = savedPose.compareWindow.transparent ?? compareWindowTransparent;
          compareWindowPos = savedPose.compareWindow.pos || compareWindowPos;
          if (typeof savedPose.compareWindow.index === 'number') { compareWindowIndex = savedPose.compareWindow.index; }
          if (savedPose.compareWindow.pan) { comparePan = savedPose.compareWindow.pan; }
          if (typeof savedPose.compareWindow.zoom === 'number') { compareZoom = savedPose.compareWindow.zoom; }
        }
      }
      applyAutoToneIfNeeded();
      function compareStageAnchorFromClient(clientX, clientY) {
        const m = computeCompareViewMetrics();
        const rect = m.stageRect;
        if (!rect) return { x: 0, y: 0 };
        const baseOffset = m.offset || { x: 0, y: 0 };
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        return { x: clientX - centerX - baseOffset.x, y: clientY - centerY - baseOffset.y };
      }
      function compareStageAnchorCenter() {
        const m = computeCompareViewMetrics();
        const rect = m.stageRect;
        if (!rect) return { x: 0, y: 0 };
        return compareStageAnchorFromClient(rect.left + rect.width / 2, rect.top + rect.height / 2);
      }
      let compareMinZoom = COMPARE_ZOOM_MIN;
      let compareMaxZoom = COMPARE_ZOOM_MAX;
      let compareViewMetricsDirty = true;
      let compareViewMetrics = { stageRect: null, parentRect: null, baseW: 0, baseH: 0, offset: { x: 0, y: 0 } };
      const markCompareMetricsDirty = () => { compareViewMetricsDirty = true; };
      const computeCompareViewMetrics = () => {
        if (!compareViewMetricsDirty) return compareViewMetrics;
        compareViewMetricsDirty = false;
        const stageRect = compareWindowStage?.getBoundingClientRect?.() || null;
        const parent = compareWindowImg?.offsetParent;
        const parentRect = parent?.getBoundingClientRect?.() || null;
        const naturalW = compareWindowImg?.naturalWidth || 0;
        const naturalH = compareWindowImg?.naturalHeight || 0;
        let baseW = compareWindowImg?.offsetWidth || compareWindowImg?.clientWidth || naturalW || 0;
        let baseH = compareWindowImg?.offsetHeight || compareWindowImg?.clientHeight || naturalH || 0;
        if (compareSliceMode && stageRect) {
          if (naturalW && naturalH) {
            const aspect = naturalH / naturalW;
            baseW = stageRect.width || baseW;
            baseH = (stageRect.width || baseW) * aspect;
          } else {
            baseW = stageRect.width || baseW;
            baseH = stageRect.height || baseH;
          }
        }
        let offset = { x: 0, y: 0 };
        if (stageRect && parentRect && compareWindowImg) {
          const layoutCenterX = parentRect.left + compareWindowImg.offsetLeft + (compareWindowImg.offsetWidth || 0) / 2;
          const layoutCenterY = parentRect.top + compareWindowImg.offsetTop + (compareWindowImg.offsetHeight || 0) / 2;
          const stageCenterX = stageRect.left + stageRect.width / 2;
          const stageCenterY = stageRect.top + stageRect.height / 2;
          offset = { x: layoutCenterX - stageCenterX, y: layoutCenterY - stageCenterY };
        }
        compareViewMetrics = { stageRect, parentRect, baseW, baseH, offset };
        return compareViewMetrics;
      };
      const refreshCompareZoomBounds = () => {
        const metrics = computeCompareViewMetrics();
        const stageRect = metrics.stageRect;
        const baseW = metrics.baseW;
        const baseH = metrics.baseH;
        if (stageRect && baseW && baseH) {
          const fitWidth = stageRect.width / (baseW || 1);
          const fitHeight = stageRect.height / (baseH || 1);
          const preferWidthFit = true; // 比較ビューは常に横を基準にフィットさせる
          const fitZoom = preferWidthFit ? fitWidth : Math.min(fitWidth, fitHeight);
          compareMinZoom = Math.max(COMPARE_ZOOM_MIN, fitZoom);
        } else {
          compareMinZoom = COMPARE_ZOOM_MIN;
        }
        compareMaxZoom = Math.max(COMPARE_ZOOM_MAX, compareMinZoom);
        if (compareZoom < compareMinZoom) compareZoom = compareMinZoom;
      };
      function setCompareZoom(next, { anchor = null } = {}) {
        markCompareMetricsDirty();
        refreshCompareZoomBounds();
        const prev = compareZoom || 1;
        const target = clamp(next, compareMinZoom, compareMaxZoom);
        const pivot = anchor || { x: 0, y: 0 };
        if (prev !== target) {
          comparePan.x = pivot.x - (target / prev) * (pivot.x - comparePan.x);
          comparePan.y = pivot.y - (target / prev) * (pivot.y - comparePan.y);
        }
        compareZoom = target;
        applyCompareTransform();
      }
      function clampComparePan() {
        const metrics = computeCompareViewMetrics();
        const stageRect = metrics.stageRect;
        const baseW = metrics.baseW;
        const baseH = metrics.baseH;
        const offset = metrics.offset || { x: 0, y: 0 };
        compareZoom = Math.max(compareMinZoom, Math.min(compareMaxZoom, compareZoom));
        if (!stageRect || !baseW || !baseH) return;
        const margin = 10;
        const scaledW = baseW * compareZoom;
        const scaledH = baseH * compareZoom;
        const softMaxX = Math.max(margin, ((scaledW - stageRect.width) / 2) + margin);
        const softMaxY = Math.max(margin, ((scaledH - stageRect.height) / 2) + margin);
        comparePan.x = Math.max(-softMaxX - offset.x, Math.min(softMaxX - offset.x, comparePan.x));
        comparePan.y = Math.max(-softMaxY - offset.y, Math.min(softMaxY - offset.y, comparePan.y));
      }
      function applyCompareTransform() {
        refreshCompareZoomBounds();
        clampComparePan();
        if (compareWindowImg) {
          compareWindowImg.style.transformOrigin = 'center center';
          compareWindowImg.style.transform = `translate(${comparePan.x}px,${comparePan.y}px) scale(${compareZoom})`;
        }
        requestPoseSave();
      }
      function resetCompareView() {
        markCompareMetricsDirty();
        refreshCompareZoomBounds();
        compareZoom = compareMinZoom;
        comparePan = { x: 0, y: 0 };
        applyCompareTransform();
      }
      function requestCompareViewReset() {
        compareNeedsReset = true;
      }
      function updateCompareLockButtons() {
        if (compareWindowZoomLock) {
          compareWindowZoomLock.classList.toggle('active', compareZoomLocked);
          compareWindowZoomLock.textContent = compareZoomLocked ? '🔒ロック' : '🔓ロック';
          compareWindowZoomLock.setAttribute('aria-pressed', compareZoomLocked ? 'true' : 'false');
        }
        if (compareWindowStage) {
          compareWindowStage.classList.toggle('pan-disabled', comparePanLocked);
        }
      }
      function setCompareZoomLock(next) {
        compareZoomLocked = next;
        comparePanLocked = next;
        saveStoredBool(COMPARE_STATE_KEYS.zoomLock, compareZoomLocked);
        saveStoredBool(COMPARE_STATE_KEYS.panLock, comparePanLocked);
        compareStageSurface?.cancel?.();
        updateCompareLockButtons();
      }
      function updateCompareDockUI() {
        if (compareWindow) {
          compareWindow.classList.remove('minimized');
        }
      }
      function rememberCompareWindowPosition() {
        const viewerRect = wrap.getBoundingClientRect();
        const rect = compareWindow?.getBoundingClientRect();
        if (!rect || !compareWindow) return;
        const clamped = clampPanelPosition(compareWindow, rect.left - viewerRect.left, rect.top - viewerRect.top);
        compareWindowPos = clamped;
        saveStoredJSON('viewer-compare-window-pos', compareWindowPos);
      }
      function applyCompareWindowPosition(pos) {
        if (!compareWindow || !pos || Number.isNaN(pos.left) || Number.isNaN(pos.top)) return;
        const clamped = clampPanelPosition(compareWindow, pos.left, pos.top);
        compareWindow.style.left = `${clamped.left}px`;
        compareWindow.style.top = `${clamped.top}px`;
        compareWindowPos = clamped;
        saveStoredJSON('viewer-compare-window-pos', compareWindowPos);
      }
      function setCompareWindowMinimized(next) {
        compareWindowMinimized = false;
        if (compareWindowOpen) {
          if (compareWindowPos) {
            applyCompareWindowPosition(compareWindowPos);
          } else {
            ensureCompareWindowPosition();
          }
        }
        updateCompareDockUI();
        markCompareMetricsDirty();
        applyCompareTransform();
      }
      function setCompareWindowTransparent(next) {
        compareWindowTransparent = !!next;
        saveStoredBool('viewer-compare-window-transparent', compareWindowTransparent);
        if (!compareWindowTransparent) clearCompareTransparentCache();
        syncCompareWindowImage();
        updateCompareWindowUI(true);
        requestPoseSave();
        applyAutoToneIfNeeded();
      }
      function registerAnswerMapping() {
        if (!compareWindowOpen || !compareWindowBook || !compareWindowBook.pages?.length) {
          showToast && showToast('解答ウィンドウが開いていません', 'error');
          return;
        }
        const realPage = realOf(page);
        const baseId = currentAnswerBaseId();
        if (!baseId) {
          showToast && showToast('解答を紐付けできませんでした', 'error');
          return;
        }
        const targetIdx = clamp(compareWindowIndex, 0, compareWindowBook.pages.length - 1);
        setAnswerPageMapping(baseId, compareWindowBook.id, realPage, targetIdx);
        showToast && showToast(`解答を ${realPage}p に登録しました`, `ok`);
      }
      const updateCompareWindowPinUI = () => { };
      let compareModalTarget = 'split'; // 'split' | 'window'

      let filter = 'all', customFilterId = '';
      let flipTimer = null;
      let multi = false; const selected = new Set();
      const BASE_MIN_ZOOM = 0.4;
      const BASE_MAX_ZOOM = 6;
      const viewState = { zoom: 1, minZoom: BASE_MIN_ZOOM, maxZoom: BASE_MAX_ZOOM, translateX: 0, translateY: 0, userAdjusted: false };
      let viewMetricsDirty = true;
      let viewMetrics = { stageRect: null, parentRect: null, baseW: 0, baseH: 0, offset: { x: 0, y: 0 } };
      let lastMainTransform = '';
      const drawStore = new Map();
      const drawDocs = new Map();
      const layerBuffers = new Map();
      const CUSTOM_STAMP_KEY = 'draw-custom-stamps';
      const getLayerBuffer = (id) => {
        if (!id || !drawCanvas) return null;
        let buf = layerBuffers.get(id);
        if (!buf) {
          buf = document.createElement('canvas');
          layerBuffers.set(id, buf);
        }
        if (buf.width !== drawCanvas.width || buf.height !== drawCanvas.height) {
          buf.width = drawCanvas.width;
          buf.height = drawCanvas.height;
        }
        return buf;
      };
      const STAMP_BUILTINS = [
        { id: 'check', name: 'チェック', size: 32, strokes: [{ points: [{ x: -10, y: 4 }, { x: -2, y: 12 }, { x: 12, y: -8 }], width: 5, color: 'inherit', brush: 'smooth' }] },
        { id: 'star', name: 'スター', size: 28, strokes: [{ points: [{ x: 0, y: -12 }, { x: 5, y: -2 }, { x: 14, y: -2 }, { x: 7, y: 4 }, { x: 10, y: 14 }, { x: 0, y: 8 }, { x: -10, y: 14 }, { x: -7, y: 4 }, { x: -14, y: -2 }, { x: -5, y: -2 }, { x: 0, y: -12 }], width: 3, color: 'inherit', brush: 'pencil' }] },
        { id: 'sparkle', name: 'キラキラ', size: 30, strokes: [{ points: [{ x: 0, y: -12 }, { x: 2, y: -2 }, { x: 12, y: 0 }, { x: 2, y: 2 }, { x: 0, y: 12 }, { x: -2, y: 2 }, { x: -12, y: 0 }, { x: -2, y: -2 }, { x: 0, y: -12 }], width: 2.6, color: 'inherit', brush: 'soft' }] }
      ];
      let customStamps = Array.isArray(loadStoredJSON(CUSTOM_STAMP_KEY)) ? loadStoredJSON(CUSTOM_STAMP_KEY) : [];
      let stampTemplates = [...STAMP_BUILTINS, ...(customStamps || [])];
      const saveCustomStamps = () => {
        try { localStorage.setItem(CUSTOM_STAMP_KEY, JSON.stringify(customStamps.slice(0, 40))); } catch (_) { }
      };
      const makeBarPoof = (bar) => {
        if (!bar || !bar.parentElement) return;
        const shell = document.createElement('div');
        shell.className = 'nl-bar-poof-shell';
        shell.style.left = bar.style.left || '0';
        shell.style.width = bar.style.width || bar.getBoundingClientRect().width + 'px';
        shell.style.height = bar.style.height || '100%';
        shell.style.zIndex = '5';
        const baseColor = getComputedStyle(bar).backgroundColor || '#7dd3fc';
        shell.style.setProperty('--poof-color', baseColor);
        const dots = 8;
        for (let i = 0; i < dots; i++) {
          const d = document.createElement('span');
          d.className = 'nl-poof-dot';
          const angle = (Math.PI * 2 / dots) * i + Math.random() * 0.5;
          const dist = 26 + Math.random() * 18;
          d.style.setProperty('--tx', `${Math.cos(angle) * dist}px`);
          d.style.setProperty('--ty', `${Math.sin(angle) * dist}px`);
          shell.appendChild(d);
        }
        bar.parentElement.appendChild(shell);
        setTimeout(() => shell.remove(), 600);
      };
      const refreshStampTemplates = () => {
        stampTemplates = [...STAMP_BUILTINS, ...(customStamps || [])];
        renderStampOptions();
      };
      let activeStampId = '';
      let activeDrawKey = null;
      let drawDoc = null;
      let drawMode = false;
      let drawingStroke = false;
      const drawPointers = new Set();
      let drawGestureActive = false;
      let drawDirty = false;
      let missPanelOpen = false;
      let missActiveId = null;
      let missMoveState = null;
      let missDragState = null;
      let missClickSuppress = false;
      let missMessageState = null;
      let missMessageHighlightId = null;
      let missSpawnAnchor = null;
      let missSpawnOutsideHandler = null;
      let missSpawnFollowRaf = null;
      const missCursorClient = { x: null, y: null };
      const MISS_MESSAGE_MODES = ['reason', 'explain'];
      const missElementMap = new Map();
      let missSourceLoadToken = null;
      const DRAW_STORE_PREFIX = 'draw-layer:';
      const DRAW_DOC_PREFIX = 'draw-doc:';
      const DRAW_SAVE_DEBOUNCE = 700;
      const parseDrawKey = (key) => {
        const m = key?.match(/^book:(.+):p(\d+)$/);
        if (!m) return null;
        return { bookId: m[1], pageIndex: parseInt(m[2], 10) };
      };
      const parseStoredDrawDoc = (raw) => {
        if (!raw) return null;
        if (typeof raw === 'string') {
          try { return JSON.parse(raw); } catch (_) { return null; }
        }
        if (typeof raw === 'object') return raw;
        return null;
      };
      const attachDrawDocToPage = (key, doc) => {
        const meta = parseDrawKey(key);
        if (!meta || !doc || !book || book.id !== meta.bookId || !Array.isArray(book.pages) || !book.pages[meta.pageIndex]) return false;
        const existing = book.pages[meta.pageIndex].drawDoc;
        if (existing === doc) return false;
        book.pages[meta.pageIndex].drawDoc = doc;
        return true;
      };
      let drawPersistTimer = null;
      let drawPersistIdleHandle = null;
      const persistDrawDocToBook = ({ key = activeDrawKey, doc = drawDoc, immediate = false } = {}) => {
        const meta = parseDrawKey(key);
        if (!meta || !doc || !book || book.id !== meta.bookId || !Book?.put || !Array.isArray(book.pages) || !book.pages[meta.pageIndex]) return;
        book.pages[meta.pageIndex].drawDoc = doc;
        if (drawPersistTimer) { clearTimeout(drawPersistTimer); drawPersistTimer = null; }
        if (drawPersistIdleHandle && typeof cancelIdleCallback === 'function') {
          try { cancelIdleCallback(drawPersistIdleHandle); } catch (_) { }
          drawPersistIdleHandle = null;
        }
        const commit = () => {
          drawPersistTimer = null;
          drawPersistIdleHandle = null;
          // Skip if still actively drawing to avoid blocking UI
          if (drawingStroke && !immediate) {
            // Re-schedule after a delay
            drawPersistTimer = setTimeout(() => {
              scheduleCommit();
            }, 500);
            return;
          }
          try {
            const p = Book.put(book);
            if (p?.catch) p.catch((err) => console.warn('draw persist failed', err));
          } catch (err) { console.warn('draw persist failed', err); }
        };
        const scheduleCommit = () => {
          // Use requestIdleCallback to avoid blocking main thread
          if (typeof requestIdleCallback === 'function') {
            drawPersistIdleHandle = requestIdleCallback(commit, { timeout: 2000 });
          } else {
            setTimeout(commit, 50);
          }
        };
        if (immediate) { commit(); return; }
        // Longer debounce during active drawing
        const delay = drawingStroke ? 1500 : DRAW_SAVE_DEBOUNCE;
        drawPersistTimer = setTimeout(scheduleCommit, delay);
      };
      const flushDrawPersist = () => persistDrawDocToBook({ immediate: true });
      const persistActiveDrawDocNow = () => {
        if (!activeDrawKey || !drawDoc) return;
        try { localStorage.setItem(drawDocKey(activeDrawKey), JSON.stringify(drawDoc)); } catch (_) { }
        attachDrawDocToPage(activeDrawKey, drawDoc);
        persistDrawDocToBook({ key: activeDrawKey, doc: drawDoc, immediate: true });
      };
      let drawTool = 'pen'; // 'pen' | 'eraser'
      let eraserMode = 'brush'; // 'brush' | 'stroke'
      let strokeEraseActive = false;
      let strokeEraseChanged = false;
      let drawSelection = null;
      let selectingStroke = false;
      let sizeAdjustMode = false;
      let sizeAdjustOrigin = null;
      let sizeAdjustBaseWidth = 0;
      let sizeAdjustSmoothWidth = 0;
      let lastCursorPos = { x: 0, y: 0 };
      let lastErasePoint = null;
      let gPreviewVisible = false;
      let rDrawActive = false;
      let straightAnchor = null;
      let shapeMode = 'free';
      let stampPlacementActive = false;
      let stampPreviewCanvas = null;
      let textOverlay = null;
      let activeTextStroke = null;
      let activeTextPos = null;
      let activeTextInput = null;
      let textDragOffset = null;
      let customFonts = [];
      let ctrlOverrideTool = null;
      let poseApplied = false;
      let poseSavePending = false;
      let tapDrawAlways = false;
      let tapDrawActive = false;
      let tapDrawPrevMode = false;
      const requestPoseSave = () => {
        try { if (!book?.id) return; } catch (_) { return; }
        if (poseSavePending) return;
        poseSavePending = true;
        requestAnimationFrame(() => { poseSavePending = false; try { persistViewerPose(); } catch (_) { } });
      };
      const snapshotPaneState = (ctrl) => {
        if (!ctrl || !ctrl.getState) return null;
        const st = ctrl.getState();
        return { zoom: st.zoom, translateX: st.translateX, translateY: st.translateY };
      };
      function persistViewerPose() {
        if (!book?.id) return;
        const pose = {
          page,
          mode,
          leftIndex,
          rightIndex,
          rightBookId: rightBook?.id || null,
          compareRightHidden,
          controlWidth,
          view: { zoom: viewState.zoom, tx: viewState.translateX, ty: viewState.translateY },
          left: snapshotPaneState(leftPaneController),
          right: snapshotPaneState(rightPaneController),
          compareWindow: {
            open: compareWindowOpen,
            minimized: compareWindowMinimized,
            transparent: compareWindowTransparent,
            bookId: compareWindowBook?.id || null,
            index: compareWindowIndex,
            pos: compareWindowPos,
            pan: comparePan,
            zoom: compareZoom
          }
        };
        saveViewerPose(book.id, pose);
      }
      const markViewMetricsDirty = () => { viewMetricsDirty = true; };
      const computeViewMetrics = () => {
        if (!viewMetricsDirty) return viewMetrics;
        viewMetricsDirty = false;
        const stageRect = stage?.getBoundingClientRect?.() || null;
        const target = pageLayer || img;
        const parent = target?.offsetParent;
        const parentRect = parent?.getBoundingClientRect?.() || null;
        const targetRect = target?.getBoundingClientRect?.() || null;
        const baseW = img?.offsetWidth || target?.offsetWidth || img?.clientWidth || targetRect?.width || img?.naturalWidth || 0;
        const baseH = img?.offsetHeight || target?.offsetHeight || img?.clientHeight || targetRect?.height || img?.naturalHeight || 0;
        let offset = { x: 0, y: 0 };
        if (stageRect && parentRect && target) {
          const layoutCenterX = parentRect.left + target.offsetLeft + (target.offsetWidth || 0) / 2;
          const layoutCenterY = parentRect.top + target.offsetTop + (target.offsetHeight || 0) / 2;
          const stageCenterX = stageRect.left + stageRect.width / 2;
          const stageCenterY = stageRect.top + stageRect.height / 2;
          offset = { x: layoutCenterX - stageCenterX, y: layoutCenterY - stageCenterY };
        }
        viewMetrics = { stageRect, parentRect, baseW, baseH, offset };
        return viewMetrics;
      };
      let skipNextPageAnim = false;
      let zoomLocked = loadStoredBool(VIEWER_STATE_KEYS.zoomLock, false);
      let panLocked = loadStoredBool(VIEWER_STATE_KEYS.panLock, false);
      let sliceMode = loadStoredBool(VIEWER_STATE_KEYS.sliceView, false);
      function useZoomResetOnly() { return sliceMode && zoomResetOnly; }
      function syncZoomResetOnlyToggle() {
        const toggle = keyNavForm.resetZoomOnlyToggle;
        if (!toggle) return;
        toggle.disabled = !sliceMode;
        toggle.checked = sliceMode ? !!zoomResetOnly : false;
      }
      const COMPARE_SLICE_KEY = 'compare-slice-view';
      let compareSliceMode = loadStoredBool(COMPARE_SLICE_KEY, false);
      syncZoomResetOnlyToggle();
      let panMoved = false;
      let hintTimer = null;
      let stagePanning = false;
      let swipeStart = null;
      let answerLinkBookCache = [];
      const PANE_SPLIT_KEY = 'viewer-pane-split';
      let splitRatio = parseFloat(localStorage.getItem(PANE_SPLIT_KEY));
      if (isNaN(splitRatio)) splitRatio = 0.5;
      splitRatio = Math.min(0.8, Math.max(0.2, splitRatio));
      const computeMinZoomForClamp = () => {
        // 半切モードで「画面外に出ない」がONならカバー基準、OFFなら通常通り。
        const preferFitHeight = (mode === 'single') && !sliceMode;
        const clampEnabled = keyNavConfig.bookClamp || preferFitHeight || sliceMode;
        if (!clampEnabled) return BASE_MIN_ZOOM;
        const metrics = computeViewMetrics();
        const stageRect = metrics.stageRect;
        const clientW = metrics.baseW || 0;
        const clientH = metrics.baseH || 0;
        const naturalW = img?.naturalWidth || 0;
        const naturalH = img?.naturalHeight || 0;
        const baseW = clientW || naturalW;
        const baseH = clientH || naturalH;
        if (!stageRect || !baseW || !baseH) return BASE_MIN_ZOOM;
        if (sliceMode && !keyNavConfig.bookClamp) {
          const fitHeight = stageRect.height / baseH;
          const sliceMin = Math.min(1, fitHeight);
          return Math.max(BASE_MIN_ZOOM, sliceMin);
        }
        if (sliceMode && keyNavConfig.bookClamp) {
          // cover 基準: 横・縦どちらもステージを埋める最小ズームを採用
          const coverZoom = Math.max(stageRect.width / (baseW || 1), stageRect.height / (baseH || 1));
          return Math.max(BASE_MIN_ZOOM, coverZoom);
        }
        if (preferFitHeight) {
          if (!baseH) return BASE_MIN_ZOOM;
          const fitHeight = stageRect.height / baseH;
          return Math.min(1, fitHeight);
        }
        const fitZoom = Math.min(stageRect.width / (baseW || 1), stageRect.height / (baseH || 1)); // contain基準
        const minZoom = Math.max(BASE_MIN_ZOOM, fitZoom);
        return Math.min(1, minZoom); // ベースを1以上に跳ね上げない
      };
      const refreshZoomBounds = () => {
        const minZoom = computeMinZoomForClamp();
        viewState.minZoom = minZoom;
        viewState.maxZoom = Math.max(BASE_MAX_ZOOM, minZoom);
        const preferFitHeight = (mode === 'single') && !sliceMode;
        if (preferFitHeight && !viewState.userAdjusted) {
          viewState.zoom = minZoom;
        } else if (viewState.zoom < minZoom) {
          viewState.zoom = minZoom;
        }
      };
      let lastImgLoadKey = null;
      if (img) {
        img.onload = () => {
          const key = `${page}|${img.currentSrc || img.src || ''}`;
          const sameImage = key === lastImgLoadKey;
          lastImgLoadKey = key;
          markViewMetricsDirty();
          if (sameImage) {
            applyViewTransform();
            syncDrawCanvasSize();
            return;
          }
          // 初期表示から滑らかに動くように、リセット時もスムーズを有効にする
          resetViewState({ keepAdjusted: false, smooth: true });
          syncDrawCanvasSize();
        };
      }
      if (stage && typeof ResizeObserver !== 'undefined') {
        const ro = new ResizeObserver(() => {
          markViewMetricsDirty();
        });
        ro.observe(stage);
      }
      if (pageLayer && typeof ResizeObserver !== 'undefined') {
        let drawResizeTimer = null;
        const roDraw = new ResizeObserver(() => {
          // Skip resize sync during active drawing to prevent lag
          if (drawingStroke) return;
          // Throttle resize events
          if (drawResizeTimer) return;
          drawResizeTimer = setTimeout(() => {
            drawResizeTimer = null;
            if (!drawingStroke) syncDrawCanvasSize();
          }, 150);
        });
        roDraw.observe(pageLayer);
      }
      function primaryAnswerId() {
        // Completed-viewer: choose answer linked to the source book/page
        if (state.viewerContext === 'completed' && book?._sourceAnswerLinkMap) {
          const real = realOf(page);
          const links = book._sourceAnswerLinkMap?.[real];
          if (Array.isArray(links) && links.length) return links[0];
        }
        const links = book.answerBookIds || [];
        return links.length ? links[0] : null;
      }
      function triggerPrimaryAnswer(mode) {
        const id = primaryAnswerId();
        if (!id) return;
        if (mode === 'window') { openLinkedAnswerInWindow(id); }
        else { startLinkedCompare(id); }
      }
      // expose for quick-menu helpers
      window.primaryAnswerId = primaryAnswerId;
      window.triggerPrimaryAnswer = triggerPrimaryAnswer;
      memoToggle?.addEventListener('click', () => {
        if (!memoBody) return;
        const nowHidden = memoBody.classList.toggle('hidden');
        memoToggle.textContent = nowHidden ? 'メモ欄を開く' : 'メモ欄を閉じる';
        updateQuickActionButtons();
      });
      stageMenuBtn?.addEventListener('click', (e) => {
        e.stopPropagation();
        setMenu(true);
      });
      pageListBtn?.addEventListener('click', (e) => {
        e.stopPropagation();
        if (typeof window.__openThumbGrid === 'function') {
          const goTo = (idx) => {
            if (jumpInput) jumpInput.value = String((book.firstPageNumber || 1) + idx);
            if (jumpGo) jumpGo.click();
          };
          window.__openThumbGrid(book, page, goTo);
        }
      });
      answerLinkAdd?.addEventListener('click', async () => {
        if (!answerLinkSelect) return;
        const targetId = answerLinkSelect.value;
        if (!targetId) {
          showToast('解答を選択してください', 'error');
          return;
        }
        if (book.answerBookIds.includes(targetId)) {
          showToast('既に紐付け済みです');
          return;
        }
        book.answerBookIds.push(targetId);
        await Book.put(book);
        answerLinkSelect.value = '';
        await refreshAnswerLinkUI();
        refresh();
        showToast('解答を紐付けました', 'ok');
      });
      linkedAnswerQuick?.addEventListener('click', async (e) => {
        const actionBtn = e.target.closest('button');
        if (!actionBtn) return;
        const chip = actionBtn.closest('.answer-chip');
        if (!chip) return;
        const targetId = chip.dataset.answer;
        if (!targetId) return;
        const action = actionBtn.dataset.action;
        if (action === 'window') {
          await openLinkedAnswerInWindow(targetId);
          return;
        }
        if (action === 'remove') {
          book.answerBookIds = book.answerBookIds.filter(id => id !== targetId);
          await Book.put(book);
          await refreshAnswerLinkUI();
          refresh();
          showToast('紐付けを解除しました', 'ok');
          return;
        }
        await startLinkedCompare(targetId);
      });
      linkedAnswerCompareBtn?.addEventListener('click', (e) => { e.stopPropagation(); triggerPrimaryAnswer('compare'); });
      linkedAnswerWindowBtn?.addEventListener('click', (e) => { e.stopPropagation(); triggerPrimaryAnswer('window'); });
      function updateLockButtons() {
        if (zoomLockBtn) {
          zoomLockBtn.classList.toggle('active', zoomLocked);
          zoomLockBtn.textContent = zoomLocked ? '🔒ズ' : '🔓ズ';
          zoomLockBtn.setAttribute('aria-pressed', zoomLocked ? 'true' : 'false');
        }
        if (panLockBtn) {
          panLockBtn.classList.toggle('active', panLocked);
          panLockBtn.textContent = panLocked ? '🔒移' : '🔓移';
          panLockBtn.setAttribute('aria-pressed', panLocked ? 'true' : 'false');
        }
        if (sliceViewBtn) {
          sliceViewBtn.classList.toggle('active', sliceMode);
          sliceViewBtn.setAttribute('aria-pressed', sliceMode ? 'true' : 'false');
        }
        updateQuickActionButtons();
      }
      function applySliceViewState() {
        stageHost?.classList.toggle('slice-view', sliceMode);
        if (sliceViewBtn) {
          sliceViewBtn.textContent = sliceMode ? '半切✓' : '半切';
        }
      }
      function applyCompareSliceState() {
        if (compareWindow) compareWindow.classList.toggle('slice-view', compareSliceMode);
        if (compareWindowSlice) {
          compareWindowSlice.classList.toggle('active', compareSliceMode);
          compareWindowSlice.textContent = compareSliceMode ? '半切✓' : '半切';
          compareWindowSlice.setAttribute('aria-pressed', compareSliceMode ? 'true' : 'false');
        }
      }
      function setZoomLock(next) {
        zoomLocked = next;
        saveStoredBool(VIEWER_STATE_KEYS.zoomLock, zoomLocked);
        stageSurface?.cancel?.();
        stopInertia();
        paneControllers.forEach(ctrl => ctrl.cancelInteractions?.());
        updateLockButtons();
        updateHintText();
        if (mode === 'single') showInteractionHint();
      }
      function setPanLock(next) {
        panLocked = next;
        saveStoredBool(VIEWER_STATE_KEYS.panLock, panLocked);
        if (panLocked) {
          stageSurface?.cancel?.();
          paneControllers.forEach(ctrl => ctrl.cancelInteractions?.());
          stopInertia();
        }
        stage?.classList.toggle('pan-disabled', mode !== 'single' || panLocked);
        updateLockButtons();
        updateHintText();
      }
      function setSliceView(next) {
        sliceMode = next;
        saveStoredBool(VIEWER_STATE_KEYS.sliceView, sliceMode);
        syncZoomResetOnlyToggle();
        updateLockButtons();
        applySliceViewState();
        markViewMetricsDirty();
        skipNextPageAnim = true;
        if (sliceMode) {
          autoFitForSlice();
        } else {
          autoFitForMainMode();
        }
      }
      function setCompareSliceView(next) {
        compareSliceMode = next;
        saveStoredBool(COMPARE_SLICE_KEY, compareSliceMode);
        applyCompareSliceState();
        markCompareMetricsDirty();
        resetCompareView();
      }
      async function getBooksForLinking(force = false) {
        if (!force && Array.isArray(window.__allBooksCache) && window.__allBooksCache.length) {
          return window.__allBooksCache;
        }
        const books = await Book.listMeta();
        window.__allBooksCache = books;
        return books;
      }
      function renderAnswerLinkSelect(allBooks) {
        if (!answerLinkSelect) return;
        const links = book.answerBookIds || [];
        const candidates = allBooks.filter(b => b.id !== book.id && !links.includes(b.id)).sort((a, b) => (a.title || '').localeCompare(b.title || ''));
        answerLinkSelect.innerHTML = '';
        if (!candidates.length) {
          const opt = document.createElement('option');
          opt.value = '';
          opt.textContent = '追加できる本がありません';
          answerLinkSelect.appendChild(opt);
          answerLinkSelect.disabled = true;
          if (answerLinkAdd) answerLinkAdd.disabled = true;
          return;
        }
        answerLinkSelect.disabled = false;
        if (answerLinkAdd) answerLinkAdd.disabled = false;
        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.textContent = '解答を選択';
        answerLinkSelect.appendChild(placeholder);
        candidates.forEach(b => {
          const opt = document.createElement('option');
          opt.value = b.id;
          opt.textContent = `${b.title || '無題'} (${pageCountOf(b)}p)`;
          answerLinkSelect.appendChild(opt);
        });
      }
      function updateLinkedAnswerChips(allBooks) {
        if (!linkedAnswerBar || !linkedAnswerQuick) return;
        linkedAnswerQuick.innerHTML = '';
        let links = [];
        try { links = book?.answerBookIds || []; } catch (_) { links = []; }
        const hasLinks = links.length > 0;
        linkedAnswerBar.classList.toggle('hidden', !hasLinks);
        if (linkedAnswerActions) {
          linkedAnswerActions.classList.toggle('hidden', !hasLinks);
        }
        if (!hasLinks) { updateQuickActionButtons(); return; }
        links.forEach(id => {
          const target = allBooks.find(b => b.id === id);
          const title = target?.title || '（見つかりません）';
          const chip = document.createElement('div');
          chip.className = 'answer-chip';
          chip.dataset.answer = id;
          chip.innerHTML = `<strong>${escapeHTML(title)}</strong>
        <button type="button" data-action="split" title="並べて比較">↔</button>
        <button type="button" data-action="window" title="解答ウィンドウ">🗔</button>
        <button type="button" data-action="remove" title="紐付け解除">×</button>`;
          linkedAnswerQuick.appendChild(chip);
        });
        updateQuickActionButtons();
      }
      async function refreshAnswerLinkUI(force = false) {
        if (!answerLinkSelect && !linkedAnswerBar) return;
        const books = await getBooksForLinking(force);
        answerLinkBookCache = books;
        renderAnswerLinkSelect(books);
        updateLinkedAnswerChips(books);
      }
      async function resolveAnswerBook(targetId) {
        if (!targetId) return null;
        let target = answerLinkBookCache.find(b => b.id === targetId && Array.isArray(b.pages) && b.pages.length);
        if (!target) {
          target = await Book.get(targetId);
          if (target) {
            const idx = answerLinkBookCache.findIndex(b => b.id === targetId);
            if (idx >= 0) answerLinkBookCache[idx] = target;
            else answerLinkBookCache.push(target);
          }
        }
        return target;
      }
      function getCompareStartIndexFor(targetBook) {
        if (!targetBook?.pages?.length) return 0;
        const saved = getLastCompareIndex(book.id, targetBook.id);
        if (typeof saved === 'number' && !Number.isNaN(saved)) {
          return clamp(saved, 0, targetBook.pages.length - 1);
        }
        return idxFromRealForBook(targetBook, realOf(page));
      }
      async function startLinkedCompare(targetId, { forceResetIndex = false } = {}) {
        if (!targetId) return;
        if (mode === 'compare' && rightBook?.id === targetId) {
          exitCompareMode({ toast: true });
          return;
        }
        let target = await resolveAnswerBook(targetId);
        if (!target) {
          showToast('解答が見つかりません', 'error');
          return;
        }
        if (!target.pages?.length) {
          showToast('ページがありません', 'error');
          return;
        }
        rightBook = target;
        rightIndex = getCompareStartIndexFor(target);
        mode = 'compare';
        compareEnd?.classList.remove('hidden');
        compareStart?.classList.add('hidden');
        compareRightHidden = false;
        pendingAnswerCrop = null;
        selecting = false;
        syncSelectingUI();
        load();
        showToast(`${target.title || '解答'} と比較を開始`, 'ok');
      }
      async function openLinkedAnswerInWindow(targetId) {
        if (!targetId) return;
        if (compareWindowBook?.id === targetId) {
          syncCompareWindowToMapping({ allowClosed: true });
          if (compareWindowOpen) {
            setCompareWindowOpen(false);
            showToast('解答ウィンドウを一時的に閉じました', 'ok');
            return;
          }
          setCompareWindowMinimized(false);
          setCompareWindowOpen(true);
          showToast('解答ウィンドウを表示しました', 'ok');
          return;
        }
        let target = await resolveAnswerBook(targetId);
        if (!target) {
          showToast('解答が見つかりません', 'error');
          return;
        }
        if (!target.pages?.length) {
          showToast('ページがありません', 'error');
          return;
        }
        setCompareWindowBook(target, { forceResetIndex: true });
        setCompareWindowMinimized(false);
        setCompareWindowOpen(true);
      }
      const toggleAnswerWindowHotkey = () => {
        if (compareWindowOpen) {
          setCompareWindowOpen(false);
          return;
        }
        const pid = primaryAnswerId();
        if (!pid) {
          showToast('紐付け解答がありません', 'error');
          return;
        }
        openLinkedAnswerInWindow(pid);
      };
      updateLockButtons();
      applySliceViewState();
      applyCompareSliceState();
      refreshAnswerLinkUI(true);
      drawToggleBtn?.setAttribute('title', 'ドローモードOFF');
      zoomLockBtn?.addEventListener('click', (e) => {
        e.stopPropagation();
        setZoomLock(!zoomLocked);
      });
      panLockBtn?.addEventListener('click', (e) => {
        e.stopPropagation();
        setPanLock(!panLocked);
      });
      sliceViewBtn?.addEventListener('click', (e) => {
        e.stopPropagation();
        setSliceView(!sliceMode);
      });
      studyQuickBtn?.addEventListener('click', (e) => {
        e.stopPropagation();
        try { StudyActionMenu && StudyActionMenu.toggle && StudyActionMenu.toggle({ source: 'viewer-button' }); renderPageProgressOverlay(); } catch (_) { }
      });
      answerQuickBtn?.addEventListener('click', (e) => {
        e.stopPropagation();
        const pid = primaryAnswerId();
        if (!pid) {
          showToast('紐付け解答がありません', 'error');
          return;
        }
        openLinkedAnswerInWindow(pid);
      });
      selectQuickBtn?.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleSelect();
      });
      function syncMemoFields(value, source) {
        if (memoEl && source !== 'main') memoEl.value = value;
        if (memoWindowInput && source !== 'window') memoWindowInput.value = value;
      }
      async function commitMemo(value) {
        book.pages[page].memo = value;
        await Book.put(book);
        updateThumbs();
      }
      memoEl?.addEventListener('input', () => { syncMemoFields(memoEl.value, 'main'); });
      memoEl?.addEventListener('change', () => commitMemo(memoEl.value));
      memoWindowInput?.addEventListener('input', () => { syncMemoFields(memoWindowInput.value, 'window'); });
      memoWindowInput?.addEventListener('change', () => commitMemo(memoWindowInput.value));
      let menuOpen = false;
      let memoWindowOpen = false;
      const bodyObserver = new MutationObserver(() => updateFloatbarVisibility());
      bodyObserver.observe(document.body, { attributes: true, attributeFilter: ['class'] });
      function updateFloatbarVisibility() {
        if (!floatbar) return;
        const shouldShow = document.body.classList.contains('mainmode2');
        floatbar.classList.toggle('hidden', !shouldShow);
      }
      function clampPanelPosition(panel, left, top) {
        const viewerRect = wrap.getBoundingClientRect();
        const panelRect = panel.getBoundingClientRect();
        const width = panelRect.width || panel.offsetWidth || 320;
        const height = panelRect.height || panel.offsetHeight || 220;
        const barRect = document.querySelector('.topbar')?.getBoundingClientRect();
        const minTop = Math.max(0, (barRect?.bottom ?? 0) - viewerRect.top + 8);
        const minLeft = -width * 0.2;
        const maxLeft = viewerRect.width - width * 0.2;
        const maxTop = viewerRect.height - height * 0.2;
        return {
          left: Math.max(minLeft, Math.min(left, maxLeft)),
          top: Math.max(minTop, Math.min(top, maxTop))
        };
      }
      function makeDraggable(panel, handle, { onMove, isEnabled, allowResize = false } = {}) {
        if (!panel || !handle) return;
        let dragging = false;
        let offsetX = 0, offsetY = 0;
        const canDrag = () => typeof isEnabled === 'function' ? !!isEnabled() : true;
        const isResizeZone = (clientX, clientY) => {
          if (!allowResize || handle !== panel) return false;
          const rect = panel.getBoundingClientRect();
          const edge = 18;
          const nearRight = (rect.right - clientX) <= edge;
          const nearLeft = (clientX - rect.left) <= edge;
          const nearBottom = (rect.bottom - clientY) <= edge;
          const nearTop = (clientY - rect.top) <= edge;
          return nearRight || nearLeft || nearBottom || nearTop;
        };
        const move = (clientX, clientY) => {
          if (!dragging) return;
          const viewerRect = wrap.getBoundingClientRect();
          let left = clientX - offsetX - viewerRect.left;
          let top = clientY - offsetY - viewerRect.top;
          const clamped = clampPanelPosition(panel, left, top);
          panel.style.left = `${clamped.left}px`;
          panel.style.top = `${clamped.top}px`;
          onMove?.(clamped.left, clamped.top);
        };
        const end = () => {
          if (!dragging) return;
          dragging = false;
          panel.classList.remove('dragging');
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
          document.removeEventListener('touchmove', onTouchMove);
          document.removeEventListener('touchend', onTouchEnd);
        };
        const start = (clientX, clientY) => {
          if (!canDrag()) return;
          if (isResizeZone(clientX, clientY)) return; // allow native resize handles
          const rect = panel.getBoundingClientRect();
          offsetX = clientX - rect.left;
          offsetY = clientY - rect.top;
          dragging = true;
          panel.classList.add('dragging');
        };
        const onMouseMove = (e) => move(e.clientX, e.clientY);
        const onMouseUp = () => end();
        const onTouchMove = (e) => { const { x, y } = pointerClientXY(e); move(x, y); e.preventDefault(); };
        const onTouchEnd = () => end();
        handle.addEventListener('mousedown', (e) => {
          if (e.button !== 0) return;
          if (e.target.closest('button, input, select, textarea')) return;
          const { clientX, clientY } = e;
          if (isResizeZone(clientX, clientY)) return; // let native resize work
          e.preventDefault();
          start(clientX, clientY);
          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', onMouseUp);
        });
        handle.addEventListener('touchstart', (e) => {
          if (e.target.closest('button, input, select, textarea')) return;
          const { x, y } = pointerClientXY(e);
          if (isResizeZone(x, y)) return; // let native resize work
          start(x, y);
          e.preventDefault();
          document.addEventListener('touchmove', onTouchMove, { passive: false });
          document.addEventListener('touchend', onTouchEnd);
        }, { passive: false });
      }
      makeDraggable(bookMenuPanel, menuDragHandle);
      makeDraggable(memoWindow, memoWindowDrag);
      makeDraggable(compareWindow, compareWindowDrag, {
        onMove: (left, top) => {
          compareWindowPos = { left, top };
          saveStoredJSON('viewer-compare-window-pos', compareWindowPos);
          markCompareMetricsDirty();
          applyCompareTransform();
          requestPoseSave();
        }
      });
      makeDraggable(compareWindow, compareWindow, {
        isEnabled: () => compareWindowOpen && compareZoomLocked,
        onMove: (left, top) => {
          compareWindowPos = { left, top };
          saveStoredJSON('viewer-compare-window-pos', compareWindowPos);
          requestPoseSave();
        },
        allowResize: true
      });
      if (compareWindowStage) {
        const ro = new ResizeObserver(() => { markCompareMetricsDirty(); applyCompareTransform(); });
        ro.observe(compareWindowStage);
      }
      if (compareWindowImg) {
        compareWindowImg.addEventListener('load', () => {
          markCompareMetricsDirty();
          refreshCompareZoomBounds();
          if (compareNeedsReset) {
            resetCompareView();
          } else {
            applyCompareTransform();
          }
          compareNeedsReset = false;
        });
        if (compareWindowImg.complete && compareWindowImg.naturalWidth) {
          markCompareMetricsDirty();
          refreshCompareZoomBounds();
          applyCompareTransform();
          compareNeedsReset = false;
        }
      }
      if (tonePreset) {
        tonePreset.addEventListener('change', () => {
          const mode = tonePreset.value;
          updateToneConfig({ mode });
        });
      }
      const handleToneInput = () => {
        updateToneConfig({
          mode: tonePreset?.value || 'custom',
          light: toneLight?.value || '#000000',
          dark: toneDark?.value || '#00ff00'
        });
      };
      toneLight?.addEventListener('input', () => { if ((tonePreset?.value || '') === 'custom') handleToneInput(); });
      toneDark?.addEventListener('input', () => { if ((tonePreset?.value || '') === 'custom') handleToneInput(); });
      toneApply?.addEventListener('click', (e) => { e.preventDefault(); handleToneInput(); });
      let compareStageSurface = null;
      if (compareWindowStage) {
        const canUseCompareStage = () => compareWindowOpen && !!compareWindowBook && !!compareWindowImg?.src;
        compareStageSurface = createPanZoomSurface({
          element: compareWindowStage,
          anchorFromClient: compareStageAnchorFromClient,
          getEnabled: () => canUseCompareStage(),
          getZoom: () => compareZoom,
          setZoom: (next, { anchor } = {}) => setCompareZoom(next, { anchor }),
          getZoomLocked: () => compareZoomLocked,
          getPanLocked: () => comparePanLocked || (selecting && !selectionPanOverride),
          applyPanDelta: (dx, dy) => {
            comparePan.x += dx;
            comparePan.y += dy;
            applyCompareTransform();
          },
          onPanStart: () => { compareWindowStage.classList.add('grabbing'); },
          onPanEnd: () => { compareWindowStage.classList.remove('grabbing'); },
          onReset: () => { resetCompareView(); compareNeedsReset = false; },
          doubleTapResetEnabled: true,
          shouldIgnoreTarget: (target) => target.closest('.compare-quick') || target.closest('.stage-arrows') || target.closest('.compare-page-badge')
        });
        const ignoreTarget = (target) => target.closest('.compare-quick') || target.closest('.stage-arrows') || target.closest('.compare-page-badge');
        compareWindowStage.addEventListener('mousedown', (e) => {
          if (!selecting) return;
          if (pendingAnswerCrop && pendingAnswerCrop.surfaceKey !== 'compareWindow') return;
          if (ignoreTarget(e.target)) return;
          selectionPanOverride = false;
          e.preventDefault();
          startDrag(e, selectionSurfaces.compareWindow);
        });
        compareWindowStage.addEventListener('touchstart', (e) => {
          if (!selecting) return;
          if (pendingAnswerCrop && pendingAnswerCrop.surfaceKey !== 'compareWindow') return;
          if (ignoreTarget(e.target)) return;
          selectionPanOverride = e.touches.length > 1;
          if (e.touches.length === 1) {
            e.preventDefault();
            startDrag(e, selectionSurfaces.compareWindow);
          }
        }, { passive: false });
        compareWindowStage.addEventListener('touchmove', (e) => {
          if (!selecting) return;
          if (selectionPanOverride) return;
          e.preventDefault();
          moveDrag(e);
        }, { passive: false });
        compareWindowStage.addEventListener('touchend', (e) => {
          if (!selecting) return;
          if (selectionPanOverride && e.touches.length > 0) return;
          selectionPanOverride = false;
          e.preventDefault();
          endDrag(e);
        }, { passive: false });
      }
      updateCompareLockButtons();
      updateCompareDockUI();
      function setMenu(open) {
        if (!bookMenuPanel) return;
        menuOpen = open;
        bookMenuPanel.classList.toggle('open', open);
      }
      function toggleMenu() { setMenu(!menuOpen); }
      function setMemoWindow(open) {
        if (!memoWindow) return;
        memoWindowOpen = open;
        memoWindow.classList.toggle('open', open);
        updateQuickActionButtons();
      }
      bookMenuBtn?.addEventListener('click', (e) => { e.stopPropagation(); toggleMenu(); });
      bookMenuPanel?.addEventListener('click', (e) => e.stopPropagation());
      memoWindow?.addEventListener('click', (e) => e.stopPropagation());
      compareWindow?.addEventListener('click', (e) => e.stopPropagation());
      memoWindowClose?.addEventListener('click', () => setMemoWindow(false));
      updateFloatbarVisibility();
      const menuActionsContainer = document.getElementById('menuActions');
      const menuActionSettings = document.getElementById('menuActionSettings');
      menuActionsContainerRef = menuActionsContainer;
      if (menuActionSettings) menuActionSettingsRef = menuActionSettings;
      updateCompareWindowUI();
      renderMenuButtons();
      renderMenuActionSettings();
      menuCloseBtn?.addEventListener('click', () => setMenu(false));
      function saveSplitRatio() {
        try { localStorage.setItem(PANE_SPLIT_KEY, splitRatio.toFixed(3)); } catch (err) { }
      }
      function applySplitRatio() {
        if (!paneLeft || !paneRight) return;
        const activeRatio = (compareRightHidden && mode === 'compare') ? 0.9 : splitRatio;
        const leftFlex = Math.min(0.95, Math.max(0.2, activeRatio));
        const rightFlex = Math.max(0.05, 1 - leftFlex);
        paneLeft.style.flex = `${leftFlex}`;
        paneRight.style.flex = `${rightFlex}`;
        if (paneDivider) {
          if (mode === 'single' || compareRightHidden) {
            paneDivider.style.display = 'none';
          } else {
            paneDivider.style.display = '';
            paneDivider.style.left = `calc(${(leftFlex * 100).toFixed(2)}% - 6px)`;
          }
        }
        markViewMetricsDirty();
      }
      let dividerDragging = false;
      let dividerRect = null;
      const dividerMouseMove = (e) => {
        if (!dividerDragging || !dividerRect) return;
        let ratio = (e.clientX - dividerRect.left) / dividerRect.width;
        ratio = Math.min(0.85, Math.max(0.15, ratio));
        splitRatio = ratio;
        saveSplitRatio();
        applySplitRatio();
      };
      const dividerTouchMove = (e) => {
        if (!dividerDragging || !dividerRect) return;
        const { x } = pointerClientXY(e);
        let ratio = (x - dividerRect.left) / dividerRect.width;
        ratio = Math.min(0.85, Math.max(0.15, ratio));
        splitRatio = ratio;
        saveSplitRatio();
        applySplitRatio();
      };
      const stopDividerDrag = () => {
        if (!dividerDragging) return;
        dividerDragging = false;
        paneDivider?.classList.remove('active');
        document.removeEventListener('mousemove', dividerMouseMove);
        document.removeEventListener('mouseup', stopDividerDrag);
        document.removeEventListener('touchmove', dividerTouchMove);
        document.removeEventListener('touchend', stopDividerDrag);
      };
      const startDividerDrag = (clientX) => {
        if (!paneDivider || !stageDual || mode === 'single' || compareRightHidden || stageDual.classList.contains('hidden')) return;
        dividerDragging = true;
        paneDivider.classList.add('active');
        dividerRect = stageDual.getBoundingClientRect();
        document.addEventListener('mousemove', dividerMouseMove);
        document.addEventListener('mouseup', stopDividerDrag);
        document.addEventListener('touchmove', dividerTouchMove, { passive: false });
        document.addEventListener('touchend', stopDividerDrag);
      };
      paneDivider?.addEventListener('mousedown', (e) => { e.preventDefault(); startDividerDrag(e.clientX); });
      paneDivider?.addEventListener('touchstart', (e) => { const { x } = pointerClientXY(e); startDividerDrag(x); e.preventDefault(); }, { passive: false });
      let resizeRaf = null;
      const onWindowResize = () => {
        if (resizeRaf) return;
        resizeRaf = requestAnimationFrame(() => {
          resizeRaf = null;
          markViewMetricsDirty();
          applySplitRatio();
          refreshZoomBounds();
          syncDrawCanvasSize();
          applyViewTransform();
        });
      };
      window.addEventListener('resize', onWindowResize);
      compareHideBtn?.addEventListener('click', () => {
        if (mode !== 'compare') return;
        compareRightHidden = !compareRightHidden;
        applyCompareHideState();
      });
      function anchorFromElement(el, clientX, clientY) {
        if (!el) return { x: 0, y: 0 };
        const rect = el.getBoundingClientRect();
        return { x: clientX - (rect.left + rect.width / 2), y: clientY - (rect.top + rect.height / 2) };
      }
      function computeLayoutOffset(containerEl, imgEl) {
        if (containerEl === stage && imgEl === img) {
          const m = computeViewMetrics();
          return m.offset || { x: 0, y: 0 };
        }
        if (!containerEl || !imgEl) return { x: 0, y: 0 };
        const parent = imgEl.offsetParent;
        const containerRect = containerEl.getBoundingClientRect?.();
        const parentRect = parent?.getBoundingClientRect?.();
        if (!containerRect || !parentRect) return { x: 0, y: 0 };
        const layoutCenterX = parentRect.left + imgEl.offsetLeft + (imgEl.offsetWidth || 0) / 2;
        const layoutCenterY = parentRect.top + imgEl.offsetTop + (imgEl.offsetHeight || 0) / 2;
        const containerCenterX = containerRect.left + containerRect.width / 2;
        const containerCenterY = containerRect.top + containerRect.height / 2;
        return { x: layoutCenterX - containerCenterX, y: layoutCenterY - containerCenterY };
      }
      function getStageLayoutOffset() {
        const m = computeViewMetrics();
        return m.offset || { x: 0, y: 0 };
      }
      function stageAnchorFromClient(clientX, clientY) {
        const m = computeViewMetrics();
        const rect = m.stageRect;
        if (!rect) return { x: 0, y: 0 };
        const baseOffset = m.offset || { x: 0, y: 0 };
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        return { x: clientX - centerX - baseOffset.x, y: clientY - centerY - baseOffset.y };
      }
      function stageAnchorCenter() {
        const m = computeViewMetrics();
        const rect = m.stageRect;
        if (!rect) return { x: 0, y: 0 };
        return stageAnchorFromClient(rect.left + rect.width / 2, rect.top + rect.height / 2);
      }
      const applyArrowPadding = (container, stageRect, targetRect, minPad = 12) => {
        if (!container || !stageRect) return;
        const arrow = container.querySelector('.stage-arrow');
        const arrowH = arrow?.getBoundingClientRect?.().height || 82;
        const mid = targetRect ? (targetRect.top + targetRect.height / 2) - stageRect.top : stageRect.height / 2;
        const top = Math.max(minPad, Math.min(stageRect.height - arrowH - minPad, mid - arrowH / 2));
        const bottom = Math.max(minPad, stageRect.height - arrowH - top);
        container.style.alignItems = 'flex-start';
        container.style.paddingTop = `${top}px`;
        container.style.paddingBottom = `${bottom}px`;
      };
      const clearArrowPadding = (container) => {
        if (!container) return;
        container.style.removeProperty('padding-top');
        container.style.removeProperty('padding-bottom');
        container.style.removeProperty('align-items');
      };
      function syncArrowLayouts() {
        if (stageArrows) {
          const stageRect = stage?.getBoundingClientRect?.();
          const targetRect = pageLayer?.getBoundingClientRect?.() || img?.getBoundingClientRect?.();
          // 半切モードでも通常配置を維持し、ページ移動で位置が変わらないように固定
          clearArrowPadding(stageArrows);
        }
        if (compareArrows) {
          clearArrowPadding(compareArrows);
        }
      }
      function touchDistance(a, b) {
        const dx = a.clientX - b.clientX;
        const dy = a.clientY - b.clientY;
        return Math.hypot(dx, dy);
      }
      function createPanZoomSurface(options = {}) {
        const {
          element,
          anchorFromClient = (x, y) => ({ x, y }),
          getEnabled = () => true,
          getZoom = () => 1,
          setZoom = () => { },
          getZoomLocked = () => false,
          getPanLocked = () => false,
          applyPanDelta = () => { },
          onPanStart = () => { },
          onPanEnd = () => { },
          onReset = () => { },
          shouldIgnoreTarget = (_target, _evt) => false,
          doubleTapThreshold = 350,
          doubleTapDistance = 28,
          doubleTapResetEnabled = true
        } = options || {};
        if (!element) return { destroy: () => { } };
        let dragging = false;
        let pointerId = null;
        let lastPointer = null;
        let pinchActive = false;
        let pinchStartDist = 0;
        let pinchStartZoom = 1;
        let pinchAnchor = null;
        let pinchMid = null;
        let lastTapTime = 0;
        let lastTapPos = null;
        const cleanup = [];
        const add = (target, type, handler, opts) => {
          if (!target) return;
          target.addEventListener(type, handler, opts);
          cleanup.push(() => target.removeEventListener(type, handler, opts));
        };
        const resetPanTotals = () => {
          panTotalDX = 0;
          lastPanDeltaX = 0;
        };
        const canInteract = (target, evt) => getEnabled() && !shouldIgnoreTarget(target, evt);
        const stopDrag = (withMomentum = false) => {
          if (!dragging) return;
          dragging = false;
          if (pointerId !== null) {
            try { element.releasePointerCapture(pointerId); } catch (err) { }
          }
          pointerId = null;
          if (withMomentum) { startMomentum(); } else { stopMomentum(); }
          onPanEnd();
        };
        const supportsPointer = typeof window !== 'undefined' && 'PointerEvent' in window;
        let velocity = { x: 0, y: 0 };
        // 慣性の強さを調整（軽いドラッグでも少し残る）
        const MOMENTUM_WINDOW = 200;
        const MIN_SPEED = 0.00003;
        const DECAY = 0.94;
        const BOOST = 1.1;
        const MAX_SPEED = 1.4;
        let moveHistory = [];
        let moveHistoryTime = 0;
        let lastMoveTime = 0;
        let momentumId = null;
        const clampVel = (v) => Math.max(-MAX_SPEED, Math.min(MAX_SPEED, v));
        const clearHistory = () => {
          moveHistory = [];
          moveHistoryTime = 0;
        };
        const pushMove = (dx, dy, dt) => {
          if (dt <= 0) return;
          moveHistory.push({ dx, dy, dt });
          moveHistoryTime += dt;
          while (moveHistoryTime > MOMENTUM_WINDOW && moveHistory.length) {
            moveHistoryTime -= moveHistory[0].dt;
            moveHistory.shift();
          }
        };
        const blendedVelocity = () => {
          if (!moveHistory.length) return { ...velocity };
          let totalW = 0, totalX = 0, totalY = 0, elapsed = 0;
          // weight recent moves more for a snappier release
          for (let i = moveHistory.length - 1; i >= 0; i--) {
            const m = moveHistory[i];
            elapsed += m.dt;
            const recency = Math.max(0, MOMENTUM_WINDOW - elapsed) / MOMENTUM_WINDOW;
            const weight = 0.6 + 1.4 * recency;
            totalW += m.dt * weight;
            totalX += m.dx * weight;
            totalY += m.dy * weight;
            if (elapsed > MOMENTUM_WINDOW) break;
          }
          if (totalW <= 0) return { ...velocity };
          return {
            x: clampVel(totalX / totalW),
            y: clampVel(totalY / totalW)
          };
        };
        const stopMomentum = (resetVelocity = true) => {
          if (momentumId) { cancelAnimationFrame(momentumId); momentumId = null; }
          if (resetVelocity) velocity = { x: 0, y: 0 };
        };
        const startMomentum = () => {
          if (getPanLocked() || !getEnabled()) return;
          const releaseVel = blendedVelocity();
          stopMomentum(false);
          velocity.x = clampVel(releaseVel.x);
          velocity.y = clampVel(releaseVel.y);
          const speed = Math.max(Math.abs(velocity.x), Math.abs(velocity.y));
          if (speed < MIN_SPEED) {
            stopMomentum();
            return;
          }
          let lastTs = performance.now();
          const step = (ts) => {
            const dt = Math.max(1, ts - lastTs);
            lastTs = ts;
            velocity.x = clampVel(velocity.x * DECAY);
            velocity.y = clampVel(velocity.y * DECAY);
            applyPanDelta(velocity.x * dt * BOOST, velocity.y * dt * BOOST);
            if (Math.max(Math.abs(velocity.x), Math.abs(velocity.y)) < MIN_SPEED) {
              stopMomentum();
              return;
            }
            momentumId = requestAnimationFrame(step);
          };
          momentumId = requestAnimationFrame(step);
        };
        const pointerDown = (e) => {
          if (!canInteract(e.target, e)) return;
          if (getPanLocked()) return;
          if (e.pointerType !== 'touch' && e.button !== 0) return;
          if (e.pointerType === 'touch' && pinchActive) return;
          dragging = true;
          pointerId = e.pointerId;
          lastPointer = { x: e.clientX, y: e.clientY };
          lastMoveTime = performance.now();
          velocity = { x: 0, y: 0 };
          clearHistory();
          stopMomentum();
          onPanStart();
          try { element.setPointerCapture(e.pointerId); } catch (err) { }
          e.preventDefault();
        };
        const pointerMove = (e) => {
          if (!dragging || e.pointerId !== pointerId) return;
          if (getPanLocked()) { stopDrag(); try { element.releasePointerCapture(e.pointerId); } catch (err) { } return; }
          const dx = e.clientX - (lastPointer?.x || e.clientX);
          const dy = e.clientY - (lastPointer?.y || e.clientY);
          lastPointer = { x: e.clientX, y: e.clientY };
          if (dx !== 0 || dy !== 0) {
            const now = performance.now();
            const dt = Math.max(1, now - lastMoveTime);
            pushMove(dx, dy, dt);
            velocity.x = clampVel(dx / dt);
            velocity.y = clampVel(dy / dt);
            lastMoveTime = now;
            applyPanDelta(dx, dy);
          }
          e.preventDefault();
        };
        const pointerEnd = (e) => {
          if (e.pointerId !== pointerId) return;
          stopDrag(true);
        };
        const pointerLost = () => { stopDrag(); };
        const mouseDown = (e) => {
          if (!canInteract(e.target, e)) return;
          if (getPanLocked()) return;
          if (e.button !== 0) return;
          dragging = true;
          resetPanTotals();
          lastPointer = { x: e.clientX, y: e.clientY };
          lastMoveTime = performance.now();
          velocity = { x: 0, y: 0 };
          clearHistory();
          stopMomentum();
          onPanStart();
          e.preventDefault();
        };
        const mouseMove = (e) => {
          if (!dragging) return;
          if (getPanLocked()) { stopDrag(); return; }
          const dx = e.clientX - (lastPointer?.x || e.clientX);
          const dy = e.clientY - (lastPointer?.y || e.clientY);
          lastPointer = { x: e.clientX, y: e.clientY };
          if (dx !== 0 || dy !== 0) {
            const now = performance.now();
            const dt = Math.max(1, now - lastMoveTime);
            pushMove(dx, dy, dt);
            velocity.x = clampVel(dx / dt);
            velocity.y = clampVel(dy / dt);
            lastMoveTime = now;
            applyPanDelta(dx, dy);
          }
        };
        const mouseUp = () => { if (!dragging) return; stopDrag(true); };
        if (supportsPointer) {
          add(element, 'pointerdown', pointerDown);
          add(element, 'pointermove', pointerMove);
          add(element, 'pointerup', pointerEnd);
          add(element, 'pointercancel', pointerEnd);
          add(element, 'lostpointercapture', pointerLost);
        } else {
          add(element, 'mousedown', mouseDown);
          add(document, 'mousemove', mouseMove);
          add(document, 'mouseup', mouseUp);
        }
        const wheelHandler = (e) => {
          if (!canInteract(e.target, e)) return;
          if (!getEnabled()) return;
          e.preventDefault();
          const deltaMode = e.deltaMode || 0;
          const deltaY = normalizeWheelDelta(e.deltaY, deltaMode);
          const deltaX = normalizeWheelDelta(e.deltaX, deltaMode);
          if (getZoomLocked()) {
            if (getPanLocked()) return;
            const prioritizeX = e.shiftKey || Math.abs(deltaX) > Math.abs(deltaY);
            if (prioritizeX) { applyPanDelta(-deltaX, 0); }
            else { applyPanDelta(0, -deltaY); }
            return;
          }
          const anchor = anchorFromClient(e.clientX, e.clientY);
          const scale = Math.exp(-e.deltaY / 400);
          setZoom(getZoom() * scale, { anchor });
        };
        add(element, 'wheel', wheelHandler, { passive: false });
        const resetSurface = () => {
          stopMomentum();
          clearHistory();
          dragging = false;
          pinchActive = false;
          lastTapTime = 0;
          lastTapPos = null;
          onReset();
        };
        const dblHandler = (e) => {
          if (!canInteract(e.target, e)) return;
          if (!getEnabled() || getZoomLocked()) return;
          if (typeof drawMode !== 'undefined' && drawMode) return; // ドローモード中はリセットしない
          // ページめくりボタンやナビゲーションUIは無視
          if (e.target.closest('#stagePrevArrow') || e.target.closest('#stageNextArrow') || e.target.closest('.pane-arrows')) return;
          e.preventDefault();
          resetSurface();
        };
        add(element, 'dblclick', dblHandler);
        const touchStart = (e) => {
          if (!getEnabled()) return;
          if (shouldIgnoreTarget(e.target, e)) return;
          if (e.touches.length === 2) {
            if (getZoomLocked()) return;
            stopDrag();
            pinchActive = true;
            pinchStartDist = touchDistance(e.touches[0], e.touches[1]) || 1;
            pinchStartZoom = getZoom();
            const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
            const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
            pinchAnchor = anchorFromClient(midX, midY);
            pinchMid = { x: midX, y: midY };
            e.preventDefault();
          } else if (e.touches.length === 1) {
            resetPanTotals();
          }
        };
        const touchMove = (e) => {
          if (!getEnabled()) return;
          if (pinchActive && e.touches.length === 2) {
            if (getZoomLocked()) { pinchActive = false; return; }
            e.preventDefault();
            const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
            const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
            if (pinchMid) {
              const dx = midX - pinchMid.x;
              const dy = midY - pinchMid.y;
              if (dx !== 0 || dy !== 0) applyPanDelta(dx, dy);
            }
            pinchMid = { x: midX, y: midY };
            pinchAnchor = anchorFromClient(midX, midY);
            const dist = touchDistance(e.touches[0], e.touches[1]) || 1;
            const scale = dist / (pinchStartDist || dist);
            setZoom(pinchStartZoom * scale, { anchor: pinchAnchor });
          }
        };
        const touchEnd = (e) => {
          if (!getEnabled()) return;
          if (shouldIgnoreTarget(e.target, e)) {
            lastTapTime = 0;
            lastTapPos = null;
            return;
          }
          if (e.touches.length < 2) { pinchActive = false; pinchMid = null; }
          if (e.touches.length === 0 && e.changedTouches.length === 1) {
            const now = Date.now();
            const tap = e.changedTouches[0];
            const dist = lastTapPos ? Math.hypot(tap.clientX - lastTapPos.x, tap.clientY - lastTapPos.y) : 0;
            if (doubleTapResetEnabled && !getZoomLocked() && !(typeof drawMode !== 'undefined' && drawMode) && !dragging && !pinchActive && now - lastTapTime < doubleTapThreshold && dist < doubleTapDistance) {
              resetSurface();
              e.preventDefault();
            }
            lastTapTime = now;
            lastTapPos = { x: tap.clientX, y: tap.clientY };
          }
        };
        add(element, 'touchstart', touchStart, { passive: false });
        add(element, 'touchmove', touchMove, { passive: false });
        add(element, 'touchend', touchEnd, { passive: false });
        add(element, 'touchcancel', touchEnd, { passive: false });
        const cancelInteractions = () => {
          pinchActive = false;
          stopDrag();
        };
        return { destroy: () => cleanup.forEach(fn => fn()), cancel: cancelInteractions };
      }
      function applyViewTransform() {
        if (!img) return;
        const metrics = computeViewMetrics();
        const stageRect = metrics.stageRect;
        const baseW = metrics.baseW;
        const baseH = metrics.baseH;
        const offset = metrics.offset || { x: 0, y: 0 };
        viewState.zoom = Math.max(viewState.minZoom, Math.min(viewState.maxZoom, viewState.zoom));
        const clampBookTranslate = () => {
          if (!stageRect || !baseW || !baseH) return;
          const offsetX = offset.x || 0;
          const offsetY = offset.y || 0;
          viewState.zoom = Math.max(viewState.minZoom, Math.min(viewState.maxZoom, viewState.zoom));
          if (keyNavConfig.bookClamp) {
            const scaledW = baseW * viewState.zoom;
            const scaledH = baseH * viewState.zoom;
            const hardMaxX = Math.max(0, (scaledW - stageRect.width) / 2);
            const hardMaxY = Math.max(0, (scaledH - stageRect.height) / 2);
            viewState.translateX = clamp(viewState.translateX, -hardMaxX - offsetX, hardMaxX - offsetX);
            viewState.translateY = clamp(viewState.translateY, -hardMaxY - offsetY, hardMaxY - offsetY);
          } else {
            const margin = 10;
            const scaledW = baseW * viewState.zoom;
            const scaledH = baseH * viewState.zoom;
            const softMaxX = Math.max(margin, ((scaledW - stageRect.width) / 2) + margin);
            const softMaxY = Math.max(margin, ((scaledH - stageRect.height) / 2) + margin);
            viewState.translateX = Math.max(-softMaxX - offsetX, Math.min(softMaxX - offsetX, viewState.translateX));
            viewState.translateY = Math.max(-softMaxY - offsetY, Math.min(softMaxY - offsetY, viewState.translateY));
          }
        };
        const preferFitHeight = (mode === 'single') && !sliceMode;
        const shouldClamp = !clampSkipOnce && (keyNavConfig.bookClamp || sliceMode || preferFitHeight);
        if (shouldClamp) clampBookTranslate();
        const transformStr = `translate3d(${viewState.translateX}px, ${viewState.translateY}px, 0) scale(${viewState.zoom})`;
        syncDrawTransform(transformStr);
        updateSelectionBox();
        requestPoseSave();
      }
      function syncDrawTransform(transformStr = lastMainTransform) {
        const target = pageLayer || img;
        const t = transformStr || lastMainTransform || '';
        if (!target || !t) return;
        target.style.transformOrigin = 'center center';
        if (target.style.transform !== t) {
          target.style.transform = t;
        }
        if (img && target !== img) { img.style.transform = 'none'; }
        if (drawCanvas && target !== drawCanvas) { drawCanvas.style.transform = 'none'; }
        lastMainTransform = t;
      }
      function currentDrawKey() {
        if (!book?.id) return null;
        if (book._ephemeral && Array.isArray(book.pages)) {
          const meta = book.pages[page];
          const srcBookId = meta?._sourceBookId;
          const srcIndex = Number.isFinite(meta?._sourcePageIndex) ? meta._sourcePageIndex : null;
          if (srcBookId && Number.isFinite(srcIndex)) {
            return `book:${srcBookId}:p${srcIndex}`;
          }
        }
        return `book:${book.id}:p${page}`;
      }
      const drawStorageKey = (key = activeDrawKey) => key ? `${DRAW_STORE_PREFIX}${key}` : '';
      const drawDocKey = (key = activeDrawKey) => key ? `${DRAW_DOC_PREFIX}${key}` : '';
      const DRAW_PNG_CACHE_ENABLED = false; // 重いPNGキャッシュはデフォルトで無効
      const saveDrawData = (key, dataUrl) => {
        if (!key || !dataUrl) return;
        try { localStorage.setItem(drawStorageKey(key), dataUrl); } catch (_) { }
      };
      const loadDrawData = (key) => {
        if (!key) return null;
        try { return localStorage.getItem(drawStorageKey(key)); } catch (_) { return null; }
      };
      const loadDrawDoc = (key) => {
        if (!key) return null;
        const cached = drawDocs.get(key);
        if (cached) return cached;
        let stored = null;
        try { stored = localStorage.getItem(drawDocKey(key)); } catch (_) { }
        const parsedLocal = parseStoredDrawDoc(stored);
        if (parsedLocal) {
          drawDocs.set(key, parsedLocal);
          attachDrawDocToPage(key, parsedLocal);
          return parsedLocal;
        }
        const meta = parseDrawKey(key);
        if (meta && book?.id === meta.bookId && Array.isArray(book.pages)) {
          const fromBook = parseStoredDrawDoc(book.pages?.[meta.pageIndex]?.drawDoc);
          if (fromBook) {
            drawDocs.set(key, fromBook);
            try { localStorage.setItem(drawDocKey(key), JSON.stringify(fromBook)); } catch (_) { }
            return fromBook;
          }
        }
        return null;
      };
      // Debounced saveDrawDoc to prevent blocking during drawing
      let saveDrawDocTimer = null;
      let saveDrawDocIdleHandle = null;
      const saveDrawDoc = (key = activeDrawKey, doc = drawDoc) => {
        if (!key || !doc) return;
        // Cancel pending saves
        if (saveDrawDocTimer) { clearTimeout(saveDrawDocTimer); saveDrawDocTimer = null; }
        if (saveDrawDocIdleHandle && typeof cancelIdleCallback === 'function') {
          try { cancelIdleCallback(saveDrawDocIdleHandle); } catch (_) { }
          saveDrawDocIdleHandle = null;
        }
        // Always update in-memory immediately
        attachDrawDocToPage(key, doc);

        const doSave = () => {
          saveDrawDocTimer = null;
          saveDrawDocIdleHandle = null;
          try { localStorage.setItem(drawDocKey(key), JSON.stringify(doc)); } catch (_) { }
          persistDrawDocToBook({ key, doc });
        };

        // If actively drawing, use longer debounce and idle callback
        if (drawingStroke) {
          saveDrawDocTimer = setTimeout(() => {
            saveDrawDocTimer = null;
            if (typeof requestIdleCallback === 'function') {
              saveDrawDocIdleHandle = requestIdleCallback(doSave, { timeout: 2000 });
            } else {
              setTimeout(doSave, 50);
            }
          }, 500);
        } else {
          // Not drawing: still debounce but shorter
          saveDrawDocTimer = setTimeout(doSave, 100);
        }
      };
      // Immediate save for critical moments (page change, etc)
      const saveDrawDocImmediate = (key = activeDrawKey, doc = drawDoc) => {
        if (!key || !doc) return;
        if (saveDrawDocTimer) { clearTimeout(saveDrawDocTimer); saveDrawDocTimer = null; }
        if (saveDrawDocIdleHandle && typeof cancelIdleCallback === 'function') {
          try { cancelIdleCallback(saveDrawDocIdleHandle); } catch (_) { }
          saveDrawDocIdleHandle = null;
        }
        try { localStorage.setItem(drawDocKey(key), JSON.stringify(doc)); } catch (_) { }
        attachDrawDocToPage(key, doc);
        persistDrawDocToBook({ key, doc, immediate: true });
      };
      const defaultLayer = (i = 1) => ({ id: `layer-${i}`, name: `Layer ${i}`, visible: true, strokes: [] });
      const defaultDrawDoc = () => ({
        layers: [defaultLayer()],
        activeLayerId: 'layer-1',
        history: [],
        historyIndex: -1,
        width: 3.5,
        penWidth: 3.5,
        eraserWidth: 18,
        opacity: 1,
        color: '#000000',
        textColor: '#000000',
        textColorSlots: ['#0f172a', '#2563eb', '#ef4444'],
        textSlotIndex: 0,
        textFont: 'system-ui, sans-serif',
        textSize: 28,
        brush: 'smooth',
        shape: 'free',
        activeStampId: '',
        shadow: false,
        glow: false
      });
      const ensureDrawDoc = (key = activeDrawKey) => {
        let doc = loadDrawDoc(key);
        if (!doc) {
          doc = defaultDrawDoc();
          drawDocs.set(key, doc);
          saveDrawDoc(key, doc);
        }
        doc.width = clampStrokeWidth(doc.width || DRAW_WIDTH);
        doc.penWidth = clampStrokeWidth(doc.penWidth || doc.width || DRAW_WIDTH);
        doc.eraserWidth = clampStrokeWidth(doc.eraserWidth || 18);
        doc.textSize = clampTextSize(doc.textSize || 28);
        doc.textColorSlots = Array.isArray(doc.textColorSlots) && doc.textColorSlots.length ? doc.textColorSlots.slice(0, 3) : ['#0f172a', '#2563eb', '#ef4444'];
        while (doc.textColorSlots.length < 3) doc.textColorSlots.push('#0f172a');
        if (typeof doc.textSlotIndex !== 'number') doc.textSlotIndex = 0;
        doc.textSlotIndex = clamp(doc.textSlotIndex, 0, doc.textColorSlots.length - 1);
        doc.textColor = doc.textColorSlots[doc.textSlotIndex] || doc.textColor || doc.color || DRAW_COLOR;
        doc.opacity = clampOpacity(doc.opacity ?? 1);
        doc.color = doc.color || DRAW_COLOR;
        doc.brush = doc.brush || 'smooth';
        doc.shape = doc.shape || 'free';
        doc.activeStampId = doc.activeStampId || '';
        doc.shadow = !!doc.shadow;
        doc.glow = !!doc.glow;
        doc.layers = Array.isArray(doc.layers) && doc.layers.length ? doc.layers : [defaultLayer()];
        doc.layers = (doc.layers || []).map((l, idx) => {
          if (!l.id) l.id = `layer-${idx + 1}`;
          if (typeof l.visible !== 'boolean') l.visible = true;
          if (!Array.isArray(l.strokes)) l.strokes = [];
          return l;
        });
        if (!doc.activeLayerId || !doc.layers.find(l => l.id === doc.activeLayerId)) {
          doc.activeLayerId = doc.layers[0].id;
        }
        doc.history = Array.isArray(doc.history) ? doc.history : [];
        if (typeof doc.historyIndex !== 'number') doc.historyIndex = doc.history.length - 1;
        if (!doc.history.length) {
          doc.history.push(JSON.stringify({ layers: doc.layers, activeLayerId: doc.activeLayerId }));
          doc.historyIndex = doc.history.length - 1;
        }
        const attached = attachDrawDocToPage(key, doc);
        if (attached) persistDrawDocToBook({ key, doc });
        return doc;
      };
      // Deferred persist to prevent UI blocking during drawing
      let persistDrawPending = null;
      function persistDrawLayer(key = activeDrawKey, immediate = false) {
        if (!drawDirty) return; // 変化が無いときは何もしない
        if (!drawCanvas || !key) { drawDirty = false; return; }
        if (!drawCanvas.width || !drawCanvas.height) { drawDirty = false; return; }
        drawDirty = false;
        saveDrawDoc(key, drawDoc); // 軽いJSON保存だけは常に行う
        if (!DRAW_PNG_CACHE_ENABLED) {
          drawStore.delete(key);
          try { localStorage.removeItem(drawStorageKey(key)); } catch (_) { }
          return;
        }

        // Defer heavy toDataURL processing to prevent drawing lag
        const doExport = () => {
          try {
            // Skip if still actively drawing - re-schedule
            if (drawingStroke) {
              persistDrawPending = setTimeout(() => {
                if (typeof requestIdleCallback === 'function') {
                  persistDrawPending = requestIdleCallback(doExport, { timeout: 2000 });
                } else {
                  persistDrawPending = setTimeout(doExport, 100);
                }
              }, 500);
              return;
            }
            // Check if canvas is still valid
            if (!drawCanvas || !drawCanvas.width || !drawCanvas.height) return;
            const dataUrl = drawCanvas.toDataURL('image/png');
            drawStore.set(key, { dataUrl });
            saveDrawData(key, dataUrl);
          } catch (_) { }
          persistDrawPending = null;
        };

        // Cancel any pending export
        if (persistDrawPending) {
          if (typeof cancelIdleCallback === 'function') {
            try { cancelIdleCallback(persistDrawPending); } catch (_) { }
          }
          if (typeof persistDrawPending === 'number') {
            clearTimeout(persistDrawPending);
          }
          persistDrawPending = null;
        }

        if (immediate) {
          // Immediate save (e.g., before page change)
          doExport();
        } else {
          // Deferred save - won't block UI, use longer timeout
          if (typeof requestIdleCallback === 'function') {
            persistDrawPending = requestIdleCallback(doExport, { timeout: 2000 });
          } else {
            persistDrawPending = setTimeout(doExport, 100);
          }
        }
      }
      function clearDrawCanvas() {
        if (!drawCtx || !drawCanvas) return;
        drawCtx.clearRect(0, 0, drawCanvas.width || 0, drawCanvas.height || 0);
        drawDirty = false;
        drawingStroke = false;
        drawPointers.clear();
        drawGestureActive = false;
      }
      function restoreDrawLayer() {
        if (!drawCtx || !drawCanvas) return;
        clearDrawCanvas();
        const key = activeDrawKey;
        let entry = key ? drawStore.get(key) : null;
        if (!entry?.dataUrl) {
          const saved = loadDrawData(key);
          if (saved) {
            entry = { dataUrl: saved };
            drawStore.set(key, entry);
          }
        }
        if (!entry?.dataUrl) { drawDirty = false; return; }
        const imgEl = new Image();
        imgEl.onload = () => {
          clearDrawCanvas();
          drawCtx.drawImage(imgEl, 0, 0, drawCanvas.width, drawCanvas.height);
          drawDirty = false;
        };
        imgEl.src = entry.dataUrl;
      }
      const activeLayer = () => drawDoc?.layers?.find(l => l.id === drawDoc?.activeLayerId) || drawDoc?.layers?.[0];
      const clampStrokeWidth = (v) => clamp(v || 1, 1, 200);
      const clampOpacity = (v) => clamp(v || 1, 0.05, 1);
      const clampTextSize = (v) => clamp(v || 16, 8, 180);
      // Throttle pushHistory to avoid blocking during rapid strokes
      let pushHistoryPending = false;
      const pushHistory = () => {
        if (!drawDoc || pushHistoryPending) return;
        pushHistoryPending = true;

        // Create lightweight reference for immediate UI feedback
        const doSnapshot = () => {
          pushHistoryPending = false;
          if (!drawDoc) return;
          try {
            const snap = JSON.stringify({ layers: drawDoc.layers, activeLayerId: drawDoc.activeLayerId });
            const limit = 50;
            if (drawDoc.historyIndex < drawDoc.history.length - 1) {
              drawDoc.history = drawDoc.history.slice(0, drawDoc.historyIndex + 1);
            }
            drawDoc.history.push(snap);
            if (drawDoc.history.length > limit) drawDoc.history.shift();
            drawDoc.historyIndex = drawDoc.history.length - 1;
            saveDrawDoc();
          } catch (_) { }
        };

        // Use requestIdleCallback to avoid blocking during drawing
        if (typeof requestIdleCallback === 'function') {
          requestIdleCallback(doSnapshot, { timeout: 1000 });
        } else {
          setTimeout(doSnapshot, 50);
        }
      };
      const restoreFromHistory = (offset) => {
        if (!drawDoc) return;
        const target = drawDoc.historyIndex + offset;
        if (target < 0 || target >= drawDoc.history.length) return;
        const raw = drawDoc.history[target];
        if (!raw) return;
        try {
          const parsed = JSON.parse(raw);
          drawDoc.layers = parsed.layers || drawDoc.layers;
          drawDoc.activeLayerId = parsed.activeLayerId || drawDoc.activeLayerId;
          drawDoc.historyIndex = target;
          renderDrawDoc(true);
          saveDrawDoc();
          updateDrawControls();
          hideSelectionBox();
        } catch (_) { }
      };
      function renderStroke(ctx, stroke) {
        if (!stroke || !Array.isArray(stroke.points) || stroke.points.length < 1) return;
        const pts = stroke.points;
        const mode = stroke.type || 'stroke';
        const brush = stroke.brush || drawDoc?.brush || 'smooth';
        const width = clampStrokeWidth(stroke.width || drawDoc?.penWidth || drawDoc?.width || 3);
        const widths = Array.isArray(stroke.widths) && stroke.widths.length ? stroke.widths.map(w => clampStrokeWidth(w)) : null;
        const opacity = clampOpacity(stroke.opacity ?? drawDoc?.opacity ?? 1);
        const selected = selectedStrokeSet?.has?.(stroke);
        const drawHighlight = () => {
          if (!selected) return;
          const b = strokeBounds(stroke);
          ctx.save();
          ctx.globalAlpha = 1;
          if (mode === 'text' && b) {
            ctx.strokeStyle = 'rgba(96, 165, 250, 0.95)'; // blue highlight
            ctx.lineWidth = 2;
            ctx.setLineDash([6, 4]);
            ctx.shadowColor = 'rgba(96, 165, 250, 0.5)';
            ctx.shadowBlur = 8;
            ctx.strokeRect(b.minX - 4, b.minY - 4, (b.maxX - b.minX) + 8, (b.maxY - b.minY) + 8);
            ctx.restore();
            return;
          }
          ctx.strokeStyle = 'rgba(96, 165, 250, 0.95)';
          ctx.lineWidth = Math.max(2, width * 0.6);
          ctx.setLineDash([8, 6]);
          ctx.shadowColor = 'rgba(96, 165, 250, 0.6)';
          ctx.shadowBlur = 10;
          ctx.beginPath();
          if (pts.length === 1) {
            ctx.arc(pts[0].x, pts[0].y, Math.max(4, width), 0, Math.PI * 2);
          } else {
            for (let i = 0; i < pts.length - 1; i++) {
              const p1 = pts[i];
              const p2 = pts[i + 1];
              const mid = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
              ctx.moveTo(p1.x, p1.y);
              ctx.quadraticCurveTo(mid.x, mid.y, p2.x, p2.y);
            }
          }
          ctx.stroke();
          ctx.restore();
        };
        ctx.save();
        if (mode === 'erase') {
          ctx.globalCompositeOperation = 'destination-out';
          ctx.strokeStyle = 'rgba(0,0,0,1)';
          ctx.lineWidth = width;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          ctx.beginPath();
        } else if (mode === 'text') {
          ctx.globalAlpha = opacity;
          ctx.fillStyle = stroke.color || '#000';
          const fontSize = clampTextSize(stroke.size || stroke.width * 4 || drawDoc?.textSize || 24);
          const fontFamily = stroke.font || drawDoc?.textFont || 'system-ui, sans-serif';
          ctx.font = `${fontSize}px ${fontFamily}`;
          ctx.textBaseline = 'top';
          ctx.textAlign = 'left';
          ctx.shadowColor = stroke.glow ? stroke.color || '#fff' : 'rgba(0,0,0,0.35)';
          ctx.shadowBlur = stroke.glow ? 8 : (stroke.shadow ? 2 : 0);
          const lines = String(stroke.text || '').split('\n');
          const lh = fontSize * 1.25;
          lines.forEach((line, idx) => {
            ctx.fillText(line, pts[0].x, pts[0].y + lh * idx);
          });
          drawHighlight();
          ctx.restore();
          return;
        } else {
          ctx.globalAlpha = opacity;
          ctx.strokeStyle = stroke.color || '#000';
          ctx.lineWidth = width;
          ctx.lineCap = brush === 'calligraphy' ? 'butt' : 'round';
          ctx.lineJoin = 'round';
          ctx.shadowColor = stroke.glow ? (stroke.color || '#fff') : (stroke.shadow ? 'rgba(0,0,0,0.35)' : 'transparent');
          ctx.shadowBlur = stroke.glow ? 10 : (stroke.shadow ? 2 : 0);
          if (brush === 'soft') ctx.shadowBlur = Math.max(ctx.shadowBlur, 8);
          ctx.beginPath();
        }
        if (pts.length === 1) {
          ctx.moveTo(pts[0].x, pts[0].y);
          ctx.lineTo(pts[0].x + 0.01, pts[0].y + 0.01);
        } else {
          for (let i = 0; i < pts.length - 1; i++) {
            const p1 = pts[i];
            const p2 = pts[i + 1];
            const mid = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
            let segWidth = widths ? ((widths[i] || width) + (widths[i + 1] || width)) / 2 : width;
            if (brush === 'pencil') {
              mid.x += (Math.random() - 0.5) * width * 0.4;
              mid.y += (Math.random() - 0.5) * width * 0.4;
            }
            if (brush === 'marker') ctx.globalAlpha = opacity * 0.82;
            if (brush === 'calligraphy') ctx.lineCap = 'butt';
            ctx.lineWidth = clampStrokeWidth(segWidth);
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.quadraticCurveTo(mid.x, mid.y, p2.x, p2.y);
            ctx.stroke();
          }
          drawHighlight();
          ctx.restore();
          return;
        }
        ctx.stroke();
        drawHighlight();
        ctx.restore();
      }
      function renderDrawDoc(markDirty = false) {
        if (!drawCtx || !drawCanvas) return;
        if (markDirty) drawDirty = true;
        drawCtx.clearRect(0, 0, drawCanvas.width || 0, drawCanvas.height || 0);
        drawCtx.imageSmoothingEnabled = true;
        const hasStrokes = drawDoc && Array.isArray(drawDoc.layers) && drawDoc.layers.some(l => Array.isArray(l.strokes) && l.strokes.length);
        if (hasStrokes && drawDoc) {
          (drawDoc.layers || []).forEach(layer => {
            if (!layer.visible) return;
            const buf = getLayerBuffer(layer.id);
            const g = buf?.getContext('2d');
            if (!buf || !g) return;
            g.clearRect(0, 0, buf.width || 0, buf.height || 0);
            g.imageSmoothingEnabled = true;
            (layer.strokes || []).forEach(stroke => renderStroke(g, stroke));
            drawCtx.drawImage(buf, 0, 0);
          });
        } else {
          drawCtx.clearRect(0, 0, drawCanvas.width || 0, drawCanvas.height || 0);
        }
        if (activeTextStroke) {
          renderStroke(drawCtx, activeTextStroke);
        }
        if (markDirty && drawDirty) {
          persistDrawLayer();
        }
      }
      const DRAW_RECENT_KEY = 'draw-recent-colors';
      const loadRecentColors = () => {
        try {
          const arr = JSON.parse(localStorage.getItem(DRAW_RECENT_KEY) || '[]');
          return Array.isArray(arr) ? arr.slice(0, 12) : [];
        } catch (_) { return []; }
      };
      const saveRecentColor = (color) => {
        if (!color) return;
        const list = loadRecentColors();
        const next = [color, ...list.filter(c => c !== color)].slice(0, 12);
        try { localStorage.setItem(DRAW_RECENT_KEY, JSON.stringify(next)); } catch (_) { }
      };
      const loadTapDraw = () => {
        try { return localStorage.getItem(TAP_DRAW_KEY) === '1'; } catch (_) { return false; }
      };
      const saveTapDraw = (v) => {
        try { localStorage.setItem(TAP_DRAW_KEY, v ? '1' : '0'); } catch (_) { }
      };
      const presetColors = ['#000000', '#ffffff', '#ef4444', '#f97316', '#facc15', '#22c55e', '#14b8a6', '#0ea5e9', '#6366f1', '#a855f7', '#ec4899', '#9ca3af'];
      function rebuildColorGrid() {
        if (!drawColorGrid) return;
        drawColorGrid.innerHTML = '';
        const recent = loadRecentColors();
        [...presetColors, ...recent].forEach(c => {
          const sw = document.createElement('button');
          sw.type = 'button';
          sw.className = 'color-swatch';
          sw.style.background = c;
          sw.title = c;
          sw.addEventListener('click', () => {
            drawDoc.color = c;
            drawColorInput.value = c;
            saveRecentColor(c);
            saveDrawDoc();
          });
          drawColorGrid.appendChild(sw);
        });
      }
      const setActiveStamp = (id) => {
        activeStampId = id || '';
        if (drawDoc) drawDoc.activeStampId = activeStampId;
        saveDrawDoc();
        updateDrawControls();
      };
      const findStamp = (id) => (stampTemplates || []).find(s => s.id === id);
      const renderStampOptions = () => {
        if (!drawStampSelect) return;
        drawStampSelect.innerHTML = '<option value=\"\">なし</option>';
        stampTemplates.forEach(st => {
          const opt = document.createElement('option');
          opt.value = st.id;
          opt.textContent = st.name || st.id;
          drawStampSelect.appendChild(opt);
        });
        if (drawDoc) drawStampSelect.value = drawDoc.activeStampId || '';
      };
      function updateDrawControls() {
        if (!drawDoc) return;
        renderStampOptions();
        if (drawWidthInput) {
          const penW = clampStrokeWidth(drawDoc.penWidth || drawDoc.width || DRAW_WIDTH);
          drawWidthInput.value = penW;
          drawWidthVal.value = penW.toFixed(1);
        }
        if (drawEraserWidthInput) {
          const ew = clampStrokeWidth(drawDoc.eraserWidth || ERASER_DEFAULT);
          drawEraserWidthInput.value = ew;
          drawEraserWidthVal.value = ew.toFixed(1);
        }
        if (drawOpacityInput) {
          drawOpacityInput.value = clampOpacity(drawDoc.opacity ?? 1);
          drawOpacityVal.value = parseFloat(drawOpacityInput.value || 1).toFixed(2);
        }
        if (drawColorInput) drawColorInput.value = drawDoc.color || DRAW_COLOR;
        if (drawTextSizeInput) {
          drawTextSizeInput.value = clampTextSize(drawDoc.textSize || 28);
          drawTextSizeVal.textContent = `${drawTextSizeInput.value}px`;
        }
        if (drawTextFontSelect) drawTextFontSelect.value = drawDoc.textFont || 'system-ui, sans-serif';
        if (drawBrushSelect) drawBrushSelect.value = drawDoc.brush || 'smooth';
        if (drawShapeSelect) drawShapeSelect.value = drawDoc.shape || 'free';
        shapeMode = drawDoc.shape || 'free';
        if (drawStampSelect) drawStampSelect.value = drawDoc.activeStampId || '';
        activeStampId = drawDoc.activeStampId || '';
        if (drawShadowInput) drawShadowInput.checked = !!drawDoc.shadow;
        if (drawGlowInput) drawGlowInput.checked = !!drawDoc.glow;
        if (drawToolBtn) drawToolBtn.classList.toggle('active', drawTool === 'pen');
        if (drawEraserModeBtn) {
          drawEraserModeBtn.textContent = eraserMode === 'stroke' ? '線消' : '消';
          drawEraserModeBtn.classList.toggle('active', eraserMode === 'stroke');
        }
        if (drawSelectBtn) drawSelectBtn.classList.toggle('active', selectMode);
        renderTextColorSlots();
        rebuildColorGrid();
        renderLayerList();
      }
      function renderLayerList() {
        if (!drawLayerList || !drawDoc) return;
        drawLayerList.innerHTML = '';
        (drawDoc.layers || []).forEach((layer, idx) => {
          const it = document.createElement('div');
          it.className = 'layer-item' + (layer.id === drawDoc.activeLayerId ? ' active' : '');
          it.dataset.layer = layer.id;
          it.innerHTML = `<span class="muted">${idx + 1}</span><span>${layer.name || layer.id}</span>`;
          it.addEventListener('click', () => {
            drawDoc.activeLayerId = layer.id;
            setSelection(null);
            hideSelectionBox();
            saveDrawDoc();
            renderLayerList();
          });
          drawLayerList.appendChild(it);
        });
      }
      function addLayer() {
        if (!drawDoc) return;
        const nextIndex = (drawDoc.layers?.length || 0) + 1;
        const layer = defaultLayer(nextIndex);
        drawDoc.layers.push(layer);
        drawDoc.activeLayerId = layer.id;
        pushHistory();
        renderDrawDoc(true);
        saveDrawDoc();
        renderLayerList();
      }
      function deleteLayer() {
        if (!drawDoc) return;
        if (!drawDoc.layers || drawDoc.layers.length <= 1) return;
        const idx = drawDoc.layers.findIndex(l => l.id === drawDoc.activeLayerId);
        if (idx >= 0) drawDoc.layers.splice(idx, 1);
        drawDoc.activeLayerId = drawDoc.layers[drawDoc.layers.length - 1].id;
        pushHistory();
        renderDrawDoc(true);
        saveDrawDoc();
        renderLayerList();
      }
      function moveLayer(dir) {
        if (!drawDoc) return;
        const layers = drawDoc.layers || [];
        const idx = layers.findIndex(l => l.id === drawDoc.activeLayerId);
        if (idx < 0) return;
        const target = idx + dir;
        if (target < 0 || target >= layers.length) return;
        const [l] = layers.splice(idx, 1);
        layers.splice(target, 0, l);
        pushHistory();
        renderDrawDoc(true);
        saveDrawDoc();
        renderLayerList();
      }
      const currentTool = () => ctrlOverrideTool || drawTool;
      const currentColor = () => drawDoc?.color || DRAW_COLOR;
      const currentWidth = () => {
        const isEraser = currentTool() === 'eraser';
        const w = isEraser ? (drawDoc?.eraserWidth ?? ERASER_DEFAULT) : (drawDoc?.penWidth ?? drawDoc?.width ?? DRAW_WIDTH);
        return clampStrokeWidth(w);
      };
      const currentOpacity = () => clampOpacity(drawDoc?.opacity ?? 1);
      const setWidthForTool = (w) => {
        if (!drawDoc) return;
        const clamped = clampStrokeWidth(w);
        if (currentTool() === 'eraser') {
          drawDoc.eraserWidth = clamped;
        } else {
          drawDoc.penWidth = clamped;
          drawDoc.width = clamped;
        }
      };
      const isEraseStrokeMode = () => currentTool() === 'eraser' && eraserMode === 'stroke';
      let selectMode = false;
      let selectedStroke = null;
      let selectionDragStart = null;
      let selectionOriginalPoints = null;
      let selectionPath = [];
      let selectionDrawing = false;
      let selectionRectMode = false;
      let selectedStrokes = [];
      let selectionFollowId = null;
      let selectedStrokeSet = new WeakSet();
      const updateSelectOverlayRect = () => {
        if (!drawSelectOverlay || !drawCanvas) return null;
        const rect = drawCanvas.getBoundingClientRect();
        drawSelectOverlay.style.position = 'fixed';
        drawSelectOverlay.style.left = `${rect.left}px`;
        drawSelectOverlay.style.top = `${rect.top}px`;
        drawSelectOverlay.width = Math.max(1, rect.width);
        drawSelectOverlay.height = Math.max(1, rect.height);
        return rect;
      };
      const stopSelectionFollow = () => {
        if (selectionFollowId) {
          cancelAnimationFrame(selectionFollowId);
          selectionFollowId = null;
        }
      };
      const hideSelectionBox = () => {
        stopSelectionFollow();
        if (drawSelectionBox) drawSelectionBox.style.display = 'none';
        if (drawSelectOverlay) {
          drawSelectOverlay.width = 0;
          drawSelectOverlay.height = 0;
          drawSelectOverlay.style.display = 'none';
        }
      };
      const mapPointToOverlay = (p) => {
        if (!drawCanvas || !drawSelectOverlay) return { x: 0, y: 0 };
        const rect = drawCanvas.getBoundingClientRect();
        const sx = (rect.width || 1) / (drawCanvas.width || 1);
        const sy = (rect.height || 1) / (drawCanvas.height || 1);
        return { x: p.x * sx, y: p.y * sy };
      };
      const drawSelectionPath = (clear = false) => {
        if (!drawSelectOverlay || !drawCanvas) return;
        const rect = updateSelectOverlayRect();
        const g = drawSelectOverlay.getContext('2d');
        if (!g) return;
        g.clearRect(0, 0, rect.width, rect.height);
        if (clear || !selectionPath.length) {
          drawSelectOverlay.style.display = 'none';
          return;
        }
        let pts = selectionPath.map(mapPointToOverlay);
        if (selectionRectMode && selectionPath.length >= 2) {
          const a = selectionPath[0], b = selectionPath[selectionPath.length - 1];
          const minX = Math.min(a.x, b.x), maxX = Math.max(a.x, b.x);
          const minY = Math.min(a.y, b.y), maxY = Math.max(a.y, b.y);
          pts = [
            mapPointToOverlay({ x: minX, y: minY }),
            mapPointToOverlay({ x: maxX, y: minY }),
            mapPointToOverlay({ x: maxX, y: maxY }),
            mapPointToOverlay({ x: minX, y: maxY }),
            mapPointToOverlay({ x: minX, y: minY })
          ];
        }
        g.save();
        g.lineWidth = 3;
        g.strokeStyle = 'rgba(255, 64, 64, 0.98)';
        g.fillStyle = 'rgba(255, 64, 64, 0.2)';
        g.shadowColor = 'rgba(0, 0, 0, 0.4)';
        g.shadowBlur = 12;
        g.setLineDash([10, 6]);
        g.beginPath();
        g.moveTo(pts[0].x, pts[0].y);
        pts.slice(1).forEach(p => g.lineTo(p.x, p.y));
        g.closePath();
        g.fill();
        g.stroke();
        g.restore();
        drawSelectOverlay.style.display = 'block';
      };
      const pointInPoly = (pt, poly) => {
        let inside = false;
        for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
          const xi = poly[i].x, yi = poly[i].y;
          const xj = poly[j].x, yj = poly[j].y;
          const intersect = ((yi > pt.y) !== (yj > pt.y)) && (pt.x < (xj - xi) * (pt.y - yi) / ((yj - yi) || 1) + xi);
          if (intersect) inside = !inside;
        }
        return inside;
      };
      const rectContainsPoint = (rect, p) => p.x >= rect.minX && p.x <= rect.maxX && p.y >= rect.minY && p.y <= rect.maxY;
      const linesIntersect = (a, b, c, d) => {
        const cross = (p1, p2, p3) => (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);
        const d1 = cross(a, b, c);
        const d2 = cross(a, b, d);
        const d3 = cross(c, d, a);
        const d4 = cross(c, d, b);
        return ((d1 <= 0 && d2 >= 0) || (d1 >= 0 && d2 <= 0)) && ((d3 <= 0 && d4 >= 0) || (d3 >= 0 && d4 <= 0));
      };
      const segmentIntersectsRect = (p1, p2, rect) => {
        if (rectContainsPoint(rect, p1) || rectContainsPoint(rect, p2)) return true;
        const minX = Math.min(p1.x, p2.x), maxX = Math.max(p1.x, p2.x);
        const minY = Math.min(p1.y, p2.y), maxY = Math.max(p1.y, p2.y);
        if (maxX < rect.minX || minX > rect.maxX || maxY < rect.minY || minY > rect.maxY) return false;
        const corners = [
          { x: rect.minX, y: rect.minY }, { x: rect.maxX, y: rect.minY },
          { x: rect.maxX, y: rect.maxY }, { x: rect.minX, y: rect.maxY }
        ];
        for (let i = 0; i < 4; i++) {
          const a = corners[i];
          const b = corners[(i + 1) % 4];
          if (linesIntersect(p1, p2, a, b)) return true;
        }
        return false;
      };
      const pathIntersectsRect = (pts, rect) => {
        for (let i = 0; i < pts.length - 1; i++) {
          if (segmentIntersectsRect(pts[i], pts[i + 1], rect)) return true;
        }
        return false;
      };
      const finalizeSelectionArea = (rectMode = false) => {
        if (!drawDoc || !selectionPath.length) return;
        const layers = drawDoc.layers.filter(l => l.id === drawDoc.activeLayerId);
        if (selectionPath.length < 3 && !rectMode) {
          const hit = hitTestStroke(selectionPath[0]);
          setSelectionGroup(hit ? [hit] : []);
          drawSelectionPath(true);
          return;
        }
        const poly = (() => {
          if (rectMode && selectionPath.length >= 2) {
            const a = selectionPath[0], b = selectionPath[selectionPath.length - 1];
            const minX = Math.min(a.x, b.x), maxX = Math.max(a.x, b.x);
            const minY = Math.min(a.y, b.y), maxY = Math.max(a.y, b.y);
            return [{ x: minX, y: minY }, { x: maxX, y: minY }, { x: maxX, y: maxY }, { x: minX, y: maxY }];
          }
          return selectionPath;
        })();
        if (poly.length < 3) return;
        const rect = rectMode && poly.length >= 2 ? {
          minX: Math.min(poly[0].x, poly[2]?.x ?? poly[0].x),
          maxX: Math.max(poly[0].x, poly[2]?.x ?? poly[0].x),
          minY: Math.min(poly[0].y, poly[2]?.y ?? poly[0].y),
          maxY: Math.max(poly[0].y, poly[2]?.y ?? poly[0].y)
        } : null;
        let found = null;
        const hits = [];
        for (let li = layers.length - 1; li >= 0; li--) {
          const layer = layers[li];
          for (let si = layer.strokes.length - 1; si >= 0; si--) {
            const s = layer.strokes[si];
            const b = strokeBounds(s);
            if (!b) continue;
            const center = { x: (b.minX + b.maxX) / 2, y: (b.minY + b.maxY) / 2 };
            const pts = s.points || [];
            let hit = false;
            if (rectMode && rect) {
              const pointInside = pts.some(p => rectContainsPoint(rect, p));
              const centerInside = rectContainsPoint(rect, center);
              const segmentHit = pathIntersectsRect(pts, rect);
              hit = centerInside || pointInside || segmentHit;
            } else {
              hit = pointInPoly(center, poly) || pts.some(p => pointInPoly(p, poly));
            }
            if (hit) { hits.push({ layer, stroke: s, layerIndex: li, strokeIndex: si }); }
          }
        }
        const pick = hits.length ? hits : null;
        setSelectionGroup(pick);
        renderDrawDoc();
      };
      function selectionCenter(stroke) {
        const b = strokeBounds(stroke);
        if (!b) return null;
        return { x: (b.minX + b.maxX) / 2, y: (b.minY + b.maxY) / 2 };
      }
      function scaleSelectedStroke(factor) {
        if (!selectedStrokes.length) return;
        const b = selectionBounds(selectedStrokes);
        if (!b) return;
        const center = { x: (b.minX + b.maxX) / 2, y: (b.minY + b.maxY) / 2 };
        selectedStrokes.forEach(sel => {
          sel.stroke.points = (sel.stroke.points || []).map(p => ({
            x: center.x + (p.x - center.x) * factor,
            y: center.y + (p.y - center.y) * factor
          }));
          if (Array.isArray(sel.stroke.widths)) {
            sel.stroke.widths = sel.stroke.widths.map(w => clampStrokeWidth(w * factor));
          }
          sel.stroke.width = clampStrokeWidth((sel.stroke.width || currentWidth()) * factor);
        });
        renderDrawDoc();
        updateSelectionBox();
        pushHistory();
        saveDrawDoc();
      }
      function duplicateSelectionStroke() {
        if (!selectedStrokes.length || !drawDoc) return;
        const layer = activeLayer();
        if (!layer) return;
        const clones = selectedStrokes.map(sel => {
          const clone = JSON.parse(JSON.stringify(sel.stroke));
          clone.points = (clone.points || []).map(p => ({ x: p.x + 10, y: p.y + 10 }));
          layer.strokes.push(clone);
          return { layer, stroke: clone, layerIndex: drawDoc.layers.indexOf(layer), strokeIndex: layer.strokes.length - 1 };
        });
        pushHistory();
        saveDrawDoc();
        setSelectionGroup(clones);
        renderDrawDoc(true);
      }
      function deleteSelectionStroke() {
        if (!selectedStrokes.length || !drawDoc) return;
        const layer = activeLayer();
        if (!layer) return;
        selectedStrokes.forEach(sel => {
          const idx = layer.strokes.indexOf(sel.stroke);
          if (idx >= 0) layer.strokes.splice(idx, 1);
        });
        setSelectionGroup([]);
        pushHistory();
        saveDrawDoc();
        renderDrawDoc(true);
      }
      const selectionBounds = (strokes) => {
        const allPts = strokes.flatMap(h => h.stroke.points || []);
        if (!allPts.length) return null;
        const xs = allPts.map(p => p.x), ys = allPts.map(p => p.y);
        return {
          minX: Math.min(...xs), maxX: Math.max(...xs),
          minY: Math.min(...ys), maxY: Math.max(...ys)
        };
      };
      const pointInSelectionBox = (pt, pad = 6) => {
        const b = selectionBounds(selectedStrokes);
        if (!b) return false;
        return (
          pt.x >= b.minX - pad && pt.x <= b.maxX + pad &&
          pt.y >= b.minY - pad && pt.y <= b.maxY + pad
        );
      };
      const updateSelectionBox = () => {
        if (!drawSelectionBox || !selectedStrokes.length) { hideSelectionBox(); return; }
        const b = selectionBounds(selectedStrokes);
        if (!b) { hideSelectionBox(); return; }
        const canvasRect = drawCanvas?.getBoundingClientRect?.();
        const hostRect = stageHost?.getBoundingClientRect?.();
        const sx = canvasRect ? (canvasRect.width || 1) / (drawCanvas?.width || 1) : 1;
        const sy = canvasRect ? (canvasRect.height || 1) / (drawCanvas?.height || 1) : 1;
        const ox = canvasRect && hostRect ? (canvasRect.left - hostRect.left) : 0;
        const oy = canvasRect && hostRect ? (canvasRect.top - hostRect.top) : 0;
        drawSelectionBox.style.display = 'block';
        drawSelectionBox.style.left = `${ox + b.minX * sx}px`;
        drawSelectionBox.style.top = `${oy + b.minY * sy}px`;
        drawSelectionBox.style.width = `${Math.max(1, (b.maxX - b.minX) * sx)}px`;
        drawSelectionBox.style.height = `${Math.max(1, (b.maxY - b.minY) * sy)}px`;
      };
      function startSelectionFollow() {
        if (selectionFollowId || !drawSelectionBox || !selectedStrokes.length) return;
        selectionFollowId = requestAnimationFrame(() => {
          selectionFollowId = null;
          if (!selectedStrokes.length || !drawSelectionBox || drawSelectionBox.style.display === 'none') return;
          updateSelectionBox();
        });
      };
      function strokeBounds(stroke) {
        if (!stroke?.points?.length) return null;
        const xs = stroke.points.map(p => p.x);
        const ys = stroke.points.map(p => p.y);
        return { minX: Math.min(...xs), maxX: Math.max(...xs), minY: Math.min(...ys), maxY: Math.max(...ys) };
      }
      function hitTestStroke(pt) {
        if (!drawDoc) return null;
        const layers = (drawDoc.layers || []).filter(l => l.id === drawDoc.activeLayerId);
        for (let li = layers.length - 1; li >= 0; li--) {
          const layer = layers[li];
          if (!layer.visible) continue;
          const strokes = layer.strokes || [];
          for (let si = strokes.length - 1; si >= 0; si--) {
            const s = strokes[si];
            if (s.type === 'erase' || s.type === 'strokeErase') continue;
            if (s.type === 'text') {
              const b = strokeBounds(s);
              const pad = (s.width || 10) * 1.2;
              if (b && pt.x >= b.minX - pad && pt.x <= b.maxX + pad && pt.y >= b.minY - pad && pt.y <= b.maxY + pad) {
                return { layer, stroke: s, layerIndex: li, strokeIndex: si };
              }
            } else {
              const b = strokeBounds(s);
              const pad = (s.width || 6) * 1.1;
              if (!b || pt.x < b.minX - pad || pt.x > b.maxX + pad || pt.y < b.minY - pad || pt.y > b.maxY + pad) continue;
              for (let i = 0; i < s.points.length - 1; i++) {
                const p1 = s.points[i], p2 = s.points[i + 1];
                const dx = p2.x - p1.x, dy = p2.y - p1.y;
                const lenSq = dx * dx + dy * dy || 1;
                const t = Math.max(0, Math.min(1, ((pt.x - p1.x) * dx + (pt.y - p1.y) * dy) / lenSq));
                const projX = p1.x + t * dx;
                const projY = p1.y + t * dy;
                const dist = Math.hypot(pt.x - projX, pt.y - projY);
                if (dist <= (s.width || 6) * 0.65) {
                  return { layer, stroke: s, layerIndex: li, strokeIndex: si };
                }
              }
            }
          }
        }
        return null;
      }
      function setSelectionGroup(list) {
        selectedStrokes = Array.isArray(list) ? list.filter(Boolean) : [];
        selectedStroke = selectedStrokes[0] || null;
        selectedStrokeSet = new WeakSet();
        selectedStrokes.forEach(sel => { if (sel?.stroke) selectedStrokeSet.add(sel.stroke); });
        selectionDragStart = null;
        selectionOriginalPoints = null;
        selectionDrawing = false;
        selectionPath = [];
        selectionRectMode = false;
        drawSelectionPath(true);
        updateSelectionBox();
      }
      const setSelection = (hit) => setSelectionGroup(hit ? [hit] : []);
      const openTextSlotEditor = (idx) => {
        if (!drawDoc || idx < 0) return;
        const picker = document.createElement('input');
        picker.type = 'color';
        picker.value = drawDoc.textColorSlots[idx] || drawDoc.textColor || DRAW_COLOR;
        picker.style.position = 'fixed';
        picker.style.opacity = '0';
        picker.style.pointerEvents = 'none';
        document.body.appendChild(picker);
        picker.addEventListener('input', () => {
          drawDoc.textColorSlots[idx] = picker.value;
          drawDoc.textSlotIndex = idx;
          drawDoc.textColor = picker.value;
          saveDrawDoc();
          renderTextColorSlots();
          if (activeTextStroke) {
            activeTextStroke.color = picker.value;
            renderDrawDoc();
          }
          if (activeTextInput) activeTextInput.style.color = drawDoc.textColor;
        }, { once: true });
        picker.addEventListener('change', () => picker.remove(), { once: true });
        picker.addEventListener('blur', () => picker.remove(), { once: true });
        picker.click();
      };
      const addCustomFont = async (name, url) => {
        if (!name || !url) return;
        try {
          const face = new FontFace(name, `url(${url})`);
          await face.load();
          document.fonts.add(face);
          customFonts = [{ name, value: `"${name}"` }, ...customFonts.filter(f => f.name !== name)];
          const opt = document.createElement('option');
          opt.value = `"${name}"`;
          opt.textContent = name;
          drawTextFontSelect?.appendChild(opt);
          drawDoc.textFont = `"${name}"`;
          saveDrawDoc();
          updateDrawControls();
          showToast && showToast('フォントを追加しました', 'ok');
        } catch (err) {
          console.error(err);
          showToast && showToast('フォントの追加に失敗しました', 'error');
        }
      };
      const renderTextColorSlots = () => {
        if (!drawTextColorSlots || !drawDoc) return;
        drawTextColorSlots.innerHTML = '';
        (drawDoc.textColorSlots || []).forEach((c, idx) => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'text-color-slot';
          btn.style.background = c;
          if (drawDoc.textSlotIndex === idx) btn.classList.add('active');
          btn.title = `色スロット${idx + 1}`;
          btn.addEventListener('click', () => {
            if (drawDoc.textSlotIndex === idx) {
              openTextSlotEditor(idx);
              return;
            }
            drawDoc.textSlotIndex = idx;
            drawDoc.textColor = c;
            saveDrawDoc();
            renderTextColorSlots();
            if (activeTextStroke) {
              activeTextStroke.color = c;
              renderDrawDoc();
            }
            if (activeTextInput) activeTextInput.style.color = drawDoc.textColor;
          });
          drawTextColorSlots.appendChild(btn);
        });
      };
      const ensureTextOverlay = () => {
        if (textOverlay && activeTextInput) return { overlay: textOverlay, input: activeTextInput };
        const wrap = document.createElement('div');
        wrap.className = 'draw-text-overlay';
        const input = document.createElement('textarea');
        input.rows = 1;
        input.style.height = 'auto';
        input.style.overflow = 'hidden';
        input.style.color = '#ffffff';
        wrap.appendChild(input);
        document.body.appendChild(wrap);
        textOverlay = wrap;
        activeTextInput = input;
        return { overlay: wrap, input };
      };
      const positionTextOverlay = (pos) => {
        if (!textOverlay || !drawCanvas || !pos) return;
        const rect = drawCanvas.getBoundingClientRect();
        const cx = rect.left + (pos.x / (drawCanvas.width || 1)) * rect.width;
        const cy = rect.top + (pos.y / (drawCanvas.height || 1)) * rect.height;
        const off = Math.max(12, (activeTextStroke?.size || drawDoc?.textSize || 28) * 0.8);
        textOverlay.style.left = `${cx}px`;
        textOverlay.style.top = `${Math.max(8, cy - off)}px`;
      };
      const closeTextOverlay = () => {
        if (textOverlay) {
          textOverlay.style.display = 'none';
        }
        activeTextPos = null;
        if (activeTextStroke) {
          activeTextStroke = null;
          renderDrawDoc();
        }
      };
      let textEditTarget = null;
      const commitTextStroke = () => {
        if (!drawDoc || !activeTextStroke || !activeTextStroke.text) { closeTextOverlay(); textEditTarget = null; return; }
        const layer = activeLayer();
        if (!layer) { closeTextOverlay(); textEditTarget = null; return; }
        if (textEditTarget) {
          textEditTarget.text = activeTextStroke.text;
          textEditTarget.color = activeTextStroke.color;
          textEditTarget.font = activeTextStroke.font;
          textEditTarget.size = activeTextStroke.size;
          textEditTarget.opacity = activeTextStroke.opacity;
        } else {
          layer.strokes.push(activeTextStroke);
        }
        pushHistory();
        saveDrawDoc();
        activeTextStroke = null;
        textEditTarget = null;
        renderDrawDoc(true);
        closeTextOverlay();
      };
      const updateActiveTextStroke = () => {
        if (!activeTextStroke || !activeTextPos || !drawDoc) return;
        activeTextStroke.color = drawDoc.textColor || drawDoc.color || DRAW_COLOR;
        activeTextStroke.font = drawDoc.textFont || 'system-ui, sans-serif';
        activeTextStroke.size = clampTextSize(drawDoc.textSize || 28);
        activeTextStroke.opacity = currentOpacity();
        if (activeTextInput) {
          activeTextInput.style.fontSize = `${activeTextStroke.size}px`;
          activeTextInput.style.fontFamily = activeTextStroke.font;
          activeTextInput.style.color = activeTextStroke.color;
          activeTextInput.style.height = 'auto';
          activeTextInput.style.height = `${Math.max(activeTextInput.scrollHeight, activeTextStroke.size * 1.3)}px`;
        }
        renderDrawDoc();
      };
      const startTextInput = (pos, existingStroke = null) => {
        if (!drawMode || !drawDoc) return;
        const { overlay, input } = ensureTextOverlay();
        activeTextPos = pos || clientToDrawPoint(window.innerWidth / 2, window.innerHeight / 2);
        const baseStroke = existingStroke ? Object.assign({}, existingStroke) : null;
        activeTextStroke = baseStroke || {
          type: 'text',
          points: [activeTextPos],
          text: '',
          color: drawDoc.textColor || drawDoc.color || DRAW_COLOR,
          width: drawDoc.textSize || currentWidth(),
          size: drawDoc.textSize || 28,
          font: drawDoc.textFont || 'system-ui, sans-serif',
          shadow: !!drawDoc.shadow,
          glow: !!drawDoc.glow,
          opacity: currentOpacity()
        };
        textEditTarget = existingStroke || null;
        overlay.style.display = 'block';
        overlay.style.pointerEvents = 'auto';
        input.value = activeTextStroke.text || '';
        input.style.fontFamily = activeTextStroke.font;
        input.style.fontSize = `${activeTextStroke.size}px`;
        input.style.color = activeTextStroke.color;
        input.style.height = 'auto';
        input.style.height = `${Math.max(input.scrollHeight, activeTextStroke.size * 1.3)}px`;
        positionTextOverlay(activeTextPos);
        setTimeout(() => input.focus(), 10);
        input.oninput = () => {
          activeTextStroke.text = input.value;
          input.style.height = 'auto';
          input.style.height = `${Math.max(input.scrollHeight, activeTextStroke.size * 1.3)}px`;
          renderDrawDoc();
        };
        overlay.onmousedown = (e) => {
          textDragOffset = { x: e.clientX, y: e.clientY, origin: { ...activeTextPos } };
        };
        input.onkeydown = (e) => {
          if (e.key === 'Enter') {
            if (e.shiftKey) return; // 改行用
            if (e.isComposing) return; // IME変換中は確定しない
            e.preventDefault();
            commitTextStroke();
            return;
          }
          if (e.key === 'Escape') { e.preventDefault(); closeTextOverlay(); }
          if (e.ctrlKey && e.key === 'ArrowUp') {
            e.preventDefault();
            drawDoc.textSize = clampTextSize((drawDoc.textSize || 28) + 1);
            input.style.fontSize = `${drawDoc.textSize}px`;
            updateActiveTextStroke();
            updateDrawControls();
          }
          if (e.ctrlKey && e.key === 'ArrowDown') {
            e.preventDefault();
            drawDoc.textSize = clampTextSize((drawDoc.textSize || 28) - 1);
            input.style.fontSize = `${drawDoc.textSize}px`;
            updateActiveTextStroke();
            updateDrawControls();
          }
        };
        input.onblur = () => commitTextStroke();
        updateActiveTextStroke();
      };
      const ensureStampPreview = () => {
        if (stampPreviewCanvas) return stampPreviewCanvas;
        const c = document.createElement('canvas');
        c.className = 'stamp-preview';
        document.body.appendChild(c);
        stampPreviewCanvas = c;
        return c;
      };
      const hideStampPreview = () => {
        if (stampPreviewCanvas) stampPreviewCanvas.style.display = 'none';
      };
      const showStampPreview = (pt, stamp) => {
        if (!stamp || !drawCanvas || !pt) { hideStampPreview(); return; }
        const canvas = ensureStampPreview();
        const rect = drawCanvas.getBoundingClientRect();
        const cx = rect.left + (pt.x / (drawCanvas.width || 1)) * rect.width;
        const cy = rect.top + (pt.y / (drawCanvas.height || 1)) * rect.height;
        const targetSize = Math.max(32, (drawDoc?.penWidth || DRAW_WIDTH) * 10);
        const baseSize = stamp.size || 32;
        const scale = targetSize / baseSize;
        canvas.width = Math.ceil(targetSize * 1.3);
        canvas.height = Math.ceil(targetSize * 1.3);
        const g = canvas.getContext('2d');
        g.clearRect(0, 0, canvas.width, canvas.height);
        g.translate(canvas.width / 2, canvas.height / 2);
        (stamp.strokes || []).forEach(st => {
          const pts = (st.points || []).map(p => ({ x: p.x * scale, y: p.y * scale }));
          const w = clampStrokeWidth((st.width || currentWidth()) * scale / Math.max(1, baseSize / 18));
          renderStroke(g, {
            type: 'stroke',
            points: pts,
            color: st.color === 'inherit' ? currentColor() : (st.color || currentColor()),
            width: w,
            widths: pts.map(() => w),
            brush: st.brush || drawDoc?.brush || 'smooth',
            opacity: 1,
            shadow: false,
            glow: false
          });
        });
        canvas.style.left = `${cx}px`;
        canvas.style.top = `${cy}px`;
        canvas.style.display = 'block';
      };
      const registerStampFromSelection = () => {
        if (!selectedStroke?.stroke) {
          showToast && showToast('スタンプにする線を選択してください', 'error');
          return;
        }
        const s = selectedStroke.stroke;
        const pts = s.points || [];
        if (!pts.length) return;
        const b = strokeBounds(s);
        if (!b) return;
        const cx = (b.minX + b.maxX) / 2;
        const cy = (b.minY + b.maxY) / 2;
        const size = Math.max(24, Math.max(b.maxX - b.minX, b.maxY - b.minY));
        const normPoints = pts.map(p => ({ x: p.x - cx, y: p.y - cy }));
        const template = {
          id: `custom-${Date.now()}`,
          name: `自作${customStamps.length + 1}`,
          size,
          strokes: [{
            points: normPoints,
            width: clampStrokeWidth(s.width || drawDoc?.penWidth || DRAW_WIDTH),
            color: s.color || 'inherit',
            brush: s.brush || drawDoc?.brush || 'smooth'
          }]
        };
        customStamps = [template, ...customStamps].slice(0, 40);
        saveCustomStamps();
        refreshStampTemplates();
        setActiveStamp(template.id);
        showToast && showToast('スタンプを登録しました', 'ok');
      };
      const placeStampAt = (pt) => {
        if (!drawDoc || !pt) return;
        const stamp = findStamp(drawDoc.activeStampId || activeStampId);
        if (!stamp) return;
        const layer = activeLayer();
        if (!layer) return;
        const baseSize = stamp.size || 32;
        const targetSize = Math.max(32, (drawDoc?.penWidth || DRAW_WIDTH) * 10);
        const scale = targetSize / baseSize;
        (stamp.strokes || []).forEach(st => {
          const points = (st.points || []).map(p => ({
            x: pt.x + p.x * scale,
            y: pt.y + p.y * scale
          }));
          const w = clampStrokeWidth((st.width || currentWidth()) * scale / Math.max(1, baseSize / 18));
          const stroke = {
            type: 'stroke',
            points,
            color: st.color === 'inherit' ? currentColor() : (st.color || currentColor()),
            width: w,
            widths: points.map(() => w),
            baseWidth: w,
            brush: st.brush || drawDoc.brush || 'smooth',
            opacity: currentOpacity(),
            shadow: !!drawDoc.shadow,
            glow: !!drawDoc.glow
          };
          layer.strokes.push(stroke);
        });
        pushHistory();
        saveDrawDoc();
        renderDrawDoc(true);
      };
      const showSizePreview = (pos, size) => {
        if (!drawSizePreview || !pos || !drawCanvas) return;
        const rect = drawCanvas.getBoundingClientRect();
        const sx = (rect.width || 1) / (drawCanvas.width || 1);
        const sy = (rect.height || 1) / (drawCanvas.height || 1);
        const cx = rect.left + pos.x * sx;
        const cy = rect.top + pos.y * sy;
        const r = ((size || 0) * (sx + sy) * 0.5);
        drawSizePreview.style.display = 'block';
        drawSizePreview.style.width = `${r}px`;
        drawSizePreview.style.height = `${r}px`;
        drawSizePreview.style.left = `${cx}px`;
        drawSizePreview.style.top = `${cy}px`;
        gPreviewVisible = true;
      };
      const hideSizePreview = () => {
        if (drawSizePreview) drawSizePreview.style.display = 'none';
        gPreviewVisible = false;
      };
      const beginTapDraw = () => {
        if (tapDrawActive || drawMode || mode !== 'single') return false;
        tapDrawPrevMode = drawMode;
        setDrawMode(true);
        tapDrawActive = true;
        return true;
      };
      const endTapDraw = () => {
        if (!tapDrawActive) return;
        tapDrawActive = false;
        if (!tapDrawPrevMode) setDrawMode(false);
      };
      const setDrawTool = (tool) => {
        drawTool = tool === 'eraser' ? 'eraser' : 'pen';
        if (drawToolBtn) {
          drawToolBtn.innerHTML = `<span class="icon">${drawTool === 'pen' ? '✏️' : '🩹'}</span>`;
          drawToolBtn.classList.toggle('active', drawTool === 'pen');
        }
        updateDrawControls();
      };
      const toggleDrawTool = () => setDrawTool(drawTool === 'pen' ? 'eraser' : 'pen');
      const toggleEraserMode = () => {
        eraserMode = eraserMode === 'stroke' ? 'brush' : 'stroke';
        updateDrawControls();
      };
      const toggleDrawSettings = () => {
        if (!drawSettingsPanel) return;
        drawSettingsPanel.classList.toggle('open');
      };
      const closeDrawSettings = () => drawSettingsPanel?.classList.remove('open');
      const setSelectMode = (next) => {
        selectMode = !!next;
        drawSelectBtn?.classList.toggle('active', selectMode);
        if (!selectMode) { setSelection(null); hideSelectionBox(); }
        if (!selectMode) { selectionPath = []; selectionDrawing = false; selectionRectMode = false; drawSelectionPath(true); }
      };
      const clearDrawDoc = () => {
        if (!activeDrawKey) return;
        drawDocs.set(activeDrawKey, defaultDrawDoc());
        drawDoc = ensureDrawDoc(activeDrawKey);
        localStorage.removeItem(drawStorageKey(activeDrawKey));
        localStorage.removeItem(drawDocKey(activeDrawKey));
        drawStore.delete(activeDrawKey);
        renderDrawDoc(true);
        updateDrawControls();
      };
      const resetDrawPage = () => {
        if (!activeDrawKey) return;
        if (!confirm('このページの線をすべて消去しますか？')) return;
        clearDrawDoc();
      };
      const clearAllDrawData = async () => {
        if (!book?.id || !Array.isArray(book.pages)) return;
        if (!confirm('この本の全ページの線データを削除しますか？')) return;
        if (drawPersistTimer) { clearTimeout(drawPersistTimer); drawPersistTimer = null; }
        let cleared = false;
        book.pages.forEach((p, idx) => {
          const key = `book:${book.id}:p${idx}`;
          drawDocs.delete(key);
          drawStore.delete(key);
          try { localStorage.removeItem(drawStorageKey(key)); } catch (_) { }
          try { localStorage.removeItem(drawDocKey(key)); } catch (_) { }
          if (p?.drawDoc) { delete p.drawDoc; cleared = true; }
        });
        if (activeDrawKey) {
          drawDoc = defaultDrawDoc();
          drawDocs.set(activeDrawKey, drawDoc);
          saveDrawDoc(activeDrawKey, drawDoc);
          renderDrawDoc(true);
          setSelectionGroup([]);
          hideSelectionBox();
          updateDrawControls();
          cleared = true;
        } else {
          drawDirty = false;
        }
        if (cleared && Book?.put) {
          try { await Book.put(book); } catch (err) { console.warn('failed to clear draw data', err); }
        }
        showToast && showToast('線データを全ページから削除しました', 'ok');
      };
      const drawUndo = () => restoreFromHistory(-1);
      const drawRedo = () => restoreFromHistory(+1);
      function syncDrawCanvasSize() {
        if (!drawCanvas || !img) return;
        // Skip heavy persist during active drawing to prevent lag
        if (activeDrawKey && drawDirty && !drawingStroke) { persistDrawLayer(activeDrawKey, false); }
        const baseW = img.naturalWidth || img.clientWidth || 0;
        const baseH = img.naturalHeight || img.clientHeight || 0;
        if (!baseW || !baseH) return;
        const cssW = img.clientWidth || baseW;
        const cssH = img.clientHeight || baseH;
        drawCanvas.width = baseW;
        drawCanvas.height = baseH;
        drawCanvas.style.width = `${cssW}px`;
        drawCanvas.style.height = `${cssH}px`;
        drawCanvas.style.transformOrigin = 'center center';
        if (drawSelectOverlay) {
          drawSelectOverlay.width = cssW;
          drawSelectOverlay.height = cssH;
          updateSelectOverlayRect();
        }
        renderDrawDoc();
        syncDrawTransform();
      }

      const missTypeInfo = (type) => MISS_TYPE_MAP[type] || MISS_TYPE_MAP.important;
      const missClamp01 = (v) => Math.max(0, Math.min(1, v || 0));
      const getMissSourceBook = (srcBookId) => {
        if (!srcBookId || !book) return null;
        if (!book._sourceBookMap) book._sourceBookMap = new Map();
        const map = book._sourceBookMap;
        const cached = typeof map.get === 'function' ? map.get(srcBookId) : map[srcBookId];
        if (cached) return cached;
        if (typeof getEphemeralSourceBook === 'function' && missSourceLoadToken !== srcBookId) {
          missSourceLoadToken = srcBookId;
          getEphemeralSourceBook(srcBookId).then((loaded) => {
            if (loaded) {
              if (typeof map.set === 'function') map.set(srcBookId, loaded);
              else map[srcBookId] = loaded;
              if ((state.viewerContext === 'completed' || book?._openTabType === 'completed') && book?.pages?.[page]?._sourceBookId === srcBookId) {
                renderMissMarkers();
              }
            }
            missSourceLoadToken = null;
          }).catch(() => { missSourceLoadToken = null; });
        }
        return null;
      };
      const resolveMissTarget = () => {
        if (state.viewerContext === 'completed' || book?._openTabType === 'completed') {
          const meta = book?.pages?.[page];
          const srcBookId = meta?._sourceBookId || null;
          const srcIndex = Number.isFinite(meta?._sourcePageIndex) ? meta._sourcePageIndex : null;
          const srcBook = getMissSourceBook(srcBookId);
          return { book: srcBook, bookId: srcBookId, pageIndex: srcIndex };
        }
        return { book, bookId: book?.id || null, pageIndex: page };
      };
      const getMissPageMarks = () => {
        const target = resolveMissTarget();
        if (!target.book || !Number.isFinite(target.pageIndex)) return [];
        const pageMeta = target.book.pages?.[target.pageIndex];
        if (!pageMeta) return [];
        const bookId = target.bookId || target.book?.id;
        return MissStore.ensurePage(pageMeta, { bookId, pageIndex: target.pageIndex });
      };
      const updateMissElement = (el, mark) => {
        if (!el || !mark) return;
        const info = missTypeInfo(mark.type);
        el.style.left = `${missClamp01(mark.x) * 100}%`;
        el.style.top = `${missClamp01(mark.y) * 100}%`;
        el.style.setProperty('--miss-color', info.color);
        el.dataset.type = mark.type;
        el.textContent = info.short;
        const checks = Number.isFinite(mark.checks) ? mark.checks : 0;
        el.classList.toggle('danger', checks < 0);
        if (checks !== 0) {
          let badge = el.querySelector('.miss-count');
          if (!badge) {
            badge = document.createElement('span');
            badge.className = 'miss-count';
            el.appendChild(badge);
          }
          badge.textContent = String(checks);
          badge.classList.toggle('negative', checks < 0);
        } else {
          const badge = el.querySelector('.miss-count');
          if (badge) badge.remove();
        }
        const nameLine = mark.name ? `: ${mark.name}` : '';
        const reasonLine = mark.reason ? `\n${mark.reason}` : '';
        el.title = `${info.label}${nameLine}${reasonLine}`;
      };
      const setMissMessageHighlight = (markId) => {
        if (!missLayer) {
          missMessageHighlightId = markId || null;
          return;
        }
        if (missMessageHighlightId && missMessageHighlightId !== markId) {
          const prev = missElementMap.get(missMessageHighlightId) || missLayer?.querySelector?.(`.miss-marker[data-id="${missMessageHighlightId}"]`);
          if (prev) prev.classList.remove('message-glow');
        }
        missMessageHighlightId = markId || null;
        if (!markId) return;
        const el = missElementMap.get(markId) || missLayer?.querySelector?.(`.miss-marker[data-id="${markId}"]`);
        if (el) el.classList.add('message-glow');
      };
      const renderMissMarkers = () => {
        if (!missLayer) return;
        missLayer.innerHTML = '';
        missElementMap.clear();
        if (mode !== 'single') {
          closeMissMessageBox();
          return;
        }
        const marks = getMissPageMarks();
        const messageOpen = !!(missMessageBox && !missMessageBox.classList.contains('hidden'));
        marks.forEach(mark => {
          const el = document.createElement('button');
          el.type = 'button';
          el.className = 'miss-marker';
          el.dataset.id = mark.id;
          if (missMoveState && missMoveState.id === mark.id) el.classList.add('moving');
          if (missMessageState?.id === mark.id && messageOpen) el.classList.add('message-glow');
          updateMissElement(el, mark);
          missLayer.appendChild(el);
          missElementMap.set(mark.id, el);
        });
        if (missMessageState?.id && messageOpen) {
          if (!marks.some(m => m.id === missMessageState.id)) {
            closeMissMessageBox();
          } else {
            syncMissMessageBox({ animate: false });
            setMissMessageHighlight(missMessageState.id);
          }
        } else {
          setMissMessageHighlight(null);
        }
      };
      const pulseMissMarker = (id, opts = {}) => {
        const { strong = false, retries = 6, delay = 120 } = opts || {};
        const el = id ? missElementMap.get(id) || missLayer?.querySelector?.(`.miss-marker[data-id="${id}"]`) : null;
        if (!el) {
          if (retries > 0) {
            setTimeout(() => pulseMissMarker(id, { strong, retries: retries - 1, delay }), delay);
          }
          return;
        }
        const cls = strong ? 'pulse-strong' : 'pulse';
        el.classList.remove('pulse');
        el.classList.remove('pulse-strong');
        void el.offsetWidth;
        el.classList.add(cls);
        const duration = strong ? 2200 : 900;
        setTimeout(() => el.classList.remove(cls), duration);
      };
      const setMissPanelOpen = (next) => {
        missPanelOpen = !!next;
        missPanel?.classList.toggle('open', missPanelOpen);
        missQuickBtn?.classList.toggle('active', missPanelOpen);
        missBtn?.classList.toggle('active', missPanelOpen);
      };
      const toggleMissPanel = () => {
        if (mode !== 'single') {
          showToast && showToast('ミス目印は単ページ表示で使用できます', 'error');
          return;
        }
        setMissPanelOpen(!missPanelOpen);
      };
      const getMissDropRect = () => {
        const rect = drawCanvas?.getBoundingClientRect?.();
        if (rect && rect.width > 5 && rect.height > 5) return rect;
        const imgRect = img?.getBoundingClientRect?.();
        if (imgRect && imgRect.width > 5 && imgRect.height > 5) return imgRect;
        return null;
      };
      const isMissCancelDrop = (clientX, clientY) => {
        if (!missPanelOpen || !missPanel) return false;
        const rect = missPanel.getBoundingClientRect();
        if (!rect || rect.width <= 0 || rect.height <= 0) return false;
        return clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;
      };
      const clientToMissRatio = (clientX, clientY) => {
        const rect = getMissDropRect();
        if (!rect) return null;
        if (clientX < rect.left || clientX > rect.right || clientY < rect.top || clientY > rect.bottom) return null;
        const x = (clientX - rect.left) / (rect.width || 1);
        const y = (clientY - rect.top) / (rect.height || 1);
        return { x: missClamp01(x), y: missClamp01(y) };
      };
      const updateMissCursor = (e) => {
        if (!e) return;
        missCursorClient.x = e.clientX;
        missCursorClient.y = e.clientY;
      };
      if (stageHost && !stageHost.__missCursorBound) {
        stageHost.__missCursorBound = true;
        stageHost.addEventListener('pointermove', updateMissCursor);
        stageHost.addEventListener('pointerdown', updateMissCursor);
        stageHost.addEventListener('mousemove', updateMissCursor);
      }
      const getMissCursorClient = () => {
        if (!stageHost) return null;
        const x = missCursorClient.x;
        const y = missCursorClient.y;
        if (!Number.isFinite(x) || !Number.isFinite(y)) return null;
        const rect = stageHost.getBoundingClientRect();
        if (!rect || rect.width <= 0 || rect.height <= 0) return null;
        if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) return null;
        return { x, y };
      };
      const getMissMessageLabel = (mode) => {
        if (mode === 'explain') return '説明/解説';
        return '理由';
      };
      const getMissMessageText = (mark, mode) => {
        if (!mark) return '';
        if (mode === 'explain') return String(mark.explain || '');
        if (mode === 'answer') return '（解答ウィンドウを表示中）';
        return String(mark.reason || '');
      };
      let missMessageTypingTimer = null;
      let missMessageTypingText = '';
      let missMessageTypingIndex = 0;
      let missMessageSaveTimer = null;
      const isMissMessageEditing = () => !!(missMessageBody && document.activeElement === missMessageBody);
      const focusMissMessageBodyEnd = () => {
        if (!missMessageBody) return;
        missMessageBody.focus();
        const range = document.createRange();
        range.selectNodeContents(missMessageBody);
        range.collapse(false);
        const sel = window.getSelection();
        sel?.removeAllRanges?.();
        sel?.addRange?.(range);
      };
      const stopMissMessageTyping = (fill = true) => {
        if (!missMessageTypingTimer) return;
        clearInterval(missMessageTypingTimer);
        missMessageTypingTimer = null;
        if (fill && missMessageBody) missMessageBody.textContent = missMessageTypingText || '';
      };
      const startMissMessageTyping = (text) => {
        if (!missMessageBody) return;
        stopMissMessageTyping(false);
        missMessageTypingText = text || '';
        missMessageTypingIndex = 0;
        missMessageBody.textContent = '';
        if (!missMessageTypingText) return;
        const stepForLen = (len) => (len > 320 ? 3 : len > 180 ? 2 : 1);
        const step = stepForLen(missMessageTypingText.length);
        missMessageTypingTimer = setInterval(() => {
          missMessageTypingIndex = Math.min(missMessageTypingText.length, missMessageTypingIndex + step);
          missMessageBody.textContent = missMessageTypingText.slice(0, missMessageTypingIndex);
          if (missMessageTypingIndex >= missMessageTypingText.length) {
            stopMissMessageTyping(false);
          }
        }, 22);
      };
      const renderMissMessageText = (text, { animate = false } = {}) => {
        if (!missMessageBody) return;
        if (isMissMessageEditing()) return;
        if (animate) startMissMessageTyping(text);
        else {
          stopMissMessageTyping(false);
          missMessageBody.textContent = text || '';
        }
      };
      const scheduleMissMessageSave = () => {
        if (!missMessageState?.id || !missMessageBody) return;
        if (missMessageState.mode === 'answer') return;
        if (missMessageSaveTimer) clearTimeout(missMessageSaveTimer);
        missMessageSaveTimer = setTimeout(() => {
          missMessageSaveTimer = null;
          if (!missMessageState?.id || !missMessageBody) return;
          const mode = missMessageState.mode || 'reason';
          const text = missMessageBody.textContent || '';
          const patch = mode === 'explain' ? { explain: text } : { reason: text };
          updateMissData(missMessageState.id, patch);
        }, 240);
      };
      const flushMissMessageSave = () => {
        if (!missMessageSaveTimer) return;
        clearTimeout(missMessageSaveTimer);
        missMessageSaveTimer = null;
        if (!missMessageState?.id || !missMessageBody) return;
        if (missMessageState.mode === 'answer') return;
        const mode = missMessageState.mode || 'reason';
        const text = missMessageBody.textContent || '';
        const patch = mode === 'explain' ? { explain: text } : { reason: text };
        updateMissData(missMessageState.id, patch);
      };
      function syncMissMessageBox({ animate = false } = {}) {
        if (!missMessageBox || !missMessageState?.id) return;
        const mark = getMissPageMarks().find(m => m.id === missMessageState.id);
        if (!mark) {
          closeMissMessageBox();
          return;
        }
        const mode = missMessageState.mode || 'reason';

        // Handle Answer Window visibility
        const ansWin = document.getElementById('answerWindow');
        if (mode === 'answer') {
          // Open answer window if not open
          if (ansWin && ansWin.classList.contains('hidden')) {
            if (typeof toggleAnswerWindow === 'function') toggleAnswerWindow();
            else ansWin.classList.remove('hidden');
          }
        }

        if (missMessageTitle) missMessageTitle.textContent = getMissMessageLabel(mode);
        const text = getMissMessageText(mark, mode) || '';
        renderMissMessageText(text, { animate });
      }
      function openMissMessageBox(markId, { mode = 'reason', focus = false } = {}) {
        if (!missMessageBox || !markId) return;
        missMessageState = { id: markId, mode };
        missMessageBox.classList.remove('hidden');
        syncMissMessageBox({ animate: true });
        setMissMessageHighlight(markId);

        // Conditional focus
        if (focus) {
          focusMissMessageBodyEnd();
        }

        if (!missMessageBox.__outsideHandler) {
          missMessageBox.__outsideHandler = (e) => {
            if (!missMessageBox || missMessageBox.classList.contains('hidden')) return;
            const t = e.target && e.target.nodeType === 3 ? e.target.parentElement : e.target;
            if (t?.closest?.('#missMessageBox')) return;
            if (document.activeElement === missMessageBody) {
              flushMissMessageSave();
              missMessageBody.blur();
            }
          };
          document.addEventListener('pointerdown', missMessageBox.__outsideHandler, true);
        }
        if (!missMessageBox.__keyHandler) {
          missMessageBox.__keyHandler = (e) => {
            if (!missMessageBox || missMessageBox.classList.contains('hidden')) return;
            if (e.key === 'Escape') {
              e.preventDefault();
              e.stopPropagation();
              closeMissMessageBox();
              return;
            }
            if (e.key === 'Tab') {
              e.preventDefault();
              stopMissMessageTyping(true);
              focusMissMessageBodyEnd();
            }
          };
          document.addEventListener('keydown', missMessageBox.__keyHandler, true);
        }
      }
      function closeMissMessageBox() {
        if (!missMessageBox) return;
        flushMissMessageSave();
        stopMissMessageTyping(false);
        missMessageBox.classList.add('hidden');
        missMessageState = null;
        setMissMessageHighlight(null);
        if (missMessageBox.__outsideHandler) {
          document.removeEventListener('pointerdown', missMessageBox.__outsideHandler, true);
          missMessageBox.__outsideHandler = null;
        }
        if (missMessageBox.__keyHandler) {
          document.removeEventListener('keydown', missMessageBox.__keyHandler, true);
          missMessageBox.__keyHandler = null;
        }
      }
      function toggleMissMessageBox(markId) {
        if (!markId) return;
        if (missMessageBox && missMessageState?.id === markId && !missMessageBox.classList.contains('hidden')) {
          closeMissMessageBox();
          return;
        }
        openMissMessageBox(markId, { mode: 'reason' });
      }
      function cycleMissMessageMode() {
        if (!missMessageState) return;
        flushMissMessageSave();
        // Cycle 'explain' <-> 'reason', excluding 'answer' as requested
        const modes = ['explain', 'reason'];
        const current = missMessageState.mode || 'reason';
        let next = 'explain';
        const idx = modes.indexOf(current);
        if (idx >= 0) {
          next = modes[(idx + 1) % modes.length];
        }
        missMessageState.mode = next;
        syncMissMessageBox({ animate: true });
      }
      const syncMissSpawnMenu = () => {
        if (!missSpawnMenu || missSpawnMenu.classList.contains('hidden')) return;
        if (mode !== 'single' || !missSpawnAnchor?.pos) { closeMissSpawnMenu(); return; }
        const rect = getMissDropRect();
        if (!rect) { closeMissSpawnMenu(); return; }
        const x = rect.left + missSpawnAnchor.pos.x * rect.width;
        const y = rect.top + missSpawnAnchor.pos.y * rect.height;
        positionMissOverlay(missSpawnMenu, x, y, { margin: 0 });
      };
      const startMissSpawnFollow = () => {
        if (missSpawnFollowRaf) return;
        const tick = () => {
          missSpawnFollowRaf = null;
          if (!missSpawnMenu || missSpawnMenu.classList.contains('hidden')) return;
          syncMissSpawnMenu();
          missSpawnFollowRaf = requestAnimationFrame(tick);
        };
        missSpawnFollowRaf = requestAnimationFrame(tick);
      };
      const stopMissSpawnFollow = () => {
        if (missSpawnFollowRaf) {
          cancelAnimationFrame(missSpawnFollowRaf);
          missSpawnFollowRaf = null;
        }
      };
      const closeMissSpawnMenu = () => {
        missSpawnMenu?.classList.add('hidden');
        missSpawnAnchor = null;
        stopMissSpawnFollow();
        if (missSpawnOutsideHandler) {
          document.removeEventListener('pointerdown', missSpawnOutsideHandler, true);
          missSpawnOutsideHandler = null;
        }
      };
      const openMissSpawnMenu = (clientX, clientY) => {
        if (!missSpawnMenu) return false;
        const pos = clientToMissRatio(clientX, clientY);
        if (!pos) return false;
        closeMissEditPopover();
        closeMissPieMenu();
        closeMissTypePicker();
        missSpawnAnchor = { x: clientX, y: clientY, pos };
        missSpawnMenu.classList.remove('hidden');
        positionMissOverlay(missSpawnMenu, clientX, clientY, { margin: 0 });
        startMissSpawnFollow();
        if (missSpawnOutsideHandler) document.removeEventListener('pointerdown', missSpawnOutsideHandler, true);
        missSpawnOutsideHandler = (e) => {
          if (e.target?.closest?.('#missSpawnMenu')) return;
          closeMissSpawnMenu();
        };
        document.addEventListener('pointerdown', missSpawnOutsideHandler, true);
        return true;
      };
      const openMissSpawnMenuAtCursor = () => {
        if (mode !== 'single') {
          showToast && showToast('ミス目印は単ページ表示で使用できます', 'error');
          return false;
        }
        const client = getMissCursorClient();
        if (!client) {
          showToast && showToast('カーソル位置が見つかりません', 'error');
          return false;
        }
        const ok = openMissSpawnMenu(client.x, client.y);
        if (!ok) showToast && showToast('ミス目印を置けません', 'error');
        return ok;
      };
      const openMissSpawnMenuFromKey = () => {
        if (missSpawnMenu && !missSpawnMenu.classList.contains('hidden')) {
          closeMissSpawnMenu();
          return true;
        }
        return openMissSpawnMenuAtCursor();
      };
      window.__openMissSpawnMenu = openMissSpawnMenuFromKey;
      // 最後に追加されたミスマーカーのIDを追跡
      let lastAddedMissId = null;

      const updateMissData = (markId, patch, { notify = true } = {}) => {
        const target = resolveMissTarget();
        if (!target.book || !Number.isFinite(target.pageIndex)) return null;
        const updated = MissStore.updateMark(target.book, target.pageIndex, markId, patch);
        if (!updated) return null;
        MissStore.queueSave(target.book);
        if (notify) MissStore.emitUpdate(target.book?.id || target.bookId);
        renderMissMarkers();
        return updated;
      };
      const addMissMarkerAt = (type, pos, meta = {}) => {
        if (!pos || mode !== 'single') return null;
        const target = resolveMissTarget();
        if (!target.book || !Number.isFinite(target.pageIndex)) return null;
        const mark = MissStore.addMark(target.book, target.pageIndex, {
          type,
          x: pos.x,
          y: pos.y,
          name: meta.name || '',
          reason: meta.reason || '',
          explain: meta.explain || '',
          checks: 0
        });
        if (!mark) return null;
        MissStore.queueSave(target.book);
        MissStore.emitUpdate(target.book?.id || target.bookId);
        renderMissMarkers();
        // 最後に追加されたIDを保存
        lastAddedMissId = mark.id;
        return mark;
      };

      // Tab押下で最後に追加されたミスボタンのメッセージウィンドウを開く
      const openLastAddedMissMessage = () => {
        if (!lastAddedMissId) return false;
        const marks = getMissPageMarks();
        if (!marks.some(m => m.id === lastAddedMissId)) {
          lastAddedMissId = null;
          return false;
        }
        openMissMessageBox(lastAddedMissId, { mode: 'reason', focus: true });
        return true;
      };

      // メッセージボックスの「次のミスボタンへ」機能
      const missMessageNext = () => {
        if (!missMessageState?.id) return false;
        const marks = getMissPageMarks();
        if (marks.length === 0) return false;
        const currentIdx = marks.findIndex(m => m.id === missMessageState.id);
        const nextIdx = (currentIdx + 1) % marks.length;
        openMissMessageBox(marks[nextIdx].id, { mode: missMessageState.mode || 'reason', focus: true });
        return true;
      };

      const missMessageFocusBelow = () => {
        if (!missMessageState?.id) return false;
        const marks = getMissPageMarks();
        if (marks.length === 0) return false;
        const current = marks.find(m => m.id === missMessageState.id);
        if (!current) {
          if (marks.length > 0) { openMissMessageBox(marks[0].id, { mode: 'reason', focus: false }); return true; }
          return false;
        }
        const sorted = [...marks].sort((a, b) => (a.y - b.y) || (a.x - b.x));
        const idx = sorted.findIndex(m => m.id === current.id);
        const next = sorted[(idx + 1) % sorted.length];
        if (next) {
          // Move focus without starting input on the message box
          openMissMessageBox(next.id, { mode: missMessageState.mode || 'reason', focus: false });
          return true;
        }
        return false;
      };

      const missMessageFocusAbove = () => {
        if (!missMessageState?.id) return false;
        const marks = getMissPageMarks();
        if (marks.length === 0) return false;
        const current = marks.find(m => m.id === missMessageState.id);
        if (!current) {
          if (marks.length > 0) { openMissMessageBox(marks[0].id, { mode: 'reason', focus: false }); return true; }
          return false;
        }
        const sorted = [...marks].sort((a, b) => (a.y - b.y) || (a.x - b.x));
        const idx = sorted.findIndex(m => m.id === current.id);
        // Go backwards, wrap around
        const prevIdx = (idx - 1 + sorted.length) % sorted.length;
        const next = sorted[prevIdx];
        if (next) {
          openMissMessageBox(next.id, { mode: missMessageState.mode || 'reason', focus: false });
          return true;
        }
        return false;
      };

      // 波紋を飛ばして最寄りのミスボタンを検出しメッセージを開く
      const missRippleFindNearest = () => {
        const client = getMissCursorClient();
        if (!client) {
          showToast && showToast('カーソル位置が見つかりません', 'error');
          return false;
        }

        // 波紋エフェクトを表示
        const ripple = document.createElement('div');
        ripple.className = 'miss-ripple-find';
        ripple.style.left = `${client.x}px`;
        ripple.style.top = `${client.y}px`;
        ripple.style.width = '100px';
        ripple.style.height = '100px';
        document.body.appendChild(ripple);
        setTimeout(() => ripple.remove(), 850);

        // 最寄りのミスマーカーを検出
        const rect = getMissDropRect();
        if (!rect) return false;
        const marks = getMissPageMarks();
        if (marks.length === 0) {
          showToast && showToast('ミス目印がありません', 'warn');
          return false;
        }

        // クライアント座標からの距離を計算し、最寄りを検出
        let nearest = null;
        let minDist = Infinity;
        const cursorPos = { x: (client.x - rect.left) / rect.width, y: (client.y - rect.top) / rect.height };

        marks.forEach(mark => {
          const dx = cursorPos.x - mark.x;
          const dy = cursorPos.y - mark.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < minDist) {
            minDist = dist;
            nearest = mark;
          }
        });

        if (nearest) {
          // 少し遅延させて波紋が見えてから開く
          setTimeout(() => {
            openMissMessageBox(nearest.id, { mode: 'reason' });
            pulseMissMarker(nearest.id, { strong: true });
          }, 200);
          return true;
        }
        return false;
      };

      // グローバル関数として公開
      window.__openLastAddedMissMessage = openLastAddedMissMessage;
      window.__missMessageNext = missMessageNext;
      window.__missMessageFocusBelow = missMessageFocusBelow;
      window.__missMessageFocusAbove = missMessageFocusAbove;
      window.__cycleMissMessageMode = cycleMissMessageMode;
      window.__missRippleFindNearest = missRippleFindNearest;

      let missMenuAnchor = null;
      let missOutsideHandler = null;
      let missEditOutsideHandler = null;
      let missOverlayRaf = null;
      let missEditTargetId = null;

      const isMissOverlayOpen = () => {
        const pieOpen = !!(missPieMenu && !missPieMenu.classList.contains('hidden'));
        const typeOpen = !!(missTypePicker && missTypePicker.classList.contains('open'));
        const editOpen = !!(missEditPopover && missEditPopover.classList.contains('open'));
        return pieOpen || typeOpen || editOpen;
      };

      const stopMissOverlayFollow = () => {
        if (missOverlayRaf) {
          cancelAnimationFrame(missOverlayRaf);
          missOverlayRaf = null;
        }
      };

      const closeMissTypePicker = () => {
        missTypePicker?.classList.remove('open');
      };
      const closeMissEditPopover = ({ keepActive = false } = {}) => {
        missEditPopover?.classList.remove('open');
        missEditTargetId = null;
        if (missEditOutsideHandler) {
          document.removeEventListener('pointerdown', missEditOutsideHandler, true);
          missEditOutsideHandler = null;
        }
        if (!keepActive && !isMissOverlayOpen()) {
          missActiveId = null;
          missMenuAnchor = null;
        }
        if (!isMissOverlayOpen()) stopMissOverlayFollow();
      };
      const closeMissPieMenu = ({ keepActive = false } = {}) => {
        missPieMenu?.classList.add('hidden');
        closeMissTypePicker();
        if (missOutsideHandler) {
          document.removeEventListener('pointerdown', missOutsideHandler, true);
          missOutsideHandler = null;
        }
        if (!keepActive && !isMissOverlayOpen()) {
          missActiveId = null;
          missMenuAnchor = null;
        }
        if (!isMissOverlayOpen()) stopMissOverlayFollow();
      };
      const positionMissOverlay = (el, clientX, clientY, { offsetX = 0, offsetY = 0, margin = 80 } = {}) => {
        if (!el || !stageHost) return;
        const hostRect = stageHost.getBoundingClientRect();
        if (!hostRect) return;
        const rawX = clientX - hostRect.left + offsetX;
        const rawY = clientY - hostRect.top + offsetY;
        const x = Math.max(margin, Math.min(hostRect.width - margin, rawX));
        const y = Math.max(margin, Math.min(hostRect.height - margin, rawY));
        el.style.left = `${x}px`;
        el.style.top = `${y}px`;
      };
      const getMissMarkerCenter = (markId) => {
        if (!markId) return null;
        const el = missElementMap.get(markId) || missLayer?.querySelector?.(`.miss-marker[data-id="${markId}"]`);
        if (!el) return null;
        const rect = el.getBoundingClientRect();
        return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
      };
      const emitMissFocusWave = (markId) => {
        if (!missLayer || !markId) return;
        const center = getMissMarkerCenter(markId);
        if (!center) return;
        const layerRect = missLayer.getBoundingClientRect();
        if (!layerRect || layerRect.width < 1 || layerRect.height < 1) return;
        const baseW = missLayer.offsetWidth || 0;
        const baseH = missLayer.offsetHeight || 0;
        if (baseW < 1 || baseH < 1) return;
        const scaleX = layerRect.width / baseW;
        const scaleY = layerRect.height / baseH;
        const x = (center.x - layerRect.left) / scaleX;
        const y = (center.y - layerRect.top) / scaleY;
        const spawn = (delayMs) => {
          const wave = document.createElement('div');
          wave.className = 'miss-focus-wave';
          wave.style.left = `${x}px`;
          wave.style.top = `${y}px`;
          if (delayMs) wave.style.animationDelay = `${delayMs}ms`;
          missLayer.appendChild(wave);
          wave.addEventListener('animationend', () => wave.remove());
        };
        spawn(0);
        spawn(140);
      };
      const syncMissOverlays = () => {
        if (!missActiveId) return;
        const anchor = getMissMarkerCenter(missActiveId) || missMenuAnchor;
        if (!anchor) {
          closeMissPieMenu();
          closeMissEditPopover();
          return;
        }
        missMenuAnchor = anchor;
        if (missPieMenu && !missPieMenu.classList.contains('hidden')) {
          positionMissOverlay(missPieMenu, anchor.x, anchor.y, { margin: 90 });
        }
        if (missTypePicker && missTypePicker.classList.contains('open')) {
          positionMissOverlay(missTypePicker, anchor.x, anchor.y, { offsetY: 90, margin: 20 });
        }
        if (missEditPopover && missEditPopover.classList.contains('open')) {
          positionMissOverlay(missEditPopover, anchor.x, anchor.y, { offsetX: 120, margin: 24 });
        }
      };
      const startMissOverlayFollow = () => {
        if (missOverlayRaf) return;
        const tick = () => {
          missOverlayRaf = null;
          if (!isMissOverlayOpen()) return;
          syncMissOverlays();
          missOverlayRaf = requestAnimationFrame(tick);
        };
        missOverlayRaf = requestAnimationFrame(tick);
      };
      const openMissPieMenu = (markId, clientX, clientY) => {
        if (!missPieMenu || !markId) return;
        const mark = getMissPageMarks().find(m => m.id === markId);
        if (!mark) return;
        closeMissEditPopover({ keepActive: true });
        closeMissPieMenu({ keepActive: true });
        closeMissSpawnMenu();
        missActiveId = markId;
        missPieMenu.classList.remove('hidden');
        const anchor = getMissMarkerCenter(markId) || { x: clientX, y: clientY };
        missMenuAnchor = anchor;
        positionMissOverlay(missPieMenu, anchor.x, anchor.y, { margin: 90 });
        missOutsideHandler = (e) => {
          if (e.target?.closest?.('#missPieMenu') || e.target?.closest?.('#missTypePicker') || e.target?.closest?.('.miss-marker')) return;
          closeMissPieMenu();
        };
        document.addEventListener('pointerdown', missOutsideHandler, true);
        startMissOverlayFollow();
      };
      const openMissTypePicker = () => {
        if (!missTypePicker || !missActiveId) return;
        missTypePicker.classList.add('open');
        syncMissOverlays();
        startMissOverlayFollow();
      };
      const openMissEditPopover = (mark, { focus = 'name' } = {}) => {
        if (!mark || !missEditPopover) return;
        missEditTargetId = mark.id;
        if (missEditNameInput) missEditNameInput.value = mark.name || '';
        if (missEditReasonInput) missEditReasonInput.value = mark.reason || '';
        if (missEditExplainInput) missEditExplainInput.value = mark.explain || '';
        missActiveId = mark.id;
        closeMissPieMenu({ keepActive: true });
        missEditPopover.classList.add('open');
        syncMissOverlays();
        startMissOverlayFollow();
        if (missEditOutsideHandler) {
          document.removeEventListener('pointerdown', missEditOutsideHandler, true);
        }
        missEditOutsideHandler = (e) => {
          if (e.target?.closest?.('#missEditPopover') || e.target?.closest?.('.miss-marker')) return;
          closeMissEditPopover();
        };
        document.addEventListener('pointerdown', missEditOutsideHandler, true);
        setTimeout(() => {
          let target = missEditNameInput;
          if (focus === 'reason') target = missEditReasonInput;
          if (focus === 'explain') target = missEditExplainInput;
          target?.focus?.();
        }, 10);
      };
      if (missEditPopover && !missEditPopover.__bound) {
        missEditPopover.__bound = true;
        const saveMissEditPopover = () => {
          if (!missEditTargetId) { closeMissEditPopover(); return; }
          updateMissData(missEditTargetId, {
            name: missEditNameInput?.value?.trim() || '',
            reason: missEditReasonInput?.value?.trim() || '',
            explain: missEditExplainInput?.value?.trim() || ''
          });
          closeMissEditPopover();
        };
        missEditPopover.addEventListener('click', (e) => {
          const btn = e.target.closest('[data-miss-edit]');
          if (!btn) return;
          const act = btn.dataset.missEdit;
          if (act === 'close') { closeMissEditPopover(); return; }
          if (act === 'save') saveMissEditPopover();
        });
        missEditPopover.addEventListener('keydown', (e) => {
          if (e.key !== 'Enter') return;
          if (!(e.ctrlKey || e.metaKey)) return;
          const target = e.target;
          if (!target) return;
          if (target.tagName !== 'TEXTAREA' && target.tagName !== 'INPUT') return;
          e.preventDefault();
          saveMissEditPopover();
        });
      }
      if (missMessageBox && !missMessageBox.__bound) {
        missMessageBox.__bound = true;
        const setCaretFromPoint = (clientX, clientY) => {
          if (!missMessageBody) return false;
          const sel = window.getSelection();
          if (!sel) return false;
          if (document.caretRangeFromPoint) {
            const range = document.caretRangeFromPoint(clientX, clientY);
            if (!range) return false;
            sel.removeAllRanges();
            sel.addRange(range);
            return true;
          }
          if (document.caretPositionFromPoint) {
            const pos = document.caretPositionFromPoint(clientX, clientY);
            if (!pos) return false;
            const range = document.createRange();
            range.setStart(pos.offsetNode, pos.offset);
            range.collapse(true);
            sel.removeAllRanges();
            sel.addRange(range);
            return true;
          }
          return false;
        };
        const isInsideMissMessageBody = (target) => {
          const el = target && target.nodeType === 3 ? target.parentElement : target;
          return !!el?.closest?.('#missMessageBody');
        };
        missMessageBox.addEventListener('click', (e) => {
          const btn = e.target.closest('[data-miss-message]');
          if (btn) {
            const act = btn.dataset.missMessage;
            if (act === 'close') { closeMissMessageBox(); return; }
            if (act === 'next') { cycleMissMessageMode(); return; }
          }
          if (isInsideMissMessageBody(e.target)) return;
          stopMissMessageTyping(true);
          focusMissMessageBodyEnd();
        });
        missMessageBody?.addEventListener('pointerdown', (e) => {
          if (!missMessageTypingTimer) return;
          e.preventDefault();
          stopMissMessageTyping(true);
          missMessageBody.focus();
          setCaretFromPoint(e.clientX, e.clientY);
        });
        missMessageBody?.addEventListener('focus', () => {
          stopMissMessageTyping(true);
        });
        missMessageBody?.addEventListener('input', () => {
          scheduleMissMessageSave();
        });
        missMessageBody?.addEventListener('blur', () => {
          flushMissMessageSave();
        });
        missMessageBody?.addEventListener('keydown', (e) => {
          if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
            e.preventDefault();
            flushMissMessageSave();
            missMessageBody.blur();
            return;
          }
          if (e.key === 'Escape') {
            e.preventDefault();
            closeMissMessageBox();
          }
        });
      }

      missPalette?.addEventListener('pointerdown', (e) => {
        const chip = e.target?.closest?.('.miss-chip');
        if (!chip) return;
        if (mode !== 'single') {
          showToast && showToast('ミス目印は単ページ表示で使用できます', 'error');
          return;
        }
        const type = chip.dataset.type || 'important';
        const info = missTypeInfo(type);
        const ghost = document.createElement('div');
        ghost.className = 'miss-drag-ghost';
        ghost.style.setProperty('--miss-color', info.color);
        ghost.textContent = info.short;
        document.body.appendChild(ghost);
        const pointerId = e.pointerId ?? null;
        if (pointerId !== null) {
          try { chip.setPointerCapture(pointerId); } catch (_) { }
        }
        missDragState = { type, ghost };
        const move = (ev) => {
          if (pointerId !== null && ev.pointerId !== pointerId) return;
          ghost.style.left = `${ev.clientX}px`;
          ghost.style.top = `${ev.clientY}px`;
          if (ev.cancelable) ev.preventDefault();
        };
        const end = (ev) => {
          if (pointerId !== null && ev.pointerId !== pointerId) return;
          document.removeEventListener('pointermove', move);
          document.removeEventListener('pointerup', end);
          document.removeEventListener('pointercancel', end);
          if (pointerId !== null) {
            try { chip.releasePointerCapture(pointerId); } catch (_) { }
          }
          ghost.remove();
          if (ev && !isMissCancelDrop(ev.clientX, ev.clientY)) {
            const pos = clientToMissRatio(ev.clientX, ev.clientY);
            if (pos) {
              addMissMarkerAt(type, pos);
              showToast && showToast('ミス目印を追加しました', 'ok');
            }
          }
          missDragState = null;
        };
        document.addEventListener('pointermove', move, { passive: false });
        document.addEventListener('pointerup', end);
        document.addEventListener('pointercancel', end);
        move(e);
        e.preventDefault();
      });
      missQuickBtn?.addEventListener('click', (e) => { e.stopPropagation(); toggleMissPanel(); });
      missBtn?.addEventListener('click', (e) => { e.stopPropagation(); toggleMissPanel(); });
      missPieMenu?.addEventListener('click', (e) => {
        const btn = e.target.closest('[data-miss-action]');
        if (!btn) return;
        const act = btn.dataset.missAction;
        if (!missActiveId) return;
        const mark = getMissPageMarks().find(m => m.id === missActiveId);
        if (!mark) return;
        e.stopPropagation();
        if (act === 'close') { closeMissPieMenu(); return; }
        if (act === 'confirm') {
          updateMissData(mark.id, { checks: (mark.checks || 0) + 1 });
          showToast && showToast('確認 +1', 'ok');
          return;
        }
        if (act === 'decrement') {
          const next = (Number.isFinite(mark.checks) ? mark.checks : 0) - 1;
          updateMissData(mark.id, { checks: next });
          showToast && showToast(next < 0 ? '危険: 確認がマイナスです' : '確認 -1', next < 0 ? 'warn' : 'info');
          return;
        }
        if (act === 'delete') {
          const target = resolveMissTarget();
          if (!target.book || !Number.isFinite(target.pageIndex)) return;
          MissStore.removeMark(target.book, target.pageIndex, mark.id);
          MissStore.queueSave(target.book);
          MissStore.emitUpdate(target.book?.id || target.bookId);
          renderMissMarkers();
          if (missMessageState?.id === mark.id) closeMissMessageBox();
          closeMissPieMenu();
          return;
        }
        if (act === 'move') {
          missMoveState = { id: mark.id };
          renderMissMarkers();
          showToast && showToast('ドラッグして移動してください', 'info');
          closeMissPieMenu();
          return;
        }
        if (act === 'type') {
          openMissTypePicker();
          return;
        }
        if (act === 'rename') {
          openMissEditPopover(mark, { focus: 'name' });
          return;
        }
        if (act === 'reason') {
          openMissEditPopover(mark, { focus: 'reason' });
          return;
        }
      });
      missTypePicker?.addEventListener('click', (e) => {
        const chip = e.target?.closest?.('.miss-chip');
        if (!chip || !missActiveId) return;
        const nextType = chip.dataset.type || 'important';
        updateMissData(missActiveId, { type: nextType });
        closeMissTypePicker();
      });
      missSpawnMenu?.addEventListener('click', (e) => {
        const btn = e.target.closest('[data-miss-spawn]');
        if (!btn) return;
        const act = btn.dataset.missSpawn;
        if (act === 'cancel') { closeMissSpawnMenu(); return; }
        if (!missSpawnAnchor?.pos) { closeMissSpawnMenu(); return; }
        const type = MISS_TYPE_MAP[act] ? act : 'important';
        const mark = addMissMarkerAt(type, missSpawnAnchor.pos);
        if (mark) showToast && showToast('ミス目印を追加しました', 'ok');
        closeMissSpawnMenu();
      });
      missLayer?.addEventListener('pointerdown', (e) => {
        const target = e.target?.closest?.('.miss-marker');
        if (!target) return;
        if (!missMoveState || missMoveState.id !== target.dataset.id) return;
        const dragId = target.dataset.id;
        const rect = getMissDropRect();
        if (!rect) return;
        missClickSuppress = true;
        const pointerId = e.pointerId ?? null;
        if (pointerId !== null) {
          try { target.setPointerCapture(pointerId); } catch (_) { }
        }
        const onMove = (ev) => {
          if (pointerId !== null && ev.pointerId !== pointerId) return;
          const pos = clientToMissRatio(ev.clientX, ev.clientY);
          if (!pos) return;
          target.style.left = `${pos.x * 100}%`;
          target.style.top = `${pos.y * 100}%`;
          missMoveState = { id: dragId, x: pos.x, y: pos.y };
          if (ev.cancelable) ev.preventDefault();
        };
        const onUp = (ev) => {
          if (pointerId !== null && ev && ev.pointerId !== pointerId) return;
          document.removeEventListener('pointermove', onMove);
          document.removeEventListener('pointerup', onUp);
          document.removeEventListener('pointercancel', onUp);
          if (pointerId !== null) {
            try { target.releasePointerCapture(pointerId); } catch (_) { }
          }
          if (missMoveState && missMoveState.id === dragId && Number.isFinite(missMoveState.x)) {
            updateMissData(dragId, { x: missMoveState.x, y: missMoveState.y }, { notify: true });
          }
          missMoveState = null;
          renderMissMarkers();
          setTimeout(() => { missClickSuppress = false; }, 0);
        };
        document.addEventListener('pointermove', onMove, { passive: false });
        document.addEventListener('pointerup', onUp);
        document.addEventListener('pointercancel', onUp);
        e.preventDefault();
      });
      missLayer?.addEventListener('click', (e) => {
        if (missClickSuppress) return;
        const target = e.target?.closest?.('.miss-marker');
        if (!target) return;
        if (selecting) return;
        const targetId = target.dataset.id;
        const pieOpen = !!(missPieMenu && !missPieMenu.classList.contains('hidden'));
        if (pieOpen && missActiveId === targetId) {
          openMissMessageBox(targetId, { mode: 'reason' });
          closeMissPieMenu({ keepActive: true });
          return;
        }
        const rect = target.getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;
        openMissPieMenu(targetId, cx, cy);
      });
      function setDrawMode(next) {
        const enabled = !!next && mode === 'single';
        drawMode = enabled;
        if (drawMode && activeDrawKey && !drawDoc) {
          drawDoc = ensureDrawDoc(activeDrawKey);
          updateDrawControls();
        }
        drawingStroke = false;
        if (drawCanvas) {
          drawCanvas.classList.toggle('active', drawMode);
          drawCanvas.classList.toggle('drawing', false);
        }
        if (stage) stage.classList.toggle('draw-mode', drawMode);
        if (drawToggleBtn) {
          drawToggleBtn.classList.toggle('active', drawMode);
          drawToggleBtn.setAttribute('aria-pressed', drawMode ? 'true' : 'false');
          drawToggleBtn.setAttribute('title', drawMode ? 'ドローモードON' : 'ドローモードOFF');
        }
        if (drawToolbar) {
          drawToolbar.classList.toggle('hidden', !drawMode);
        }
        if (!drawMode) {
          drawSettingsPanel?.classList.remove('open');
          drawPointers.clear();
          drawGestureActive = false;
          drawingStroke = false;
          rDrawActive = false;
          straightAnchor = null;
          ctrlOverrideTool = null;
          hideSizePreview();
          hideSelectionBox();
          hideStampPreview();
          stampPlacementActive = false;
          closeTextOverlay();
          selectionDrawing = false;
          selectionPath = [];
          selectionRectMode = false;
          drawSelectionPath(true);
        }
        if (drawMode) {
          selecting = false;
          syncSelectingUI();
          syncDrawCanvasSize();
        } else {
          drawPointers.clear();
          drawGestureActive = false;
          drawingStroke = false;
        }
      }
      const toggleDrawMode = () => {
        if (mode !== 'single') {
          showToast && showToast('ドローは単ページ表示で使用できます', 'error');
          return;
        }
        setDrawMode(!drawMode);
        showToast && showToast(drawMode ? 'ドローモードON' : 'ドローモードOFF');
      };
      const pieMenu = document.getElementById('pieMenu');
      const pieShell = document.getElementById('pieTimerShell');
      const pieDial = document.getElementById('pieDial');
      const pieDialRing = document.getElementById('pieDialRing');
      const pieDialTicks = document.getElementById('pieDialTicks');
      const pieModeLabel = document.getElementById('pieModeLabel');
      const pieTimeValue = document.getElementById('pieTimeValue');
      const pieTimeSub = document.getElementById('pieTimeSub');
      const piePrimary = document.getElementById('piePrimary');
      const pieClose = document.getElementById('pieClose');
      const pieActions = document.getElementById('pieActions');
      const pieHint = document.getElementById('pieHint');

      const PIE_MIN = 1;
      const PIE_MAX = 180;
      const PIE_STEP = 1;
      const PIE_STORE_KEY = 'pie-timer-minutes';
      let pieOpen = false;
      let pieMode = 'set';
      let pieMinutes = 25;
      let pieActiveTimerId = null;

      let dialRotation = 0;
      let dialTarget = 0;
      let dialVelocity = 0;
      let dialAnim = null;
      let dialDragging = false;
      let dialDragAngle = 0;
      let dialDragCarry = 0;
      let dialPointerId = null;
      let pieRunTick = null;

      let keyHoldTimer = null;
      let keySpinTimer = null;
      let keySpinDir = 0;
      const pieAllowOutsideInteraction = true;

      const pad2 = (n) => String(n).padStart(2, '0');
      const isLockedPieTimer = (t) => !!(t && (t.locked || t.source === 'lesson'));
      const notifyLockedPieTimer = () => {
        try { if (typeof showToast === 'function') showToast('授業タイマーは操作できません', 'info'); } catch (_) { }
      };
      const splitTimerRemain = (remainSec) => {
        const raw = Number(remainSec || 0);
        const isNeg = raw < 0;
        const abs = Math.abs(raw);
        const rounded = isNeg ? Math.floor(abs) : Math.ceil(abs);
        const mm = Math.floor(rounded / 60);
        const ss = rounded % 60;
        const sign = (isNeg && rounded > 0) ? '-' : '';
        return { sign, mm, ss, rounded, isNeg };
      };

      const loadPieMinutes = () => {
        try {
          const raw = parseInt(localStorage.getItem(PIE_STORE_KEY) || '', 10);
          if (!Number.isNaN(raw)) pieMinutes = clamp(raw, PIE_MIN, PIE_MAX);
        } catch (e) { }
      };
      const savePieMinutes = () => {
        try { localStorage.setItem(PIE_STORE_KEY, String(pieMinutes)); } catch (e) { }
      };
      loadPieMinutes();

      const buildDialTicks = () => {
        if (!pieDialTicks || pieDialTicks.childElementCount) return;
        for (let i = 0; i < 60; i += 5) {
          const mark = document.createElement('div');
          mark.className = 'pie-dial-mark';
          mark.style.setProperty('--angle', `${i * 6}deg`);
          mark.textContent = String(i).padStart(2, '0');
          pieDialTicks.appendChild(mark);
        }
      };

      const applyDialRotation = () => {
        if (pieDialTicks) pieDialTicks.style.setProperty('--dial-rot', `${dialRotation}deg`);
      };

      const animateDial = () => {
        const diff = dialTarget - dialRotation;
        dialVelocity = (dialVelocity + diff * 0.12) * 0.78;
        dialRotation += dialVelocity;
        applyDialRotation();
        if (Math.abs(diff) > 0.2 || Math.abs(dialVelocity) > 0.2) {
          dialAnim = requestAnimationFrame(animateDial);
        } else {
          dialRotation = dialTarget;
          dialVelocity = 0;
          applyDialRotation();
          dialAnim = null;
        }
      };

      const setDialTarget = (next, animate = true) => {
        dialTarget = next;
        if (!animate) {
          dialRotation = next;
          dialVelocity = 0;
          applyDialRotation();
          return;
        }
        if (!dialAnim) dialAnim = requestAnimationFrame(animateDial);
      };

      const updateDialDisplay = ({ animate = true } = {}) => {
        const totalSec = Math.max(0, Math.floor(pieMinutes * 60));
        const mm = Math.floor(totalSec / 60);
        const ss = totalSec % 60;
        if (pieTimeValue) pieTimeValue.textContent = `${pad2(mm)}:${pad2(ss)}`;
        if (pieTimeSub) pieTimeSub.textContent = `${pieMinutes}分`;
        if (pieDialRing) {
          const progress = (pieMinutes / PIE_MAX) * 360;
          pieDialRing.style.setProperty('--pie-progress', `${progress}deg`);
        }
        setDialTarget(-pieMinutes * 6, animate);
      };

      const setPieMinutes = (next, { animate = true, save = true } = {}) => {
        const clamped = clamp(Math.round(next), PIE_MIN, PIE_MAX);
        if (clamped === pieMinutes && animate) return;
        pieMinutes = clamped;
        updateDialDisplay({ animate });
        if (save) savePieMinutes();
      };

      const getPieAccent = () => {
        if (!pieShell) return '#38bdf8';
        const val = getComputedStyle(pieShell).getPropertyValue('--pie-accent') || '#38bdf8';
        return val.trim() || '#38bdf8';
      };

      const createTimerFromPie = () => {
        if (!window.timers) window.timers = [];
        if (typeof window.timerId !== 'number') window.timerId = window.timers.length ? window.timers.length : 0;
        const now = (window.__getNow ? window.__getNow() : new Date());
        const color = getPieAccent();
        const timer = {
          id: window.timerId++,
          total: pieMinutes * 60,
          remain: pieMinutes * 60,
          running: false,
          start: 0,
          alerted: false,
          overtime: false,
          startMin: now.getMinutes(),
          minutes: pieMinutes,
          gaugeColor: color,
          clockMode: 'outer',
          __hasStarted: false
        };
        if (typeof window.__resetTimerSoundFlags === 'function') {
          window.__resetTimerSoundFlags(timer);
        } else {
          timer._soundFlags = { half: false, last60: false, last10: false, last01: false, complete: false };
        }
        window.timers.push(timer);
        if (typeof renderTimers === 'function') renderTimers();
        return { timer, index: window.timers.length - 1 };
      };

      const resolveActiveTimer = () => {
        const timers = window.timers || [];
        if (!timers.length) return { timer: null, index: -1 };
        if (pieActiveTimerId != null) {
          const idx = timers.findIndex(t => t.id === pieActiveTimerId);
          if (idx >= 0) return { timer: timers[idx], index: idx };
        }
        let candidate = -1;
        let bestRem = Infinity;
        timers.forEach((t, i) => {
          if (t.running) {
            const rem = Math.abs(t.remain || 0);
            if (rem < bestRem) { bestRem = rem; candidate = i; }
          }
        });
        if (candidate === -1) candidate = timers.length - 1;
        pieActiveTimerId = timers[candidate]?.id ?? null;
        return { timer: timers[candidate], index: candidate };
      };
      const hasTimers = () => Array.isArray(window.timers) && window.timers.length > 0;

      const updatePieRunView = () => {
        if (document.hidden) return;
        if (!pieShell || pieMode !== 'run') return;
        const { timer, index } = resolveActiveTimer();
        if (!timer) {
          setPieMode('set');
          return;
        }
        const remainRaw = Number(timer.remain || 0);
        const { sign, mm, ss, rounded, isNeg } = splitTimerRemain(remainRaw);
        if (pieTimeValue) pieTimeValue.textContent = `${sign}${pad2(mm)}:${pad2(ss)}`;
        if (pieTimeSub) {
          if (isNeg && rounded > 0) {
            pieTimeSub.textContent = `経過 ${pad2(mm)}:${pad2(ss)}`;
          } else {
            const end = new Date(Date.now() + Math.max(0, remainRaw) * 1000);
            pieTimeSub.textContent = `終了 ${pad2(end.getHours())}:${pad2(end.getMinutes())}`;
          }
        }
        if (pieDialRing) {
          const ratio = timer.total > 0 ? Math.max(0, Math.min(1, timer.remain / timer.total)) : 0;
          pieDialRing.style.setProperty('--pie-progress', `${ratio * 360}deg`);
        }
        pieShell.classList.toggle('warn', timer.remain > 0 && timer.remain <= 60);
        pieShell.classList.toggle('danger', timer.remain <= 0);
        pieShell.classList.toggle('overrun', timer.remain < 0);
        if (piePrimary) {
          const locked = isLockedPieTimer(timer);
          piePrimary.textContent = locked ? '授業中' : (timer.running ? '一時停止' : '再開');
          piePrimary.disabled = locked;
        }
        updatePieActionLabels();
      };

      const startPieRunTicker = () => {
        if (pieRunTick) return;
        pieRunTick = setInterval(() => {
          if (pieOpen && pieMode === 'run') updatePieRunView();
        }, 1000);
      };

      const stopPieRunTicker = () => {
        if (pieRunTick) { clearInterval(pieRunTick); pieRunTick = null; }
      };

      const setPieMode = (next) => {
        pieMode = next;
        if (!pieShell) return;
        pieShell.classList.toggle('mode-run', next === 'run');
        if (pieHint) pieHint.classList.toggle('hidden', next === 'run');
        if (next === 'set') {
          pieShell.classList.remove('warn', 'danger', 'overrun');
          if (pieModeLabel) pieModeLabel.textContent = 'TIMER SET';
          if (piePrimary) { piePrimary.textContent = '開始'; piePrimary.disabled = false; }
          updateDialDisplay({ animate: true });
          renderPieActions();
          stopPieRunTicker();
        } else {
          if (pieModeLabel) pieModeLabel.textContent = 'TIMER';
          renderPieActions();
          updatePieRunView();
          startPieRunTicker();
        }
      };

      window.__isPieMenuOpen = () => !!pieOpen;
      window.__setPieTimerTarget = (timerId) => {
        if (timerId == null) return false;
        const normalized = (typeof timerId === 'string' && timerId.trim() !== '')
          ? (Number.isFinite(parseInt(timerId, 10)) ? parseInt(timerId, 10) : timerId)
          : timerId;
        pieActiveTimerId = normalized;
        if (pieOpen) {
          setPieMode('run');
          updatePieRunView();
        }
        return true;
      };

      const pieActionDefs = {
        set: [
          { id: 'm5', label: '-5分', run: () => setPieMinutes(pieMinutes - 5) },
          { id: 'p5', label: '+5分', run: () => setPieMinutes(pieMinutes + 5) },
          { id: '5', label: '5分', run: () => setPieMinutes(5) },
          { id: '10', label: '10分', run: () => setPieMinutes(10) },
          { id: '25', label: '25分', run: () => setPieMinutes(25), cls: 'primary' },
          { id: '45', label: '45分', run: () => setPieMinutes(45) },
          { id: '60', label: '60分', run: () => setPieMinutes(60) },
          {
            id: 'live',
            label: '残り',
            run: () => {
              const active = resolveActiveTimer();
              if (!active.timer) {
                if (typeof showToast === 'function') showToast('進行中のタイマーがありません', 'error');
                return;
              }
              pieActiveTimerId = active.timer.id;
              setPieMode('run');
            }
          }
        ],
        run: [
          {
            id: 'toggle',
            label: () => {
              const { timer } = resolveActiveTimer();
              if (timer && isLockedPieTimer(timer)) return '授業中';
              return timer && timer.running ? '一時停止' : '再開';
            },
            cls: 'primary',
            run: () => {
              const { timer, index } = resolveActiveTimer();
              if (!timer || index < 0) return;
              if (isLockedPieTimer(timer)) { notifyLockedPieTimer(); return; }
              if (timer.running) { if (typeof pauseTimer === 'function') pauseTimer(index); }
              else { if (typeof startTimer === 'function') startTimer(index); }
              updatePieRunView();
            }
          },
          {
            id: 'add1',
            label: '+1分',
            run: () => {
              const { timer } = resolveActiveTimer();
              if (isLockedPieTimer(timer)) { notifyLockedPieTimer(); return; }
              adjustActiveTimer(1);
            }
          },
          {
            id: 'add5',
            label: '+5分',
            run: () => {
              const { timer } = resolveActiveTimer();
              if (isLockedPieTimer(timer)) { notifyLockedPieTimer(); return; }
              adjustActiveTimer(5);
            }
          },
          {
            id: 'sub1',
            label: '-1分',
            run: () => {
              const { timer } = resolveActiveTimer();
              if (isLockedPieTimer(timer)) { notifyLockedPieTimer(); return; }
              adjustActiveTimer(-1);
            }
          },
          {
            id: 'reset',
            label: 'リセット',
            run: () => {
              const { timer, index } = resolveActiveTimer();
              if (isLockedPieTimer(timer)) { notifyLockedPieTimer(); return; }
              if (index < 0) return;
              if (typeof resetTimer === 'function') resetTimer(index);
              updatePieRunView();
            }
          },
          {
            id: 'delete',
            label: '削除',
            cls: 'danger',
            run: () => {
              const { timer, index } = resolveActiveTimer();
              if (!timer || index < 0) return;
              if (isLockedPieTimer(timer)) { notifyLockedPieTimer(); return; }
              window.timers.splice(index, 1);
              pieActiveTimerId = null;
              if (typeof renderTimers === 'function') renderTimers();
              if (typeof drawTimerArcs === 'function') drawTimerArcs();
              if (typeof nlRenderTimerOverlays === 'function') nlRenderTimerOverlays();
              try { if (typeof refreshPlannerFlyClock === 'function') refreshPlannerFlyClock(true); } catch (_) { }
              if (hasTimers()) {
                resolveActiveTimer();
                updatePieRunView();
              } else {
                setPieMode('set');
              }
            }
          },
          {
            id: 'stop',
            label: '停止',
            cls: 'danger',
            run: () => {
              const { timer, index } = resolveActiveTimer();
              if (!timer || index < 0) return;
              if (isLockedPieTimer(timer)) { notifyLockedPieTimer(); return; }
              timer.running = false;
              timer.remain = 0;
              timer.overtime = false;
              timer.alerted = true;
              if (typeof updateTimer === 'function') updateTimer(index);
              if (typeof renderTimers === 'function') renderTimers();
              if (typeof drawTimerArcs === 'function') drawTimerArcs();
              if (typeof nlRenderTimerOverlays === 'function') nlRenderTimerOverlays();
              try { if (typeof refreshPlannerFlyClock === 'function') refreshPlannerFlyClock(true); } catch (_) { }
              updatePieRunView();
            }
          },
          {
            id: 'new',
            label: '新規',
            run: () => {
              setPieMode('set');
            }
          },
          {
            id: 'planner',
            label: 'プランナー',
            run: () => {
              try {
                if (typeof showTab === 'function') showTab('planner', { preserveOpenTab: true });
                if (typeof __activatePlannerTab === 'function') __activatePlannerTab('timer');
              } catch (_) { }
              hidePieMenu();
            }
          }
        ]
      };

      const pieActionButtons = new Map();

      const renderPieActions = () => {
        if (!pieActions) return;
        pieActions.innerHTML = '';
        pieActionButtons.clear();
        const actions = pieActionDefs[pieMode] || [];
        const lockedActive = pieMode === 'run' && isLockedPieTimer(resolveActiveTimer().timer);
        const lockedIds = new Set(['toggle', 'add1', 'add5', 'sub1', 'reset', 'delete', 'stop']);
        const rect = pieShell?.getBoundingClientRect();
        const radius = (rect?.width || 360) * 0.39;
        const baseAngle = -90;
        const count = actions.length || 1;
        actions.forEach((act, idx) => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'pie-action';
          if (act.cls) btn.classList.add(act.cls);
          const label = typeof act.label === 'function' ? act.label() : act.label;
          btn.textContent = label;
          if (lockedActive && lockedIds.has(act.id)) {
            btn.disabled = true;
            btn.classList.add('disabled');
          }
          const angle = baseAngle + (idx / count) * 360;
          const rad = angle * Math.PI / 180;
          const x = Math.cos(rad) * radius;
          const y = Math.sin(rad) * radius;
          btn.style.setProperty('--act-x', `${x}px`);
          btn.style.setProperty('--act-y', `${y}px`);
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            act.run && act.run();
          });
          pieActions.appendChild(btn);
          pieActionButtons.set(act.id, { btn, act });
        });
      };

      const updatePieActionLabels = () => {
        pieActionButtons.forEach(({ btn, act }) => {
          if (!btn) return;
          const label = typeof act.label === 'function' ? act.label() : act.label;
          if (label != null) btn.textContent = label;
        });
      };

      const adjustActiveTimer = (deltaMin) => {
        const { timer, index } = resolveActiveTimer();
        if (!timer || index < 0) return;
        if (isLockedPieTimer(timer)) { notifyLockedPieTimer(); return; }
        const deltaSec = deltaMin * 60;
        const nextTotal = Math.max(60, timer.total + deltaSec);
        const diff = nextTotal - timer.total;
        timer.total = nextTotal;
        timer.minutes = Math.max(1, Math.round(timer.total / 60));
        const nowSec = (window.__timerNowSec ? window.__timerNowSec() : Math.floor(Date.now() / 1000));
        if (!timer.running) {
          timer.remain = Math.min(timer.total, timer.remain + diff);
        } else {
          if (!Number.isFinite(timer._endSec)) {
            const roundRemain = window.__timerRoundRemainSec
              ? window.__timerRoundRemainSec(timer.remain)
              : (timer.remain >= 0 ? Math.ceil(timer.remain) : -Math.floor(Math.abs(timer.remain)));
            timer._endSec = nowSec + roundRemain;
          }
          timer._endSec += diff;
          timer.remain = timer._endSec - nowSec;
        }
        if (timer.remain > 0) {
          timer.alerted = false;
          timer.overtime = false;
          if (typeof window.__resetTimerSoundFlags === 'function') window.__resetTimerSoundFlags(timer);
        } else {
          timer.overtime = true;
        }
        if (typeof updateTimer === 'function') updateTimer(index);
        if (typeof renderTimers === 'function') renderTimers();
        if (typeof drawTimerArcs === 'function') drawTimerArcs();
        if (typeof nlRenderTimerOverlays === 'function') nlRenderTimerOverlays();
        try { if (typeof refreshPlannerFlyClock === 'function') refreshPlannerFlyClock(true); } catch (_) { }
        updatePieRunView();
      };

      const positionPieMenu = (clientX, clientY) => {
        if (!pieMenu) return;
        const host = stageHost || stage;
        if (!host) return;
        const rect = host.getBoundingClientRect();
        const cssSize = parseFloat(getComputedStyle(pieMenu).getPropertyValue('--pie-size')) || 360;
        const pad = cssSize / 2 + 18;
        const x = clamp(clientX - rect.left, pad, Math.max(pad, rect.width - pad));
        const y = clamp(clientY - rect.top, pad, Math.max(pad, rect.height - pad));
        pieMenu.style.setProperty('--pie-x', `${x}px`);
        pieMenu.style.setProperty('--pie-y', `${y}px`);
      };

      const showPieMenu = (clientX, clientY) => {
        if (!pieMenu) return;
        buildDialTicks();
        positionPieMenu(clientX, clientY);
        pieMenu.classList.remove('hidden');
        pieMenu.classList.add('active');
        pieOpen = true;
        if (hasTimers()) {
          resolveActiveTimer();
          setPieMode('run');
        } else {
          setPieMode('set');
        }
      };

      const hidePieMenu = () => {
        pieOpen = false;
        pieMenu?.classList.add('hidden');
        pieMenu?.classList.remove('active');
        stopPieRunTicker();
        if (keyHoldTimer) { clearTimeout(keyHoldTimer); keyHoldTimer = null; }
        if (keySpinTimer) { clearInterval(keySpinTimer); keySpinTimer = null; }
        keySpinDir = 0;
      };

      const angleFromEvent = (e) => {
        const rect = pieDial.getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;
        const dx = e.clientX - cx;
        const dy = e.clientY - cy;
        let deg = Math.atan2(dy, dx) * 180 / Math.PI + 90;
        if (deg < 0) deg += 360;
        return deg;
      };

      const onDialPointerDown = (e) => {
        if (pieMode !== 'set' || !pieDial) return;
        if (e.button !== 0) return;
        if (e.target && e.target.closest && e.target.closest('button')) return;
        if (e.cancelable) e.preventDefault();
        dialPointerId = e.pointerId ?? null;
        if (dialPointerId != null) pieDial.setPointerCapture?.(dialPointerId);
        dialDragging = true;
        dialDragAngle = angleFromEvent(e);
        dialDragCarry = 0;
      };

      const onDialPointerMove = (e) => {
        if (!dialDragging || pieMode !== 'set') return;
        if (e.cancelable) e.preventDefault();
        const angle = angleFromEvent(e);
        let delta = angle - dialDragAngle;
        if (delta > 180) delta -= 360;
        if (delta < -180) delta += 360;
        dialDragAngle = angle;
        dialDragCarry += delta;
        const step = dialDragCarry >= 0 ? Math.floor(dialDragCarry / 6) : Math.ceil(dialDragCarry / 6);
        if (step) {
          dialDragCarry -= step * 6;
          setPieMinutes(pieMinutes + step, { animate: true, save: false });
        }
      };

      const onDialPointerUp = () => {
        if (!dialDragging) return;
        dialDragging = false;
        dialDragCarry = 0;
        if (dialPointerId != null) {
          pieDial?.releasePointerCapture?.(dialPointerId);
          dialPointerId = null;
        }
        savePieMinutes();
      };

      const startKeySpin = (dir) => {
        if (keySpinTimer) return;
        let speed = 1;
        keySpinTimer = setInterval(() => {
          speed = Math.min(speed + 0.25, 6);
          const step = speed < 2 ? 1 : speed < 4 ? 2 : 3;
          setPieMinutes(pieMinutes + dir * step, { animate: true });
        }, 60);
      };

      const stopKeySpin = () => {
        if (keySpinTimer) { clearInterval(keySpinTimer); keySpinTimer = null; }
        if (keyHoldTimer) { clearTimeout(keyHoldTimer); keyHoldTimer = null; }
        keySpinDir = 0;
      };

      const handleKeyDown = (e) => {
        if (!pieOpen) return;
        const stopKey = () => {
          e.preventDefault();
          e.stopImmediatePropagation();
          e.stopPropagation();
        };
        if (e.key === 'Escape') {
          stopKey();
          hidePieMenu();
          return;
        }
        if (e.key === 'Enter' && pieMode === 'set') {
          stopKey();
          runPiePrimary();
          return;
        }
        if (!['ArrowUp', 'ArrowRight', 'ArrowDown', 'ArrowLeft'].includes(e.key)) return;
        stopKey();
        if (pieMode !== 'set') return;
        const dir = (e.key === 'ArrowUp' || e.key === 'ArrowRight') ? 1 : -1;
        if (!e.repeat) setPieMinutes(pieMinutes + dir * PIE_STEP, { animate: true });
        if (keySpinDir !== dir) stopKeySpin();
        keySpinDir = dir;
        if (!keyHoldTimer) {
          keyHoldTimer = setTimeout(() => startKeySpin(dir), 220);
        }
      };

      const handleKeyUp = (e) => {
        if (!pieOpen) return;
        if (!['ArrowUp', 'ArrowRight', 'ArrowDown', 'ArrowLeft', 'Enter'].includes(e.key)) return;
        e.preventDefault();
        e.stopImmediatePropagation();
        e.stopPropagation();
        stopKeySpin();
      };

      const runPiePrimary = () => {
        if (pieMode === 'set') {
          const res = createTimerFromPie();
          if (!res) return;
          if (typeof startTimer === 'function') startTimer(res.index);
          pieActiveTimerId = res.timer.id;
          if (typeof window.__requestTimerVizUpdate === 'function') window.__requestTimerVizUpdate(true);
          setPieMode('run');
          updatePieRunView();
          return;
        }
        const { timer, index } = resolveActiveTimer();
        if (!timer || index < 0) return;
        if (isLockedPieTimer(timer)) { notifyLockedPieTimer(); return; }
        if (timer.running) { if (typeof pauseTimer === 'function') pauseTimer(index); }
        else { if (typeof startTimer === 'function') startTimer(index); }
        if (typeof window.__requestTimerVizUpdate === 'function') window.__requestTimerVizUpdate(true);
        updatePieRunView();
      };

      if (piePrimary) {
        piePrimary.addEventListener('click', (e) => {
          e.stopPropagation();
          runPiePrimary();
        });
      }
      if (pieClose) {
        pieClose.addEventListener('click', (e) => {
          e.stopPropagation();
          hidePieMenu();
        });
      }

      if (pieDial) pieDial.addEventListener('pointerdown', onDialPointerDown);
      window.addEventListener('pointermove', onDialPointerMove);
      window.addEventListener('pointerup', onDialPointerUp);
      window.addEventListener('pointercancel', onDialPointerUp);

      document.addEventListener('keydown', handleKeyDown, true);
      document.addEventListener('keyup', handleKeyUp, true);

      const pieContextTarget = stageHost || stage;
      if (pieContextTarget && pieMenu) {
        pieContextTarget.addEventListener('contextmenu', (e) => {
          if (!pieContextTarget.contains(e.target)) return;
          e.preventDefault();
          if (pieOpen) {
            hidePieMenu();
            return;
          }
          showPieMenu(e.clientX, e.clientY);
        });
      }
      document.addEventListener('pointerdown', (e) => {
        if (!pieOpen || pieAllowOutsideInteraction) return;
        if (!pieMenu || pieMenu.contains(e.target)) return;
        hidePieMenu();
      }, { capture: true });
      document.addEventListener('wheel', () => { if (pieOpen && !pieAllowOutsideInteraction) hidePieMenu(); }, { passive: true });
      window.addEventListener('blur', hidePieMenu);
      let clampSkipOnce = false;
      let suppressSmoothNextReset = false; // disable smooth resets for page turns
      function resetViewState(opts = {}) {
        const smooth = (opts.smooth !== false) && !suppressSmoothNextReset; // 通常はスムーズに、必要な場面のみ明示的にオフ
        const singlePass = opts.singlePass === true;
        if (suppressSmoothNextReset) suppressSmoothNextReset = false;
        if (panAnimId) { cancelAnimationFrame(panAnimId); panAnimId = null; panVel = { x: 0, y: 0 }; panLastTs = 0; }
        if (zoomAnimId) { cancelAnimationFrame(zoomAnimId); zoomAnimId = null; zoomVel = 0; zoomLastTs = 0; }
        const scrollTarget = (() => {
          const root = document.scrollingElement || document.documentElement || document.body;
          if (sliceMode) return root;
          if (stageHost && (stageHost.scrollHeight - stageHost.clientHeight > 2)) return stageHost;
          return root || stageHost;
        })();
        const preserveScroll = opts.zoomOnly === true && !!scrollTarget;
        const savedScroll = preserveScroll ? { target: scrollTarget, top: scrollTarget.scrollTop, left: scrollTarget.scrollLeft } : null;
        const applyResetCore = (recalcBounds = false) => {
          if (recalcBounds) {
            markViewMetricsDirty();
            refreshZoomBounds();
          }
          const preferFitHeight = (mode === 'single') && !sliceMode;
          const baseZoom = preferFitHeight ? viewState.minZoom : 1;
          const targetZoom = Math.max(viewState.minZoom, baseZoom);
          const keepPan = opts.zoomOnly === true;
          if (keepPan) {
            const anchor = stageAnchorCenter();
            clampSkipOnce = true;
            setZoom(targetZoom, { anchor, silent: true, skipClamp: true });
            clampSkipOnce = false;
            return;
          }
          viewState.zoom = targetZoom;
          viewState.translateX = 0;
          viewState.translateY = 0;
          applyViewTransform();
        };
        markViewMetricsDirty();
        refreshZoomBounds();
        stopInertia();
        if (!opts.keepAdjusted) viewState.userAdjusted = false;
        const doApply = () => applyResetCore(false);
        if (!singlePass) {
          if (smooth && img) {
            const target = pageLayer || img;
            const prev = target.style.transition;
            const trans = 'transform 260ms cubic-bezier(0.22,0.61,0.36,1)';
            target.style.transition = trans;
            doApply();
            setTimeout(() => {
              if (target.style.transition === trans) target.style.transition = prev || '';
            }, 320);
          } else {
            doApply();
          }
          requestAnimationFrame(() => applyResetCore(true));
        } else {
          applyResetCore(true);
        }
        if (preserveScroll && savedScroll?.target) {
          savedScroll.target.scrollTop = savedScroll.top;
          savedScroll.target.scrollLeft = savedScroll.left;
          requestAnimationFrame(() => {
            savedScroll.target.scrollTop = savedScroll.top;
            savedScroll.target.scrollLeft = savedScroll.left;
          });
        }
        if (opts.toast) { showToast('ビューをリセットしました', 'ok'); }
        hideInteractionHint();
      }
      function triggerResetFlash(el) {
        if (!el) return;
        el.classList.remove('reset-anim');
        void el.offsetWidth;
        el.classList.add('reset-anim');
        setTimeout(() => el.classList.remove('reset-anim'), 650);
      }
      function setZoom(next, { anchor = null, silent = false, skipClamp = false } = {}) {
        refreshZoomBounds();
        const prev = viewState.zoom || 1;
        const maxZoom = Math.max(viewState.maxZoom, viewState.minZoom);
        const target = Math.max(viewState.minZoom, Math.min(maxZoom, next));
        const pivot = anchor || { x: 0, y: 0 };
        if (prev !== target) {
          const ratio = target / prev;
          viewState.translateX = pivot.x - ratio * (pivot.x - viewState.translateX);
          viewState.translateY = pivot.y - ratio * (pivot.y - viewState.translateY);
        }
        viewState.zoom = target;
        if (!silent) viewState.userAdjusted = true;
        const allowSkip = skipClamp && !keyNavConfig.bookClamp;
        if (allowSkip) clampSkipOnce = true;
        applyViewTransform();
        clampSkipOnce = false;
        hideInteractionHint();
      }
      function hideInteractionHint() {
        if (!interactionHint) return;
        interactionHint.classList.add('hidden');
        if (hintTimer) { clearTimeout(hintTimer); hintTimer = null; }
      }
      function showInteractionHint() {
        if (!interactionHint) return;
        interactionHint.classList.remove('hidden');
        if (hintTimer) { clearTimeout(hintTimer); }
        hintTimer = setTimeout(() => interactionHint.classList.add('hidden'), 3500);
      }
      function updateHintText() {
        if (!interactionHint) return;
        let text = '';
        if (zoomLocked && panLocked) {
          text = 'ズーム＆移動ロック中';
        } else if (zoomLocked) {
          text = 'ズーム固定: ホイール＝上下移動 / ドラッグ＝移動';
        } else if (panLocked) {
          text = '移動ロック: ホイール＝ズーム / ドラッグ不可';
        } else {
          text = 'ホイール＝ズーム / ドラッグ＝移動 / ダブルクリック＝リセット';
        }
        interactionHint.textContent = text;
      }
      const paneControllers = [];
      let activePane = 'single'; // 'single' | 'left' | 'right'
      const setActivePane = (key) => { activePane = key; };
      function createPaneZoomer(paneEl, imgEl, surfaceKey) {
        const surfaceRef = () => selectionSurfaces[surfaceKey];
        if (!paneEl || !imgEl) return { reset: () => { }, destroy: () => { }, cancelInteractions: () => { }, panBy: () => { }, setZoomValue: () => { }, getState: () => ({ zoom: 1, minZoom: 0.4, maxZoom: 6, translateX: 0, translateY: 0 }), nav: {} };
        const state = { zoom: 1, minZoom: 0.4, maxZoom: 6, translateX: 0, translateY: 0 };
        const nav = { panVel: { x: 0, y: 0 }, panAnimId: null, panLastTs: 0, zoomVel: 0, zoomAnimId: null, zoomLastTs: 0 };
        const enforceClamp = () => {
          const rect = paneEl.getBoundingClientRect?.();
          const baseW = imgEl?.clientWidth || imgEl?.naturalWidth || 0;
          const baseH = imgEl?.clientHeight || imgEl?.naturalHeight || 0;
          const layoutOffset = computeLayoutOffset(paneEl, imgEl);
          const offsetX = layoutOffset.x || 0;
          const offsetY = layoutOffset.y || 0;
          if (!rect || !baseW || !baseH) return;
          const fitWidth = rect.width / (baseW || 1);
          const fitHeight = rect.height / (baseH || 1);
          const preferWidthFit = mode === 'compare';
          const fitZoom = preferWidthFit ? fitWidth : Math.max(fitWidth, fitHeight);
          state.minZoom = Math.max(0.4, fitZoom);
          state.maxZoom = Math.max(state.maxZoom, state.minZoom);
          state.zoom = Math.max(state.minZoom, Math.min(state.maxZoom, state.zoom));
          const scaledW = baseW * state.zoom;
          const scaledH = baseH * state.zoom;
          const margin = 10;
          const maxX = Math.max(margin, ((scaledW - rect.width) / 2) + margin);
          const maxY = Math.max(margin, ((scaledH - rect.height) / 2) + margin);
          state.translateX = clamp(state.translateX, -maxX - offsetX, maxX - offsetX);
          state.translateY = clamp(state.translateY, -maxY - offsetY, maxY - offsetY);
        };
        const apply = () => {
          enforceClamp();
          imgEl.style.transformOrigin = 'center center';
          imgEl.style.transform = `translate(${state.translateX}px,${state.translateY}px) scale(${state.zoom})`;
          requestPoseSave();
        };
        const reset = ({ toast = false, zoomOnly = false } = {}) => {
          const baseZoom = (mode === 'compare') ? state.minZoom : Math.max(state.minZoom, 1);
          state.zoom = baseZoom;
          if (!zoomOnly) {
            state.translateX = 0;
            state.translateY = 0;
          }
          apply();
          nav.panVel = { x: 0, y: 0 };
          nav.zoomVel = 0;
          nav.panLastTs = 0; nav.zoomLastTs = 0;
          if (nav.panAnimId) { cancelAnimationFrame(nav.panAnimId); nav.panAnimId = null; }
          if (nav.zoomAnimId) { cancelAnimationFrame(nav.zoomAnimId); nav.zoomAnimId = null; }
          if (toast) showToast('ビューをリセットしました', 'ok');
        };
        const onImgLoad = () => reset();
        imgEl.addEventListener('load', onImgLoad);
        const setZoomValue = (value, { anchor = null } = {}) => {
          const prev = state.zoom;
          enforceClamp();
          const target = Math.max(state.minZoom, Math.min(state.maxZoom, value));
          const pivot = anchor || { x: 0, y: 0 };
          if (prev !== target) {
            state.translateX = pivot.x - (target / prev) * (pivot.x - state.translateX);
            state.translateY = pivot.y - (target / prev) * (pivot.y - state.translateY);
          }
          state.zoom = target;
          apply();
        };
        const applyPanDelta = (dx, dy) => {
          setActivePane(surfaceKey);
          state.translateX += dx;
          state.translateY += dy;
          apply();
        };
        const isPaneVisible = () => {
          if (stageDual && stageDual.classList.contains('hidden')) return false;
          return !paneEl.classList.contains('hidden-content');
        };
        const shouldIgnoreTarget = (target) => {
          return target.closest('.pane-controls') || target.closest('.pane-arrows') || target.closest('.mini-menu');
        };
        const controller = createPanZoomSurface({
          element: paneEl,
          anchorFromClient: (x, y) => anchorFromElement(paneEl, x, y),
          getEnabled: () => isPaneVisible(),
          getZoom: () => state.zoom,
          setZoom: (next, opts) => setZoomValue(next, opts),
          getZoomLocked: () => zoomLocked,
          getPanLocked: () => panLocked || (selecting && !selectionPanOverride),
          applyPanDelta: (dx, dy) => applyPanDelta(dx, dy),
          onPanStart: () => paneEl.classList.add('is-panning'),
          onPanEnd: () => paneEl.classList.remove('is-panning'),
          onReset: () => { reset(); triggerResetFlash(paneEl); },
          shouldIgnoreTarget: shouldIgnoreTarget,
          doubleTapResetEnabled: true
        });
        const handleMouseDown = (e) => {
          if (!selecting) return;
          if (shouldIgnoreTarget(e.target)) return;
          setActivePane(surfaceKey);
          selectionPanOverride = false;
          e.preventDefault();
          startDrag(e, surfaceRef());
        };
        const handleTouchStart = (e) => {
          if (!selecting) return;
          if (shouldIgnoreTarget(e.target)) return;
          setActivePane(surfaceKey);
          selectionPanOverride = e.touches.length > 1;
          if (e.touches.length === 1) {
            e.preventDefault();
            startDrag(e, surfaceRef());
          }
        };
        const handleTouchMove = (e) => {
          if (!selecting) return;
          if (selectionPanOverride) return;
          e.preventDefault();
          moveDrag(e);
        };
        const handleTouchEnd = (e) => {
          if (!selecting) return;
          if (selectionPanOverride && e.touches.length > 0) return;
          selectionPanOverride = false;
          e.preventDefault();
          endDrag(e);
        };
        const handleWheel = () => setActivePane(surfaceKey);
        paneEl.addEventListener('mousedown', handleMouseDown);
        paneEl.addEventListener('touchstart', handleTouchStart, { passive: false });
        paneEl.addEventListener('wheel', handleWheel, { passive: true });
        paneEl.addEventListener('touchmove', handleTouchMove, { passive: false });
        paneEl.addEventListener('touchend', handleTouchEnd, { passive: false });
        paneEl.addEventListener('touchcancel', handleTouchEnd, { passive: false });
        const handleDblClick = (e) => {
          e.preventDefault();
          if (zoomLocked) return;
          reset();
        };
        paneEl.addEventListener('dblclick', handleDblClick);
        return {
          reset,
          cancelInteractions: () => controller.cancel?.(),
          panBy: (dx, dy) => applyPanDelta(dx, dy),
          setZoomValue: (z, opts) => setZoomValue(z, opts),
          getState: () => state,
          setPose: (pose) => {
            if (!pose) return;
            if (typeof pose.translateX === 'number') state.translateX = pose.translateX;
            if (typeof pose.translateY === 'number') state.translateY = pose.translateY;
            if (typeof pose.zoom === 'number') state.zoom = Math.max(state.minZoom, Math.min(state.maxZoom, pose.zoom));
            apply();
          },
          getZoom: () => state.zoom,
          getMinZoom: () => state.minZoom,
          getMaxZoom: () => state.maxZoom,
          nav,
          destroy: () => {
            controller.destroy?.();
            if (nav.panAnimId) { cancelAnimationFrame(nav.panAnimId); nav.panAnimId = null; }
            if (nav.zoomAnimId) { cancelAnimationFrame(nav.zoomAnimId); nav.zoomAnimId = null; }
            paneEl.removeEventListener('mousedown', handleMouseDown);
            paneEl.removeEventListener('touchstart', handleTouchStart);
            paneEl.removeEventListener('wheel', handleWheel);
            paneEl.removeEventListener('touchmove', handleTouchMove);
            paneEl.removeEventListener('touchend', handleTouchEnd);
            paneEl.removeEventListener('touchcancel', handleTouchEnd);
            paneEl.removeEventListener('dblclick', handleDblClick);
            imgEl.removeEventListener('load', onImgLoad);
          }
        };
      }

      function realOf(idx) {
        if (Array.isArray(book.pageNumberMap)) {
          const val = book.pageNumberMap[idx];
          if (Number.isFinite(val)) return val;
        }
        return book.firstPageNumber + idx;
      }
      function idxFromReal(real) {
        if (Array.isArray(book.pageNumberMap)) {
          const found = book.pageNumberMap.indexOf(real);
          if (found >= 0) return found;
        }
        return Math.min(Math.max(0, real - book.firstPageNumber), book.pages.length - 1);
      }

      // --- Page progress overlay (Study menu限定) ---
      const PAGE_PROGRESS_SPEED = 0.45; // per second (slower)
      const PAGE_PROGRESS_CHARGE_MS = 1000;
      const clamp01 = (v) => Math.max(0, Math.min(1, v || 0));
      const currentStudyContext = () => {
        if (!window.StudyMgr || !StudyMgr.active) return null;
        const ctx = StudyMgr.currentAndNext(Date.now());
        if (!ctx || ctx.curIdx < 0) return null;
        const ev = ctx.events[ctx.curIdx];
        if (!ev) return null;
        const realPage = realOf(page);
        if (!Number.isFinite(realPage)) return null;
        if (String(ev.bookId || '') !== String(book?.id || '')) return null;
        if (!Number.isFinite(ev.pageNumber) || ev.pageNumber !== realPage) return null;
        return ev;
      };
      const canUsePageProgress = () => {
        if (!isBookViewerContext() || mode !== 'single') return false;
        if (!book?.id || !Number.isFinite(realOf(page))) return false;
        return !!currentStudyContext();
      };
      const currentProgressKey = () => {
        if (!book?.id) return null;
        const realPage = realOf(page);
        if (!Number.isFinite(realPage)) return null;
        return { bookId: book.id, page: realPage };
      };
      const getProgressFor = (bookId, realPage) => {
        const byBook = pageProgressMarks?.[bookId] || {};
        const entry = byBook?.[realPage];
        if (entry && typeof entry === 'object') {
          if (typeof entry.progress === 'number') return { progress: clamp01(entry.progress) };
          // migrate legacy top/bottom
          const migrated = clamp01(entry.top || 0);
          return { progress: migrated };
        }
        return { progress: 0 };
      };
      const setProgressFor = (bookId, realPage, next) => {
        if (!bookId || !Number.isFinite(realPage)) return;
        if (!pageProgressMarks[bookId]) pageProgressMarks[bookId] = {};
        const progress = clamp01(next.progress);
        pageProgressMarks[bookId][realPage] = { progress };
        savePageProgressMarks();
        renderPageProgressOverlay();
      };
      const clearPageProgress = (bookId, realPage) => {
        if (!bookId || !Number.isFinite(realPage)) return;
        if (pageProgressMarks?.[bookId]) {
          delete pageProgressMarks[bookId][realPage];
          if (!Object.keys(pageProgressMarks[bookId]).length) delete pageProgressMarks[bookId];
          savePageProgressMarks();
        }
        pageProgressState.charge = 0;
        renderPageProgressOverlay();
      };
      const pageProgressState = { charge: 0, burstTimer: null };
      const renderPageProgressOverlay = () => {
        if (!pageProgressOverlay || !pageLayer) return;
        const ok = canUsePageProgress();
        if (!ok) {
          pageProgressOverlay.classList.remove('visible');
          pageProgressFill.style.height = '0%';
          pageProgressFill.classList.remove('charging');
          return;
        }
        const key = currentProgressKey();
        if (!key) {
          pageProgressOverlay.classList.remove('visible');
          return;
        }
        const { progress } = getProgressFor(key.bookId, key.page);
        const charge = pageProgressState.charge || 0;
        const mix = (a, b, t) => Math.round(a + (b - a) * t);
        const base = { r: 96, g: 165, b: 250, a: 0.18, border: 0.22, shadow: 0.12 };
        const high = { r: 74, g: 222, b: 128, a: 0.20, border: 0.25, shadow: 0.18 };
        const r = mix(base.r, high.r, charge);
        const g = mix(base.g, high.g, charge);
        const b = mix(base.b, high.b, charge);
        const alpha = base.a + (high.a - base.a) * charge;
        const borderA = base.border + (high.border - base.border) * charge;
        const shadowA = base.shadow + (high.shadow - base.shadow) * charge;
        pageProgressFill.style.background = `rgba(${r}, ${g}, ${b}, ${alpha})`;
        pageProgressFill.style.borderColor = `rgba(${r}, ${g}, ${b}, ${borderA})`;
        pageProgressFill.style.boxShadow = `0 10px 22px rgba(${r}, ${g}, ${b}, ${shadowA})`;
        pageProgressFill.style.height = `${progress * 100}%`;
        pageProgressFill.classList.toggle('charging', charge > 0);
        pageProgressOverlay.classList.toggle('visible', progress > 0.001 || charge > 0);
      };
      let progressHold = { active: false, dir: null, key: null, last: 0, chargeStart: null, raf: null };
      const stopProgressHold = (key) => {
        if (key && progressHold.key && key !== progressHold.key) return;
        if (progressHold.raf) cancelAnimationFrame(progressHold.raf);
        progressHold = { active: false, dir: null, key: null, last: 0, chargeStart: null, raf: null };
        pageProgressState.charge = 0;
        renderPageProgressOverlay();
      };
      const triggerProgressEffect = () => {
        if (!pageProgressEffect) return;
        pageProgressEffect.classList.remove('run');
        // restart animation
        void pageProgressEffect.offsetWidth;
        pageProgressEffect.classList.add('run');
        if (pageProgressState.burstTimer) clearTimeout(pageProgressState.burstTimer);
        pageProgressState.burstTimer = setTimeout(() => pageProgressEffect.classList.remove('run'), 900);
      };
      const completeCurrentProgress = () => {
        const key = currentProgressKey();
        if (!key) return;
        clearPageProgress(key.bookId, key.page);
        if (stDone && !stDone.checked) {
          stDone.checked = true;
          stDone.onchange?.();
        }
        try {
          const ctx = currentStudyContext();
          if (ctx) {
            StudyMgr.completePageNow();
          }
        } catch (_) { }
        triggerProgressEffect();
      };
      const stepProgressHold = (ts) => {
        if (!progressHold.active) return;
        const key = currentProgressKey();
        if (!key || !canUsePageProgress()) { stopProgressHold(); return; }
        if (!progressHold.last) progressHold.last = ts;
        const dt = Math.max(0, Math.min(0.12, (ts - progressHold.last) / 1000));
        progressHold.last = ts;
        const cur = getProgressFor(key.bookId, key.page);
        let progress = cur.progress;
        if (progressHold.dir === 'down') {
          progress = clamp01(progress + dt * PAGE_PROGRESS_SPEED);
          if (progress >= 1) {
            progress = 1;
            if (!progressHold.chargeStart) progressHold.chargeStart = ts;
            const ratio = clamp01((ts - progressHold.chargeStart) / PAGE_PROGRESS_CHARGE_MS);
            pageProgressState.charge = ratio;
            if (ratio >= 1) {
              completeCurrentProgress();
              stopProgressHold();
              return;
            }
          } else {
            progressHold.chargeStart = null;
            pageProgressState.charge = 0;
          }
        } else if (progressHold.dir === 'up') {
          progressHold.chargeStart = null;
          pageProgressState.charge = 0;
          progress = clamp01(progress - dt * PAGE_PROGRESS_SPEED);
        }
        setProgressFor(key.bookId, key.page, { progress });
        renderPageProgressOverlay();
        progressHold.raf = requestAnimationFrame(stepProgressHold);
      };
      const startProgressHold = (dir, keyId) => {
        if (!canUsePageProgress()) return false;
        stopProgressHold();
        progressHold = { active: true, dir, key: keyId || dir, last: 0, chargeStart: null, raf: null };
        progressHold.raf = requestAnimationFrame(stepProgressHold);
        return true;
      };
      window.__pageProgressFillHandler = (direction) => {
        if (direction === 'down' || direction === 'up') return startProgressHold(direction);
        stopProgressHold();
        return false;
      };
      window.__pageProgressOverlayRender = renderPageProgressOverlay;
      window.__clearPageProgress = clearPageProgress;


      function refreshCustomControls() {
        customArea.innerHTML = '';
        customFilter.innerHTML = '<option value="">カスタム状態（任意）</option>';
        book.customStates.forEach(cs => {
          const span = document.createElement('label'); span.className = 'tag';
          span.style.borderColor = cs.color || '#2a3a55';
          span.innerHTML = `<input type="checkbox" data-cs="${cs.id}"> ${escapeHTML(cs.name)} <span class="x" data-delcs="${cs.id}">✕</span>`;
          customArea.appendChild(span);
          const opt = document.createElement('option'); opt.value = cs.id; opt.textContent = cs.name; customFilter.appendChild(opt);
        });
      }
      refreshCustomControls();
      const leftPaneController = createPaneZoomer(paneLeft, imgLeft, 'left');
      const rightPaneController = createPaneZoomer(paneRight, imgRight, 'right');
      paneControllers.push(leftPaneController, rightPaneController);
      const applyControlWidth = () => {
        wrap.style.setProperty('--control-width', `${controlWidth}px`);
        requestPoseSave();
      };
      applyControlWidth();
      const startResize = (clientX) => {
        const rect = wrap.getBoundingClientRect();
        const stageRect = stageHost.getBoundingClientRect();
        const min = 240, max = Math.max(280, rect.width * 0.55);
        const onMove = (x) => {
          const relative = rect.right - x;
          controlWidth = Math.min(max, Math.max(min, relative));
          applyControlWidth();
          markViewMetricsDirty();
          refreshZoomBounds();
          applyViewTransform();
        };
        const moveMouse = (e) => { e.preventDefault(); onMove(e.clientX); };
        const moveTouch = (e) => {
          const t = e.touches?.[0] || e.changedTouches?.[0];
          if (!t) return;
          e.preventDefault();
          onMove(t.clientX);
        };
        const end = () => {
          document.removeEventListener('mousemove', moveMouse);
          document.removeEventListener('mouseup', end);
          document.removeEventListener('touchmove', moveTouch);
          document.removeEventListener('touchend', end);
          document.removeEventListener('touchcancel', end);
          localStorage.setItem('viewer-control-width', String(controlWidth));
        };
        document.addEventListener('mousemove', moveMouse);
        document.addEventListener('mouseup', end);
        document.addEventListener('touchmove', moveTouch, { passive: false });
        document.addEventListener('touchend', end);
        document.addEventListener('touchcancel', end);
        // initial set
        onMove(clientX);
      };
      controlResizer?.addEventListener('mousedown', (e) => {
        e.preventDefault();
        startResize(e.clientX);
      });
      controlResizer?.addEventListener('touchstart', (e) => {
        const t = e.touches?.[0];
        if (!t) return;
        e.preventDefault();
        startResize(t.clientX);
      }, { passive: false });
      updateInteractionUI();
      applySplitRatio();
      function applyCompareHideState() {
        const shouldHide = compareRightHidden && mode === 'compare';
        paneRight?.classList.toggle('hidden-content', shouldHide);
        if (shouldHide && pendingAnswerCrop?.surfaceKey === 'right') {
          pendingAnswerCrop = null;
          selecting = false;
          syncSelectingUI();
        }
        if (compareHideBtn) {
          compareHideBtn.classList.toggle('hidden', mode !== 'compare');
          compareHideBtn.classList.toggle('active', shouldHide);
          compareHideBtn.textContent = shouldHide ? '右側表示' : '右側隠す';
          compareHideBtn.setAttribute('aria-pressed', shouldHide ? 'true' : 'false');
        }
        applySplitRatio();
        updateQuickActionButtons();
        requestPoseSave();
      }
      function resetCurrentView({ toast = false } = {}) {
        stopPageTurbo();
        stageSurface?.cancel?.();
        stopInertia();
        if (mode === 'single') {
          resetViewState({ toast, zoomOnly: useZoomResetOnly() });
        } else {
          paneControllers.forEach((ctrl, idx) => ctrl.reset({ toast: toast && idx === 0, zoomOnly: useZoomResetOnly() }));
          if (toast && paneControllers.length === 0) showToast('ビューをリセットしました', 'ok');
        }
      }
      window.__viewerResetView = ({ toast = false } = {}) => resetCurrentView({ toast });
      window.__viewerJumpToMiss = ({ x, y, missId } = {}) => {
        if (mode !== 'single') return false;
        const rx = Number(x);
        const ry = Number(y);
        if (!Number.isFinite(rx) || !Number.isFinite(ry)) return false;
        const metrics = computeViewMetrics();
        const baseW = metrics.baseW || img?.clientWidth || img?.naturalWidth || 0;
        const baseH = metrics.baseH || img?.clientHeight || img?.naturalHeight || 0;
        if (!baseW || !baseH) return false;
        const clampedX = Math.max(0, Math.min(1, rx));
        const clampedY = Math.max(0, Math.min(1, ry));
        const xPx = clampedX * baseW;
        const yPx = clampedY * baseH;
        const dx = xPx - baseW / 2;
        const dy = yPx - baseH / 2;
        const z = viewState.zoom || 1;
        viewState.translateX = -dx * z;
        viewState.translateY = -dy * z;
        viewState.userAdjusted = true;
        applyViewTransform();
        if (missId) {
          try { renderMissMarkers(); } catch (_) { }
          pulseMissMarker(missId, { strong: true, retries: 16, delay: 120 });
          emitMissFocusWave(missId);
        }
        return true;
      };
      window.__viewerRefreshMiss = () => {
        try { renderMissMarkers(); } catch (_) { }
      };
      window.__persistActiveDrawDoc = () => persistActiveDrawDocNow();
      function updateInteractionUI() {
        const isSingle = mode === 'single';
        stage?.classList.toggle('pan-disabled', !isSingle || panLocked);
        if (!isSingle) stageSurface?.cancel?.();
        if (isSingle) { updateHintText(); showInteractionHint(); } else { hideInteractionHint(); }
      }

      const closePageBadgeEdit = (idx = null) => {
        if (!pageBadge) return;
        pageBadgeEditing = false;
        pageBadgeEditClosedAt = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
        pageBadge.classList.remove('editing');
        pageBadge.innerHTML = '';
        const targetIdx = idx !== null ? idx : page;
        pageBadge.textContent = `${realOf(targetIdx)}p`;
      };
      const startPageBadgeEdit = () => {
        const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
        if (pageBadgeEditing) return;
        if (now - pageBadgeEditClosedAt < 200) return;
        if (!pageBadge) return;
        pageBadgeEditing = true;
        pageBadge.classList.add('editing');
        const input = document.createElement('input');
        input.type = 'text';
        input.inputMode = 'numeric';
        input.value = String(realOf(page));
        pageBadge.innerHTML = '';
        pageBadge.appendChild(input);
        requestAnimationFrame(() => { input.focus(); input.select?.(); });
        let committed = false;
        const normalizeNumberInput = (raw) => {
          return (raw || '').replace(/[０-９]/g, ch => String.fromCharCode(ch.charCodeAt(0) - 0xFEE0)).trim();
        };
        const cleanupFocus = () => {
          if (document.activeElement === input) { input.blur(); }
          pageBadge.blur?.();
        };
        const commit = () => {
          if (committed) return;
          committed = true;
          input.disabled = true;
          const raw = normalizeNumberInput(input.value);
          const val = parseInt(raw, 10);
          const targetIdx = Number.isNaN(val) ? null : idxFromReal(val);
          const displayIdx = targetIdx !== null ? targetIdx : page;
          closePageBadgeEdit(displayIdx);
          cleanupFocus();
          if (targetIdx !== null) { page = targetIdx; load(); }
        };
        const cancel = () => {
          if (committed) return;
          committed = true;
          input.disabled = true;
          closePageBadgeEdit(page);
          cleanupFocus();
        };
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') { e.preventDefault(); commit(); }
          if (e.key === 'Escape') { e.preventDefault(); cancel(); }
        });
        input.addEventListener('blur', () => { commit(); });
        input.addEventListener('change', () => { commit(); });
      };

      function firstPageOf(targetBook) {
        return (typeof targetBook?.firstPageNumber === 'number') ? targetBook.firstPageNumber : 1;
      }
      function realOfOtherBook(targetBook, idx) {
        if (Array.isArray(targetBook?.pageNumberMap)) {
          const val = targetBook.pageNumberMap[idx];
          if (Number.isFinite(val)) return val;
        }
        return firstPageOf(targetBook) + idx;
      }
      function closeCompareBadgeEdit(idx = null) {
        if (!compareWindowPageBadge) return;
        // Force the compare badge back to display mode
        compareBadgeEditing = false;
        compareBadgeEditClosedAt = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
        compareWindowPageBadge.classList.remove('editing');
        compareWindowPageBadge.innerHTML = '';
        const targetIdx = idx !== null ? idx : compareWindowIndex;
        if (compareWindowBook && compareWindowBook.pages?.length) {
          compareWindowPageBadge.textContent = `${realOfOtherBook(compareWindowBook, clamp(targetIdx, 0, (compareWindowBook.pages?.length || 1) - 1))}p`;
        } else {
          compareWindowPageBadge.textContent = '';
        }
      }
      function idxFromRealForBook(targetBook, real) {
        if (!targetBook || !Array.isArray(targetBook.pages) || !targetBook.pages.length) return 0;
        return clamp(real - firstPageOf(targetBook), 0, targetBook.pages.length - 1);
      }
      function ensureCompareWindowPosition() {
        if (!compareWindow || !compareWindowOpen) return;
        requestAnimationFrame(() => {
          if (!compareWindow || !compareWindowOpen) return;
          if (compareWindowPos) {
            applyCompareWindowPosition(compareWindowPos);
            compareWindow.style.right = 'auto';
            return;
          }
          const viewerRect = wrap.getBoundingClientRect();
          const panelRect = compareWindow.getBoundingClientRect();
          const width = panelRect.width || 320;
          const defaultLeft = Math.max(8, viewerRect.width - width - 16);
          const clamped = clampPanelPosition(compareWindow, defaultLeft, 120);
          compareWindow.style.left = `${clamped.left}px`;
          compareWindow.style.top = `${clamped.top}px`;
          compareWindow.style.right = 'auto';
          compareWindowPos = clamped;
          saveStoredJSON('viewer-compare-window-pos', compareWindowPos);
        });
      }
      function syncCompareWindowToMapping({ allowClosed = false } = {}) {
        if ((!compareWindowOpen && !allowClosed) || !compareWindowBook || !book || !compareWindowBook.pages?.length) return;
        const baseId = currentAnswerBaseId();
        if (!baseId) return;
        const mapped = getAnswerPageMapping(baseId, compareWindowBook.id, realOf(page));
        if (typeof mapped === 'number') {
          compareWindowIndex = clamp(mapped, 0, compareWindowBook.pages.length - 1);
        }
      }
      async function updateCompareWindowUI(shouldUpdateMenu = false, { forceReset = false } = {}) {
        if (!compareWindow) return;
        applyCompareSliceState();
        compareWindow.classList.toggle('open', compareWindowOpen);
        compareWindow.classList.toggle('transparent', compareWindowTransparent);
        updateCompareWindowPinUI();
        const hasBook = !!(compareWindowBook && compareWindowBook.pages && compareWindowBook.pages.length);
        if (hasBook) {
          compareWindowIndex = clamp(compareWindowIndex, 0, compareWindowBook.pages.length - 1);
        }
        closeCompareBadgeEdit(hasBook ? compareWindowIndex : null);
        compareWindow.classList.toggle('has-book', hasBook);
        if (compareWindowTitle) {
          compareWindowTitle.textContent = hasBook ? (compareWindowBook.title || '比較ウィンドウ') : '比較ウィンドウ';
        }
        if (compareWindowRegister) {
          compareWindowRegister.disabled = !hasBook;
        }
        if (hasBook) {
          if (compareWindowImg) {
            const url = await ensurePageData(compareWindowBook, compareWindowIndex);
            const sameSrc = (compareWindowImg.dataset.rawSrc || '') === (url || '');
            if (sameSrc && compareWindowImg.complete && compareWindowImg.naturalWidth && !forceReset && !compareNeedsReset) {
              markCompareMetricsDirty();
              refreshCompareZoomBounds();
              applyCompareTransform();
            } else {
              setCompareWindowImage(url || '');
              const shouldResetView = !!forceReset;
              requestAnimationFrame(() => {
                markCompareMetricsDirty();
                refreshCompareZoomBounds();
                if (shouldResetView) {
                  resetCompareView();
                } else {
                  applyCompareTransform();
                }
                compareNeedsReset = false;
              });
            }
          }
          if (compareWindowPageBadge) compareWindowPageBadge.textContent = `${realOfOtherBook(compareWindowBook, compareWindowIndex)}p`;
          if (compareWindowPlaceholder) compareWindowPlaceholder.textContent = '';
          const controlsEnabled = compareWindowOpen;
          if (compareWindowPrev) compareWindowPrev.disabled = !controlsEnabled || compareWindowIndex <= 0;
          if (compareWindowNext) compareWindowNext.disabled = !controlsEnabled || compareWindowIndex >= compareWindowBook.pages.length - 1;
          trimPageCache(compareWindowBook, compareWindowIndex, 4);
        } else {
          if (compareWindowImg) {
            compareWindowImg.dataset.rawSrc = '';
            compareWindowImg.removeAttribute('src');
          }
          if (compareWindowPageBadge) compareWindowPageBadge.textContent = '';
          if (compareWindowPlaceholder) compareWindowPlaceholder.textContent = 'ここに比較ページが表示されます';
          [compareWindowPrev, compareWindowNext].forEach(btn => { if (btn) btn.disabled = true; });
          resetCompareView();
          compareNeedsReset = true;
        }
        if (compareWindowSync) {
          compareWindowSync.classList.toggle('active', compareWindowTransparent);
          compareWindowSync.textContent = compareWindowTransparent ? '透明ON' : '透明';
          compareWindowSync.setAttribute('aria-pressed', compareWindowTransparent ? 'true' : 'false');
        }
        if (compareWindowBtn) {
          compareWindowBtn.classList.toggle('active', compareWindowOpen);
          compareWindowBtn.textContent = compareWindowOpen ? '比較ウィンドウ解除' : '比較ウィンドウ';
        }
        updateCompareLockButtons();
        updateCompareDockUI();
        if (shouldUpdateMenu) updateQuickActionButtons();
        persistProgress();
        requestPoseSave();
        applyAutoToneIfNeeded();
      }
      function setCompareWindowOpen(open) {
        compareWindowOpen = open;
        if (!compareWindowOpen) compareWindowMinimized = false;
        closeCompareBadgeEdit(compareWindowOpen ? compareWindowIndex : null);
        if (compareWindowOpen) {
          syncCompareWindowToMapping({ allowClosed: true });
        }
        if (!compareWindowOpen) {
          compareStageSurface?.cancel?.();
          if (pendingAnswerCrop?.surfaceKey === 'compareWindow') {
            pendingAnswerCrop = null;
            selecting = false;
            syncSelectingUI();
          }
          clearCompareTransparentCache();
        }
        updateCompareWindowUI(true, { forceReset: false });
        if (compareWindowOpen) {
          ensureCompareWindowPosition();
          markCompareMetricsDirty();
          applyCompareTransform();
        }
        requestPoseSave();
        applyAutoToneIfNeeded();
      }
      function setCompareWindowBook(nextBook) {
        const prevCompareBookId = compareWindowBook?.id || null;
        compareWindowBook = nextBook;
        if ((compareWindowBook?.id || null) !== prevCompareBookId) clearCompareTransparentCache();
        if (compareWindowBook && compareWindowBook.pages && compareWindowBook.pages.length) {
          const baseId = currentAnswerBaseId();
          const mapped = baseId ? getAnswerPageMapping(baseId, compareWindowBook.id, realOf(page)) : null;
          const saved = baseId ? getLastCompareWindowIndex(baseId, compareWindowBook.id) : null;
          if (typeof mapped === 'number' && !Number.isNaN(mapped)) {
            compareWindowIndex = clamp(mapped, 0, compareWindowBook.pages.length - 1);
          } else if (typeof saved === 'number' && !Number.isNaN(saved)) {
            compareWindowIndex = clamp(saved, 0, compareWindowBook.pages.length - 1);
          } else {
            compareWindowIndex = idxFromRealForBook(compareWindowBook, realOf(page));
          }
          compareWindowOpen = true;
          compareNeedsReset = true;
        } else {
          compareWindowIndex = 0;
        }
        closeCompareBadgeEdit(compareWindowBook ? compareWindowIndex : null);
        syncCompareWindowToMapping();
        updateCompareWindowUI(true, { forceReset: false });
        if (compareWindowOpen) {
          ensureCompareWindowPosition();
          markCompareMetricsDirty();
          applyCompareTransform();
        }
        requestPoseSave();
        applyAutoToneIfNeeded();
      }
      function shiftCompareWindow(delta) {
        if (!compareWindowBook || !compareWindowBook.pages?.length) return;
        compareWindowIndex = clamp(compareWindowIndex + delta, 0, compareWindowBook.pages.length - 1);
        closeCompareBadgeEdit(compareWindowIndex);
        compareNeedsReset = true;
        updateCompareWindowUI(true, { forceReset: false });
      }
      function jumpCompareWindow(realPage) {
        if (!compareWindowBook || !compareWindowBook.pages?.length) return;
        compareWindowIndex = idxFromRealForBook(compareWindowBook, realPage);
        closeCompareBadgeEdit(compareWindowIndex);
        compareNeedsReset = true;
        updateCompareWindowUI(true, { forceReset: false });
      }
      function syncCompareWindow() {
        if (!compareWindowBook || !compareWindowBook.pages?.length) return;
        compareWindowIndex = idxFromRealForBook(compareWindowBook, realOf(page));
        closeCompareBadgeEdit(compareWindowIndex);
        compareNeedsReset = true;
        updateCompareWindowUI(true, { forceReset: false });
      }


      function setSingle() {
        document.getElementById('stageSingle').classList.remove('hidden');
        document.getElementById('stageDual').classList.add('hidden');
        markViewMetricsDirty();
      }
      function setDual() {
        document.getElementById('stageSingle').classList.add('hidden');
        document.getElementById('stageDual').classList.remove('hidden');
        markViewMetricsDirty();
      }
      // Throttled autoFitForSlice to prevent repeated calls
      let autoFitPending = null;
      function autoFitForSlice() {
        if (!sliceMode) return;
        // Cancel any pending fit to avoid redundant work
        if (autoFitPending) {
          cancelAnimationFrame(autoFitPending);
          autoFitPending = null;
        }
        // Use requestAnimationFrame instead of setTimeout for smoother scheduling
        autoFitPending = requestAnimationFrame(() => {
          autoFitPending = null;
          if (!sliceMode) return;
          setFit('width');
          suppressSmoothNextReset = true; // avoid transition flash when entering slice mode
          resetViewState({ toast: false, smooth: false });
        });
      }
      function autoFitForMainMode() {
        setFit('contain');
        resetViewState({ toast: false });
      }
      function renderBookmarks() {
        // keep bookmark structure available even if UI is hidden
        book.bookmarks = Array.isArray(book.bookmarks) ? book.bookmarks : [];
      }
      function syncImmersive() {
        // immersive/reading mode placeholder
      }
      function persistProgress() {
        if (book?.id) {
          setLastPageIndex(book.id, page);
        }
        if (mode === 'compare' && rightBook?.id) {
          setLastCompareIndex(book.id, rightBook.id, rightIndex);
        }
        if (compareWindowBook?.id) {
          setLastCompareWindowIndex(book.id, compareWindowBook.id, compareWindowIndex);
        }
        try {
          if (window.PlannerCalendar && typeof PlannerCalendar.onPageVisit === 'function') {
            PlannerCalendar.onPageVisit({ bookId: book.id, page: realOf(page), bookTitle: book.title || '' });
          }
        } catch (_) { }
      }
      function cleanupTurnLayers(target) {
        if (!target) return;
        target.querySelectorAll('.page-turn, .page-reveal, .page-anim').forEach(el => el.remove());
      }
      function applyAnimImageSizing(imgEl) {
        if (!imgEl) return;
        imgEl.style.objectFit = 'contain';
        if (sliceMode) {
          imgEl.style.width = '100%';
          imgEl.style.height = 'auto';
          imgEl.style.maxWidth = 'none';
          imgEl.style.maxHeight = '100%';
        } else {
          imgEl.style.width = 'auto';
          imgEl.style.height = '100%';
          imgEl.style.maxWidth = '100%';
          imgEl.style.maxHeight = '100%';
        }
      }
      function runPageTurn(target, direction, src) {
        if (!target || !src) return;
        const layer = document.createElement('div');
        layer.className = `page-turn page-turn-${direction}`;
        const imgEl = document.createElement('img');
        imgEl.src = src;
        imgEl.alt = 'turning page';
        applyAnimImageSizing(imgEl);
        layer.appendChild(imgEl);
        target.appendChild(layer);
        requestAnimationFrame(() => layer.classList.add('run'));
        layer.addEventListener('animationend', () => layer.remove(), { once: true });
      }
      function runPageReveal(target, direction, src) {
        if (!target || !src) return;
        const layer = document.createElement('div');
        layer.className = `page-reveal page-reveal-${direction}`;
        const imgEl = document.createElement('img');
        imgEl.src = src;
        imgEl.alt = 'new page';
        applyAnimImageSizing(imgEl);
        layer.appendChild(imgEl);
        target.appendChild(layer);
        requestAnimationFrame(() => layer.classList.add('run'));
        layer.addEventListener('animationend', () => layer.remove(), { once: true });
      }
      function createAnimLayer(target, cls, src) {
        if (!target || !src) return null;
        const layer = document.createElement('div');
        layer.className = `page-anim ${cls}`;
        const imgEl = document.createElement('img');
        imgEl.src = src;
        imgEl.alt = 'page animation';
        applyAnimImageSizing(imgEl);
        layer.appendChild(imgEl);
        target.appendChild(layer);
        requestAnimationFrame(() => layer.classList.add('run'));
        layer.addEventListener('animationend', () => layer.remove(), { once: true });
        return layer;
      }
      function runSlideAnim(target, direction, prevSrc, nextSrc) {
        cleanupTurnLayers(target);
        if (prevSrc) createAnimLayer(target, `page-slide page-slide-out-${direction}`, prevSrc);
        if (nextSrc) createAnimLayer(target, `page-slide page-slide-in-${direction}`, nextSrc);
      }
      function runGlideAnim(target, direction, prevSrc, nextSrc) {
        cleanupTurnLayers(target);
        if (prevSrc) createAnimLayer(target, `page-glide page-glide-out-${direction}`, prevSrc);
        if (nextSrc) createAnimLayer(target, `page-glide page-glide-in-${direction}`, nextSrc);
      }
      function runSimpleSlide(target, direction, nextSrc) {
        cleanupTurnLayers(target);
        if (nextSrc) createAnimLayer(target, `page-simple page-simple-in-${direction}`, nextSrc);
      }
      function snapshotSrc(el) {
        if (!el) return '';
        return el.currentSrc || el.src || '';
      }
      function runPageTurnAnimations(prevState, prevShots) {
        const nextState = { mode, page, left: leftIndex, right: rightIndex, rightBookId: rightBook?.id || null };
        if (skipNextPageAnim) {
          skipNextPageAnim = false;
          cleanupTurnLayers(stage);
          cleanupTurnLayers(paneLeft);
          cleanupTurnLayers(paneRight);
          lastViewState = nextState;
          return;
        }
        if (!prevState) { lastViewState = nextState; return; }
        if (prevState.mode !== mode) { lastViewState = nextState; return; }
        const animMode = pageAnimMode;
        const playAnim = (target, dir, prevSrc, nextSrc) => {
          if (!target) return;
          if (animMode === 'none') return cleanupTurnLayers(target);
          if (animMode === 'flip') {
            cleanupTurnLayers(target);
            if (prevSrc) runPageTurn(target, dir, prevSrc);
            if (nextSrc) runPageReveal(target, dir, nextSrc);
            return;
          }
          if (animMode === 'slide') {
            runSlideAnim(target, dir, prevSrc, nextSrc);
            return;
          }
          if (animMode === 'simple') {
            runSimpleSlide(target, dir, nextSrc);
            return;
          }
          if (animMode === 'glide') {
            runGlideAnim(target, dir, prevSrc, nextSrc);
            return;
          }
        };
        const mainDir = page < prevState.page ? 'prev' : 'next';
        if (mode === 'single' && prevState.page !== page) {
          playAnim(stage, mainDir, prevShots.single, img?.src || '');
        } else if (mode === 'spread') {
          const leftChanged = prevState.left !== undefined && prevState.left !== leftIndex;
          const rightChanged = prevState.right !== undefined && prevState.right !== rightIndex;
          const dirLeft = leftIndex < (prevState.left ?? leftIndex) ? 'prev' : 'next';
          const dirRight = rightIndex < (prevState.right ?? rightIndex) ? 'prev' : 'next';
          if (leftChanged) {
            playAnim(paneLeft, dirLeft, prevShots.left, imgLeft?.src || '');
          }
          if (rightChanged) {
            playAnim(paneRight, dirRight, prevShots.right, imgRight?.src || '');
          }
        } else if (mode === 'compare') {
          const leftChanged = prevState.left !== undefined && prevState.left !== leftIndex;
          const rightBookChanged = (prevState.rightBookId || null) !== (rightBook?.id || null);
          const rightChanged = rightBookChanged || (prevState.right !== undefined && prevState.right !== rightIndex);
          const dirLeft = leftIndex < (prevState.left ?? leftIndex) ? 'prev' : 'next';
          const dirRight = rightBookChanged ? 'next' : (rightIndex < (prevState.right ?? rightIndex) ? 'prev' : 'next');
          if (leftChanged) {
            playAnim(paneLeft, dirLeft, prevShots.left, imgLeft?.src || '');
          }
          if (rightChanged) {
            playAnim(paneRight, dirRight, prevShots.right, imgRight?.src || '');
          }
        }
        lastViewState = nextState;
      }
      const scheduleIdle = (fn, timeout = 320) => {
        if (typeof requestIdleCallback === 'function') {
          return requestIdleCallback(fn, { timeout });
        }
        return setTimeout(fn, timeout);
      };
      const cancelIdle = (handle) => {
        if (!handle) return;
        if (typeof cancelIdleCallback === 'function') { try { cancelIdleCallback(handle); } catch (_) { clearTimeout(handle); } }
        else { clearTimeout(handle); }
      };
      let pendingTurboRefresh = false;
      let pendingTurboIdle = null;
      let pendingPostLoadLight = false;
      const flushPostLoad = (overrideLight) => {
        const light = (typeof overrideLight === 'boolean') ? overrideLight : pendingPostLoadLight;
        pendingPostLoadLight = false;
        runPostLoadHeavy({ lightThumbs: light });
      };
      function runPostLoadHeavy({ lightThumbs = false } = {}) {
        pendingPostLoadLight = false;
        updateThumbs(lightThumbs);
        // Sync deferred state after turbo mode ends
        try {
          if (book?.pages?.[page]) {
            syncMemoFields(book.pages[page].memo || '', 'load');
            if (stFav) stFav.checked = !!book.pages[page].state?.fav;
            if (stWeak) stWeak.checked = !!book.pages[page].state?.weak;
            if (stDone) stDone.checked = !!book.pages[page].state?.done;
          }
          // Sync deferred draw controls
          updateDrawControls();
          updateInteractionUI();
          if (drawCanvas) {
            clearDrawCanvas();
            drawCanvas.classList.toggle('hidden', mode !== 'single');
          }
          if (drawDoc && mode === 'single') renderDrawDoc();
        } catch (_) { }
        if (!poseApplied && pendingPose) {
          applySavedPose(pendingPose);
          pendingPose = null;
          poseApplied = true;
        }
        renderBookmarks();
        syncImmersive();
        syncCompareWindowToMapping();
        updateCompareWindowUI();
        updateQuickActionButtons();
        persistProgress();
        // Prefetch nearby pages after turbo mode ends
        if (book) prefetchNearby(book, page, 4);
        if (rightBook) prefetchNearby(rightBook, rightIndex, 4);
        // Also call autoFitForSlice if it was deferred during turbo
        if (sliceMode && mode === 'single') autoFitForSlice();
        pendingTurboRefresh = false;
      }
      function queuePostLoad(opts = {}) {
        const lightThumbs = !!opts.lightThumbs;
        cancelIdle(pendingTurboIdle);
        pendingPostLoadLight = pendingPostLoadLight || lightThumbs;
        const timeout = isTurboActive() ? 600 : 100;
        pendingTurboIdle = scheduleIdle(() => {
          pendingTurboIdle = null;
          if (isTurboActive()) {
            pendingTurboRefresh = true;
            return;
          }
          pendingTurboRefresh = false;
          flushPostLoad();
        }, timeout);
      }

      // Double-buffering helper: back buffer shows previous image while front loads
      // This prevents flashing - user always sees something (old or new image)
      // Enhanced: Uses preload cache for instant display when available
      let lastValidSrc = null; // Track last valid image source for reliable backup
      let lastImgBackUpdate = 0; // Throttle back buffer updates to prevent lag

      async function setPageImageWithBuffer(newSrc, instant = false) {
        const fallback = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
        const src = newSrc || fallback;
        const now = performance.now();

        // Throttle back buffer updates to reduce memory pressure on low-spec PCs
        // Only update back buffer if enough time has passed (50ms minimum)
        const shouldUpdateBack = imgBack && (now - lastImgBackUpdate > 50);

        if (shouldUpdateBack) {
          const currentSrc = img.src;
          if (currentSrc && currentSrc !== fallback && !currentSrc.endsWith('undefined')) {
            imgBack.src = currentSrc;
            lastValidSrc = currentSrc;
            lastImgBackUpdate = now;
          }
        }

        // Check if image is already fully loaded in cache - instant display
        if (typeof isImageLoaded === 'function' && isImageLoaded(src)) {
          img.src = src;
          lastValidSrc = src;
          return;
        }

        // For data URLs, they load synchronously - just set directly
        if (src.startsWith('data:')) {
          img.src = src;
          if (src !== fallback) lastValidSrc = src;
          return;
        }

        // For turbo/instant mode: set immediately without waiting
        // The back buffer (if updated) shows the previous image
        if (instant) {
          img.src = src;
          // Start preloading in background (very low priority)
          if (typeof preloadImage === 'function') {
            // Use requestIdleCallback to not block main thread
            if (typeof requestIdleCallback === 'function') {
              requestIdleCallback(() => preloadImage(src), { timeout: 100 });
            } else {
              setTimeout(() => preloadImage(src), 10);
            }
          }
          return;
        }

        // For normal mode: set immediately but also preload
        // Don't wait for load - the back buffer provides visual continuity
        img.src = src;

        // Preload in background for cache population
        if (typeof preloadImage === 'function') preloadImage(src);

        // Short wait to give browser a chance to paint
        return new Promise(resolve => setTimeout(resolve, 16));
      }

      async function load() {
        viewerMemory.book.page = page;
        const prevState = lastViewState;
        const prevShots = {
          single: snapshotSrc(img),
          left: snapshotSrc(imgLeft),
          right: snapshotSrc(imgRight)
        };
        const turbo = isTurboActive();
        if (turbo) pendingTurboRefresh = true;
        // Defer draw layer persistence during turbo mode for speed
        if (!turbo && activeDrawKey) { persistDrawLayer(activeDrawKey, true); if (typeof saveDrawDocImmediate === 'function') saveDrawDocImmediate(); flushDrawPersist(); }
        activeDrawKey = mode === 'single' ? currentDrawKey() : null;
        drawDoc = activeDrawKey ? loadDrawDoc(activeDrawKey) : null;
        if (!drawDoc && drawMode && activeDrawKey) {
          drawDoc = ensureDrawDoc(activeDrawKey);
        }
        if (!turbo) updateDrawControls();
        clearDragTurnLayer();
        currentMode = mode;
        if (!turbo) updateInteractionUI();
        closePageBadgeEdit(page);
        if (mode !== 'single') {
          setDrawMode(false);
        }
        if (drawCanvas && !turbo) {
          clearDrawCanvas();
          drawCanvas.classList.toggle('hidden', mode !== 'single');
        }
        if (drawToggleBtn) {
          drawToggleBtn.disabled = mode !== 'single';
        }
        if (missLayer) missLayer.classList.toggle('hidden', mode !== 'single');
        if (missQuickBtn) missQuickBtn.disabled = mode !== 'single';
        if (missBtn) missBtn.disabled = mode !== 'single';
        if (mode !== 'single') {
          setMissPanelOpen(false);
          closeMissPieMenu();
        }
        if (mode === 'single') {
          setSingle();
          setActivePane('single');
          leftIndex = page;
          rightIndex = Math.min(book.pages.length - 1, page + 1);
          const rawSrc = await ensurePageData(book, page);
          // Use double-buffering to prevent flashing (skip in turbo mode for speed)
          await setPageImageWithBuffer(rawSrc, turbo);
          if (!rawSrc) {
            // Optional: Add a "No Page" watermark or similar if needed, but transparent is safer for now
          }
          setPageTitle(book.pages[page]?._sourceTitle || book.title || '電子書籍');
          pageBadge.textContent = `${realOf(page)}p`;
          if (drawDoc && !turbo) renderDrawDoc();
          renderMissMarkers();
          if (!turbo) autoFitForSlice(); // Skip during turbo to reduce CPU load
        } else if (mode === 'spread') {
          setDual();
          setActivePane('left');
          leftIndex = page;
          rightIndex = Math.min(book.pages.length - 1, leftIndex + 1);
          const [leftSrc, rightSrc] = await Promise.all([
            ensurePageData(book, leftIndex),
            ensurePageData(book, rightIndex)
          ]);
          if (imgLeft) imgLeft.src = leftSrc || 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
          if (imgRight) imgRight.src = rightSrc || 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
          if (!turbo) {
            leftPaneController.reset();
            rightPaneController.reset();
          }
          if (badgeLeft) badgeLeft.textContent = `${leftIndex + 1}/${book.pages.length} ・ ${realOf(leftIndex)}p`;
          if (badgeRight) badgeRight.textContent = `${rightIndex + 1}/${book.pages.length} ・ ${realOf(rightIndex)}p`;
          setPageTitle(book.pages[leftIndex]?._sourceTitle || book.title || '電子書籍');
        } else if (mode === 'compare') {
          setDual();
          setActivePane(compareRightHidden ? 'left' : 'right');
          // left: current book
          leftIndex = page;
          const leftPromise = ensurePageData(book, leftIndex);
          if (badgeLeft) badgeLeft.textContent = `${leftIndex + 1}/${book.pages.length} ・ ${realOf(leftIndex)}p`;
          setPageTitle(book.pages[leftIndex]?._sourceTitle || book.title || '電子書籍');
          if (!turbo) leftPaneController.reset();
          // right: other book
          if (rightBook && rightBook.pages && rightBook.pages.length) {
            rightIndex = Math.min(rightIndex, rightBook.pages.length - 1);
            const [leftSrc, rightSrc] = await Promise.all([
              leftPromise,
              ensurePageData(rightBook, rightIndex)
            ]);
            if (imgLeft) imgLeft.src = leftSrc;
            if (imgRight) imgRight.src = rightSrc;
            if (badgeRight) badgeRight.textContent = `${rightIndex + 1}/${rightBook.pages.length} ・ ${realOfOtherBook(rightBook, rightIndex)}p`;
            if (!turbo) rightPaneController.reset();
          } else {
            if (imgLeft) imgLeft.src = await leftPromise || 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
            if (imgRight) imgRight.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
            if (badgeRight) badgeRight.textContent = '右側: 未選択';
            if (!turbo) rightPaneController.reset();
          }
          autoFitForSlice();
        }
        syncCompletedPageLink();
        applyCompareHideState();
        scrub.max = book.pages.length.toString();
        scrub.value = (page + 1).toString();
        // Defer expensive DOM updates during turbo mode
        if (!turbo) {
          syncMemoFields(book.pages[page].memo || '', 'load');
          stFav.checked = !!book.pages[page].state?.fav;
          stWeak.checked = !!book.pages[page].state?.weak;
          stDone.checked = !!book.pages[page].state?.done;
          runPageTurnAnimations(prevState, prevShots);
          // custom checks
          document.querySelectorAll('[data-cs]').forEach(chk => {
            const id = chk.getAttribute('data-cs');
            const curr = Array.isArray(book.pages[page].state.extra) ? book.pages[page].state.extra : (book.pages[page].state.extra = []);
            chk.checked = curr.includes(id);
            chk.onchange = async () => {
              const arr = Array.isArray(book.pages[page].state.extra) ? book.pages[page].state.extra : (book.pages[page].state.extra = []);
              if (chk.checked) { if (!arr.includes(id)) arr.push(id); }
              else { const i = arr.indexOf(id); if (i >= 0) arr.splice(i, 1); }
              await Book.put(book); updateThumbs();
            };
          });
        }
        trimPageCache(book, page, 8);
        if (rightBook) trimPageCache(rightBook, rightIndex, 8);
        renderPageProgressOverlay();
        // During turbo mode, skip prefetch entirely to reduce CPU load
        // Full prefetch happens after turbo ends via queuePostLoad
        if (!turbo) {
          prefetchNearby(book, page, 4);
          if (rightBook) prefetchNearby(rightBook, rightIndex, 4);
        }
        queuePostLoad({ lightThumbs: true });
      }
      let thumbsInitialized = false;
      let lastThumbSig = '';
      let thumbsDirty = true;
      let thumbUpdatePending = null;
      const markThumbsDirty = () => { thumbsDirty = true; };
      function updateThumbs(lightMode = false) {
        const list = document.getElementById('thumbList');
        if (!list) return;
        // Skip completely during turbo mode - will be updated after
        if (isTurboActive() && lightMode) {
          // Just update active class without full rebuild
          const prev = list.querySelector('.item.active');
          if (prev) prev.classList.remove('active');
          const next = list.querySelector(`.item[data-idx="${page}"]`);
          if (next) next.classList.add('active');
          return;
        }
        const sig = `${book?.id || ''}|${filter}|${customFilterId || ''}|${multi ? '1' : '0'}`;
        const reusable = thumbsInitialized && sig === lastThumbSig && !multi && !thumbsDirty;
        if (lightMode && reusable) {
          const prev = list.querySelector('.item.active');
          if (prev) prev.classList.remove('active');
          const next = list.querySelector(`.item[data-idx="${page}"]`);
          if (next) {
            next.classList.add('active');
            const hostRect = list.getBoundingClientRect();
            const rect = next.getBoundingClientRect();
            if (hostRect && rect && (rect.top < hostRect.top || rect.bottom > hostRect.bottom)) {
              next.scrollIntoView({ block: 'nearest' });
            }
            return;
          }
        }
        list.innerHTML = '';
        const frag = document.createDocumentFragment();
        const shown = book.pages.map((p, i) => ({ p, i })).filter(({ p }) => {
          if (customFilterId) { return (p.state?.extra || []).includes(customFilterId); }
          if (filter === 'all') return true;
          if (filter === 'fav') return p.state?.fav;
          if (filter === 'weak') return p.state?.weak;
          if (filter === 'done') return p.state?.done;
          if (filter === 'undone') return !p.state?.done;
          if (filter === 'hasMemo') return (p.memo || '').trim().length > 0;
          return true;
        });
        const currentShownIdx = shown.findIndex(({ i }) => i === page);
        const MAX_THUMBS = 200;
        let sliceStart = 0, sliceEnd = shown.length;
        if (shown.length > MAX_THUMBS && currentShownIdx >= 0) {
          const radius = 80;
          sliceStart = Math.max(0, currentShownIdx - radius);
          sliceEnd = Math.min(shown.length, currentShownIdx + radius + 1);
          const info = document.createElement('div');
          info.className = 'muted';
          info.style.margin = '4px 0';
          info.textContent = `周辺のみ表示中 (${sliceStart + 1}-${sliceEnd} / ${shown.length} 件)`;
          frag.appendChild(info);
        }
        const targetItems = shown.slice(sliceStart, sliceEnd);
        targetItems.forEach(({ p, i }) => {
          const it = document.createElement('div'); it.className = 'item' + (i === page ? ' active' : '');
          it.draggable = true; it.dataset.idx = i;
          const marks = [p.state?.fav ? '★' : '', p.state?.weak ? '×' : '', p.state?.done ? '✓' : ''].filter(Boolean).join(' ');
          const real = realOf(i);
          it.innerHTML = `
        ${multi ? `<input type='checkbox' class='sel' ${selected.has(i) ? 'checked' : ''} data-sel='${i}'>` : ''}
        <span class="pill">${i + 1}</span><span class="muted">${real}p</span>
        <span class="muted">${marks}</span>
        <span class="muted">${(p.memo || '').slice(0, 12)}</span>`;
          it.onclick = (e) => {
            if (e.target.classList.contains('sel')) {
              const idx = +e.target.getAttribute('data-sel');
              if (e.target.checked) selected.add(idx); else selected.delete(idx);
            } else { page = i; load(); }
          };
          it.ondragstart = (e) => { e.dataTransfer.setData('text/plain', i); };
          it.ondragover = (e) => { e.preventDefault(); it.classList.add('dragover'); };
          it.ondragleave = () => it.classList.remove('dragover');
          it.ondrop = (e) => {
            e.preventDefault(); it.classList.remove('dragover');
            const from = +e.dataTransfer.getData('text/plain'); const to = i;
            movePage(from, to);
          };
          frag.appendChild(it);
        });
        list.appendChild(frag);
        thumbsInitialized = true;
        lastThumbSig = sig;
        thumbsDirty = false;
      }
      function movePage(from, to) {
        if (from === to) return;
        const item = book.pages.splice(from, 1)[0];
        book.pages.splice(to, 0, item);
        markThumbsDirty();
        Book.put(book).then(() => { showToast('並べ替えました', 'ok'); page = to; load(); });
      }

      // fit modes
      function setFit(mode) {
        if (mode === 'contain') { img.style.maxWidth = '100%'; img.style.width = ''; }
        if (mode === 'width') { img.style.maxWidth = 'none'; img.style.width = '100%'; }
        markViewMetricsDirty();
      }

      // selection crop
      function highlightAnswerTarget() {
        const targetKey = pendingAnswerCrop?.surfaceKey || null;
        [{ key: 'right', el: paneRight }, { key: 'compareWindow', el: compareWindowStage }].forEach(({ key: k, el }) => {
          if (!el) return;
          el.classList.toggle('answer-target', !!targetKey && k === targetKey);
        });
      }
      let selectionPanOverride = false; // allow pinch-zoom/pan while選択モード
      function resetSelectionPanOverride() { selectionPanOverride = false; }
      function syncSelectingUI() {
        document.body.classList.toggle('selecting', selecting);
        [stage, paneLeft, paneRight, compareWindowStage].forEach(el => { if (el) el.style.cursor = selecting ? 'crosshair' : ''; });
        if (!selecting) { clearSelectionCanvas(); resetSelectionPanOverride(); }
        highlightAnswerTarget();
        selectQuickBtn?.classList.toggle('active', selecting);
        selectQuickBtn?.setAttribute('aria-pressed', selecting ? 'true' : 'false');
        if (selectQuickBtn) { selectQuickBtn.textContent = selecting ? '切取✓' : '切取'; }
      }
      function toggleSelect() {
        pendingAnswerCrop = null;
        selecting = !selecting;
        resetSelectionPanOverride();
        syncSelectingUI();
        floatbar.classList.remove('hidden');
        showToast(selecting ? '選択モードON' : '選択モードOFF');
      }
      function clearSelectionCanvas() {
        Object.values(selectionSurfaces).forEach(s => {
          if (!s.canvas) return;
          s.canvas.classList.add('hidden');
          s.canvas.width = 0;
          s.canvas.height = 0;
        });
        boxRect = null;
        highlightAnswerTarget();
        resetSelectionPanOverride();
      }
      function chooseAnswerSurface() {
        if (compareWindowOpen && compareWindowBook && compareWindowStage && compareWindowImg && compareWindowImg.naturalWidth) {
          return selectionSurfaces.compareWindow;
        }
        if (mode === 'compare' && rightBook && !compareRightHidden && paneRight && imgRight?.naturalWidth) {
          return selectionSurfaces.right;
        }
        return null;
      }
      function applySavedPose(pose) {
        if (!pose) return;
        const prevSkipClamp = clampSkipOnce;
        clampSkipOnce = true; // avoid clamping away the saved pan/zoom
        if (typeof pose.controlWidth === 'number') {
          controlWidth = clamp(pose.controlWidth, 240, Math.max(280, pose.controlWidth));
          applyControlWidth();
        }
        if (pose.view) {
          if (typeof pose.view.tx === 'number') viewState.translateX = pose.view.tx;
          if (typeof pose.view.ty === 'number') viewState.translateY = pose.view.ty;
          if (typeof pose.view.zoom === 'number') viewState.zoom = Math.max(viewState.minZoom, Math.min(viewState.maxZoom, pose.view.zoom));
          viewState.userAdjusted = true;
          applyViewTransform();
        }
        if (mode !== 'single') {
          if (pose.left) leftPaneController?.setPose?.(pose.left);
          if (pose.right) rightPaneController?.setPose?.(pose.right);
        }
        if (pose.compareWindow) {
          compareWindowOpen = !!pose.compareWindow.open;
          compareWindowMinimized = !!pose.compareWindow.minimized;
          compareWindowTransparent = pose.compareWindow.transparent ?? compareWindowTransparent;
          compareWindowPos = pose.compareWindow.pos || compareWindowPos;
          if (typeof pose.compareWindow.index === 'number' && compareWindowBook?.pages?.length) {
            compareWindowIndex = clamp(pose.compareWindow.index, 0, compareWindowBook.pages.length - 1);
          }
          if (pose.compareWindow.pan) comparePan = pose.compareWindow.pan;
          if (typeof pose.compareWindow.zoom === 'number') compareZoom = pose.compareWindow.zoom;
          requestCompareViewReset();
          updateCompareWindowUI(true);
          applyCompareTransform();
        }
        clampSkipOnce = prevSkipClamp;
      }
      // Apply pose instantly without visible transition (used on tab return)
      function applySavedPoseInstant(pose) {
        if (!pose) return;
        const target = pageLayer || img;
        const prevTransition = target ? target.style.transition : null;
        if (target) target.style.transition = 'none';
        const prevSuppress = suppressSmoothNextReset;
        suppressSmoothNextReset = true;
        applySavedPose(pose);
        suppressSmoothNextReset = prevSuppress;
        if (target) {
          void target.offsetHeight; // force reflow before restoring transition
          target.style.transition = prevTransition || '';
        }
      }
      function startAnswerCropTask({ boxId, name, note, snippetId }) {
        const surface = chooseAnswerSurface();
        if (!surface || !surface.container || !surface.img) {
          showToast('解答側のビューが開いていません', 'error');
          return false;
        }
        pendingAnswerCrop = { boxId, name, note, surfaceKey: surface.key, snippetId };
        selecting = true;
        syncSelectingUI();
        showToast('解答を切り取ってください（Escで中止）');
        return true;
      }
      function cancelAnswerCrop() {
        if (!pendingAnswerCrop) return;
        pendingAnswerCrop = null;
        selecting = false;
        syncSelectingUI();
        showToast('解答の追加切り取りをキャンセルしました', 'ok');
      }
      function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
      const clampInertia = (v) => clamp(isNaN(v) ? 0 : parseFloat(v), 0.9, 0.9995);
      function pointerClientXY(ev) {
        if (ev.touches && ev.touches.length) { return { x: ev.touches[0].clientX, y: ev.touches[0].clientY }; }
        if (ev.changedTouches && ev.changedTouches.length) { return { x: ev.changedTouches[0].clientX, y: ev.changedTouches[0].clientY }; }
        return { x: ev.clientX, y: ev.clientY };
      }
      function normalizeWheelDelta(delta, mode) {
        if (mode === 1) return delta * 28;
        if (mode === 2) return delta * 80;
        return delta;
      }
      function selectionMetaForSurface(surface) {
        if (!surface) return null;
        if (surface === selectionSurfaces.single) return { bookId: book.id, pageIndex: page, firstPage: book.firstPageNumber || 1 };
        if (surface === selectionSurfaces.left) return { bookId: book.id, pageIndex: mode === 'single' ? page : leftIndex, firstPage: book.firstPageNumber || 1 };
        if (surface === selectionSurfaces.right) {
          if (mode === 'compare' && rightBook) { return { bookId: rightBook.id, pageIndex: rightIndex, firstPage: rightBook.firstPageNumber || 1 }; }
          return { bookId: book.id, pageIndex: rightIndex, firstPage: book.firstPageNumber || 1 };
        }
        if (surface === selectionSurfaces.compareWindow && compareWindowBook) {
          return { bookId: compareWindowBook.id, pageIndex: compareWindowIndex, firstPage: compareWindowBook.firstPageNumber || 1 };
        }
        return { bookId: book.id, pageIndex: page, firstPage: book.firstPageNumber || 1 };
      }
      function startDrag(ev, surface) {
        if (!selecting || !surface || !surface.img || !surface.canvas || !surface.container) return;
        if (pendingAnswerCrop && surface.key !== pendingAnswerCrop.surfaceKey) return;
        if (surface.container.classList.contains('hidden-content')) return;
        if (surface.key === 'compareWindow' && (!compareWindowOpen)) return;
        resetSelectionPanOverride();
        const { x, y } = pointerClientXY(ev);
        rectImg = surface.img.getBoundingClientRect(); rectContainer = surface.container.getBoundingClientRect();
        if (x < rectImg.left || x > rectImg.right || y < rectImg.top || y > rectImg.bottom) { return }
        dragging = true; startX = x; startY = y; activeSelectionSurface = surface;
        selectionMeta = selectionMetaForSurface(surface);
        const canvas = surface.canvas;
        canvas.classList.remove('hidden');
        canvas.style.left = (startX - rectContainer.left) + 'px'; canvas.style.top = (startY - rectContainer.top) + 'px';
        canvas.style.width = '0px'; canvas.style.height = '0px';
      }
      function moveDrag(ev) {
        if (!dragging || !activeSelectionSurface) return;
        const { x, y } = pointerClientXY(ev);
        const cx = clamp(x, rectImg.left, rectImg.right);
        const cy = clamp(y, rectImg.top, rectImg.bottom);
        const relativeX = Math.min(startX, cx) - rectContainer.left;
        const relativeY = Math.min(startY, cy) - rectContainer.top;
        const w = Math.abs(cx - startX), h = Math.abs(cy - startY);
        const canvas = activeSelectionSurface.canvas;
        canvas.style.left = relativeX + 'px'; canvas.style.top = relativeY + 'px'; canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
        canvas.width = Math.max(1, Math.floor(w)); canvas.height = Math.max(1, Math.floor(h));
        const ix0 = Math.min(startX, cx) - rectImg.left, iy0 = Math.min(startY, cy) - rectImg.top;
        boxRect = { x: ix0, y: iy0, w: w, h: h };
      }
      async function endDrag(ev) {
        if (!dragging || !activeSelectionSurface) return; dragging = false;
        if (!boxRect || boxRect.w < 10 || boxRect.h < 10) { clearSelectionCanvas(); return; }
        const dataUrl = await cropDataUrlFromImg(activeSelectionSurface.img, boxRect, rectImg);
        const metaNow = selectionMeta || selectionMetaForSurface(activeSelectionSurface) || pendingSelectionMeta;
        selectionMeta = null;
        clearSelectionCanvas();
        if (pendingAnswerCrop) {
          await saveAnswerCrop(dataUrl, metaNow);
          return;
        }
        pendingSelectionMeta = metaNow || pendingSelectionMeta;
        openBoxSelect(dataUrl, pendingSelectionMeta);
      }
      function interactiveTarget(target) {
        return target.closest('.floatbar') || target.closest('.stage-arrows') || target.closest('.pane-controls') || target.closest('.pane-arrows') || target.closest('.mini-menu') || target.closest('.pane-divider') || target.closest('.draw-toolbar') || target.closest('.draw-settings-panel') || target.closest('.miss-marker') || target.closest('.miss-panel') || target.closest('#missPieMenu') || target.closest('#missTypePicker');
      }
      let inertiaRaf = null;
      let inertiaVel = { x: 0, y: 0 };
      let inertiaPanTs = 0;
      let lastPanDeltaX = 0;
      let panTotalDX = 0;
      let dragTurnLayer = null;
      let dragTurnCurrent = null;
      let dragTurnIncoming = null;
      let dragTurnDir = null;
      let dragTurnWidth = 0;
      let dragTurnPull = 0;
      let dragTurnTotalDX = 0;
      let dragTurnTotalDY = 0;
      let dragTurnStartTs = 0;
      const EDGE_TURN_THRESHOLD = 0.94; // need to be almost at the edge
      const EDGE_TURN_MIN_OFFSET = 16;  // ignore tiny pans when zoomed out
      const EDGE_TURN_MIN_DRAG = 28;    // require some travel distance
      const EDGE_TURN_SPEED = 0.32;     // require a clearer push
      const DRAG_TURN_MIN_START = 12;
      const DRAG_TURN_DOMINANCE = 1.35;
      const DRAG_TURN_PULL_LIMIT = 260;
      const DRAG_TURN_COMMIT_RATIO = 0.24;
      const DRAG_TURN_COMMIT_MIN = 78;
      const DRAG_TURN_EDGE_GRACE = 0.92;
      const DRAG_TURN_VEL_TRIGGER = 6.5;
      const DRAG_TURN_SPEED_MS = 0.55;
      function computeMaxPanX() {
        const stageRect = stage?.getBoundingClientRect?.();
        const baseW = img?.naturalWidth || img?.clientWidth || 0;
        if (!stageRect || !baseW) return 0;
        const scale = viewState.zoom || 1;
        const scaledW = baseW * scale;
        return Math.max(0, (scaledW - stageRect.width) / 2);
      }
      const canTurnOutward = (delta, maxX = 0) => {
        const slack = Math.max(12, Math.abs(maxX || 0) * (keyNavConfig.bookClamp ? 0.22 : 0.12));
        if (delta > 0) return viewState.translateX > -slack;
        if (delta < 0) return viewState.translateX < slack;
        return false;
      };
      function tryEdgePageTurn() {
        if (mode !== 'single') return false;
        const maxX = computeMaxPanX();
        if (maxX <= EDGE_TURN_MIN_OFFSET) return false;
        const edgeRatio = Math.abs(viewState.translateX) / (maxX || 1);
        if (edgeRatio < EDGE_TURN_THRESHOLD) return false;
        if (Math.abs(panTotalDX) < EDGE_TURN_MIN_DRAG) return false;
        const push = lastPanDeltaX || inertiaVel.x;
        if (Math.abs(push) < EDGE_TURN_SPEED) return false;
        if (!canTurnOutward(push, maxX)) return false;
        const dir = push > 0 ? 'right' : 'left';
        if (dir === 'right') { goPrev(); return true; }
        if (dir === 'left') { goNext(); return true; }
        return false;
      }
      function resetPanTotals() {
        panTotalDX = 0;
        lastPanDeltaX = 0;
        dragTurnTotalDX = 0;
        dragTurnTotalDY = 0;
        dragTurnStartTs = 0;
        dragTurnPull = 0;
      }
      const clearDragTurnLayer = () => {
        if (dragTurnLayer) { dragTurnLayer.remove(); }
        dragTurnLayer = null;
        dragTurnCurrent = null;
        dragTurnIncoming = null;
        dragTurnDir = null;
        dragTurnWidth = 0;
        dragTurnPull = 0;
      };
      function canDragTurn() {
        return false; // disable drag-based visual turn effect for stability
      }
      function primeDragTurn(direction) {
        if (!canDragTurn()) return false;
        const targetIdx = direction === 'next' ? findNext(page) : findPrev(page);
        if (targetIdx === page) return false;
        const currSrc = snapshotSrc(img) || '';
        const targetSrc = book.pages[targetIdx]?.dataUrl || '';
        if (!currSrc || !targetSrc) return false;
        const rect = stage?.getBoundingClientRect?.();
        if (!rect || rect.width < 40 || rect.height < 40) return false;
        cleanupTurnLayers(stage);
        const layer = document.createElement('div');
        layer.className = 'drag-turn-layer';
        const curr = document.createElement('img');
        curr.src = currSrc;
        curr.alt = 'current page';
        const incoming = document.createElement('img');
        incoming.src = targetSrc;
        incoming.alt = 'incoming page';
        applyAnimImageSizing(curr);
        applyAnimImageSizing(incoming);
        layer.appendChild(curr);
        layer.appendChild(incoming);
        stage.appendChild(layer);
        dragTurnLayer = layer;
        dragTurnCurrent = curr;
        dragTurnIncoming = incoming;
        dragTurnDir = direction;
        dragTurnWidth = rect.width;
        dragTurnPull = 0;
        dragTurnLayer.style.opacity = '0.96';
        dragTurnCurrent.style.transform = 'translate3d(0,0,0)';
        dragTurnIncoming.style.transform = `translate3d(${direction === 'next' ? dragTurnWidth : -dragTurnWidth}px,0,0)`;
        return true;
      }
      function updateDragTurnPull(nextPull) {
        if (!dragTurnLayer || !dragTurnCurrent || !dragTurnIncoming) return;
        const limit = Math.max(DRAG_TURN_PULL_LIMIT, (dragTurnWidth || 0) * 0.45);
        const clamped = clamp(nextPull, -limit, limit);
        dragTurnPull = clamped;
        const incomingBase = clamped + (dragTurnDir === 'next' ? dragTurnWidth : -dragTurnWidth);
        dragTurnCurrent.style.transform = `translate3d(${clamped}px,0,0)`;
        dragTurnIncoming.style.transform = `translate3d(${incomingBase}px,0,0)`;
        const commitDist = Math.max(DRAG_TURN_COMMIT_MIN, (dragTurnWidth || 0) * DRAG_TURN_COMMIT_RATIO);
        const prog = commitDist > 0 ? Math.min(1, Math.abs(clamped) / commitDist) : 0;
        dragTurnLayer.style.opacity = (0.9 + prog * 0.1).toString();
      }
      function finishDragTurn(commit) {
        if (!dragTurnLayer) { clearDragTurnLayer(); return; }
        const width = dragTurnWidth || stage?.getBoundingClientRect?.().width || 0;
        const incomingStart = dragTurnDir === 'next' ? width : -width;
        const toCurrent = commit ? -incomingStart : 0;
        const toIncoming = commit ? 0 : incomingStart;
        dragTurnLayer.classList.add('smooth');
        dragTurnCurrent.style.transform = `translate3d(${toCurrent}px,0,0)`;
        dragTurnIncoming.style.transform = `translate3d(${toIncoming}px,0,0)`;
        let finished = false;
        const finalize = () => {
          if (finished) return;
          finished = true;
          clearDragTurnLayer();
          if (commit) {
            skipNextPageAnim = true;
            if (dragTurnDir === 'next') goNext(); else goPrev();
          }
        };
        dragTurnLayer.addEventListener('transitionend', finalize, { once: true });
        setTimeout(finalize, 280);
      }
      function releaseDragTurn() {
        if (!dragTurnLayer) return false;
        const width = dragTurnWidth || stage?.getBoundingClientRect?.().width || 0;
        const commitDist = Math.max(DRAG_TURN_COMMIT_MIN, width * DRAG_TURN_COMMIT_RATIO);
        const hasTarget = dragTurnDir === 'next' ? findNext(page) !== page : findPrev(page) !== page;
        const velocity = Math.abs(inertiaVel.x);
        const dragDuration = dragTurnStartTs ? (performance.now() - dragTurnStartTs) : 0;
        const avgSpeed = dragDuration > 0 ? Math.abs(dragTurnTotalDX) / (dragDuration) : 0;
        const quick = (velocity >= DRAG_TURN_VEL_TRIGGER && Math.abs(panTotalDX) >= DRAG_TURN_MIN_START * 2) || (avgSpeed >= DRAG_TURN_SPEED_MS && Math.abs(dragTurnTotalDX) >= DRAG_TURN_MIN_START * 1.5);
        const shouldCommit = hasTarget && (Math.abs(dragTurnPull) >= commitDist || quick);
        finishDragTurn(shouldCommit);
        return true;
      }
      function handleDragTurnDuringPan(dx, dy) {
        dragTurnTotalDX += dx;
        dragTurnTotalDY += dy;
        if (!canDragTurn()) return;
        const stageRect = stage?.getBoundingClientRect?.();
        if (!stageRect || stageRect.width < 40) return;
        const maxX = computeMaxPanX();
        const atEdge = maxX <= 2 || Math.abs(viewState.translateX) >= maxX * DRAG_TURN_EDGE_GRACE;
        const zoomFriendly = viewState.zoom <= 1.12 || atEdge;
        if (!dragTurnLayer) {
          if (!zoomFriendly) return;
          const absX = Math.abs(dragTurnTotalDX);
          const absY = Math.abs(dragTurnTotalDY);
          if (absX < DRAG_TURN_MIN_START || absX < absY * DRAG_TURN_DOMINANCE) return;
          const dir = dragTurnTotalDX < 0 ? 'next' : 'prev';
          if (!atEdge && maxX > 0 && viewState.zoom > 1.01) return;
          if (!primeDragTurn(dir)) return;
          dragTurnStartTs = performance.now();
        }
        const damping = (!atEdge && maxX > 0) ? 0.35 : 1;
        updateDragTurnPull(dragTurnPull + dx * damping);
      }
      const stopInertia = () => {
        if (inertiaRaf) { cancelAnimationFrame(inertiaRaf); inertiaRaf = null; }
        inertiaVel = { x: 0, y: 0 };
        inertiaPanTs = 0;
      };
      const startInertia = () => {
        if (zoomLocked || panLocked) return;
        const step = () => {
          inertiaVel.x *= 0.9;
          inertiaVel.y *= 0.9;
          if (Math.abs(inertiaVel.x) + Math.abs(inertiaVel.y) < 0.05) {
            stopInertia(); return;
          }
          viewState.translateX += inertiaVel.x;
          viewState.translateY += inertiaVel.y;
          applyViewTransform();
          inertiaRaf = requestAnimationFrame(step);
        };
        if (!inertiaRaf && (Math.abs(inertiaVel.x) > 0.1 || Math.abs(inertiaVel.y) > 0.1)) {
          inertiaRaf = requestAnimationFrame(step);
        }
      };
      const stageSurface = createPanZoomSurface({
        element: stage,
        anchorFromClient: stageAnchorFromClient,
        getEnabled: () => !!stage && !stage.classList.contains('hidden') && mode === 'single',
        getZoom: () => viewState.zoom,
        setZoom: (next, { anchor } = {}) => setZoom(next, { anchor, skipClamp: !keyNavConfig.bookClamp }),
        getZoomLocked: () => zoomLocked,
        getPanLocked: () => panLocked || (selecting && !selectionPanOverride),
        applyPanDelta: (dx, dy) => {
          setActivePane('single');
          stopInertia();
          const now = performance.now();
          const dt = Math.max(8, now - (inertiaPanTs || now));
          inertiaPanTs = now;
          inertiaVel.x = dx / (dt / 16);
          inertiaVel.y = dy / (dt / 16);
          if (dx !== 0) lastPanDeltaX = dx;
          panTotalDX += dx;
          if (Math.abs(dx) > 3 || Math.abs(dy) > 3) panMoved = true;
          viewState.translateX += dx;
          viewState.translateY += dy;
          viewState.userAdjusted = true;
          applyViewTransform();
          hideInteractionHint();
        },
        onPanStart: () => {
          stopInertia();
          stagePanning = true;
          stage?.classList.add('is-panning');
          viewState.userAdjusted = true;
          clearDragTurnLayer();
          resetPanTotals();
          dragTurnStartTs = performance.now();
        },
        onPanEnd: () => {
          stagePanning = false;
          stage?.classList.remove('is-panning');
          if (releaseDragTurn()) {
            stopInertia();
            resetPanTotals();
            return;
          }
          const turned = tryEdgePageTurn();
          if (!turned) startInertia();
          else { stopInertia(); resetPanTotals(); }
          setTimeout(() => { panMoved = false; }, 120);
        },
        onReset: () => {
          resetViewState({ toast: false, zoomOnly: useZoomResetOnly() });
          hideInteractionHint();
          triggerResetFlash(stage);
        },
        shouldIgnoreTarget: (target, evt) => {
          if (interactiveTarget(target)) return true;
          const onDrawLayer = drawMode && drawCanvas && drawCanvas.contains(target);
          if (!onDrawLayer) return false;
          const evtType = evt?.type || '';
          const wheelLike = evtType === 'wheel' || evtType === 'dblclick';
          const pinchZoom = evtType.startsWith('touch') && evt?.touches?.length >= 2;
          if (selectMode && (wheelLike || pinchZoom)) return false;
          if (selectMode) return true;
          if (drawGestureActive) return false;
          if (wheelLike) return false;
          return drawingStroke;
        },
      });
      const DRAW_COLOR = '#000000';
      const DRAW_WIDTH = 3.5;
      const ERASER_DEFAULT = 18;
      const STRAIGHT_SNAP_RAD = Math.PI / 10;
      const TOUCH_STROKE_DELAY = 80;
      const TOUCH_STROKE_DIST = 3;
      let activeStroke = null;
      let lastPoint = null;
      let touchDrawPending = null;
      const clearTouchDrawPending = () => { touchDrawPending = null; };
      const updateDrawGestureState = () => {
        drawGestureActive = drawPointers.size >= 2;
        if (drawGestureActive && drawingStroke) finishStroke(false);
        if (drawGestureActive) clearTouchDrawPending();
      };
      const drawPointFromEvent = (e) => {
        if (!drawCanvas) return { x: 0, y: 0 };
        const rect = drawCanvas.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / (rect.width || 1)) * drawCanvas.width;
        const y = ((e.clientY - rect.top) / (rect.height || 1)) * drawCanvas.height;
        lastCursorPos = { x, y };
        return { x, y };
      };
      const beginStroke = (pt, tool) => {
        const layer = activeLayer();
        if (!layer) return;
        const type = tool === 'eraser' ? 'erase' : 'stroke';
        const brush = drawDoc?.brush || 'smooth';
        const baseWidth = currentWidth();
        const stroke = {
          type: type === 'erase' ? 'erase' : 'stroke',
          points: [pt],
          color: currentColor(),
          width: baseWidth,
          baseWidth,
          brush,
          shape: shapeMode,
          shapeAnchor: pt,
          widths: [],
          opacity: currentOpacity(),
          shadow: !!drawDoc?.shadow,
          glow: !!drawDoc?.glow
        };
        stroke.widths.push(computeStrokeWidth(stroke, null, pt));
        activeStroke = stroke;
        layer.strokes.push(stroke);
        drawingStroke = true;
        drawDirty = true;
        drawCanvas?.classList.add('drawing');
        lastPoint = pt;
      };
      const finishStroke = (save = true) => {
        if (!drawingStroke) return;
        drawingStroke = false;
        drawCanvas?.classList.remove('drawing');
        activeStroke = null;
        lastPoint = null;
        straightAnchor = null;
        ctrlOverrideTool = null;
        if (save) {
          pushHistory();
          saveDrawDoc();
        }
        renderDrawDoc(true);
      };
      const applyStraight = (pt) => {
        if (!straightAnchor) return pt;
        const dx = pt.x - straightAnchor.x;
        const dy = pt.y - straightAnchor.y;
        const len = Math.hypot(dx, dy);
        if (len === 0) return { x: pt.x, y: pt.y, straightFrom: straightAnchor };
        const angle = Math.atan2(dy, dx);
        const snaps = [0, Math.PI / 4, Math.PI / 2, (3 * Math.PI) / 4, -Math.PI / 4, -Math.PI / 2, (-3 * Math.PI) / 4, Math.PI];
        let best = angle;
        let bestDiff = Infinity;
        snaps.forEach(a => {
          const diff = Math.abs(Math.atan2(Math.sin(angle - a), Math.cos(angle - a)));
          if (diff < bestDiff) { bestDiff = diff; best = a; }
        });
        const finalAngle = bestDiff < STRAIGHT_SNAP_RAD ? best : angle;
        return {
          x: straightAnchor.x + Math.cos(finalAngle) * len,
          y: straightAnchor.y + Math.sin(finalAngle) * len,
          straightFrom: straightAnchor,
          snapped: bestDiff < STRAIGHT_SNAP_RAD
        };
      };
      const computeStrokeWidth = (stroke, prev, pt) => {
        const base = clampStrokeWidth(stroke?.baseWidth || stroke?.width || currentWidth());
        const brush = stroke?.brush || drawDoc?.brush || 'smooth';
        if (brush === 'simple') return base;
        const speed = prev ? Math.hypot(pt.x - prev.x, pt.y - prev.y) : 0;
        let factor = Math.max(0.6, 1.12 - speed * 0.02);
        if (brush === 'pencil') factor *= 0.85 + Math.random() * 0.25;
        if (brush === 'soft') factor *= 1.08;
        if (brush === 'marker') factor *= 1.15;
        if (brush === 'calligraphy' && prev) {
          const ang = Math.atan2(pt.y - prev.y, pt.x - prev.x);
          factor *= 0.7 + Math.abs(Math.cos(ang)) * 0.9;
        }
        return clampStrokeWidth(base * factor);
      };
      const buildShapePoints = (anchor, pt, mode) => {
        const a = anchor || pt;
        const target = mode === 'line' ? applyStraight(pt) : pt;
        if (mode === 'rectangle') {
          return [
            { x: a.x, y: a.y },
            { x: target.x, y: a.y },
            { x: target.x, y: target.y },
            { x: a.x, y: target.y },
            { x: a.x, y: a.y }
          ];
        }
        if (mode === 'ellipse') {
          const cx = (a.x + target.x) / 2;
          const cy = (a.y + target.y) / 2;
          const rx = Math.max(1, Math.abs(target.x - a.x) / 2);
          const ry = Math.max(1, Math.abs(target.y - a.y) / 2);
          const seg = 28;
          const pts = [];
          for (let i = 0; i <= seg; i++) {
            const t = (i / seg) * Math.PI * 2;
            pts.push({ x: cx + Math.cos(t) * rx, y: cy + Math.sin(t) * ry });
          }
          return pts;
        }
        if (mode === 'line') return [a, target];
        return [a, pt];
      };
      const addPointToStroke = (pt) => {
        if (!activeStroke) return;
        const target = applyStraight(pt);
        if (activeStroke.shape && activeStroke.shape !== 'free') {
          const anchor = activeStroke.shapeAnchor || straightAnchor || activeStroke.points[0] || target;
          const shaped = buildShapePoints(anchor, target, activeStroke.shape);
          activeStroke.points = shaped;
          const w = computeStrokeWidth(activeStroke, anchor, target);
          activeStroke.widths = shaped.map(() => w);
          lastPoint = target;
          renderDrawDoc();
          return;
        }
        const prev = lastPoint || activeStroke.points[activeStroke.points.length - 1] || target;
        const segWidth = computeStrokeWidth(activeStroke, prev, target);
        if (straightAnchor) {
          activeStroke.points = [straightAnchor, { x: target.x, y: target.y }];
          activeStroke.widths = [activeStroke.widths?.[0] || segWidth, segWidth];
        } else {
          activeStroke.points.push(target);
          if (!Array.isArray(activeStroke.widths)) activeStroke.widths = [];
          activeStroke.widths.push(segWidth);
        }
        lastPoint = target;
        renderDrawDoc();
      };
      function eraseStrokeAt(pt, { deferHistory = false } = {}) {
        const hit = hitTestStroke(pt);
        if (!hit) return false;
        if (hit.stroke.type === 'text' && (hit.stroke.text || '').length > 0) {
          const b = strokeBounds(hit.stroke);
          const size = clampTextSize(hit.stroke.size || hit.stroke.width * 4 || 24);
          const charW = size * 0.6;
          const offsetX = b ? Math.max(b.minX, pt.x) - (b ? b.minX : pt.x) : 0;
          const idx = Math.max(0, Math.min(hit.stroke.text.length - 1, Math.floor(offsetX / Math.max(1, charW))));
          hit.stroke.text = hit.stroke.text.slice(0, idx) + hit.stroke.text.slice(idx + 1);
          if (hit.stroke.text.length === 0) {
            hit.layer.strokes.splice(hit.strokeIndex, 1);
          }
        } else {
          hit.layer.strokes.splice(hit.strokeIndex, 1);
        }
        setSelection(null);
        if (deferHistory) {
          drawDirty = true;
          renderDrawDoc();
        } else {
          pushHistory();
          renderDrawDoc(true);
          saveDrawDoc();
        }
        return true;
      }
      function eraseAlongStroke(from, to) {
        if (!from || !to) return;
        const dx = to.x - from.x;
        const dy = to.y - from.y;
        const dist = Math.hypot(dx, dy);
        const steps = Math.max(1, Math.ceil(dist / Math.max(2, currentWidth() * 0.6)));
        for (let i = 0; i <= steps; i++) {
          const t = i / steps;
          const pt = { x: from.x + dx * t, y: from.y + dy * t };
          if (eraseStrokeAt(pt, { deferHistory: true })) strokeEraseChanged = true;
        }
      }
      const handleDrawPointerDown = (e) => {
        if (!drawCanvas || !drawCtx) return;
        const isTouch = e.pointerType === 'touch';
        if (!drawMode) {
          if (tapDrawAlways && isTouch) {
            if (!beginTapDraw()) return;
          } else {
            return;
          }
        }
        if (tapDrawActive && !isTouch) { endTapDraw(); if (!drawMode) return; }
        if (e.pointerType !== 'touch' && e.button !== 0) return;
        e.stopPropagation();
        drawCanvas?.setPointerCapture?.(e.pointerId);
        drawPointers.add(e.pointerId);
        updateDrawGestureState();
        if (drawGestureActive) { clearTouchDrawPending(); return; }
        const pt = drawPointFromEvent(e);
        if (selectMode) {
          clearTouchDrawPending();
          updateSelectOverlayRect();
          const hit = hitTestStroke(pt);
          if (hit && selectedStrokes.some(s => s.stroke === hit.stroke)) {
            selectionDragStart = pt;
            selectionOriginalPoints = selectedStrokes.map(sel => sel.stroke.points.map(p => ({ x: p.x, y: p.y })));
            return;
          }
          if (selectedStrokes.length && pointInSelectionBox(pt)) {
            selectionDragStart = pt;
            selectionOriginalPoints = selectedStrokes.map(sel => sel.stroke.points.map(p => ({ x: p.x, y: p.y })));
            return;
          }
          selectionDrawing = true;
          selectionRectMode = !!e.shiftKey;
          selectionPath = [pt];
          selectionDragStart = null;
          selectionOriginalPoints = null;
          hideSelectionBox();
          drawSelectionPath();
          return;
        }
        const stampId = drawDoc?.activeStampId || activeStampId;
        if (stampId) {
          stampPlacementActive = true;
          showStampPreview(pt, findStamp(stampId));
          e.preventDefault();
          return;
        }
        if (currentTool() === 'eraser' && eraserMode === 'stroke') {
          strokeEraseChanged = false;
          strokeEraseActive = true;
          strokeEraseChanged = eraseStrokeAt(pt, { deferHistory: true }) || strokeEraseChanged;
          lastErasePoint = pt;
          activeStroke = null;
          drawingStroke = false;
          showSizePreview(pt, currentWidth());
          e.preventDefault();
          return;
        }
        ctrlOverrideTool = e.ctrlKey ? (drawTool === 'pen' ? 'eraser' : 'pen') : null;
        straightAnchor = e.shiftKey ? pt : null;
        if (isTouch) {
          touchDrawPending = { id: e.pointerId, pt, tool: currentTool(), ctrl: ctrlOverrideTool, straight: straightAnchor, ts: performance.now() };
          return;
        }
        beginStroke(pt, currentTool());
        e.preventDefault();
      };
      const handleDrawPointerMove = (e) => {
        if (!drawMode || !drawCtx) return;
        e.stopPropagation();
        lastCursorPos = drawPointFromEvent(e);
        if (touchDrawPending && e.pointerId === touchDrawPending.id && !drawingStroke) {
          if (drawGestureActive || drawPointers.size > 1) { clearTouchDrawPending(); return; }
          const dt = performance.now() - (touchDrawPending.ts || 0);
          const dist = Math.hypot(lastCursorPos.x - touchDrawPending.pt.x, lastCursorPos.y - touchDrawPending.pt.y);
          if (dt >= TOUCH_STROKE_DELAY || dist >= TOUCH_STROKE_DIST) {
            ctrlOverrideTool = touchDrawPending.ctrl || null;
            straightAnchor = touchDrawPending.straight || null;
            beginStroke(touchDrawPending.pt, touchDrawPending.tool);
            clearTouchDrawPending();
          } else {
            return;
          }
        }
        if (sizeAdjustMode && gPreviewVisible) {
          return;
        }
        if (selectMode && selectionDrawing) {
          selectionPath.push(lastCursorPos);
          drawSelectionPath();
          return;
        }
        if (stampPlacementActive) {
          const stamp = findStamp(drawDoc?.activeStampId || activeStampId);
          showStampPreview(lastCursorPos, stamp);
          return;
        }
        if (strokeEraseActive) {
          if (lastErasePoint) eraseAlongStroke(lastErasePoint, lastCursorPos);
          lastErasePoint = lastCursorPos;
          showSizePreview(lastCursorPos, currentWidth());
          return;
        }
        if (selectMode && selectedStroke && selectionDragStart) {
          const dx = lastCursorPos.x - selectionDragStart.x;
          const dy = lastCursorPos.y - selectionDragStart.y;
          selectedStrokes.forEach((sel, idx) => {
            const basePts = selectionOriginalPoints[idx] || [];
            sel.stroke.points = basePts.map(p => ({ x: p.x + dx, y: p.y + dy }));
          });
          renderDrawDoc();
          updateSelectionBox();
          return;
        }
        if (drawGestureActive) return;
        if (!drawingStroke || !activeStroke) return;
        addPointToStroke(lastCursorPos);
        if (currentTool() === 'eraser') showSizePreview(lastCursorPos, currentWidth());
      };
      const handleDrawPointerUp = (e) => {
        if (!drawMode || !drawCtx) return;
        e.stopPropagation();
        drawCanvas?.releasePointerCapture?.(e.pointerId);
        drawPointers.delete(e.pointerId);
        updateDrawGestureState();
        if (touchDrawPending && e.pointerId === touchDrawPending.id) {
          clearTouchDrawPending();
          return;
        }
        if (selectMode && selectionDrawing) {
          finalizeSelectionArea(selectionRectMode);
          selectionDrawing = false;
          selectionPath = [];
          selectionRectMode = false;
          drawSelectionPath(true);
          return;
        }
        if (stampPlacementActive) {
          stampPlacementActive = false;
          hideStampPreview();
          placeStampAt(drawPointFromEvent(e));
          return;
        }
        if (strokeEraseActive) {
          const endPt = drawPointFromEvent(e);
          if (lastErasePoint) eraseAlongStroke(lastErasePoint, endPt);
          strokeEraseActive = false;
          lastErasePoint = null;
          activeStroke = null;
          drawingStroke = false;
          if (strokeEraseChanged) {
            pushHistory();
            saveDrawDoc();
            renderDrawDoc(true);
          }
          strokeEraseChanged = false;
          hideSizePreview();
          return;
        }
        if (selectMode && selectedStroke && selectionDragStart) {
          pushHistory();
          saveDrawDoc();
          selectionDragStart = null;
          selectionOriginalPoints = null;
          renderDrawDoc(true);
          updateSelectionBox();
          return;
        }
        if (!drawingStroke) return;
        addPointToStroke(drawPointFromEvent(e));
        finishStroke(true);
        endTapDraw();
      };
      const handleDrawPointerCancel = (e) => {
        if (e?.pointerId !== undefined) {
          drawPointers.delete(e.pointerId);
          updateDrawGestureState();
        }
        e?.stopPropagation?.();
        if (touchDrawPending && e?.pointerId === touchDrawPending.id) {
          clearTouchDrawPending();
        }
        if (stampPlacementActive) {
          stampPlacementActive = false;
          hideStampPreview();
        }
        if (selectMode && selectionDrawing) {
          selectionDrawing = false;
          selectionPath = [];
          selectionRectMode = false;
          drawSelectionPath(true);
        }
        if (strokeEraseActive) {
          strokeEraseActive = false;
          lastErasePoint = null;
          strokeEraseChanged = false;
          hideSizePreview();
          return;
        }
        if (selectMode && selectionDragStart) {
          commitSelectionDragFromBox();
          return;
        }
        finishStroke(false);
        endTapDraw();
      };
      if (drawCanvas) {
        drawCanvas.addEventListener('pointerdown', handleDrawPointerDown);
        drawCanvas.addEventListener('pointermove', handleDrawPointerMove);
        drawCanvas.addEventListener('pointerup', handleDrawPointerUp);
        drawCanvas.addEventListener('pointercancel', handleDrawPointerCancel);
        drawCanvas.addEventListener('pointerleave', handleDrawPointerCancel);
      }
      const clientToDrawPoint = (x, y) => {
        if (!drawCanvas) return { x: 0, y: 0 };
        const rect = drawCanvas.getBoundingClientRect();
        return {
          x: ((x - rect.left) / (rect.width || 1)) * drawCanvas.width,
          y: ((y - rect.top) / (rect.height || 1)) * drawCanvas.height
        };
      };
      const startSelectionDragFromBox = (x, y) => {
        if (!selectMode || !selectedStrokes.length) return;
        const pt = clientToDrawPoint(x, y);
        selectionDragStart = pt;
        selectionOriginalPoints = selectedStrokes.map(sel => sel.stroke.points.map(p => ({ x: p.x, y: p.y })));
      };
      const moveSelectionDragFromBox = (x, y) => {
        if (!selectMode || !selectionDragStart || !selectedStrokes.length) return;
        const pt = clientToDrawPoint(x, y);
        const dx = pt.x - selectionDragStart.x;
        const dy = pt.y - selectionDragStart.y;
        selectedStrokes.forEach((sel, idx) => {
          const basePts = selectionOriginalPoints[idx] || [];
          sel.stroke.points = basePts.map(p => ({ x: p.x + dx, y: p.y + dy }));
        });
        renderDrawDoc();
        updateSelectionBox();
      };
      const commitSelectionDragFromBox = () => {
        if (!selectionDragStart || !selectionOriginalPoints) return;
        pushHistory();
        saveDrawDoc();
        selectionDragStart = null;
        selectionOriginalPoints = null;
        renderDrawDoc(true);
        updateSelectionBox();
      };
      if (drawSelectionBox) {
        drawSelectionBox.addEventListener('mousedown', (e) => {
          startSelectionDragFromBox(e.clientX, e.clientY);
          drawSelectionBox.setPointerCapture?.(e.pointerId || 0);
          e.preventDefault();
          e.stopPropagation();
        });
        drawSelectionBox.addEventListener('pointermove', (e) => {
          moveSelectionDragFromBox(e.clientX, e.clientY);
        });
        drawSelectionBox.addEventListener('pointerup', (e) => {
          commitSelectionDragFromBox();
          drawSelectionBox.releasePointerCapture?.(e.pointerId || 0);
          e.preventDefault();
          e.stopPropagation();
        });
        drawSelectionBox.addEventListener('pointercancel', (e) => {
          commitSelectionDragFromBox();
          drawSelectionBox.releasePointerCapture?.(e.pointerId || 0);
        });
        drawSelectionBox.addEventListener('touchstart', (e) => {
          const t = e.touches?.[0];
          if (!t) return;
          startSelectionDragFromBox(t.clientX, t.clientY);
          e.preventDefault();
          e.stopPropagation();
        }, { passive: false });
        drawSelectionBox.addEventListener('touchmove', (e) => {
          const t = e.touches?.[0];
          if (!t) return;
          moveSelectionDragFromBox(t.clientX, t.clientY);
          e.preventDefault();
        }, { passive: false });
        drawSelectionBox.addEventListener('touchend', (e) => {
          commitSelectionDragFromBox();
          e.preventDefault();
        }, { passive: false });
      }
      const addTextStroke = async () => {
        const pos = lastCursorPos.x || lastCursorPos.y ? lastCursorPos : clientToDrawPoint(window.innerWidth / 2, window.innerHeight / 2);
        startTextInput(pos);
      };
      const startRDraw = () => {
        if (!drawMode || selectMode) return;
        if (rDrawActive) return;
        rDrawActive = true;
        if (!drawingStroke) {
          const pt = lastCursorPos.x || lastCursorPos.y ? lastCursorPos : clientToDrawPoint(window.innerWidth / 2, window.innerHeight / 2);
          beginStroke(pt, currentTool());
        }
      };
      const stopRDraw = () => {
        if (!rDrawActive) return;
        rDrawActive = false;
        finishStroke(true);
      };
      const startSizeAdjust = () => {
        if (!drawMode) return;
        sizeAdjustMode = true;
        sizeAdjustOrigin = Object.assign({}, lastCursorPos);
        sizeAdjustBaseWidth = currentWidth();
        sizeAdjustSmoothWidth = sizeAdjustBaseWidth;
        showSizePreview(sizeAdjustOrigin, sizeAdjustBaseWidth);
      };
      const stopSizeAdjust = () => {
        sizeAdjustMode = false;
        sizeAdjustOrigin = null;
        sizeAdjustBaseWidth = 0;
        hideSizePreview();
      };
      const adjustSizeWithCursor = (pt) => {
        if (!sizeAdjustMode || !drawDoc || !sizeAdjustOrigin) return;
        const dx = pt.x - sizeAdjustOrigin.x;
        const target = clampStrokeWidth(sizeAdjustBaseWidth + dx * 0.12);
        sizeAdjustSmoothWidth = sizeAdjustSmoothWidth * 0.65 + target * 0.35;
        setWidthForTool(sizeAdjustSmoothWidth);
        updateDrawControls();
        saveDrawDoc();
        showSizePreview(sizeAdjustOrigin, sizeAdjustSmoothWidth);
      };
      const toggleDrawModeHotkey = () => setDrawMode(!drawMode);
      document.addEventListener('mousemove', (e) => {
        lastCursorPos = clientToDrawPoint(e.clientX, e.clientY);
        if (sizeAdjustMode) adjustSizeWithCursor(lastCursorPos);
        if (rDrawActive && drawingStroke) addPointToStroke(lastCursorPos);
        if (textDragOffset && activeTextPos && drawCanvas) {
          const rect = drawCanvas.getBoundingClientRect();
          const dx = e.clientX - textDragOffset.x;
          const dy = e.clientY - textDragOffset.y;
          activeTextPos = {
            x: textDragOffset.origin.x + dx * (drawCanvas.width / (rect.width || 1)),
            y: textDragOffset.origin.y + dy * (drawCanvas.height / (rect.height || 1))
          };
          if (activeTextStroke) activeTextStroke.points = [activeTextPos];
          positionTextOverlay(activeTextPos);
          renderDrawDoc();
        }
        if (drawMode && drawTool === 'eraser' && !strokeEraseActive && !sizeAdjustMode) {
          showSizePreview(lastCursorPos, currentWidth());
        } else if (!sizeAdjustMode && !drawingStroke && !strokeEraseActive) {
          hideSizePreview();
        }
      });
      drawCanvas?.addEventListener('dblclick', (e) => {
        if (!selectMode || !selectedStroke?.stroke) return;
        if (selectedStroke.stroke.type === 'text') {
          const pt = drawPointFromEvent(e);
          startTextInput(pt, selectedStroke.stroke);
        }
      });
      const drawHotkeyHandler = (e) => {
        if (isTypingTarget(e.target)) return;
        if (state.viewerContext && !isBookViewerContext()) return;
        const k = e.key?.toLowerCase();
        if (k === 'x') {
          toggleDrawModeHotkey();
          e.preventDefault();
          e.stopPropagation();
          return;
        }
        if (!drawMode) return;
        if (k === 'r') {
          startRDraw();
          e.preventDefault();
          e.stopPropagation();
          return;
        }
        if (k === 'g') {
          startSizeAdjust();
          e.preventDefault();
          e.stopPropagation();
          return;
        }
        if (e.key === 'Tab') {
          e.preventDefault();
          e.stopPropagation();
          addTextStroke();
          return;
        }
        if (k === 'z' && e.ctrlKey) {
          e.preventDefault();
          e.stopPropagation();
          if (e.shiftKey) drawRedo();
          else drawUndo();
          return;
        }
        if (selectMode && selectedStroke?.stroke?.type === 'text' && k === 'enter') {
          e.preventDefault();
          startTextInput(selectedStroke.stroke.points?.[0] || lastCursorPos, selectedStroke.stroke);
          return;
        }
        if (k === 'escape' && selectMode) { setSelectMode(false); hideSelectionBox(); }
        if (k === 'escape' && stampPlacementActive) { stampPlacementActive = false; hideStampPreview(); }
      };
      const drawHotkeyUpHandler = (e) => {
        const k = e.key?.toLowerCase();
        if (k === 'r') { stopRDraw(); }
        if (k === 'g') { stopSizeAdjust(); }
        if (k === 'control') {
          ctrlOverrideTool = null;
          if (drawMode && drawTool !== 'eraser' && !strokeEraseActive && !sizeAdjustMode && !drawingStroke) {
            hideSizePreview();
          }
        }
      };
      document.addEventListener('keydown', drawHotkeyHandler, true);
      document.addEventListener('keyup', drawHotkeyUpHandler, true);
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
          flushDrawPersist();
          try { persistViewerPose?.(); } catch (_) { }
          // Flush pending saves for NLStore and TodoStore when tab becomes hidden
          if (typeof NLStore !== 'undefined' && NLStore.flushSync) {
            try { NLStore.flushSync(); } catch (_) { }
          }
          if (typeof TodoStore !== 'undefined' && TodoStore.flushSync) {
            try { TodoStore.flushSync(); } catch (_) { }
          }
          return;
        }
        // Tab復帰時にビューの座標を強制再適用してリセットを防止
        if (state.viewerContext === 'book' && book?.id && typeof loadViewerPose === 'function') {
          const savedPose = loadViewerPose(book.id);
          if (savedPose) {
            requestAnimationFrame(() => {
              const prevSuppress = suppressSmoothNextReset;
              suppressSmoothNextReset = true;
              if (typeof applySavedPoseInstant === 'function') applySavedPoseInstant(savedPose);
              else applySavedPose(savedPose);
              suppressSmoothNextReset = prevSuppress;
            });
          } else {
            requestAnimationFrame(() => applyViewTransform?.());
          }
        }
      });
      window.addEventListener('beforeunload', () => {
        if (activeDrawKey) { persistDrawLayer(activeDrawKey, true); flushDrawPersist(); }
        // Flush pending saves for NLStore and TodoStore
        if (typeof NLStore !== 'undefined' && NLStore.flushSync) {
          try { NLStore.flushSync(); } catch (_) { }
        }
        if (typeof TodoStore !== 'undefined' && TodoStore.flushSync) {
          try { TodoStore.flushSync(); } catch (_) { }
        }
      });
      window.addEventListener('pagehide', () => {
        if (activeDrawKey) { persistDrawLayer(activeDrawKey, true); flushDrawPersist(); }
        // Flush pending saves for NLStore and TodoStore
        if (typeof NLStore !== 'undefined' && NLStore.flushSync) {
          try { NLStore.flushSync(); } catch (_) { }
        }
        if (typeof TodoStore !== 'undefined' && TodoStore.flushSync) {
          try { TodoStore.flushSync(); } catch (_) { }
        }
      });
      drawToggleBtn?.addEventListener('click', (e) => { e.stopPropagation(); toggleDrawMode(); });
      drawToolBtn?.addEventListener('click', (e) => { e.stopPropagation(); toggleDrawTool(); });
      drawEraserModeBtn?.addEventListener('click', (e) => { e.stopPropagation(); toggleEraserMode(); renderDrawDoc(); });
      drawSettingsBtn?.addEventListener('click', (e) => { e.stopPropagation(); toggleDrawSettings(); });
      drawSelectBtn?.addEventListener('click', (e) => { e.stopPropagation(); setSelectMode(!selectMode); });
      drawUndoBtn?.addEventListener('click', (e) => { e.stopPropagation(); drawUndo(); });
      drawRedoBtn?.addEventListener('click', (e) => { e.stopPropagation(); drawRedo(); });
      drawResetBtn?.addEventListener('click', (e) => { e.stopPropagation(); resetDrawPage(); });
      drawLayerAdd?.addEventListener('click', (e) => { e.stopPropagation(); addLayer(); });
      drawLayerDelete?.addEventListener('click', (e) => { e.stopPropagation(); deleteLayer(); });
      drawLayerUp?.addEventListener('click', (e) => { e.stopPropagation(); moveLayer(-1); });
      drawLayerDown?.addEventListener('click', (e) => { e.stopPropagation(); moveLayer(1); });
      drawWidthInput?.addEventListener('input', () => {
        if (!drawDoc) return;
        drawDoc.penWidth = clampStrokeWidth(parseFloat(drawWidthInput.value) || DRAW_WIDTH);
        drawDoc.width = drawDoc.penWidth;
        updateDrawControls();
        saveDrawDoc();
      });
      drawWidthVal?.addEventListener('change', () => {
        if (!drawDoc) return;
        const v = clampStrokeWidth(parseFloat(drawWidthVal.value) || DRAW_WIDTH);
        drawDoc.penWidth = v; drawDoc.width = v;
        drawWidthInput.value = v;
        updateDrawControls();
        saveDrawDoc();
      });
      drawEraserWidthInput?.addEventListener('input', () => {
        if (!drawDoc) return;
        drawDoc.eraserWidth = clampStrokeWidth(parseFloat(drawEraserWidthInput.value) || ERASER_DEFAULT);
        updateDrawControls();
        saveDrawDoc();
      });
      drawEraserWidthVal?.addEventListener('change', () => {
        if (!drawDoc) return;
        const v = clampStrokeWidth(parseFloat(drawEraserWidthVal.value) || ERASER_DEFAULT);
        drawDoc.eraserWidth = v;
        drawEraserWidthInput.value = v;
        updateDrawControls();
        saveDrawDoc();
      });
      drawTextSizeInput?.addEventListener('input', () => {
        if (!drawDoc) return;
        drawDoc.textSize = clampTextSize(parseInt(drawTextSizeInput.value, 10) || 28);
        drawTextSizeVal.textContent = `${drawDoc.textSize}px`;
        saveDrawDoc();
        updateActiveTextStroke();
      });
      drawTextFontSelect?.addEventListener('change', () => {
        if (!drawDoc) return;
        drawDoc.textFont = drawTextFontSelect.value || 'system-ui, sans-serif';
        saveDrawDoc();
        updateActiveTextStroke();
      });
      drawBrushSelect?.addEventListener('change', () => {
        if (!drawDoc) return;
        drawDoc.brush = drawBrushSelect.value || 'smooth';
        saveDrawDoc();
      });
      drawFontUploadBtn?.addEventListener('click', () => drawFontUpload?.click());
      drawFontUpload?.addEventListener('change', (e) => {
        const file = e.target?.files?.[0];
        if (!file) return;
        const url = URL.createObjectURL(file);
        const name = file.name.replace(/\.[^/.]+$/, '') || `font-${Date.now()}`;
        addCustomFont(name, url);
        drawFontUpload.value = '';
      });
      drawShapeSelect?.addEventListener('change', () => {
        if (!drawDoc) return;
        drawDoc.shape = drawShapeSelect.value || 'free';
        shapeMode = drawDoc.shape;
        saveDrawDoc();
      });
      drawStampSelect?.addEventListener('change', () => {
        setActiveStamp(drawStampSelect.value || '');
      });
      drawStampSave?.addEventListener('click', (e) => {
        e.stopPropagation();
        registerStampFromSelection();
      });
      drawOpacityInput?.addEventListener('input', () => {
        if (!drawDoc) return;
        drawDoc.opacity = clampOpacity(parseFloat(drawOpacityInput.value) || 1);
        updateDrawControls();
        saveDrawDoc();
      });
      drawOpacityVal?.addEventListener('change', () => {
        if (!drawDoc) return;
        const v = clampOpacity(parseFloat(drawOpacityVal.value) || 1);
        drawDoc.opacity = v;
        drawOpacityInput.value = v;
        updateDrawControls();
        saveDrawDoc();
      });
      drawColorInput?.addEventListener('input', () => {
        if (!drawDoc) return;
        drawDoc.color = drawColorInput.value || DRAW_COLOR;
        saveRecentColor(drawDoc.color);
        saveDrawDoc();
      });
      drawShadowInput?.addEventListener('change', () => {
        if (!drawDoc) return;
        drawDoc.shadow = !!drawShadowInput.checked;
        saveDrawDoc();
      });
      drawGlowInput?.addEventListener('change', () => {
        if (!drawDoc) return;
        drawDoc.glow = !!drawGlowInput.checked;
        saveDrawDoc();
      });
      document.addEventListener('click', (e) => {
        if (!drawSettingsPanel?.classList.contains('open')) return;
        if (e.target.closest('.draw-settings-panel') || e.target.closest('#drawSettingsBtn')) return;
        closeDrawSettings();
      });
      // swipe-to-turn (quick horizontal flick)
      stage?.addEventListener('touchstart', (e) => {
        if (selecting || drawMode) return;
        if (interactiveTarget(e.target)) return;
        if (e.touches.length !== 1) { swipeStart = null; return; }
        const zoomNow = viewState.zoom || 1;
        const maxX = computeMaxPanX();
        const edgeRatio = maxX > 0 ? Math.abs(viewState.translateX) / (maxX || 1) : 1;
        const nearEdge = edgeRatio >= 0.9 || maxX <= 18;
        if (zoomNow > 1.02 && !nearEdge) { swipeStart = null; return; }
        const t = e.touches[0];
        swipeStart = { x: t.clientX, y: t.clientY, t: performance.now(), edgeRatio, maxX, zoom: zoomNow };
      }, { passive: true });
      stage?.addEventListener('touchmove', (e) => { if (e.touches.length > 1) swipeStart = null; }, { passive: true });
      stage?.addEventListener('touchend', (e) => {
        if (selecting || drawMode || stagePanning) return;
        const start = swipeStart; swipeStart = null;
        if (!start) return;
        const t = e.changedTouches && e.changedTouches[0]; if (!t) return;
        const dx = t.clientX - start.x;
        const dy = t.clientY - start.y;
        const dt = performance.now() - start.t;
        const maxX = computeMaxPanX();
        const edgeRatio = maxX > 0 ? Math.abs(viewState.translateX) / (maxX || 1) : 1;
        const nearEdge = edgeRatio > 0.9 || maxX <= 18;
        const zoomNow = viewState.zoom || 1;
        if (zoomNow > 1.02 && !nearEdge) return;
        if (!canTurnOutward(dx, maxX)) return;
        const distOk = Math.abs(dx) > 70 && Math.abs(dx) > Math.abs(dy) * 1.35;
        if (dt <= 360 && distOk) {
          if (dx < 0) goNext(); else goPrev();
        }
      }, { passive: true });
      stage?.addEventListener('mousedown', (e) => {
        if (!selecting) return;
        if (interactiveTarget(e.target)) return;
        e.preventDefault();
        startDrag(e, selectionSurfaces.single);
      });
      const docMoveSelection = (e) => { moveDrag(e); };
      const docUpSelection = (e) => { endDrag(e); };
      document.addEventListener('mousemove', docMoveSelection);
      document.addEventListener('mouseup', docUpSelection);
      document.addEventListener('mouseup', () => { textDragOffset = null; });
      document.addEventListener('pointerdown', (e) => {
        if (tapDrawActive && e.pointerType !== 'touch') endTapDraw();
      }, true);
      stage?.addEventListener('touchstart', (e) => {
        if (!selecting) return;
        if (interactiveTarget(e.target)) return;
        selectionPanOverride = e.touches.length > 1;
        if (e.touches.length === 1) {
          e.preventDefault();
          startDrag(e, selectionSurfaces.single);
        }
      }, { passive: false });
      stage?.addEventListener('touchmove', (e) => {
        if (!selecting) return;
        if (selectionPanOverride) return;
        e.preventDefault();
        moveDrag(e);
      }, { passive: false });
      stage?.addEventListener('touchend', (e) => {
        if (!selecting) return;
        if (selectionPanOverride && e.touches.length > 0) return;
        selectionPanOverride = false;
        e.preventDefault();
        endDrag(e);
      }, { passive: false });
      const docKeydownSelection = (e) => {
        if (e.key === 'Escape' && drawMode) {
          setDrawMode(false);
          return;
        }
        if (e.key === 'Escape' && (dragging || selecting)) {
          dragging = false;
          if (pendingAnswerCrop) { cancelAnswerCrop(); return; }
          selecting = false; syncSelectingUI();
        }
      };
      document.addEventListener('keydown', docKeydownSelection);

      // Joy-Con (L) gamepad control for pan/zoom
      let gamepadLoopId = null;
      let lastGamepadTs = 0;
      const lastGamepadButtons = new Map();
      let lastGamepadVibe = 0;
      let gamepadVibeLevel = 0;
      let gamepadVibeTarget = 0;
      let gamepadLastMoveTs = 0;
      const GAMEPAD_VIBE = false; // disable all rumble
      const joyconLeftMatcher = (id = '') => {
        const v = id.toLowerCase();
        return v.includes('joy-con') && v.includes('(l');
      };
      const pickLeftGamepad = () => {
        if (!navigator.getGamepads) return null;
        const pads = Array.from(navigator.getGamepads()).filter(Boolean);
        if (!pads.length) return null;
        return pads.find(p => joyconLeftMatcher(p.id || '')) || pads[0];
      };
      const buttonPressed = (pad, idx) => {
        const b = pad?.buttons?.[idx];
        return !!(b && (b.pressed || b.value > 0.35));
      };
      const buttonJustPressed = (pad, idx) => {
        const prev = lastGamepadButtons.get(idx) || false;
        const curr = buttonPressed(pad, idx);
        lastGamepadButtons.set(idx, curr);
        return curr && !prev;
      };
      const gamepadPan = (dx, dy) => {
        if (mode !== 'single' || panLocked) return;
        viewState.translateX += dx;
        viewState.translateY += dy;
        viewState.userAdjusted = true;
        applyViewTransform();
        hideInteractionHint();
      };
      const gamepadZoom = (dir, dt) => {
        if (zoomLocked) return;
        const step = 0.045 * (dt / 16);
        const factor = dir > 0 ? (1 + step) : (1 - step);
        setZoom(viewState.zoom * factor, { anchor: stageAnchorCenter() });
      };
      const gamepadTick = (ts) => {
        const pad = pickLeftGamepad();
        if (!pad) {
          stopGamepadLoop();
          return;
        }
        const dt = lastGamepadTs ? Math.max(8, Math.min(40, ts - lastGamepadTs)) : 16;
        lastGamepadTs = ts;
        const now = performance.now();
        const dead = 0.22;
        const norm = (v) => Math.abs(v) < dead ? 0 : v;
        const rawX = norm(pad.axes?.[0] || 0);
        const rawY = norm(pad.axes?.[1] || 0);
        // Joy-Con (L) 縦持ち: 90°回転＋左右だけ反転
        const axX = rawY;      // 左右のみ反転（前ステップから符号を戻す）
        const axY = rawX * -1; // 元の rawX をさらに反転
        if (axX || axY) {
          const panScale = 20 * (dt / 16);
          gamepadPan(axX * panScale, axY * panScale);
          gamepadLastMoveTs = now;
          const mag = Math.min(1, Math.hypot(axX, axY));
          if (GAMEPAD_VIBE) {
            gamepadVibeTarget = Math.max(gamepadVibeTarget, 0.12 + mag * 0.2);
          }
        } else if (now - gamepadLastMoveTs > 200) {
          if (GAMEPAD_VIBE) {
            gamepadVibeTarget *= 0.88; // fade target when idle
            if (gamepadVibeTarget < 0.02) gamepadVibeTarget = 0;
          } else {
            gamepadVibeTarget = 0;
          }
        }
        const zoomIn = buttonPressed(pad, 4) || buttonPressed(pad, 10); // L / SL
        const zoomOut = buttonPressed(pad, 6) || buttonPressed(pad, 11); // ZL / SR
        if (zoomIn !== zoomOut) {
          // ズーム方向も反転
          gamepadZoom(zoomIn ? -1 : 1, dt);
        }
        // rumble disabled
        gamepadVibeLevel = 0;
        gamepadVibeTarget = 0;
        if (buttonJustPressed(pad, 8)) { // Minus to reset view
          resetViewState({ toast: false });
        }
        gamepadLoopId = requestAnimationFrame(gamepadTick);
      };
      const startGamepadLoop = () => {
        if (gamepadLoopId) return;
        const hasPad = navigator.getGamepads ? Array.from(navigator.getGamepads()).some(Boolean) : false;
        if (!hasPad) return;
        gamepadLoopId = requestAnimationFrame(gamepadTick);
      };
      const stopGamepadLoop = () => {
        if (gamepadLoopId) { cancelAnimationFrame(gamepadLoopId); gamepadLoopId = null; }
        lastGamepadTs = 0;
        lastGamepadButtons.clear();
        lastGamepadVibe = 0;
        gamepadVibeLevel = 0;
        gamepadVibeTarget = 0;
        gamepadLastMoveTs = 0;
      };
      window.addEventListener('gamepadconnected', startGamepadLoop);
      window.addEventListener('gamepaddisconnected', () => {
        const any = navigator.getGamepads ? Array.from(navigator.getGamepads()).some(Boolean) : false;
        if (!any) stopGamepadLoop();
      });
      startGamepadLoop();

      // ---- Keyboard pan/zoom (arrow keys + . / \ _ with IME-friendly code fallbacks)
      const isTypingTarget = (el) => {
        if (!el) return false;
        if (el.closest('input, textarea, select')) return true;
        if (el.isContentEditable) return true;
        return false;
      };
      const easeSmooth = (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2; // legacy; kept for reference
      const PAN_DURATION = 320;
      const ZOOM_DURATION = 280;
      const KEY_SLOW_FACTOR = 0.35;
      const ACTIVE_PAN_DECAY = ACTIVE_PAN_DECAY_DEFAULT;
      const ACTIVE_ZOOM_DECAY = ACTIVE_ZOOM_DECAY_DEFAULT;
      const getPanDecay = () => clampInertia(keyNavConfig.panDecay ?? DEFAULT_KEY_NAV_CONFIG.panDecay); // per ms decay
      const getZoomDecay = () => clampInertia(keyNavConfig.zoomDecay ?? DEFAULT_KEY_NAV_CONFIG.zoomDecay);
      let keySlow = false;
      let panInputActive = false, zoomInputActive = false;
      let panHoldCount = 0, zoomHoldCount = 0;
      let comparePanHoldCount = 0, compareZoomHoldCount = 0;
      const syncInputActiveFlags = () => {
        panInputActive = (panHoldCount + comparePanHoldCount) > 0;
        zoomInputActive = (zoomHoldCount + compareZoomHoldCount) > 0;
      };
      const markPanHold = (delta) => { panHoldCount = Math.max(0, panHoldCount + delta); syncInputActiveFlags(); };
      const markZoomHold = (delta) => { zoomHoldCount = Math.max(0, zoomHoldCount + delta); syncInputActiveFlags(); };
      const markComparePanHold = (delta) => { comparePanHoldCount = Math.max(0, comparePanHoldCount + delta); syncInputActiveFlags(); };
      const markCompareZoomHold = (delta) => { compareZoomHoldCount = Math.max(0, compareZoomHoldCount + delta); syncInputActiveFlags(); };
      const getActivePaneController = () => {
        if (mode === 'single') return null;
        if (activePane === 'right' && !compareRightHidden && rightPaneController) return rightPaneController;
        return leftPaneController || null;
      };
      let panAnimId = null, panLastTs = 0;
      let panVel = { x: 0, y: 0 };
      const runSmoothPan = (dx, dy, dt = 16, { slow } = {}) => {
        const paneCtrl = getActivePaneController();
        if (mode === 'single' || !paneCtrl) {
          if (panLocked || dragging) return;
          const base = keyNavConfig.panStep || DEFAULT_KEY_NAV_CONFIG.panStep;
          const panScale = (slow !== undefined ? slow : keySlow) ? KEY_SLOW_FACTOR : 1;
          const zoomScale = 1 + Math.max(0, viewState.zoom - 1) * 0.7;
          const distX = dx * base * zoomScale * panScale;
          const distY = dy * base * zoomScale * panScale;
          const impulse = (dt / 16) / Math.max(75, PAN_DURATION);
          panVel.x += distX * impulse;
          panVel.y += distY * impulse;
          if (panAnimId) { return; }
          const step = (ts) => {
            if (!panLastTs) panLastTs = ts;
            const dt = Math.min(48, ts - panLastTs || 0);
            panLastTs = ts;
            viewState.translateX += panVel.x * dt;
            viewState.translateY += panVel.y * dt;
            applyViewTransform();
            const decay = Math.pow(panInputActive ? ACTIVE_PAN_DECAY : getPanDecay(), dt);
            panVel.x *= decay;
            panVel.y *= decay;
            if (Math.abs(panVel.x) + Math.abs(panVel.y) < 0.001) {
              panVel = { x: 0, y: 0 };
              panLastTs = 0;
              panAnimId = null;
              return;
            }
            panAnimId = requestAnimationFrame(step);
          };
          panAnimId = requestAnimationFrame(step);
          return;
        }
        if (panLocked) return;
        const base = keyNavConfig.panStep || DEFAULT_KEY_NAV_CONFIG.panStep;
        const panScale = (slow !== undefined ? slow : keySlow) ? KEY_SLOW_FACTOR : 1;
        const state = paneCtrl.getState();
        const zoomScale = 1 + Math.max(0, state.zoom - 1) * 0.7;
        const distX = dx * base * zoomScale * panScale;
        const distY = dy * base * zoomScale * panScale;
        const impulse = (dt / 16) / Math.max(75, PAN_DURATION);
        paneCtrl.nav.panVel.x += distX * impulse;
        paneCtrl.nav.panVel.y += distY * impulse;
        if (paneCtrl.nav.panAnimId) { return; }
        const step = (ts) => {
          if (!paneCtrl.nav.panLastTs) paneCtrl.nav.panLastTs = ts;
          const dt = Math.min(48, ts - paneCtrl.nav.panLastTs || 0);
          paneCtrl.nav.panLastTs = ts;
          paneCtrl.panBy(paneCtrl.nav.panVel.x * dt, paneCtrl.nav.panVel.y * dt);
          const decay = Math.pow(panInputActive ? ACTIVE_PAN_DECAY : getPanDecay(), dt);
          paneCtrl.nav.panVel.x *= decay;
          paneCtrl.nav.panVel.y *= decay;
          if (Math.abs(paneCtrl.nav.panVel.x) + Math.abs(paneCtrl.nav.panVel.y) < 0.001) {
            paneCtrl.nav.panVel = { x: 0, y: 0 };
            paneCtrl.nav.panLastTs = 0;
            paneCtrl.nav.panAnimId = null;
            return;
          }
          paneCtrl.nav.panAnimId = requestAnimationFrame(step);
        };
        paneCtrl.nav.panAnimId = requestAnimationFrame(step);
      };
      let comparePanAnimId = null, comparePanLastTs = 0;
      let comparePanVel = { x: 0, y: 0 };
      const runCompareSmoothPan = (dx, dy, dt = 16, { slow } = {}) => {
        if (!compareWindowOpen || !compareWindowBook) return;
        if (comparePanLocked) return;
        const base = (keyNavConfig.panStep || DEFAULT_KEY_NAV_CONFIG.panStep) * 0.55;
        const panScale = (slow !== undefined ? slow : keySlow) ? KEY_SLOW_FACTOR : 1;
        const zoomScale = 1 + Math.max(0, compareZoom - 1) * 0.7;
        const distX = dx * base * zoomScale * panScale;
        const distY = dy * base * zoomScale * panScale;
        const impulse = (dt / 16) / Math.max(75, PAN_DURATION);
        comparePanVel.x += distX * impulse;
        comparePanVel.y += distY * impulse;
        if (comparePanAnimId) { return; }
        const step = (ts) => {
          if (!comparePanLastTs) comparePanLastTs = ts;
          const delta = Math.min(48, ts - comparePanLastTs || 0);
          comparePanLastTs = ts;
          comparePan.x += comparePanVel.x * delta;
          comparePan.y += comparePanVel.y * delta;
          applyCompareTransform();
          const decay = Math.pow(panInputActive ? ACTIVE_PAN_DECAY : getPanDecay(), delta);
          comparePanVel.x *= decay;
          comparePanVel.y *= decay;
          if (Math.abs(comparePanVel.x) + Math.abs(comparePanVel.y) < 0.001) {
            comparePanVel = { x: 0, y: 0 };
            comparePanLastTs = 0;
            comparePanAnimId = null;
            return;
          }
          comparePanAnimId = requestAnimationFrame(step);
        };
        comparePanAnimId = requestAnimationFrame(step);
      };
      let zoomAnimId = null, zoomLastTs = 0;
      let zoomVel = 0;
      const runSmoothZoom = (direction, dt = 16, { slow } = {}) => {
        const paneCtrl = getActivePaneController();
        if (mode === 'single' || !paneCtrl) {
          if (zoomLocked) return;
          refreshZoomBounds();
          const stepVal = keyNavConfig.zoomStep || DEFAULT_KEY_NAV_CONFIG.zoomStep;
          const scaleLog = Math.log(stepVal);
          const scaledLog = (slow !== undefined ? slow : keySlow) ? scaleLog * KEY_SLOW_FACTOR : scaleLog;
          const baseFactor = Math.exp(scaledLog);
          const factor = direction > 0 ? baseFactor : 1 / baseFactor; // symmetric zoom-in/out speed
          const targetZoom = Math.max(viewState.minZoom, Math.min(viewState.maxZoom, viewState.zoom * factor));
          const startZoom = viewState.zoom;
          const deltaZoom = targetZoom - startZoom;
          if (Math.abs(deltaZoom) < 0.0001) return;
          const impulse = (dt / 16) / Math.max(70, ZOOM_DURATION);
          zoomVel += deltaZoom * impulse;
          if (zoomAnimId) { return; }
          const step = (ts) => {
            if (!zoomLastTs) zoomLastTs = ts;
            const dt = Math.min(48, ts - zoomLastTs || 0);
            zoomLastTs = ts;
            const next = viewState.zoom + zoomVel * dt;
            setZoom(next, { anchor: stageAnchorCenter(), silent: false, skipClamp: !keyNavConfig.bookClamp });
            const decay = Math.pow(zoomInputActive ? ACTIVE_ZOOM_DECAY : getZoomDecay(), dt);
            zoomVel *= decay;
            if (Math.abs(zoomVel) < 0.000005) {
              zoomVel = 0;
              zoomLastTs = 0;
              zoomAnimId = null;
              return;
            }
            zoomAnimId = requestAnimationFrame(step);
          };
          zoomAnimId = requestAnimationFrame(step);
          return;
        }
        if (zoomLocked) return;
        const stepVal = keyNavConfig.zoomStep || DEFAULT_KEY_NAV_CONFIG.zoomStep;
        const scaleLog = Math.log(stepVal);
        const scaledLog = (slow !== undefined ? slow : keySlow) ? scaleLog * KEY_SLOW_FACTOR : scaleLog;
        const baseFactor = Math.exp(scaledLog);
        const factor = direction > 0 ? baseFactor : 1 / baseFactor;
        const state = paneCtrl.getState();
        const min = state.minZoom || 0.4;
        const max = state.maxZoom || 6;
        const targetZoom = Math.max(min, Math.min(max, state.zoom * factor));
        const startZoom = state.zoom;
        const deltaZoom = targetZoom - startZoom;
        if (Math.abs(deltaZoom) < 0.0001) return;
        const impulse = (dt / 16) / Math.max(70, ZOOM_DURATION);
        paneCtrl.nav.zoomVel += deltaZoom * impulse;
        if (paneCtrl.nav.zoomAnimId) { return; }
        const step = (ts) => {
          if (!paneCtrl.nav.zoomLastTs) paneCtrl.nav.zoomLastTs = ts;
          const dt = Math.min(48, ts - paneCtrl.nav.zoomLastTs || 0);
          paneCtrl.nav.zoomLastTs = ts;
          const next = state.zoom + paneCtrl.nav.zoomVel * dt;
          paneCtrl.setZoomValue(next, { anchor: { x: 0, y: 0 } });
          const decay = Math.pow(zoomInputActive ? ACTIVE_ZOOM_DECAY : getZoomDecay(), dt);
          paneCtrl.nav.zoomVel *= decay;
          if (Math.abs(paneCtrl.nav.zoomVel) < 0.000005) {
            paneCtrl.nav.zoomVel = 0;
            paneCtrl.nav.zoomLastTs = 0;
            paneCtrl.nav.zoomAnimId = null;
            return;
          }
          paneCtrl.nav.zoomAnimId = requestAnimationFrame(step);
        };
        paneCtrl.nav.zoomAnimId = requestAnimationFrame(step);
      };
      let compareZoomAnimId = null, compareZoomLastTs = 0, compareZoomVel = 0;
      const runCompareSmoothZoom = (direction, dt = 16, { slow } = {}) => {
        if (!compareWindowOpen || !compareWindowBook) return;
        if (compareZoomLocked) return;
        refreshCompareZoomBounds();
        const stepVal = 1 + ((keyNavConfig.zoomStep || DEFAULT_KEY_NAV_CONFIG.zoomStep) - 1) * 0.6;
        const scaleLog = Math.log(stepVal);
        const scaledLog = (slow !== undefined ? slow : keySlow) ? scaleLog * KEY_SLOW_FACTOR : scaleLog;
        const baseFactor = Math.exp(scaledLog);
        const factor = direction > 0 ? baseFactor : 1 / baseFactor;
        const targetZoom = Math.max(compareMinZoom, Math.min(compareMaxZoom, compareZoom * factor));
        const anchor = compareStageAnchorCenter();
        const startZoom = compareZoom;
        const deltaZoom = targetZoom - startZoom;
        if (Math.abs(deltaZoom) < 0.0001) return;
        const impulse = (dt / 16) / Math.max(70, ZOOM_DURATION);
        compareZoomVel += deltaZoom * impulse;
        if (compareZoomAnimId) { return; }
        const step = (ts) => {
          if (!compareZoomLastTs) compareZoomLastTs = ts;
          const delta = Math.min(48, ts - compareZoomLastTs || 0);
          compareZoomLastTs = ts;
          const next = compareZoom + compareZoomVel * delta;
          setCompareZoom(next, { anchor });
          const decay = Math.pow(zoomInputActive ? ACTIVE_ZOOM_DECAY : getZoomDecay(), delta);
          compareZoomVel *= decay;
          if (Math.abs(compareZoomVel) < 0.000005) {
            compareZoomVel = 0;
            compareZoomLastTs = 0;
            compareZoomAnimId = null;
            return;
          }
          compareZoomAnimId = requestAnimationFrame(step);
        };
        compareZoomAnimId = requestAnimationFrame(step);
      };
      const normKeys = (arr, fallback) => Array.isArray(arr) ? arr : fallback;
      const matchKey = (e, keys, codes) => keys.includes(e.key) || codes.includes(e.code);
      const getKeyBindings = () => {
        return {
          panLeftKeys: normKeys(keyNavConfig.panLeftKeys, DEFAULT_KEY_NAV_CONFIG.panLeftKeys),
          panRightKeys: normKeys(keyNavConfig.panRightKeys, DEFAULT_KEY_NAV_CONFIG.panRightKeys),
          panUpKeys: normKeys(keyNavConfig.panUpKeys, DEFAULT_KEY_NAV_CONFIG.panUpKeys),
          panDownKeys: normKeys(keyNavConfig.panDownKeys, DEFAULT_KEY_NAV_CONFIG.panDownKeys),
          zoomInKeys: normKeys(keyNavConfig.zoomInKeys, DEFAULT_KEY_NAV_CONFIG.zoomInKeys),
          zoomInCodes: normKeys(keyNavConfig.zoomInCodes, DEFAULT_KEY_NAV_CONFIG.zoomInCodes),
          zoomOutKeys: normKeys(keyNavConfig.zoomOutKeys, DEFAULT_KEY_NAV_CONFIG.zoomOutKeys),
          zoomOutCodes: normKeys(keyNavConfig.zoomOutCodes, DEFAULT_KEY_NAV_CONFIG.zoomOutCodes),
          pageNextKeys: normKeys(keyNavConfig.pageNextKeys, DEFAULT_KEY_NAV_CONFIG.pageNextKeys),
          pagePrevKeys: normKeys(keyNavConfig.pagePrevKeys, DEFAULT_KEY_NAV_CONFIG.pagePrevKeys),
          pageNextCodes: normKeys(keyNavConfig.pageNextCodes, DEFAULT_KEY_NAV_CONFIG.pageNextCodes),
          pagePrevCodes: normKeys(keyNavConfig.pagePrevCodes, DEFAULT_KEY_NAV_CONFIG.pagePrevCodes),
          resetKeys: normKeys(keyNavConfig.resetKeys, DEFAULT_KEY_NAV_CONFIG.resetKeys),
          resetCodes: normKeys(keyNavConfig.resetCodes, DEFAULT_KEY_NAV_CONFIG.resetCodes),
          answerToggleKeys: normKeys(keyNavConfig.answerToggleKeys, DEFAULT_KEY_NAV_CONFIG.answerToggleKeys),
          answerToggleCodes: normKeys(keyNavConfig.answerToggleCodes, DEFAULT_KEY_NAV_CONFIG.answerToggleCodes),
          studyMenuKeys: normKeys(keyNavConfig.studyMenuKeys, DEFAULT_KEY_NAV_CONFIG.studyMenuKeys),
          studyMenuCodes: normKeys(keyNavConfig.studyMenuCodes, DEFAULT_KEY_NAV_CONFIG.studyMenuCodes)
        };
      };
      const installStudyMenuHotkeyGlobal = () => {
        const normKey = (s) => (s || '').toLowerCase().trim();
        const match = (e, keys, codes) => keys.map(normKey).includes(normKey(e.key)) || codes.map(normKey).includes(normKey(e.code));
        const handler = (e) => {
          if (typeof isTypingTarget === 'function' && isTypingTarget(e.target)) return;
          const viewerActive = typeof state !== 'undefined' && (state.viewerContext === 'book' || state.viewerContext === 'box');
          if (viewerActive) return; // viewer内は専用ハンドラに任せる
          const { studyMenuKeys, studyMenuCodes } = getKeyBindings();
          if (!match(e, studyMenuKeys || [], studyMenuCodes || [])) return;
          e.preventDefault(); e.stopPropagation();
          try { StudyActionMenu && StudyActionMenu.toggle && StudyActionMenu.toggle({ source: 'global-key' }); renderPageProgressOverlay && renderPageProgressOverlay(); } catch (_) { }
        };
        if (window.__studyMenuHotkey) document.removeEventListener('keydown', window.__studyMenuHotkey);
        window.__studyMenuHotkey = handler;
        document.addEventListener('keydown', handler);
      };
      window.installStudyMenuHotkeyGlobal = installStudyMenuHotkeyGlobal;
      installStudyMenuHotkeyGlobal();
      const getActionBindings = () => {
        const current = keyNavConfig.actionBindings || {};
        const defaults = DEFAULT_KEY_NAV_CONFIG.actionBindings || {};
        const map = {};
        KEY_ACTION_DEFS.forEach(def => {
          map[def.id] = normKeys(current[def.id], defaults[def.id] || []);
        });
        return map;
      };
      const heldFns = new Map();
      let heldRaf = null, heldLastTs = 0;
      const handleShiftFlag = (e) => {
        if (e.key !== 'Shift') return;
        const active = e.type === 'keydown';
        keySlow = active;
        if (pageHoldDir !== null) pageHoldShift = active;
        if (typeof rightHoldDir !== 'undefined' && rightHoldDir !== null) rightHoldShift = active;
      };
      document.addEventListener('keydown', handleShiftFlag);
      document.addEventListener('keyup', (e) => {
        handleShiftFlag(e);
        if (e.key === 'Shift') stopAllPansAndZooms();
      });
      window.addEventListener('blur', () => {
        keySlow = false;
        pageHoldShift = false;
        if (typeof rightHoldShift !== 'undefined') rightHoldShift = false;
        stopAllPansAndZooms();
      });
      const pumpHeld = (ts) => {
        if (!heldLastTs) heldLastTs = ts;
        const dt = Math.min(60, ts - heldLastTs || 0);
        heldLastTs = ts;
        heldFns.forEach(fn => fn(dt));
        if (!heldFns.size) { heldRaf = null; heldLastTs = 0; return; }
        heldRaf = requestAnimationFrame(pumpHeld);
      };
      const startHold = (key, fn) => {
        if (heldFns.has(key)) return;
        heldFns.set(key, (dt) => fn(dt || 16));
        fn(16);
        if (!heldRaf) heldRaf = requestAnimationFrame(pumpHeld);
      };
      const stopHold = (key) => {
        heldFns.delete(key);
        if (!heldFns.size && heldRaf) { cancelAnimationFrame(heldRaf); heldRaf = null; heldLastTs = 0; }
      };
      const stopAllPansAndZooms = () => {
        ['panLeft', 'panRight', 'panUp', 'panDown', 'comparePanLeft', 'comparePanRight', 'comparePanUp', 'comparePanDown', 'compareZoomIn', 'compareZoomOut', 'zoomIn', 'zoomOut'].forEach(stopHold);
        stopPageTurbo();
        stopCompareTurbo();
        panVel = { x: 0, y: 0 }; panLastTs = 0; if (panAnimId) { cancelAnimationFrame(panAnimId); panAnimId = null; }
        comparePanVel = { x: 0, y: 0 }; comparePanLastTs = 0; if (comparePanAnimId) { cancelAnimationFrame(comparePanAnimId); comparePanAnimId = null; }
        zoomVel = 0; zoomLastTs = 0; if (zoomAnimId) { cancelAnimationFrame(zoomAnimId); zoomAnimId = null; }
        compareZoomVel = 0; compareZoomLastTs = 0; if (compareZoomAnimId) { cancelAnimationFrame(compareZoomAnimId); compareZoomAnimId = null; }
        panHoldCount = 0; comparePanHoldCount = 0; zoomHoldCount = 0; compareZoomHoldCount = 0;
        syncInputActiveFlags();
      };
      const stopCompareKeyHolds = () => {
        ['comparePanLeft', 'comparePanRight', 'comparePanUp', 'comparePanDown', 'compareZoomIn', 'compareZoomOut'].forEach(stopHold);
        stopCompareTurbo();
        if (comparePanAnimId) { cancelAnimationFrame(comparePanAnimId); comparePanAnimId = null; }
        comparePanVel = { x: 0, y: 0 }; comparePanLastTs = 0;
        if (compareZoomAnimId) { cancelAnimationFrame(compareZoomAnimId); compareZoomAnimId = null; }
        compareZoomVel = 0; compareZoomLastTs = 0;
        comparePanHoldCount = 0; compareZoomHoldCount = 0;
        syncInputActiveFlags();
      };
      const clearAllHolds = () => {
        heldFns.clear();
        if (heldRaf) { cancelAnimationFrame(heldRaf); heldRaf = null; }
        heldLastTs = 0;
        panHoldCount = 0; zoomHoldCount = 0;
        comparePanHoldCount = 0; compareZoomHoldCount = 0;
        syncInputActiveFlags();
        if (comparePanAnimId) { cancelAnimationFrame(comparePanAnimId); comparePanAnimId = null; }
        comparePanVel = { x: 0, y: 0 }; comparePanLastTs = 0;
        if (compareZoomAnimId) { cancelAnimationFrame(compareZoomAnimId); compareZoomAnimId = null; }
        compareZoomVel = 0; compareZoomLastTs = 0;
        stopCompareTurbo();
      };
      let turboHintRight = false; // true while右側ターボ中（比較用）
      const isTurboActive = () => pageHoldDir !== null || turboHintRight;

      // Performance mode management for turbo page turning
      let turboPerformanceActive = false;
      const enterTurboPerformanceMode = () => {
        if (turboPerformanceActive) return;
        turboPerformanceActive = true;
        // Add performance-mode class to disable animations
        document.body.classList.add('performance-mode');
        // Pause non-essential intervals by setting a flag
        window.__turboModeActive = true;
      };
      const exitTurboPerformanceMode = () => {
        if (!turboPerformanceActive) return;
        turboPerformanceActive = false;
        document.body.classList.remove('performance-mode');
        window.__turboModeActive = false;
      };
      const computeTurboInterval = (elapsed, shift) => {
        const cfg = getPageTurboConfig(shift);
        const initialDelay = cfg.initialDelay;
        const base = cfg.base;
        const min = cfg.min;
        const accelWindow = cfg.accelWindow;
        const progress = Math.min(1, Math.max(0, (elapsed - initialDelay) / accelWindow));
        const eased = progress * progress;
        return Math.max(min, base - (base - min) * eased);
      };
      let pageHoldDir = null, pageHoldId = null, pageHoldStart = 0, pageHoldLast = 0, pageHoldFired = false, pageHoldShift = false;
      const computePageTurboInterval = (elapsed, initialDelay) => {
        return computeTurboInterval(elapsed, pageHoldShift);
      };
      const stopPageTurbo = () => {
        if (pageHoldId) { cancelAnimationFrame(pageHoldId); pageHoldId = null; }
        const fired = pageHoldFired;
        pageHoldDir = null;
        pageHoldStart = 0;
        pageHoldLast = 0;
        pageHoldFired = false;
        pageHoldShift = false;
        __pageTurboActive = false;
        if (!isTurboActive() && pendingTurboRefresh) {
          cancelIdle(pendingTurboIdle);
          pendingTurboIdle = null;
          pendingTurboRefresh = false;
          flushPostLoad();
        }
        return fired;
      };
      const stepPageTurbo = (ts) => {
        if (!pageHoldDir) return;
        if (!pageHoldStart) pageHoldStart = ts;
        const elapsed = ts - pageHoldStart;
        const cfg = getPageTurboConfig(pageHoldShift);
        const initialDelay = cfg.initialDelay;
        const interval = computePageTurboInterval(elapsed, initialDelay);
        const readyFirst = !pageHoldLast && elapsed >= initialDelay;
        const readyNext = !!pageHoldLast && ts - pageHoldLast >= interval;
        if (readyFirst || readyNext) {
          pageHoldFired = true;
          (pageHoldDir === 'next' ? goNext : goPrev)();
          pageHoldLast = ts;
        }
        pageHoldId = requestAnimationFrame(stepPageTurbo);
      };
      const startPageTurbo = (dir, { fireNow = false, boost = false } = {}) => {
        if (pageHoldDir === dir && pageHoldShift === !!boost) return;
        stopPageTurbo();
        pageHoldDir = dir;
        pageHoldShift = !!boost;
        __pageTurboActive = true;
        if (fireNow) {
          const now = performance.now();
          pageHoldStart = now;
          pageHoldLast = now;
          pageHoldFired = true;
          (dir === 'next' ? goNext : goPrev)();
        }
        pageHoldId = requestAnimationFrame(stepPageTurbo);
      };
      let suppressPageClick = false;
      const handleKeyboardNav = (e) => {
        if (!isBookViewerContext()) return;
        if (isTypingTarget(e.target)) return;
        const {
          panLeftKeys, panRightKeys, panUpKeys, panDownKeys,
          zoomInKeys, zoomInCodes, zoomOutKeys, zoomOutCodes,
          pageNextKeys, pagePrevKeys, pageNextCodes, pagePrevCodes,
          resetKeys, resetCodes,
          answerToggleKeys, answerToggleCodes,
          studyMenuKeys, studyMenuCodes
        } = getKeyBindings();
        const normKey = (s) => (s || '').toLowerCase().trim();
        const match = (keys, codes) => keys.map(normKey).includes(normKey(e.key)) || codes.map(normKey).includes(normKey(e.code));
        const k = e.key;
        const useAnswerWindow = e.ctrlKey && compareWindowOpen && !!compareWindowBook;
        let handled = false;

        // Alt + Arrow Navigation for Miss Messages (HIGHEST PRIORITY)
        // Must be checked before page navigation keys
        if (!handled && e.altKey && (e.key === 'ArrowRight' || e.key === 'ArrowLeft' || e.key === 'ArrowDown' || e.key === 'ArrowUp')) {
          if (e.key === 'ArrowDown') {
            if (typeof window.__missMessageFocusBelow === 'function' && window.__missMessageFocusBelow()) {
              e.preventDefault(); handled = true;
            }
          } else if (e.key === 'ArrowUp') {
            if (typeof window.__missMessageFocusAbove === 'function' && window.__missMessageFocusAbove()) {
              e.preventDefault(); handled = true;
            }
          } else {
            // Left/Right -> Cycle Mode
            if (typeof window.__cycleMissMessageMode === 'function') {
              window.__cycleMissMessageMode();
              e.preventDefault(); handled = true;
            }
          }
        }

        if (!handled && viewerClockConfig.toggleKey && matchHotkey(e, viewerClockConfig.toggleKey)) {
          toggleViewerClock();
          handled = true;
          renderNumberlineFly();
        }
        if (!handled && flyClockConfig.planner?.key && matchHotkey(e, flyClockConfig.planner.key)) {
          togglePlannerFly();
          handled = true;
        }
        if (!handled && flyClockConfig.numberline?.key && matchHotkey(e, flyClockConfig.numberline.key)) {
          toggleNumberlineFly();
          handled = true;
        }
        if (!handled && match(pageNextKeys, pageNextCodes)) {
          if (useAnswerWindow) {
            stopPageTurbo();
            startCompareTurbo('next', { fireNow: true, boost: e.shiftKey });
          } else {
            startPageTurbo('next', { fireNow: true, boost: e.shiftKey });
          }
          handled = true;
        }
        else if (!handled && match(pagePrevKeys, pagePrevCodes)) {
          if (useAnswerWindow) {
            stopPageTurbo();
            startCompareTurbo('prev', { fireNow: true, boost: e.shiftKey });
          } else {
            startPageTurbo('prev', { fireNow: true, boost: e.shiftKey });
          }
          handled = true;
        }
        else if (!handled && match(answerToggleKeys, answerToggleCodes)) {
          toggleAnswerWindowHotkey(); handled = true;
        }
        else if (!handled && match(studyMenuKeys, studyMenuCodes)) {
          try { StudyActionMenu && StudyActionMenu.toggle && StudyActionMenu.toggle({ source: 'keybind' }); handled = true; renderPageProgressOverlay(); } catch (_) { }
        }
        else if (!handled && match(panLeftKeys, [])) {
          if (useAnswerWindow) {
            markComparePanHold(+1);
            startHold('comparePanLeft', (dt) => runCompareSmoothPan(1, 0, dt));
          } else {
            markPanHold(+1); startHold('panLeft', (dt) => runSmoothPan(1, 0, dt));
          }
          handled = true;
        }
        else if (!handled && match(panRightKeys, [])) {
          if (useAnswerWindow) {
            markComparePanHold(+1);
            startHold('comparePanRight', (dt) => runCompareSmoothPan(-1, 0, dt));
          } else {
            markPanHold(+1); startHold('panRight', (dt) => runSmoothPan(-1, 0, dt));
          }
          handled = true;
        }
        else if (!handled && match(panUpKeys, [])) {
          if (useAnswerWindow) {
            markComparePanHold(+1);
            startHold('comparePanUp', (dt) => runCompareSmoothPan(0, 1, dt));
          } else {
            markPanHold(+1); startHold('panUp', (dt) => runSmoothPan(0, 1, dt));
          }
          handled = true;
        }
        else if (!handled && match(panDownKeys, [])) {
          if (useAnswerWindow) {
            markComparePanHold(+1);
            startHold('comparePanDown', (dt) => runCompareSmoothPan(0, -1, dt));
          } else {
            markPanHold(+1); startHold('panDown', (dt) => runSmoothPan(0, -1, dt));
          }
          handled = true;
        }
        else if (!handled && match(zoomInKeys, zoomInCodes)) {
          if (useAnswerWindow) {
            markCompareZoomHold(+1);
            startHold('compareZoomIn', (dt) => runCompareSmoothZoom(1, dt));
          } else {
            markZoomHold(+1); startHold('zoomIn', (dt) => runSmoothZoom(1, dt, { slow: e.shiftKey }));
          }
          handled = true;
        }
        else if (!handled && match(zoomOutKeys, zoomOutCodes)) {
          if (useAnswerWindow) {
            markCompareZoomHold(+1);
            startHold('compareZoomOut', (dt) => runCompareSmoothZoom(-1, dt));
          } else {
            markZoomHold(+1); startHold('zoomOut', (dt) => runSmoothZoom(-1, dt, { slow: e.shiftKey }));
          }
          handled = true;
        }
        else if (!handled && match(resetKeys, resetCodes)) {
          stopPageTurbo();
          if (useAnswerWindow) {
            stopCompareTurbo();
            resetCompareView();
            compareNeedsReset = false;
            triggerResetFlash(compareWindowStage);
          } else {
            stageSurface?.cancel?.(); stopInertia(); resetViewState({ toast: false, zoomOnly: useZoomResetOnly() }); triggerResetFlash(stage);
          }
          handled = true;
        }
        if (!handled && e.key === 'Tab' && !e.altKey && !e.metaKey) {
          // Tab (No modifiers) -> Open last added
          if (!e.ctrlKey && typeof window.__openLastAddedMissMessage === 'function' && window.__openLastAddedMissMessage()) {
            e.preventDefault(); handled = true;
          }
          // Ctrl + Tab -> Ripple detection
          if (e.ctrlKey && typeof window.__missRippleFindNearest === 'function') {
            window.__missRippleFindNearest();
            e.preventDefault(); handled = true;
          }
        }

        if (!handled) {
          // Quick Pie Action: execute hovered button if menu is open (Timer or Miss)
          // 1. Timer Pie
          if (typeof window.__isPieMenuOpen === 'function' && window.__isPieMenuOpen()) {
            const hov = document.querySelector('.pie-action:hover, .pie-center:hover, #piePrimary:hover, #pieClose:hover');
            if (hov) {
              hov.click();
              handled = true;
              e.preventDefault();
              e.stopPropagation();
            }
          }
          // 2. Miss Pie
          if (!handled) {
            const openMiss = document.querySelector('.miss-pie-menu:not(.hidden)');
            if (openMiss) {
              const hov = openMiss.querySelector('.miss-pie-btn:hover, .miss-pie-split-btn:hover');
              if (hov) {
                hov.click();
                handled = true;
                e.preventDefault();
                e.stopPropagation();
              }
            }
          }
        }

        if (!handled) {
          const actionBindings = getActionBindings();
          const matchAction = (id) => {
            const list = actionBindings[id] || [];
            const normalized = list.map(normKey);
            return normalized.includes(normKey(e.key)) || normalized.includes(normKey(e.code));
          };
          if (e.ctrlKey && (matchAction('spawnMissAtCursor') || matchAction('toggleMissPanel'))) {
            if (typeof window.__missRippleFindNearest === 'function') {
              window.__missRippleFindNearest();
              handled = true;
              e.stopImmediatePropagation();
              e.preventDefault();
            }
          }

          if (!handled) {
            if (matchAction('pageFillDown')) {
              handled = startProgressHold('down', e.code || e.key || 'pageFillDown');
            } else if (matchAction('pageFillUp')) {
              handled = startProgressHold('up', e.code || e.key || 'pageFillUp');
            } else if (matchAction('drawHold')) {
              startRDraw();
              handled = true;
            } else {
              for (const def of KEY_ACTION_DEFS) {
                if (def.id === 'drawHold') continue;
                if (matchAction(def.id)) {
                  stopPageTurbo();
                  try { def.run?.(); } catch (err) { }
                  handled = true;
                  break;
                }
              }
            }
          }
        }
        if (handled) {
          e.preventDefault();
          e.stopPropagation();
        }
      };
      const handleKeyboardNavUp = (e) => {
        stopHold(e.key);
        if (e.key === 'Control') {
          stopCompareKeyHolds();
        }
        const {
          panLeftKeys, panRightKeys, panUpKeys, panDownKeys,
          zoomInKeys, zoomInCodes, zoomOutKeys, zoomOutCodes,
          pageNextKeys, pagePrevKeys, pageNextCodes, pagePrevCodes,
          resetKeys, resetCodes
        } = getKeyBindings();
        const compareActive = compareWindowOpen && !!compareWindowBook && (e.ctrlKey || comparePanHoldCount > 0 || compareZoomHoldCount > 0);
        if (matchKey(e, panLeftKeys, [])) {
          if (compareActive) { stopHold('comparePanLeft'); markComparePanHold(-1); }
          else { stopHold('panLeft'); markPanHold(-1); }
        }
        if (matchKey(e, panRightKeys, [])) {
          if (compareActive) { stopHold('comparePanRight'); markComparePanHold(-1); }
          else { stopHold('panRight'); markPanHold(-1); }
        }
        if (matchKey(e, panUpKeys, [])) {
          if (compareActive) { stopHold('comparePanUp'); markComparePanHold(-1); }
          else { stopHold('panUp'); markPanHold(-1); }
        }
        if (matchKey(e, panDownKeys, [])) {
          if (compareActive) { stopHold('comparePanDown'); markComparePanHold(-1); }
          else { stopHold('panDown'); markPanHold(-1); }
        }
        if (matchKey(e, zoomInKeys, zoomInCodes)) {
          if (compareActive) { stopHold('compareZoomIn'); markCompareZoomHold(-1); }
          else { stopHold('zoomIn'); markZoomHold(-1); }
        }
        if (matchKey(e, zoomOutKeys, zoomOutCodes)) {
          if (compareActive) { stopHold('compareZoomOut'); markCompareZoomHold(-1); }
          else { stopHold('zoomOut'); markZoomHold(-1); }
        }
        if (matchKey(e, pageNextKeys, pageNextCodes) || matchKey(e, pagePrevKeys, pagePrevCodes)) {
          stopPageTurbo();
          stopCompareTurbo();
        }
        const actionBindings = getActionBindings();
        const normKey = (s) => (s || '').toLowerCase().trim();
        const matchAction = (id) => {
          const list = actionBindings[id] || [];
          const normalized = list.map(normKey);
          return normalized.includes(normKey(e.key)) || normalized.includes(normKey(e.code));
        };
        if (matchAction('pageFillDown') || matchAction('pageFillUp')) stopProgressHold(e.code || e.key);
        if (matchAction('drawHold')) stopRDraw();
      };
      if (window.__viewerKeyboardNav) {
        document.removeEventListener('keydown', window.__viewerKeyboardNav);
      }
      if (window.__viewerKeyboardNavUp) {
        document.removeEventListener('keyup', window.__viewerKeyboardNavUp);
      }
      window.__viewerKeyboardNav = handleKeyboardNav;
      window.__viewerKeyboardNavUp = handleKeyboardNavUp;
      document.addEventListener('keydown', handleKeyboardNav);
      document.addEventListener('keyup', handleKeyboardNavUp);
      if (window.__viewerStopPageTurbo) {
        window.removeEventListener('blur', window.__viewerStopPageTurbo);
      }
      window.__viewerStopPageTurbo = () => stopPageTurbo();
      window.addEventListener('blur', window.__viewerStopPageTurbo);
      window.addEventListener('blur', clearAllHolds);
      window.addEventListener('blur', () => stopProgressHold());

      async function cropDataUrlFromImg(imgEl, rectOnDisp, rectDisp) {
        const scaleX = imgEl.naturalWidth / rectDisp.width;
        const scaleY = imgEl.naturalHeight / rectDisp.height;
        const sx = Math.max(0, Math.floor(rectOnDisp.x * scaleX));
        const sy = Math.max(0, Math.floor(rectOnDisp.y * scaleY));
        const sw = Math.max(1, Math.floor(rectOnDisp.w * scaleX));
        const sh = Math.max(1, Math.floor(rectOnDisp.h * scaleY));
        const c = document.createElement('canvas'); c.width = sw; c.height = sh;
        const g = c.getContext('2d'); g.drawImage(imgEl, sx, sy, sw, sh, 0, 0, sw, sh);
        return c.toDataURL('image/png');
      }

      async function openBoxSelect(dataUrl, meta) {
        if (meta) pendingSelectionMeta = meta;
        const modal = document.getElementById('boxSelectModal');
        const sel = document.getElementById('boxSelect');
        if (!modal || !sel) return;
        sel.innerHTML = '';
        const boxes = await Box.list();
        const recent = loadRecentBoxes();
        const idxMap = new Map(recent.map((id, i) => [id, i]));
        boxes.sort((a, b) => {
          const ai = idxMap.has(a.id) ? idxMap.get(a.id) : -1;
          const bi = idxMap.has(b.id) ? idxMap.get(b.id) : -1;
          if (ai !== bi) {
            if (ai === -1) return 1;
            if (bi === -1) return -1;
            return ai - bi;
          }
          const ta = a.updatedAt ?? a.createdAt ?? 0;
          const tb = b.updatedAt ?? b.createdAt ?? 0;
          return tb - ta;
        });
        boxes.forEach(b => { const o = document.createElement('option'); o.value = b.id; o.textContent = b.name; sel.appendChild(o) });
        if (boxes.length) { sel.value = boxes[0].id; }
        document.getElementById('snippetName').value = '';
        document.getElementById('snippetNote').value = '';
        if (snippetPreview) { snippetPreview.src = dataUrl || 'data:,'; }
        const sourceMeta = pendingSelectionMeta || meta || selectionMetaForSurface(activeSelectionSurface);
        if (snippetSourceHint) {
          const realPage = sourceMeta ? ((sourceMeta.firstPage || 1) + (sourceMeta.pageIndex || 0)) : realOf(page);
          snippetSourceHint.textContent = `元ページ: ${realPage}p`;
        }
        const alsoAnswer = document.getElementById('snippetAlsoAnswer');
        const ansModeCrop = document.getElementById('snippetAnswerModeCrop');
        const ansModePage = document.getElementById('snippetAnswerModePage');
        const updateAnswerOption = () => {
          const candidate = answerCutCandidate(true);
          if (alsoAnswer) {
            const enabled = alsoAnswer.checked;
            [ansModeCrop, ansModePage].forEach(r => { if (r) { r.disabled = !enabled; } });
            if (enabled) {
              if (snippetAnswerHint) snippetAnswerHint.textContent = candidate ? `${candidate.label || '解答ビュー'} から追加保存できます` : '解答ウィンドウを表示して追加します';
            } else {
              if (snippetAnswerHint) snippetAnswerHint.textContent = '解答を追加しない場合はチェックを外してください';
            }
          }
        };
        if (alsoAnswer) {
          alsoAnswer.checked = false;
          alsoAnswer.disabled = false;
          [ansModeCrop, ansModePage].forEach(r => { if (r) { r.disabled = true; } });
          if (ansModeCrop) ansModeCrop.checked = true;
          alsoAnswer.onchange = async () => {
            if (alsoAnswer.checked) {
              const hasCandidate = !!answerCutCandidate(true);
              if (!hasCandidate) {
                const ok = await ensureAnswerWindowForAdding();
                if (!ok) { alsoAnswer.checked = false; updateAnswerOption(); return; }
              }
            }
            updateAnswerOption();
          };
          updateAnswerOption();
        }
        modal.style.display = 'flex';
        modal.querySelectorAll('[data-close]').forEach(btn => {
          btn.onclick = () => { modal.style.display = 'none'; pendingAnswerCrop = null; selecting = false; syncSelectingUI(); };
        });
        document.getElementById('assignToBoxBtn').onclick = () => assignToBox(sel.value, dataUrl);
        document.getElementById('newBoxBtn').onclick = () => {
          document.getElementById('newBoxModal').style.display = 'flex';
          document.getElementById('createBoxBtn').onclick = async () => {
            const name = (document.getElementById('newBoxName').value || '新しいボックス').trim();
            const tags = (document.getElementById('newBoxTags').value || '').split(',').map(s => s.trim()).filter(Boolean);
            const nb = { id: uuid(), name, createdAt: Date.now(), snippets: [], tags };
            await Box.add(nb);
            document.getElementById('newBoxModal').style.display = 'none'; openBoxSelect(dataUrl);
          };
        };
      }
      function answerCutCandidate(preferWindow = true) {
        const windowReady = compareWindowOpen && compareWindowBook && compareWindowBook.pages?.length && compareWindowImg?.naturalWidth;
        const splitReady = mode === 'compare' && rightBook && rightBook.pages?.length && !compareRightHidden && imgRight?.naturalWidth;
        const windowCandidate = windowReady ? { dataUrl: compareWindowBook.pages?.[compareWindowIndex]?.dataUrl, meta: { bookId: compareWindowBook.id, pageIndex: compareWindowIndex, firstPage: compareWindowBook.firstPageNumber || 1 }, label: '比較ウィンドウ', surfaceKey: 'compareWindow' } : null;
        const splitCandidate = splitReady ? { dataUrl: rightBook.pages?.[rightIndex]?.dataUrl, meta: { bookId: rightBook.id, pageIndex: rightIndex, firstPage: rightBook.firstPageNumber || 1 }, label: rightBook.title ? `${rightBook.title} (右側)` : '右側', surfaceKey: 'right' } : null;
        if (preferWindow && windowCandidate) return windowCandidate;
        return windowCandidate || splitCandidate || null;
      }
      async function ensureAnswerWindowForAdding() {
        if (compareWindowOpen && compareWindowBook) return true;
        const pid = primaryAnswerId();
        if (!pid) {
          showToast('紐付け解答がありません', 'error');
          return false;
        }
        await openLinkedAnswerInWindow(pid);
        return compareWindowOpen && !!compareWindowBook;
      }
      async function assignToBox(boxId, dataUrl) {
        if (!boxId) { showToast('ボックスを選択してください', 'error'); return; }
        const bx = await Box.get(boxId);
        if (!bx) { showToast('ボックスが見つかりません', 'error'); return; }
        bx.snippets = bx.snippets || [];
        const name = (document.getElementById('snippetName').value || '').trim();
        const note = (document.getElementById('snippetNote').value || '').trim();
        const alsoAnswer = document.getElementById('snippetAlsoAnswer')?.checked;
        const ansMode = (document.querySelector('input[name="snippetAnswerMode"]:checked')?.value) || 'crop';
        const meta = pendingSelectionMeta || { bookId: book.id, pageIndex: page, firstPage: book.firstPageNumber || 1 };
        const snippetId = uuid();
        const newSnippet = { id: snippetId, bookId: meta.bookId || book.id, pageIndex: meta.pageIndex ?? page, dataUrl, name, note, memo: note, weak: false, state: { fav: false, weak: false, done: false, extra: [] }, createdAt: Date.now(), answer: null };
        if (alsoAnswer && ansMode === 'page') {
          let ans = answerCutCandidate(true);
          if (!ans) {
            const ensured = await ensureAnswerWindowForAdding();
            if (!ensured) {
              showToast('解答ウィンドウを開けませんでした', 'error');
            }
            ans = answerCutCandidate(true);
          }
          if (ans?.dataUrl) {
            newSnippet.answer = { dataUrl: ans.dataUrl, meta: ans.meta || {}, surfaceKey: ans.surfaceKey || null };
          } else {
            showToast('解答ビューが開いていません', 'error');
          }
        }
        bx.snippets.push(newSnippet);
        await Box.put(bx);
        bumpRecentBox(boxId);
        const modal = document.getElementById('boxSelectModal');
        if (modal) modal.style.display = 'none';
        showToast('ボックスに保存しました', 'ok');
        pendingSelectionMeta = null;
        if (alsoAnswer && ansMode === 'crop') {
          let surface = chooseAnswerSurface();
          if (!surface) {
            await ensureAnswerWindowForAdding();
          }
          if (startAnswerCropTask({ boxId: bx.id, name, note, snippetId })) {
            return;
          }
        }
        selecting = false; syncSelectingUI();
      }
      async function saveAnswerCrop(dataUrl, meta) {
        const task = pendingAnswerCrop;
        pendingAnswerCrop = null;
        if (!task || !task.boxId) { selecting = false; syncSelectingUI(); return; }
        const bx = await Box.get(task.boxId);
        if (!bx) { showToast('ボックスが見つかりません', 'error'); selecting = false; syncSelectingUI(); return; }
        bx.snippets = bx.snippets || [];
        const target = bx.snippets.find(s => s.id === task.snippetId);
        if (!target) {
          showToast('解答を紐付ける切り抜きが見つかりません', 'error');
          selecting = false; syncSelectingUI(); return;
        }
        const m = meta || pendingSelectionMeta || { bookId: book.id, pageIndex: page, firstPage: book.firstPageNumber || 1 };
        target.answer = { dataUrl, meta: m, surfaceKey: task.surfaceKey || null };
        await Box.put(bx);
        pendingSelectionMeta = null;
        showToast('解答を紐付けました', 'ok');
        selecting = false; syncSelectingUI();
      }

      // inline state & memo
      stFav.onchange = async () => { book.pages[page].state.fav = stFav.checked; await Book.put(book); updateThumbs(); };
      stWeak.onchange = async () => { book.pages[page].state.weak = stWeak.checked; await Book.put(book); updateThumbs(); };
      stDone.onchange = async () => {
        book.pages[page].state.done = stDone.checked;
        const realPage = (book.firstPageNumber || 1) + page;
        if (stDone.checked && window.StudyCalendar?.recordCompletion) {
          try { window.StudyCalendar.recordCompletion(book.id, realPage, book.title || '本'); } catch (e) { console.warn('recordCompletion failed', e); }
        }
        if (stDone.checked && typeof window.__clearPageProgress === 'function') {
          try { window.__clearPageProgress(book.id, realPage); } catch (_) { }
        }
        await Book.put(book);
        updateThumbs();
      };

      document.getElementById('addState').onclick = () => {
        const m = document.createElement('div'); m.className = 'modal'; m.style.display = 'flex';
        const b = document.createElement('div'); b.className = 'box';
        b.innerHTML = `<h3>カスタム状態を作成</h3>
      <input id="csName" class="input" placeholder="状態名（例：要復習/公式）" style="margin-bottom:8px"/>
      <input id="csColor" class="input" placeholder="#カラー（任意）" />
      <div class="row space" style="margin-top:10px"><button class="btn ghost" data-close>閉じる</button><button class="btn primary" data-save>追加</button></div>`;
        m.appendChild(b); document.body.appendChild(m);
        b.querySelector('[data-close]').onclick = () => m.remove();
        b.querySelector('[data-save]').onclick = async () => {
          const name = b.querySelector('#csName').value.trim(); if (!name) { showToast('名前を入れてください', 'error'); return }
          const color = (b.querySelector('#csColor').value || '').trim();
          book.customStates.push({ id: uuid(), name, color });
          markThumbsDirty();
          await Book.put(book); m.remove(); refreshCustomControls(); load();
        };
      };
      customArea.addEventListener('click', async (e) => {
        const del = e.target.getAttribute('data-delcs'); if (!del) return;
        // remove state id from all pages
        book.pages.forEach(p => { if (!Array.isArray(p.state.extra)) p.state.extra = []; p.state.extra = p.state.extra.filter(x => x !== del); });
        book.customStates = book.customStates.filter(x => x.id !== del);
        markThumbsDirty();
        await Book.put(book); refreshCustomControls(); load();
      });

      document.getElementById('customFilter').onchange = (e) => { customFilterId = e.target.value; updateThumbs(); };

      // buttons
      function goPrev() {
        const prev = findPrev(page);
        if (prev !== page) {
          suppressSmoothNextReset = true;
          page = prev;
          load();
        }
      }
      function goNext() {
        const next = findNext(page);
        if (next !== page) {
          suppressSmoothNextReset = true;
          page = next;
          load();
        }
      }
      const preventContextMenu = (btn) => {
        if (!btn) return;
        btn.addEventListener('contextmenu', (e) => e.preventDefault());
      };
      const defocusButton = (btn) => {
        if (!btn) return;
        btn.addEventListener('mousedown', () => btn.blur());
        btn.addEventListener('touchstart', () => btn.blur(), { passive: true });
        btn.addEventListener('click', () => btn.blur());
      };
      const pageClickHandler = (dir) => (e) => {
        if (suppressPageClick) { suppressPageClick = false; return; }
        if (dir === 'next') goNext(); else goPrev();
      };
      const bindTurboButton = (btn, dir) => {
        if (!btn) return;
        preventContextMenu(btn);
        const stopAndFlag = () => {
          const fired = stopPageTurbo();
          if (fired) suppressPageClick = true;
        };
        btn.addEventListener('mousedown', (e) => { if (e.button !== 0) return; startPageTurbo(dir, { boost: e.shiftKey }); });
        btn.addEventListener('touchstart', () => startPageTurbo(dir), { passive: true });
        btn.addEventListener('mouseup', stopAndFlag);
        btn.addEventListener('mouseleave', stopAndFlag);
        btn.addEventListener('touchend', stopAndFlag, { passive: true });
        btn.addEventListener('touchcancel', stopAndFlag, { passive: true });
        btn.addEventListener('blur', stopPageTurbo);
      };
      const WHEEL_NAV_THRESHOLD = 40;
      let wheelNavAccum = 0;
      function handleWheelNavigation(delta) {
        if (!delta) return;
        wheelNavAccum += delta;
        if (Math.abs(wheelNavAccum) >= WHEEL_NAV_THRESHOLD) {
          if (wheelNavAccum > 0) { goNext(); }
          else { goPrev(); }
          wheelNavAccum = 0;
        }
      }
      const focusPageJumpInput = () => {
        startPageBadgeEdit();
      };
      window.focusPageJumpInput = focusPageJumpInput;
      const jumpGoBtn = document.getElementById('jumpGo');
      const prevBtnEl = document.getElementById('prevBtn');
      const nextBtnEl = document.getElementById('nextBtn');
      const focusPageInput = () => { focusPageJumpInput(); };
      if (pageBadge) {
        pageBadge.setAttribute('tabindex', '0');
        pageBadge.setAttribute('role', 'button');
        pageBadge.addEventListener('click', (e) => { e.preventDefault(); focusPageJumpInput(); });
        pageBadge.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); focusPageJumpInput(); } });
      }
      prevBtnEl?.addEventListener('click', pageClickHandler('prev'));
      nextBtnEl?.addEventListener('click', pageClickHandler('next'));
      jumpGoBtn?.addEventListener('click', () => { const v = parseInt(document.getElementById('jumpInput').value, 10); if (!isNaN(v)) { page = idxFromReal(v); load(); } });
      bindTurboButton(prevBtnEl, 'prev');
      bindTurboButton(nextBtnEl, 'next');
      defocusButton(prevBtnEl);
      defocusButton(nextBtnEl);
      preventContextMenu(prevBtnEl);
      preventContextMenu(nextBtnEl);
      document.getElementById('fitContain').onclick = () => setFit('contain');
      document.getElementById('fitWidth').onclick = () => setFit('width');
      document.getElementById('selectBtn').onclick = toggleSelect;
      document.getElementById('insertBtn').onclick = () => { document.getElementById('pageInsertModal').style.display = 'flex'; };

      // spread toggle
      const spreadBtn = document.getElementById('spreadToggle');
      spreadBtn.onclick = () => {
        mode = (mode === 'spread') ? 'single' : 'spread';
        // selecting is not supported in dual mode (to keep UX簡潔)
        pendingAnswerCrop = null;
        selecting = false; syncSelectingUI();
        load();
      };
      // compare flow
      const compareStart = document.getElementById('compareStart');
      const compareEnd = document.getElementById('compareEnd');
      const compareModal = document.getElementById('compareModal');
      const compareSelect = document.getElementById('compareSelect');
      const compareGoBtn = document.getElementById('compareGo');
      const compareModalClose = compareModal?.querySelector('[data-close]');
      compareModal?.classList.add('window');
      compareModal?.querySelectorAll('[data-close]')?.forEach(btn => {
        btn.addEventListener('click', () => { compareModal.style.display = 'none'; });
      });
      async function openComparePicker(target) {
        if (!compareModal || !compareSelect || !compareGoBtn) return;
        compareModalTarget = target;
        compareSelect.innerHTML = '';
        const all = await Book.listMeta();
        const options = all.filter(b => b.id !== book.id);
        if (!options.length) {
          const opt = document.createElement('option');
          opt.value = '';
          opt.textContent = '比較できる本がありません';
          compareSelect.appendChild(opt);
          compareGoBtn.disabled = true;
        } else {
          options.forEach(bk => { const o = document.createElement('option'); o.value = bk.id; o.textContent = `${bk.title} (${pageCountOf(bk)}p)`; compareSelect.appendChild(o); });
          compareGoBtn.disabled = false;
        }
        compareGoBtn.textContent = target === 'window' ? 'ウィンドウに表示' : '並べて表示';
        compareModal.style.display = 'flex';
      }
      compareModalClose?.addEventListener('click', () => { compareModal.style.display = 'none'; });
      compareGoBtn?.addEventListener('click', async () => {
        if (!compareSelect?.value) return;
        if (compareModalTarget === 'window') {
          const nextBook = await Book.get(compareSelect.value);
          if (!nextBook) { showToast('選択した本が見つかりません', 'error'); return; }
          if (!nextBook.pages?.length) { showToast('ページがありません', 'error'); return; }
          setCompareWindowBook(nextBook);
        } else {
          rightBook = await Book.get(compareSelect.value);
          if (!rightBook) { showToast('選択した本が見つかりません', 'error'); return; }
          rightIndex = getCompareStartIndexFor(rightBook);
          mode = 'compare';
          compareEnd.classList.remove('hidden');
          compareStart.classList.add('hidden');
          pendingAnswerCrop = null;
          selecting = false; syncSelectingUI();
          compareRightHidden = false;
          load();
        }
        compareModal.style.display = 'none';
      });
      function exitCompareMode({ toast = false } = {}) {
        if (mode === 'compare' && rightBook?.id) {
          setLastCompareIndex(book.id, rightBook.id, rightIndex);
        }
        mode = 'single';
        rightBook = null;
        rightIndex = 0;
        if (pendingAnswerCrop) {
          pendingAnswerCrop = null;
          selecting = false;
          syncSelectingUI();
        }
        compareEnd?.classList.add('hidden');
        compareStart?.classList.remove('hidden');
        compareRightHidden = false;
        load();
        if (toast) showToast('比較を一時停止しました', 'ok');
      }
      compareStart.onclick = () => openComparePicker('split');
      compareEnd.onclick = () => exitCompareMode();
      compareWindowBtn?.addEventListener('click', (e) => {
        e.stopPropagation();
        if (compareWindowOpen) { setCompareWindowOpen(false); return; }
        if (compareWindowBook) { setCompareWindowOpen(true); return; }
        openComparePicker('window');
      });
      compareWindowZoomLock?.addEventListener('click', (e) => {
        e.stopPropagation();
        setCompareZoomLock(!compareZoomLocked);
      });
      compareWindowSlice?.addEventListener('click', (e) => {
        e.stopPropagation();
        setCompareSliceView(!compareSliceMode);
      });
      compareWindowClose?.addEventListener('click', (e) => { e.stopPropagation(); setCompareWindowOpen(false); });
      const COMPARE_HOLD_INITIAL_DELAY = 180;
      const COMPARE_HOLD_TURBO_DELAY = 480;
      const COMPARE_HOLD_INTERVAL = 230;
      const COMPARE_HOLD_TURBO_INTERVAL = 105;
      let compareHoldDir = null, compareHoldId = null, compareHoldStart = 0, compareHoldLast = 0, compareHoldFired = false;
      const stopCompareTurbo = () => {
        if (compareHoldId) { cancelAnimationFrame(compareHoldId); compareHoldId = null; }
        const fired = compareHoldFired;
        compareHoldDir = null;
        compareHoldStart = 0;
        compareHoldLast = 0;
        compareHoldFired = false;
        return fired;
      };
      const stepCompareTurbo = (ts) => {
        if (!compareHoldDir) return;
        if (!compareHoldStart) compareHoldStart = ts;
        const elapsed = ts - compareHoldStart;
        const interval = elapsed > COMPARE_HOLD_TURBO_DELAY ? COMPARE_HOLD_TURBO_INTERVAL : COMPARE_HOLD_INTERVAL;
        const readyFirst = !compareHoldLast && elapsed >= COMPARE_HOLD_INITIAL_DELAY;
        const readyNext = !!compareHoldLast && ts - compareHoldLast >= interval;
        if (readyFirst || readyNext) {
          compareHoldFired = true;
          shiftCompareWindow(compareHoldDir === 'next' ? 1 : -1);
          compareHoldLast = ts;
        }
        compareHoldId = requestAnimationFrame(stepCompareTurbo);
      };
      const startCompareTurbo = (dir, { fireNow = false } = {}) => {
        if (compareHoldDir === dir) return;
        stopCompareTurbo();
        compareHoldDir = dir;
        if (fireNow) {
          const now = performance.now();
          compareHoldStart = now;
          compareHoldLast = now;
          compareHoldFired = true;
          shiftCompareWindow(dir === 'next' ? 1 : -1);
        }
        compareHoldId = requestAnimationFrame(stepCompareTurbo);
      };
      let suppressCompareClick = false;
      const stopCompareAndFlag = () => {
        const fired = stopCompareTurbo();
        if (fired) suppressCompareClick = true;
      };
      const compareClickHandler = (dir) => (e) => {
        e?.stopPropagation?.();
        if (suppressCompareClick) {
          suppressCompareClick = false;
          return;
        }
        shiftCompareWindow(dir === 'next' ? 1 : -1);
      };
      const bindCompareTurboButton = (btn, dir) => {
        if (!btn) return;
        preventContextMenu(btn);
        btn.addEventListener('mousedown', (e) => { if (e.button !== 0) return; e.stopPropagation(); startCompareTurbo(dir); });
        btn.addEventListener('touchstart', (e) => { e.stopPropagation(); startCompareTurbo(dir); }, { passive: true });
        btn.addEventListener('mouseup', stopCompareAndFlag);
        btn.addEventListener('mouseleave', stopCompareAndFlag);
        btn.addEventListener('touchend', stopCompareAndFlag, { passive: true });
        btn.addEventListener('touchcancel', stopCompareAndFlag, { passive: true });
        btn.addEventListener('blur', stopCompareTurbo);
        btn.addEventListener('click', compareClickHandler(dir));
      };
      compareWindowSync?.addEventListener('click', (e) => { e.stopPropagation(); setCompareWindowTransparent(!compareWindowTransparent); });
      compareWindowRegister?.addEventListener('click', (e) => { e.stopPropagation(); registerAnswerMapping(); });
      const startCompareBadgeEdit = () => {
        const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
        if (compareBadgeEditing) return;
        if (now - compareBadgeEditClosedAt < 200) return;
        if (!compareWindowBook || !compareWindowBook.pages?.length || !compareWindowPageBadge) return;
        compareBadgeEditing = true;
        compareWindowPageBadge.classList.add('editing');
        const input = document.createElement('input');
        input.type = 'text';
        input.inputMode = 'numeric';
        input.value = String(realOfOtherBook(compareWindowBook, compareWindowIndex));
        compareWindowPageBadge.innerHTML = '';
        compareWindowPageBadge.appendChild(input);
        requestAnimationFrame(() => { input.focus(); input.select?.(); });
        let committed = false;
        const normalizeNumberInput = (raw) => {
          return (raw || '').replace(/[０-９]/g, ch => String.fromCharCode(ch.charCodeAt(0) - 0xFEE0)).trim();
        };
        const cleanupFocus = () => {
          if (document.activeElement === input) { input.blur(); }
          compareWindowPageBadge.blur?.();
        };
        const finalizeDisplay = (idx) => closeCompareBadgeEdit(idx);
        const commit = () => {
          if (committed) return;
          committed = true;
          input.disabled = true;
          const raw = normalizeNumberInput(input.value);
          const val = parseInt(raw, 10);
          const targetIdx = Number.isNaN(val) ? null : idxFromRealForBook(compareWindowBook, val);
          const displayIdx = targetIdx !== null ? targetIdx : compareWindowIndex;
          finalizeDisplay(displayIdx);
          cleanupFocus();
          if (targetIdx !== null) { jumpCompareWindow(val); }
        };
        const cancel = () => {
          if (committed) return;
          committed = true;
          input.disabled = true;
          finalizeDisplay(compareWindowIndex);
          cleanupFocus();
        };
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') { e.preventDefault(); commit(); }
          if (e.key === 'Escape') { e.preventDefault(); cancel(); }
        });
        input.addEventListener('blur', () => { commit(); });
        input.addEventListener('change', () => { commit(); });
      };
      window.__startCompareBadgeEdit = startCompareBadgeEdit;
      if (compareWindowPageBadge) {
        compareWindowPageBadge.setAttribute('tabindex', '0');
        compareWindowPageBadge.setAttribute('role', 'button');
        compareWindowPageBadge.addEventListener('click', (e) => { e.stopPropagation(); startCompareBadgeEdit(); });
        compareWindowPageBadge.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); startCompareBadgeEdit(); } });
      }
      bindCompareTurboButton(compareWindowPrev, 'prev');
      bindCompareTurboButton(compareWindowNext, 'next');
      if (window.__compareStopTurbo) {
        window.removeEventListener('blur', window.__compareStopTurbo);
      }
      window.__compareStopTurbo = () => { stopCompareTurbo(); stopRightTurbo(); };
      window.addEventListener('blur', window.__compareStopTurbo);
      // compare right book turbo (pane right)
      const computeRightTurboInterval = (elapsed, shift) => computeTurboInterval(elapsed, shift);
      let rightHoldDir = null, rightHoldId = null, rightHoldStart = 0, rightHoldLast = 0, rightHoldFired = false, rightHoldShift = false;
      const stopRightTurbo = () => {
        if (rightHoldId) { cancelAnimationFrame(rightHoldId); rightHoldId = null; }
        const fired = rightHoldFired;
        rightHoldDir = null;
        rightHoldStart = 0;
        rightHoldLast = 0;
        rightHoldFired = false;
        rightHoldShift = false;
        turboHintRight = false;
        if (!isTurboActive() && pendingTurboRefresh) {
          cancelIdle(pendingTurboIdle);
          pendingTurboIdle = null;
          pendingTurboRefresh = false;
          flushPostLoad();
        }
        return fired;
      };
      const stepRightTurbo = (ts) => {
        if (!rightHoldDir) return;
        if (!rightHoldStart) rightHoldStart = ts;
        const elapsed = ts - rightHoldStart;
        const interval = computeRightTurboInterval(elapsed, rightHoldShift);
        const initialDelay = rightHoldShift ? PAGE_HOLD_SHIFT_INITIAL_DELAY : PAGE_HOLD_INITIAL_DELAY;
        const readyFirst = !rightHoldLast && elapsed >= initialDelay;
        const readyNext = !!rightHoldLast && ts - rightHoldLast >= interval;
        if (readyFirst || readyNext) {
          rightHoldFired = true;
          if (mode === 'compare' && rightBook) {
            if (rightHoldDir === 'next') { rightIndex = Math.min(rightBook.pages.length - 1, rightIndex + 1); }
            else { rightIndex = Math.max(0, rightIndex - 1); }
            load();
          }
          rightHoldLast = ts;
        }
        rightHoldId = requestAnimationFrame(stepRightTurbo);
      };
      const startRightTurbo = (dir, { fireNow = false, boost = false } = {}) => {
        if (rightHoldDir === dir && rightHoldShift === !!boost) return;
        stopRightTurbo();
        rightHoldDir = dir;
        turboHintRight = true;
        rightHoldShift = !!boost;
        if (fireNow) {
          const now = performance.now();
          rightHoldStart = now;
          rightHoldLast = now;
          rightHoldFired = true;
          if (mode === 'compare' && rightBook) {
            if (dir === 'next') { rightIndex = Math.min(rightBook.pages.length - 1, rightIndex + 1); }
            else { rightIndex = Math.max(0, rightIndex - 1); }
            load();
          }
        }
        rightHoldId = requestAnimationFrame(stepRightTurbo);
      };
      const bindRightTurboButton = (btn, dir) => {
        if (!btn) return;
        const stopAndFlag = () => {
          const fired = stopRightTurbo();
          if (fired) suppressPageClick = true;
        };
        btn.addEventListener('mousedown', (e) => { if (e.button !== 0) return; startRightTurbo(dir, { boost: e.shiftKey }); });
        btn.addEventListener('touchstart', () => startRightTurbo(dir), { passive: true });
        btn.addEventListener('mouseup', stopAndFlag);
        btn.addEventListener('mouseleave', stopAndFlag);
        btn.addEventListener('touchend', stopAndFlag, { passive: true });
        btn.addEventListener('touchcancel', stopAndFlag, { passive: true });
        btn.addEventListener('blur', stopRightTurbo);
      };
      // dual pane controls
      document.getElementById('leftPrev').onclick = () => { if (mode === 'spread') { page = Math.max(0, page - 2); } else { page = Math.max(0, page - 1); } load(); };
      document.getElementById('leftNext').onclick = () => { if (mode === 'spread') { page = Math.min(book.pages.length - 1, page + 2); } else { page = Math.min(book.pages.length - 1, page + 1); } load(); };
      document.getElementById('leftGo').onclick = () => { const v = parseInt(document.getElementById('leftJump').value || ''); if (!isNaN(v)) { if (mode === 'spread') { page = idxFromReal(v); if (page % 2 === 1) page--; } else { page = idxFromReal(v); } load(); } };
      document.getElementById('rightPrev').onclick = async () => { if (mode === 'spread') { page = Math.max(0, page - 2); load(); } else if (mode === 'compare' && rightBook) { rightIndex = Math.max(0, rightIndex - 1); load(); } };
      document.getElementById('rightNext').onclick = async () => { if (mode === 'spread') { page = Math.min(book.pages.length - 1, page + 2); load(); } else if (mode === 'compare' && rightBook) { rightIndex = Math.min(rightBook.pages.length - 1, rightIndex + 1); load(); } };
      document.getElementById('rightGo').onclick = () => { const v = parseInt(document.getElementById('rightJump').value || ''); if (!isNaN(v)) { if (mode === 'spread') { const idx = idxFromReal(v); page = (idx % 2 === 0) ? idx : idx - 1; } else if (mode === 'compare' && rightBook) { rightIndex = Math.max(0, Math.min(rightBook.pages.length - 1, v - 1)); } load(); } };
      stagePrevArrow?.addEventListener('click', (e) => { e.stopPropagation(); pageClickHandler('prev')(e); });
      stageNextArrow?.addEventListener('click', (e) => { e.stopPropagation(); pageClickHandler('next')(e); });
      bindTurboButton(stagePrevArrow, 'prev');
      bindTurboButton(stageNextArrow, 'next');
      defocusButton(stagePrevArrow);
      defocusButton(stageNextArrow);
      preventContextMenu(stagePrevArrow);
      preventContextMenu(stageNextArrow);
      paneLeftPrevArrow?.addEventListener('click', (e) => { e.stopPropagation(); document.getElementById('leftPrev')?.click(); });
      paneLeftNextArrow?.addEventListener('click', (e) => { e.stopPropagation(); document.getElementById('leftNext')?.click(); });
      paneRightPrevArrow?.addEventListener('click', (e) => { e.stopPropagation(); document.getElementById('rightPrev')?.click(); });
      paneRightNextArrow?.addEventListener('click', (e) => { e.stopPropagation(); document.getElementById('rightNext')?.click(); });
      bindRightTurboButton(document.getElementById('rightPrev'), 'prev');
      bindRightTurboButton(document.getElementById('rightNext'), 'next');
      bindRightTurboButton(paneRightPrevArrow, 'prev');
      bindRightTurboButton(paneRightNextArrow, 'next');


      const backBtn = document.getElementById('backLib');
      backBtn.onclick = () => {
        persistActiveDrawDocNow();
        stopFlip();
        setMenu(false);
        setMemoWindow(false);
        state.view = 'library';
        state.viewerContext = null;
        viewerMemory.book.closed = true;
        viewerMemory.book.id = null;
        viewerMemory.book.ref = null;
        viewerMemory.book.page = 0;
        pendingAnswerCrop = null;
        selecting = false;
        syncSelectingUI();
        stage.removeEventListener('click', stageTap);
        stage.removeEventListener('wheel', wheelHandler);
        document.removeEventListener('mousemove', docMouseMovePan);
        document.removeEventListener('mouseup', docMouseUpPan);
        document.removeEventListener('mousemove', docMoveSelection);
        document.removeEventListener('mouseup', docUpSelection);
        document.removeEventListener('keydown', docKeydownSelection);
        stopGamepadLoop();
        paneControllers.forEach(ctrl => ctrl.destroy?.());
        stopInertia();
        bodyObserver.disconnect();
        cancelIdle(pendingTurboIdle);
        pendingTurboIdle = null;
        pendingTurboRefresh = false;
        pendingPostLoadLight = false;
        window.removeEventListener('resize', onWindowResize);
        pageDataCache.clear?.();
        drawDocs.clear();
        drawStore.clear();
        layerBuffers.clear();
        host.innerHTML = '';
        host.classList.add('hidden');
        showTab('library');
        window.__viewerResetView = null;
        window.__viewerJumpToMiss = null;
        window.__viewerRefreshMiss = null;
        window.__persistActiveDrawDoc = null;
        document.body.classList.remove('reading');
      };
      document.getElementById('filterSelect').onchange = (e) => { filter = e.target.value; updateThumbs(); };

      // flip-through
      const flipPlayBtn = document.getElementById('flipPlay');
      const flipStopBtn = document.getElementById('flipStop');
      const flipSpeedInput = document.getElementById('flipSpeed');
      const fFlipBtn = document.getElementById('fFlip');
      function playFlip() {
        stopFlip();
        const pps = Math.max(1, parseInt(flipSpeedInput.value, 10) || 8); // pages per second
        flipTimer = setInterval(() => {
          const next = findNext(page);
          if (next === page) { stopFlip(); return; }
          page = next; load();
        }, Math.floor(1000 / pps));
        showToast('めくりまくり開始');
      }
      function stopFlip() {
        if (flipTimer) { clearInterval(flipTimer); flipTimer = null; showToast('停止'); }
      }
      flipPlayBtn.onclick = playFlip;
      if (fFlipBtn) fFlipBtn.onclick = () => flipTimer ? stopFlip() : playFlip();
      if (flipStopBtn) flipStopBtn.onclick = stopFlip;
      scrub.oninput = (e) => { const v = Math.max(1, Math.min(book.pages.length, parseInt(scrub.value, 10) || 1)); page = v - 1; load(); };

      // floating (main2)
      const fPrev = document.getElementById('fPrev');
      const fNext = document.getElementById('fNext');
      const fGo = document.getElementById('fGo');
      const fJump = document.getElementById('fJump');
      const fSelect = document.getElementById('fSelect');
      if (fPrev) { fPrev.onclick = pageClickHandler('prev'); bindTurboButton(fPrev, 'prev'); defocusButton(fPrev); preventContextMenu(fPrev); }
      if (fNext) { fNext.onclick = pageClickHandler('next'); bindTurboButton(fNext, 'next'); defocusButton(fNext); preventContextMenu(fNext); }
      if (fGo) fGo.onclick = () => { const v = parseInt(fJump?.value || '', 10); if (!isNaN(v)) { page = idxFromReal(v); load(); } };
      if (fSelect) fSelect.onclick = () => toggleSelect();

      function findNext(from) {
        for (let i = from + 1; i < book.pages.length; i++) {
          if (matchFilter(book.pages[i])) return i;
        }
        return from; // no further page under filter
      }
      function findPrev(from) {
        for (let i = from - 1; i >= 0; i--) {
          if (matchFilter(book.pages[i])) return i;
        }
        return from; // no previous page under filter
      }
      function matchFilter(p) {
        if (customFilterId) { return (p.state?.extra || []).includes(customFilterId); }
        if (filter === 'all') return true;
        if (filter === 'fav') return p.state?.fav;
        if (filter === 'weak') return p.state?.weak;
        if (filter === 'done') return p.state?.done;
        if (filter === 'undone') return !p.state?.done;
        if (filter === 'hasMemo') return (p.memo || '').trim().length > 0;
        return true;
      }

      // multi select ops
      document.getElementById('multiToggle').onclick = () => { multi = !multi; selected.clear(); updateThumbs(); showToast(multi ? '複数選択ON' : '複数選択OFF'); };
      document.getElementById('multiAll').onclick = () => { if (!multi) return; selected.clear(); for (let i = 0; i < book.pages.length; i++) selected.add(i); updateThumbs(); };
      document.getElementById('multiNone').onclick = () => { selected.clear(); updateThumbs(); };
      document.getElementById('multiMove').onclick = () => {
        if (!selected.size) return showToast('選択がありません', 'error');
        const to = parseInt(prompt('移動先のインデックス（1始まり, 現在の並びで）'), 10);
        if (!to || to < 1 || to > book.pages.length) return;
        const idxs = [...selected].sort((a, b) => a - b);
        const block = idxs.map(i => book.pages[i]);
        // remove from end to preserve indexes
        idxs.reverse().forEach(i => book.pages.splice(i, 1));
        const insertAt = Math.min(book.pages.length, to - 1);
        markThumbsDirty();
        book.pages.splice(insertAt, 0, ...block);
        Book.put(book).then(() => { selected.clear(); page = insertAt; load(); showToast('移動しました', 'ok'); });
      };
      document.getElementById('multiCopy').onclick = async () => {
        if (!selected.size) return showToast('選択がありません', 'error');
        const to = parseInt(prompt('コピー先のインデックス（1始まり）'), 10);
        if (!to || to < 1 || to > book.pages.length + 1) return;
        const idxs = [...selected].sort((a, b) => a - b);
        const copies = [];
        for (const i of idxs) {
          const src = structuredClone(book.pages[i]);
          src.id = uuid();
          src.dataUrl = await ensurePageData(book, i);
          copies.push(src);
        }
        const insertAt = Math.min(book.pages.length, to - 1);
        markThumbsDirty();
        book.pages.splice(insertAt, 0, ...copies);
        Book.put(book).then(() => { selected.clear(); page = insertAt; load(); showToast('コピーしました', 'ok'); });
      };
      document.getElementById('multiDelete').onclick = () => {
        if (!selected.size) return showToast('選択がありません', 'error');
        if (!confirm('選択したページを削除しますか？')) return;
        const idxs = [...selected].sort((a, b) => b - a);
        markThumbsDirty();
        idxs.forEach(i => book.pages.splice(i, 1));
        Book.put(book).then(() => { selected.clear(); page = Math.max(0, Math.min(page, book.pages.length - 1)); load(); showToast('削除しました', 'ok'); });
      };
      document.getElementById('multiSet').onclick = () => {
        document.getElementById('multiNewBook').onclick = async () => {
          if (!selected.size) return showToast('選択がありません', 'error');
          const modal = document.getElementById('newBookFromSelModal');
          modal.style.display = 'flex';
          // close on backdrop
          modal.addEventListener('click', (e) => { if (e.target === modal) modal.style.display = 'none'; }, { once: true });
          const box = modal.querySelector('.box');
          const nbCreate = modal.querySelector('#nbCreate');
          const nbClose = box.querySelector('[data-close]');
          nbClose.onclick = () => { modal.style.display = 'none'; };
          nbCreate.onclick = async () => {
            const title = (box.querySelector('#nbTitle').value || '').trim();
            if (!title) { showToast('タイトルを入力してください', 'error'); return; }
            const tags = (box.querySelector('#nbTags').value || '').split(',').map(s => s.trim()).filter(Boolean);
            const folder = (box.querySelector('#nbFolder').value || '').trim();
            const remove = box.querySelector('#nbRemove').checked;
            const idxs = [...selected].sort((a, b) => a - b);
            const pages = [];
            for (const i of idxs) {
              const src = book.pages[i];
              const url = await ensurePageData(book, i);
              pages.push({ id: uuid(), dataUrl: url, state: structuredClone(src.state || { fav: false, weak: false, done: false, extra: [] }), memo: src.memo || '' });
            }
            const newBook = { id: uuid(), title, tags, folder, createdAt: Date.now(), pages, firstPageNumber: 1, coverDataUrl: pages[0]?.dataUrl || null, customStates: structuredClone(book.customStates || []), bookmarks: [], answerBookIds: [] };
            await Book.add(newBook);
            if (remove) {
              // delete from original starting from tail
              idxs.sort((a, b) => b - a).forEach(i => book.pages.splice(i, 1));
              markThumbsDirty();
              await Book.put(book);
              page = Math.max(0, Math.min(page, book.pages.length - 1));
            }
            selected.clear();
            modal.style.display = 'none';
            showToast('新しい本を作成しました', 'ok');
            // refresh library silently
            refresh();
          };
        };

        if (!selected.size) return showToast('選択がありません', 'error');
        const m = document.createElement('div'); m.className = 'modal'; m.style.display = 'flex';
        const b = document.createElement('div'); b.className = 'box';
        const csOpts = book.customStates.map(cs => `<label class='row' style='gap:6px'><input type='checkbox' data-bcs='${cs.id}'> ${escapeHTML(cs.name)}</label>`).join('');
        b.innerHTML = `<h3>選択の状態変更</h3>
      <label class='row' style='gap:6px'><input id='bFav' type='checkbox'> ★お気に入り</label>
      <label class='row' style='gap:6px'><input id='bWeak' type='checkbox'> ×苦手</label>
      <label class='row' style='gap:6px'><input id='bDone' type='checkbox'> ✓完了</label>
      <div class='hr' style='height:1px;background:#1d2738;margin:8px 0'></div>
      <div>カスタム状態</div>
      <div class='split' style='margin:6px 0'>${csOpts || '<span class="muted">（なし）</span>'}</div>
      <div class='row space' style='margin-top:10px'><button class='btn ghost' data-close>閉じる</button><button class='btn primary' data-apply>適用</button></div>`;
        m.appendChild(b); document.body.appendChild(m);
        b.querySelector('[data-close]').onclick = () => m.remove();
        b.querySelector('[data-apply]').onclick = async () => {
          const fav = b.querySelector('#bFav').checked;
          const weak = b.querySelector('#bWeak').checked;
          const done = b.querySelector('#bDone').checked;
          const extra = [...b.querySelectorAll('[data-bcs]')].filter(x => x.checked).map(x => x.getAttribute('data-bcs'));
          selected.forEach(i => {
            book.pages[i].state.fav = fav; book.pages[i].state.weak = weak; book.pages[i].state.done = done;
            book.pages[i].state.extra = extra.slice();
          });
          await Book.put(book); m.remove(); updateThumbs(); showToast('状態を更新しました', 'ok');
        };
      };

      // replace/delete single page
      const replacePicker = document.getElementById('replacePicker');
      document.getElementById('replaceBtn').onclick = () => { replacePicker?.click(); };
      replacePicker?.addEventListener('change', async (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        if (!book.pages.length) { showToast('ページがありません', 'error'); replacePicker.value = ''; return; }
        const dataUrl = await fileToDataURL(file);
        book.pages[page].dataUrl = dataUrl;
        touchPageCache(book.pages[page].id, dataUrl);
        markThumbsDirty();
        await Book.put(book);
        replacePicker.value = '';
        load();
        showToast('差し替えました', 'ok');
      });
      document.getElementById('deletePageBtn').onclick = async () => {
        if (book.pages.length <= 1) { showToast('これ以上削除できません', 'error'); return; }
        if (!confirm('このページを削除しますか？')) return;
        const removed = book.pages.splice(page, 1);
        removed.forEach(p => dropPageCache(p?.id));
        page = Math.max(0, Math.min(page, book.pages.length - 1));
        markThumbsDirty();
        await Book.put(book);
        load();
        showToast('削除しました', 'ok');
      };

      // add/insert
      (function wireInsert() {
        const modal = document.getElementById('pageInsertModal');
        const picker = document.getElementById('insertPicker');
        document.getElementById('insertNowBtn').onclick = async () => {
          const files = Array.from(picker.files || []); if (!files.length) { showToast('画像を選んでください', 'error'); return; }
          const add = []; for (const f of files) { const d = await fileToDataURL(f); add.push({ id: uuid(), dataUrl: d, state: { fav: false, weak: false, done: false, extra: [] }, memo: '' }); }
          const insertAt = page + 1;
          book.pages.splice(insertAt, 0, ...add);
          add.forEach(p => touchPageCache(p.id, p.dataUrl));
          markThumbsDirty();
          await Book.put(book);
          modal.style.display = 'none'; picker.value = ''; page = insertAt; load(); showToast('挿入しました', 'ok');
        };
        modal.addEventListener('click', (e) => { if (e.target === modal) modal.style.display = 'none'; });
      })();

      // close modals
      document.querySelectorAll('.modal').forEach(m => m.addEventListener('click', (e) => { if (e.target === m) m.style.display = 'none'; }));
      document.querySelectorAll('[data-close]').forEach(btn => {
        btn.addEventListener('click', () => {
          const modal = btn.closest('.modal');
          if (modal) modal.style.display = 'none';
        });
      });

      // initial
      setFit('contain');
      load();
      (async () => {
        if (pendingRightBookId && pendingRightBookId !== book.id) {
          const target = await Book.get(pendingRightBookId);
          if (target) {
            rightBook = target;
            rightIndex = clamp(savedPose?.rightIndex ?? rightIndex, 0, (target.pages?.length || 1) - 1);
            if (mode !== 'compare' && savedPose?.mode === 'compare') { mode = 'compare'; }
            load();
          }
        }
        if (pendingCompareWindowBookId) {
          const target = await Book.get(pendingCompareWindowBookId);
          if (target) {
            compareWindowBook = target;
            if (typeof savedPose?.compareWindow?.index === 'number') {
              compareWindowIndex = clamp(savedPose.compareWindow.index, 0, (target.pages?.length || 1) - 1);
            }
            requestCompareViewReset();
            updateCompareWindowUI(true);
            applyCompareTransform();
          }
        }
      })();
      renderOpenTabs();
    }

    /** ===== Viewer (Box) ===== */
    function mountBoxViewer(box) {
      state.view = 'viewer';
      state.viewerContext = 'box';
      state.activeTab = 'boxes';
      viewerMemory.box.id = box.id;
      viewerMemory.box.closed = false;
      ensureOpenTab('box', box.id, box.name || '無題ボックス');
      const host = document.getElementById('viewerView'); host.innerHTML = ''; host.classList.remove('hidden');
      const wrap = document.createElement('div'); wrap.className = 'viewer';
      wrap.innerHTML = `
    <div class="stage" id="stage">
      <div class="stage-inner">
        <img id="pageImg" alt="snippet" draggable="false"/>
      </div>
    </div>
    <div class="control">
      <div class="row space"><h3 style="margin:0">${escapeHTML(box.name)}</h3><span class="muted">${(box.snippets || []).length} 件</span></div>
      <div class="toolbar" style="margin-bottom:6px">
        <button class="btn" id="prevBtn">← 前へ</button>
        <button class="btn" id="nextBtn">次へ →</button>
        <button class="btn ghost" id="gridBtn">一覧</button>
        <button class="btn ghost" id="editSnip">切り取りの編集</button>
        <button class="btn" id="renameBox">ボックス編集</button>
      </div>
      <div class="hr" style="height:1px;background:#1d2738;margin:8px 0"></div>
      <div class="list" id="thumbList" style="flex:1"></div>
      <div class="hr" style="height:1px;background:#1d2738;margin:8px 0"></div>
      <button class="btn ghost" id="backBoxes">← ボックス一覧に戻る</button>
    </div>`;
      host.appendChild(wrap);
      try { ReaderHpBar.update(studyNowMs()); } catch (e) { }
      let idx = 0;
      const img = document.getElementById('pageImg');
      function setSingle() {
        document.getElementById('stageSingle').classList.remove('hidden');
        document.getElementById('stageDual').classList.add('hidden');
      }
      function setDual() {
        document.getElementById('stageSingle').classList.add('hidden');
        document.getElementById('stageDual').classList.remove('hidden');
      }
      function load() { img.src = (box.snippets?.[idx]?.dataUrl) || ''; updateThumbs(); }
      function updateThumbs() {
        const list = document.getElementById('thumbList'); list.innerHTML = '';
        (box.snippets || []).forEach((s, i) => {
          const it = document.createElement('div'); it.className = 'item' + (i === idx ? ' active' : '');
          const label = s.name ? escapeHTML(s.name) : `切り抜き${i + 1}`;
          const marks = s.weak ? ' ×' : '';
          it.innerHTML = `<span class="pill">${i + 1}</span> <span>${label}</span><span class="muted">${marks}</span>`;
          it.onclick = () => { idx = i; load(); };
          list.appendChild(it);
        });
      }
      document.getElementById('prevBtn').onclick = () => { idx = (idx - 1 + (box.snippets?.length || 1)) % (box.snippets?.length || 1); load(); };
      document.getElementById('nextBtn').onclick = () => { idx = (idx + 1) % (box.snippets?.length || 1); load(); };
      document.getElementById('gridBtn').onclick = () => {
        const m = document.createElement('div'); m.className = 'modal'; m.style.display = 'flex';
        const b = document.createElement('div'); b.className = 'box'; b.style.width = 'min(880px,96vw)';
        b.innerHTML = '<h3>一覧</h3><div class="thumbGrid" id="gridx"></div><div class="row" style="justify-content:flex-end;margin-top:8px"><button class="btn ghost" data-close>閉じる</button></div>';
        m.appendChild(b); document.body.appendChild(m);
        const gx = b.querySelector('#gridx');
        (box.snippets || []).forEach((s, i) => { const d = document.createElement('div'); d.className = 'thumbCell'; d.innerHTML = `<img src="${s.dataUrl}"/><div class="small">${escapeHTML(s.name || ('切り抜き' + (i + 1)))}</div>`; d.onclick = () => { idx = i; load(); m.remove(); }; gx.appendChild(d); });
        b.querySelector('[data-close]').onclick = () => m.remove();
      };
      document.getElementById('editSnip').onclick = async () => {
        if (!box.snippets || !box.snippets.length) return;
        const s = box.snippets[idx];
        const m = document.createElement('div'); m.className = 'modal'; m.style.display = 'flex';
        const b = document.createElement('div'); b.className = 'box';
        b.innerHTML = `<h3>切り取りの編集</h3>
      <input id="snName" class="input" value="${escapeHTML(s.name || '')}" placeholder="名前" style="margin-bottom:8px"/>
      <textarea id="snNote" class="input" placeholder="メモ">${escapeHTML(s.note || '')}</textarea>
      <label class="row" style="gap:8px;margin-top:8px"><input type="checkbox" id="snWeak" ${s.weak ? 'checked' : ''}/> 苦手</label>
      <div class="row space" style="margin-top:10px">
        <button class="btn ghost" data-close>閉じる</button>
        <button class="btn primary" data-save>保存</button>
      </div>`;
        m.appendChild(b); document.body.appendChild(m);
        b.querySelector('[data-close]').onclick = () => m.remove();
        b.querySelector('[data-save]').onclick = async () => {
          s.name = b.querySelector('#snName').value || '';
          s.note = b.querySelector('#snNote').value || '';
          s.weak = b.querySelector('#snWeak').checked;
          await Box.put(box); m.remove(); load(); showToast('保存しました', 'ok');
        };
      };
      document.getElementById('renameBox').onclick = () => editBoxMeta(box);
      document.getElementById('backBoxes').onclick = () => {
        state.view = 'boxes';
        state.viewerContext = null;
        viewerMemory.box.closed = true;
        viewerMemory.box.id = null;
        host.innerHTML = '';
        host.classList.add('hidden');
        showTab('boxes');
      };
      load();
      renderOpenTabs();
    }

    /** ===== Upload/Create ===== */
    const upload = { files: [], setFiles(list) { this.files = Array.from(list); renderPreview(); } };
    function renderPreview() {
      const area = document.getElementById('previewArea'); area.innerHTML = '';
      upload.files.forEach((f, i) => {
        const url = URL.createObjectURL(f);
        const d = document.createElement('div'); d.className = 'card'; d.draggable = true; d.dataset.idx = i;
        d.innerHTML = `<div class="thumb"><img src="${url}"/></div><div class="meta"><div class="row space"><span class="muted">${escapeHTML(f.name)}</span><span class="pill">${i + 1}</span></div></div>`;
        d.ondragstart = (e) => { e.dataTransfer.setData('text/plain', i); };
        d.ondragover = (e) => e.preventDefault();
        d.ondrop = (e) => { e.preventDefault(); const from = +e.dataTransfer.getData('text/plain'); const to = +d.dataset.idx; moveFile(from, to); };
        area.appendChild(d);
      });
    }
    function moveFile(from, to) { if (from === to) return; const arr = upload.files; const item = arr.splice(from, 1)[0]; arr.splice(to, 0, item); renderPreview(); }
    async function createBookFromUpload() {
      const title = (document.getElementById('bookTitle').value || '無題').trim();
      const tags = (document.getElementById('bookTags').value || '').split(',').map(s => s.trim()).filter(Boolean);
      const folder = (document.getElementById('bookFolder').value || '').trim();
      if (!upload.files.length) { showToast('画像を選択してください', 'error'); return; }
      const pages = [];
      for (const f of upload.files) { const dataUrl = await fileToDataURL(f); pages.push({ id: uuid(), dataUrl, state: { fav: false, weak: false, done: false, extra: [] }, memo: '' }); }
      const book = { id: uuid(), title, tags, folder, createdAt: Date.now(), pages, firstPageNumber: 1, coverDataUrl: null, customStates: [], bookmarks: [], answerBookIds: [] };
      await Book.add(book);
      upload.files = []; renderPreview(); document.getElementById('imagePicker').value = '';
      document.getElementById('bookTitle').value = ''; document.getElementById('bookTags').value = ''; document.getElementById('bookFolder').value = '';
      showToast('保存しました', 'ok'); refresh(); showTab('library');
    }
    function setupUploadUI() {
      const picker = document.getElementById('imagePicker');
      picker.onchange = (e) => upload.setFiles(e.target.files);
      document.getElementById('clearImages').onclick = () => { upload.files = []; renderPreview(); picker.value = ''; };
      const dz = document.getElementById('dropZone');
      dz.ondragover = (e) => { e.preventDefault(); dz.style.background = '#0b1322'; };
      dz.ondragleave = () => dz.style.background = '';
      dz.ondrop = (e) => { e.preventDefault(); dz.style.background = ''; upload.setFiles(e.dataTransfer.files); };
      document.getElementById('createBook').onclick = createBookFromUpload;
    }

    /** ===== Sidebar ===== */
    function renderTags(books) {
      const area = document.getElementById('tagArea'); area.innerHTML = '';
      const counts = new Map(); books.forEach(b => (b.tags || []).forEach(t => counts.set(t, (counts.get(t) || 0) + 1)));
      [...counts.entries()].sort((a, b) => b[1] - a[1]).slice(0, 50).forEach(([t, n]) => {
        const chip = document.createElement('span'); chip.className = 'chip'; chip.textContent = `${t} (${n})`;
        chip.onclick = () => { state.tagFilter = (state.tagFilter === t ? null : t); refresh(); };
        if (state.tagFilter === t) chip.style.borderColor = 'var(--brand)';
        area.appendChild(chip);
      });
    }
    function renderFolders(books) {
      const tree = document.getElementById('folderTree'); tree.innerHTML = '';
      const groups = groupBy(books, b => b.folder || '未分類');
      Object.keys(groups).sort().forEach(f => {
        const d = document.createElement('div'); d.className = 'fnode';
        d.innerHTML = `<span class="pill">${groups[f].length}</span> <span>${escapeHTML(f)}</span>`;
        d.onclick = () => { state.folderFilter = (state.folderFilter === f ? null : f); refresh(); };
        if (state.folderFilter === f) d.style.border = '1px solid var(--brand)';
        tree.appendChild(d);
      });
    }
    function updateHiddenAnswersInfo(hiddenCount) {
      const info = document.getElementById('hiddenAnswersInfo');
      if (!info) return;
      if (hiddenCount > 0) {
        info.textContent = state.showAnswers ? `${hiddenCount}冊` : `${hiddenCount}冊を非表示`;
      } else {
        info.textContent = '';
      }
    }
    async function removeAnswerReferences(bookId) {
      if (!bookId) return;
      const books = Array.isArray(window.__allBooksCache) ? window.__allBooksCache : await Book.listMeta();
      let updated = false;
      for (const bk of books) {
        if (!Array.isArray(bk.answerBookIds)) continue;
        if (!bk.answerBookIds.includes(bookId)) continue;
        bk.answerBookIds = bk.answerBookIds.filter(id => id !== bookId);
        await Book.put(bk);
        updated = true;
      }
      if (updated) {
        window.__allBooksCache = await Book.listMeta();
      }
    }

    /** ===== Export/Import ===== */
    // Create export progress modal
    function createExportProgressModal() {
      let modal = document.getElementById('exportProgressModal');
      if (!modal) {
        modal = document.createElement('div');
        modal.id = 'exportProgressModal';
        modal.style.cssText = `
          position: fixed; inset: 0; z-index: 99999;
          background: rgba(0,0,0,0.7); display: flex;
          align-items: center; justify-content: center;
        `;
        modal.innerHTML = `
          <div style="background: #1e2330; border-radius: 12px; padding: 24px 32px; min-width: 320px; text-align: center;">
            <div style="color: #e5e9f5; font-size: 16px; margin-bottom: 12px;" id="exportProgressTitle">エクスポート中...</div>
            <div style="color: #9ca3af; font-size: 13px; margin-bottom: 16px;" id="exportProgressText">準備中...</div>
            <div style="background: #0a0e16; border-radius: 8px; height: 8px; overflow: hidden;">
              <div id="exportProgressBar" style="background: linear-gradient(90deg, #3b82f6, #60a5fa); height: 100%; width: 0%; transition: width 0.2s;"></div>
            </div>
            <div style="color: #6b7280; font-size: 11px; margin-top: 12px;">処理中はページを閉じないでください</div>
          </div>
        `;
        document.body.appendChild(modal);
      }
      modal.style.display = 'flex';
      return {
        setTitle: (t) => { document.getElementById('exportProgressTitle').textContent = t; },
        setText: (t) => { document.getElementById('exportProgressText').textContent = t; },
        setProgress: (p) => { document.getElementById('exportProgressBar').style.width = `${p}%`; },
        close: () => { modal.style.display = 'none'; }
      };
    }

    async function exportData() {
      const progress = createExportProgressModal();

      // Check if streaming export is available (Chrome only)
      const canStream = 'showSaveFilePicker' in window;

      try {
        progress.setTitle('全データをエクスポート中...');
        progress.setText('本のリストを取得中...');
        progress.setProgress(0);

        const rawBooks = await Book.listMeta();
        const totalBooks = rawBooks.length;
        progress.setText(`${totalBooks}冊の本を処理します...`);
        progress.setProgress(2);

        if (canStream) {
          // ========== STREAMING EXPORT (Chrome) - Memory efficient ==========
          let fileHandle;
          try {
            fileHandle = await window.showSaveFilePicker({
              suggestedName: 'study-ebook-backup.json',
              types: [{ description: 'JSON', accept: { 'application/json': ['.json'] } }]
            });
          } catch (e) {
            if (e.name === 'AbortError') {
              progress.close();
              return;
            }
            throw e;
          }

          const writable = await fileHandle.createWritable();
          const encoder = new TextEncoder();

          // Write header
          await writable.write(encoder.encode('{\n  "version": 2,\n  "books": [\n'));

          // Process and write each book one at a time
          let firstBook = true;
          for (let i = 0; i < totalBooks; i++) {
            const bookMeta = rawBooks[i];
            progress.setText(`本 ${i + 1}/${totalBooks}: ${bookMeta.title || '無題'}`);
            progress.setProgress(2 + (i / totalBooks) * 70);

            const b = await Book.get(bookMeta.id);
            if (!b) continue;

            const fullBook = await materializeBookPages(b, (page, total) => {
              progress.setText(`本 ${i + 1}/${totalBooks}: ページ ${page}/${total}`);
            });

            // Write separator if not first book
            if (!firstBook) {
              await writable.write(encoder.encode(',\n'));
            }
            firstBook = false;

            // Write this book and IMMEDIATELY free memory
            const bookJson = JSON.stringify(fullBook);
            await writable.write(encoder.encode(bookJson));

            // Clear memory
            if (fullBook && fullBook.pages) {
              fullBook.pages.forEach(p => { p.dataUrl = null; p.blob = null; });
            }

            // Yield to prevent freeze
            await new Promise(r => setTimeout(r, 20));
          }

          // Write books closing bracket
          await writable.write(encoder.encode('\n  ],\n'));

          // Write boxes
          progress.setText('ボックスを取得中...');
          progress.setProgress(75);
          const boxes = await Box.list();
          await writable.write(encoder.encode('  "boxes": '));
          await writable.write(encoder.encode(JSON.stringify(boxes)));
          await writable.write(encoder.encode(',\n'));

          // Write planner events
          progress.setText('予定データを取得中...');
          progress.setProgress(80);
          let plannerEvents = [];
          try {
            plannerEvents = await new Promise((resolve) => {
              const req = indexedDB.open('NLStoreDB', 1);
              req.onerror = () => resolve([]);
              req.onsuccess = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains('events')) {
                  resolve([]);
                  return;
                }
                const tx = db.transaction('events', 'readonly');
                const store = tx.objectStore('events');
                const getAll = store.getAll();
                getAll.onsuccess = () => resolve(getAll.result || []);
                getAll.onerror = () => resolve([]);
              };
            });
          } catch (e) {
            console.warn('[Export] Failed to get planner events:', e);
          }
          await writable.write(encoder.encode('  "plannerEvents": '));
          await writable.write(encoder.encode(JSON.stringify(plannerEvents)));
          await writable.write(encoder.encode(',\n'));
          console.log('[Export] Wrote planner events:', plannerEvents.length);

          // Write settings
          progress.setText('設定を取得中...');
          progress.setProgress(85);
          const settings = exportAllSettings();
          try { await fillStudyCalendarSettingsFromIdb(settings); } catch (_) { }
          const settingsPayload = { settings };
          await appendOriginalLessonBackup(settingsPayload);
          await writable.write(encoder.encode('  "settings": '));
          await writable.write(encoder.encode(JSON.stringify(settingsPayload.settings)));
          if (settingsPayload.originalLesson) {
            await writable.write(encoder.encode(',\n  "originalLesson": '));
            await writable.write(encoder.encode(JSON.stringify(settingsPayload.originalLesson)));
          }
          await writable.write(encoder.encode('\n}\n'));

          // Close file
          await writable.close();

          progress.setProgress(100);
          progress.setText('完了！');
          await new Promise(r => setTimeout(r, 500));
          progress.close();
          showToast(`エクスポート完了（本: ${totalBooks}冊, 予定: ${plannerEvents.length}件）`, 'ok');

        } else {
          // ========== FALLBACK EXPORT (Safari/Firefox) - Split into multiple files ==========
          progress.setText('大きなデータは複数ファイルに分割してエクスポートします...');
          await new Promise(r => setTimeout(r, 500));

          let exportedCount = 0;
          let failedCount = 0;

          try {
            // Export settings first (small)
            progress.setText('設定をエクスポート中...');
            progress.setProgress(5);
            const settings = exportAllSettings();
            try { await fillStudyCalendarSettingsFromIdb(settings); } catch (_) { }
            const settingsPayload = { settings };
            await appendOriginalLessonBackup(settingsPayload);
            const settingsBundle = { version: 2, settings: settingsPayload.settings };
            if (settingsPayload.originalLesson) settingsBundle.originalLesson = settingsPayload.originalLesson;
            await downloadJSONAsync(settingsBundle, 'backup-settings.json');
            exportedCount++;
            await new Promise(r => setTimeout(r, 300));
          } catch (e) {
            console.error('[Export] Settings export failed:', e);
            failedCount++;
          }

          try {
            // Export boxes (usually small)
            progress.setText('ボックスをエクスポート中...');
            progress.setProgress(10);
            const boxes = await Box.list();
            await downloadJSONAsync({ version: 2, boxes }, 'backup-boxes.json');
            exportedCount++;
            await new Promise(r => setTimeout(r, 300));
          } catch (e) {
            console.error('[Export] Boxes export failed:', e);
            failedCount++;
          }

          try {
            // Export planner events
            progress.setText('予定データをエクスポート中...');
            progress.setProgress(12);
            const plannerEvents = await new Promise((resolve) => {
              const req = indexedDB.open('NLStoreDB', 1);
              req.onerror = () => resolve([]);
              req.onsuccess = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains('events')) {
                  resolve([]);
                  return;
                }
                const tx = db.transaction('events', 'readonly');
                const store = tx.objectStore('events');
                const getAll = store.getAll();
                getAll.onsuccess = () => resolve(getAll.result || []);
                getAll.onerror = () => resolve([]);
              };
            });
            if (plannerEvents.length > 0) {
              await downloadJSONAsync({ version: 2, plannerEvents }, 'backup-planner.json');
              exportedCount++;
              console.log('[Export] Exported planner events:', plannerEvents.length);
            }
            await new Promise(r => setTimeout(r, 300));
          } catch (e) {
            console.error('[Export] Planner export failed:', e);
            failedCount++;
          }

          // Export each book separately with memory management
          for (let i = 0; i < totalBooks; i++) {
            const bookMeta = rawBooks[i];
            progress.setText(`本 ${i + 1}/${totalBooks}: ${bookMeta.title || '無題'}`);
            progress.setProgress(10 + (i / totalBooks) * 85);

            try {
              const b = await Book.get(bookMeta.id);
              if (!b) continue;

              const fullBook = await materializeBookPages(b, (page, total) => {
                progress.setText(`本 ${i + 1}/${totalBooks}: ページ ${page}/${total}`);
              });

              // Create filename from title
              const safeTitle = (bookMeta.title || 'book').replace(/[^a-zA-Z0-9\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/g, '_').slice(0, 30);

              // Use async version for memory safety
              await downloadJSONAsync({ version: 2, book: fullBook }, `backup-book-${i + 1}-${safeTitle}.json`);
              exportedCount++;

              // Clear memory immediately
              if (fullBook && fullBook.pages) {
                fullBook.pages.forEach(p => { p.dataUrl = null; p.blob = null; });
                fullBook.pages = null;
              }

              // Garbage collection hint
              await gcHint();
              await new Promise(r => setTimeout(r, 300));

            } catch (e) {
              console.error(`[Export] Book ${i + 1} export failed:`, e);
              failedCount++;

              // If memory error, wait longer and try to continue
              if (e.message?.includes('メモリ') || e.message?.includes('memory') || e.name === 'RangeError') {
                progress.setText(`本 ${i + 1}/${totalBooks}: メモリ不足でスキップ`);
                await gcHint();
                await new Promise(r => setTimeout(r, 1000));
              }
            }
          }

          progress.setProgress(100);
          progress.setText('完了！');
          await new Promise(r => setTimeout(r, 500));
          progress.close();

          if (failedCount > 0) {
            showToast(`エクスポート完了: ${exportedCount}個成功、${failedCount}個失敗`, failedCount > exportedCount ? 'error' : 'ok');
          } else {
            showToast(`エクスポート完了: ${exportedCount}個のファイルがダウンロードされました`, 'ok');
          }
        }

      } catch (e) {
        progress.close();
        console.error('Export error:', e);
        showToast('エクスポートに失敗しました: ' + e.message, 'error');
      }
    }
    // Memory-efficient JSON download with chunked processing
    async function downloadJSONAsync(obj, filename, progress) {
      try {
        // Yield before heavy JSON operation to let UI breathe
        await new Promise(r => setTimeout(r, 10));

        // For very large objects, we stringify in a way that's safer
        let jsonStr;
        try {
          jsonStr = JSON.stringify(obj, null, 2);
        } catch (e) {
          // If full stringify fails, try without formatting (smaller memory footprint)
          console.warn('[Export] Formatted stringify failed, trying compact:', e.message);
          jsonStr = JSON.stringify(obj);
        }

        // Create blob and free the string reference
        const blob = new Blob([jsonStr], { type: 'application/json' });
        jsonStr = null; // Help GC

        // Create and trigger download
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();

        // Clean up after a short delay to ensure download started
        await new Promise(r => setTimeout(r, 100));
        URL.revokeObjectURL(url);

        return true;
      } catch (e) {
        console.error('[Export] downloadJSONAsync failed:', e);
        if (e.message?.includes('memory') || e.message?.includes('heap') || e.name === 'RangeError') {
          throw new Error('メモリ不足です。データが大きすぎます。');
        }
        throw e;
      }
    }

    function downloadJSON(obj, filename) {
      try {
        const blob = new Blob([JSON.stringify(obj, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        setTimeout(() => URL.revokeObjectURL(url), 1000);
      } catch (e) {
        console.error('[Export] downloadJSON failed:', e);
        throw e;
      }
    }

    function parseJsonMaybe(raw) {
      if (raw === undefined) return { has: false, value: null, ok: false };
      if (raw === null) return { has: true, value: null, ok: true };
      if (typeof raw === 'string') {
        try { return { has: true, value: JSON.parse(raw), ok: true }; } catch (_) { return { has: true, value: null, ok: false }; }
      }
      return { has: true, value: raw, ok: true };
    }
    function isEmptyValue(val) {
      if (!val) return true;
      if (Array.isArray(val)) return val.length === 0;
      if (typeof val === 'object') return Object.keys(val).length === 0;
      return false;
    }
    function countCompletedRecords(records) {
      if (!records || typeof records !== 'object') return 0;
      let total = 0;
      Object.values(records).forEach((list) => {
        if (Array.isArray(list)) total += list.length;
      });
      return total;
    }
    async function readStudyCalendarDbSnapshot() {
      if (typeof indexedDB === 'undefined') return {};
      try {
        return await new Promise((resolve) => {
          const req = indexedDB.open('StudyCalendarDB', 1);
          req.onupgradeneeded = (e) => {
            const db = e.target.result;
            if (!db.objectStoreNames.contains('kv')) {
              db.createObjectStore('kv', { keyPath: 'key' });
            }
          };
          req.onerror = () => resolve({});
          req.onsuccess = (e) => {
            const db = e.target.result;
            if (!db.objectStoreNames.contains('kv')) { resolve({}); return; }
            const tx = db.transaction('kv', 'readonly');
            const store = tx.objectStore('kv');
            const read = (key) => new Promise((res) => {
              try {
                const r = store.get(key);
                r.onsuccess = () => res(r.result ? (r.result.value ?? r.result.data ?? null) : null);
                r.onerror = () => res(null);
              } catch (_) { res(null); }
            });
            Promise.all([read('schedules'), read('schedules-memory'), read('completed')])
              .then(([schedules, memory, completed]) => resolve({ schedules, memory, completed }))
              .catch(() => resolve({}));
          };
        });
      } catch (_) { return {}; }
    }
    async function fillStudyCalendarSettingsFromIdb(settings) {
      if (!settings || typeof settings !== 'object') return;
      const scheduleKey = 'sc-schedules';
      const memKey = 'sc-schedule-memory';
      const completedKey = 'sc-completed';
      const localSchedule = parseJsonMaybe(settings[scheduleKey]);
      const localMem = parseJsonMaybe(settings[memKey]);
      const localCompleted = parseJsonMaybe(settings[completedKey]);
      const needSchedule = !localSchedule.ok || isEmptyValue(localSchedule.value);
      const needMem = !localMem.ok || isEmptyValue(localMem.value);
      const localCompletedCount = localCompleted.ok ? countCompletedRecords(localCompleted.value) : 0;
      const needCompleted = !localCompleted.ok || isEmptyValue(localCompleted.value);
      const dbValues = await readStudyCalendarDbSnapshot();
      const dbSchedule = parseJsonMaybe(dbValues.schedules);
      const dbMem = parseJsonMaybe(dbValues.memory);
      const dbCompleted = parseJsonMaybe(dbValues.completed);
      if (needSchedule && dbSchedule.ok && !isEmptyValue(dbSchedule.value)) {
        try { settings[scheduleKey] = JSON.stringify(dbSchedule.value); } catch (_) { }
      }
      if (needMem && dbMem.ok && !isEmptyValue(dbMem.value)) {
        try { settings[memKey] = JSON.stringify(dbMem.value); } catch (_) { }
      }
      if (dbCompleted.ok && !isEmptyValue(dbCompleted.value)) {
        const dbCount = countCompletedRecords(dbCompleted.value);
        if (needCompleted || dbCount > localCompletedCount) {
          try { settings[completedKey] = JSON.stringify(dbCompleted.value); } catch (_) { }
        }
      }
    }
    async function restoreStudyCalendarFromBackup(data) {
      const settings = data?.settings;
      if (!settings || typeof settings !== 'object') return { restored: false };
      const scheduleKey = 'sc-schedules';
      const memKey = 'sc-schedule-memory';
      const completedKey = 'sc-completed';
      const parsedSchedule = parseJsonMaybe(settings[scheduleKey]);
      const parsedMem = parseJsonMaybe(settings[memKey]);
      const parsedCompleted = parseJsonMaybe(settings[completedKey]);
      const entries = [];
      if (parsedSchedule.has && parsedSchedule.ok) {
        const val = (parsedSchedule.value === null) ? {} : parsedSchedule.value;
        if (val && typeof val === 'object') entries.push({ key: 'schedules', value: val });
      }
      if (parsedMem.has && parsedMem.ok) {
        const val = (parsedMem.value === null) ? {} : parsedMem.value;
        if (val && typeof val === 'object') entries.push({ key: 'schedules-memory', value: val });
      }
      if (parsedCompleted.has && parsedCompleted.ok) {
        const val = (parsedCompleted.value === null) ? {} : parsedCompleted.value;
        if (val && typeof val === 'object') entries.push({ key: 'completed', value: val });
      }
      if (!entries.length || typeof indexedDB === 'undefined') return { restored: false };
      try {
        await new Promise((resolve) => {
          const req = indexedDB.open('StudyCalendarDB', 1);
          req.onupgradeneeded = (e) => {
            const db = e.target.result;
            if (!db.objectStoreNames.contains('kv')) {
              db.createObjectStore('kv', { keyPath: 'key' });
            }
          };
          req.onerror = () => resolve(false);
          req.onsuccess = (e) => {
            const db = e.target.result;
            if (!db.objectStoreNames.contains('kv')) { resolve(false); return; }
            const tx = db.transaction('kv', 'readwrite');
            const store = tx.objectStore('kv');
            const now = Date.now();
            entries.forEach(item => { store.put({ key: item.key, value: item.value, updated: now }); });
            tx.oncomplete = () => resolve(true);
            tx.onerror = () => resolve(false);
          };
        });
        return { restored: true, keys: entries.map(e => e.key) };
      } catch (_) { return { restored: false }; }
    }
    async function appendOriginalLessonBackup(exportData) {
      if (!exportData || typeof exportData !== 'object') return;
      if (!exportData.settings || typeof exportData.settings !== 'object') return;
      try {
        const lessonKeys = ['ol_lessons_v1', 'ol_settings_v1', 'ol_session_v1', 'ol_meta_v1'];
        const readSessionValue = (key) => {
          try { return sessionStorage.getItem(key); } catch (_) { return null; }
        };
        const readOlFromIdb = async () => {
          try {
            return await new Promise((resolve) => {
              const req = indexedDB.open('OriginalLessonDB');
              req.onupgradeneeded = (e) => {
                const odb = e.target.result;
                if (!odb.objectStoreNames.contains('ol_store')) {
                  odb.createObjectStore('ol_store', { keyPath: 'key' });
                }
              };
              req.onerror = () => resolve({});
              req.onsuccess = (e) => {
                const odb = e.target.result;
                if (!odb.objectStoreNames.contains('ol_store')) { resolve({}); return; }
                const tx = odb.transaction('ol_store', 'readonly');
                const store = tx.objectStore('ol_store');
                const read = (key) => new Promise((res) => {
                  try {
                    const r = store.get(key);
                    r.onsuccess = () => {
                      const rec = r.result;
                      res(rec ? (rec.data ?? rec.value ?? rec.payload ?? null) : null);
                    };
                    r.onerror = () => res(null);
                  } catch (_) { res(null); }
                });
                Promise.all(lessonKeys.map(read)).then((values) => {
                  const out = {};
                  lessonKeys.forEach((key, idx) => { out[key] = values[idx]; });
                  resolve(out);
                }).catch(() => resolve({}));
              };
            });
          } catch (_) { return {}; }
        };
        const readOlFromMainDb = async (keys) => {
          await dbReady;
          if (!db) return {};
          const t = db.transaction('settings', 'readonly');
          const store = t.objectStore('settings');
          const read = (key) => new Promise((res) => {
            try {
              const req = store.get(key);
              req.onsuccess = () => {
                const rec = req.result;
                res(rec ? (rec.data ?? rec.value ?? rec.payload ?? null) : null);
              };
              req.onerror = () => res(null);
            } catch (_) { res(null); }
          });
          const values = await Promise.all((keys || []).map(read));
          const out = {};
          (keys || []).forEach((key, idx) => { out[key] = values[idx]; });
          return out;
        };
        const normalizeJson = (raw) => {
          if (raw === null || raw === undefined) return null;
          if (typeof raw === 'string') {
            try { return JSON.parse(raw); } catch (_) { return raw; }
          }
          return raw;
        };
        const normalizeLessonArray = (raw) => {
          const val = normalizeJson(raw);
          return Array.isArray(val) ? val : [];
        };
        const normalizeMeta = (raw) => {
          const val = normalizeJson(raw);
          if (!val || typeof val !== 'object') return null;
          const updatedAt = Number(val.updatedAt) || 0;
          const count = Number.isFinite(val.count) ? val.count : null;
          return { updatedAt, count };
        };
        const localSnapshot = {};
        lessonKeys.forEach((key) => {
          const hasKey = Object.prototype.hasOwnProperty.call(exportData.settings, key);
          const val = hasKey ? exportData.settings[key] : undefined;
          if (val !== undefined && val !== null && val !== '') {
            localSnapshot[key] = val;
            return;
          }
          const sessionVal = readSessionValue(key);
          if (sessionVal !== null && sessionVal !== undefined && sessionVal !== '') {
            localSnapshot[key] = sessionVal;
          }
        });
        const idbValues = await readOlFromIdb();
        const missingIdb = lessonKeys.filter(key => idbValues[key] === null || idbValues[key] === undefined);
        if (missingIdb.length) {
          try {
            const legacy = await readOlFromMainDb(missingIdb);
            missingIdb.forEach(key => {
              if (legacy[key] !== undefined && legacy[key] !== null) idbValues[key] = legacy[key];
            });
          } catch (_) { }
        }
        const localLessons = normalizeLessonArray(localSnapshot.ol_lessons_v1);
        const idbLessons = normalizeLessonArray(idbValues.ol_lessons_v1);
        const localMeta = normalizeMeta(localSnapshot.ol_meta_v1);
        const idbMeta = normalizeMeta(idbValues.ol_meta_v1);
        let source = 'local';
        if (idbLessons.length && !localLessons.length) source = 'idb';
        if (idbMeta?.updatedAt && (!localMeta?.updatedAt || idbMeta.updatedAt > localMeta.updatedAt)) source = 'idb';
        const pick = (key) => {
          const primary = source === 'idb' ? idbValues[key] : localSnapshot[key];
          const fallback = source === 'idb' ? localSnapshot[key] : idbValues[key];
          return primary !== undefined && primary !== null ? primary : fallback;
        };
        const picked = {};
        lessonKeys.forEach(key => {
          const val = pick(key);
          if (val === undefined || val === null) return;
          picked[key] = val;
          exportData.settings[key] = typeof val === 'string' ? val : JSON.stringify(val);
        });
        const lessonsObj = normalizeJson(picked.ol_lessons_v1);
        const settingsObj = normalizeJson(picked.ol_settings_v1);
        const sessionObj = normalizeJson(picked.ol_session_v1);
        const metaObj = normalizeJson(picked.ol_meta_v1);
        if (lessonsObj || settingsObj || sessionObj || metaObj) {
          exportData.originalLesson = {
            source,
            lessons: Array.isArray(lessonsObj) ? lessonsObj : [],
            settings: settingsObj && typeof settingsObj === 'object' ? settingsObj : {},
            session: sessionObj === undefined ? null : sessionObj,
            meta: metaObj && typeof metaObj === 'object' ? metaObj : {}
          };
        }
      } catch (_) { }
    }

    async function collectSettingsExportPayload(progress) {
      // Ensure DB and stores are ready
      try { await dbReady; } catch (_) { }
      if (window.TodoStore?.ready) {
        try { await window.TodoStore.ready(); } catch (_) { }
      }
      const setText = (t) => progress?.setText?.(t);
      const setProg = (v) => progress?.setProgress?.(v);
      setText && setText('設定を取得中...');
      setProg && setProg(10);

      const exportData = {
        version: 2,
        type: 'settings-only',
        exportDate: new Date().toISOString()
      };

      // Export settings from localStorage
      setText && setText('localStorage設定を取得中...');
      setProg && setProg(20);
      exportData.settings = exportAllSettings();
      try { await fillStudyCalendarSettingsFromIdb(exportData.settings); } catch (_) { }
      let missRaw = null;
      let missCount = 0;
      try { missRaw = localStorage.getItem(MISS_STORAGE_KEY); } catch (_) { }
      if (missRaw != null) {
        missCount = countMissMarks(missRaw);
      }
      if (missCount === 0) {
        try {
          setText && setText('ミス目印を取得中...');
          setProg && setProg(25);
          const missFromBooks = await buildMissStorageFromBooks();
          if (missFromBooks) {
            const builtRaw = JSON.stringify(missFromBooks);
            const builtCount = countMissMarks(builtRaw);
            if (builtCount > missCount) {
              missRaw = builtRaw;
              missCount = builtCount;
            }
          }
        } catch (_) { }
      }
      if (missRaw != null && missRaw !== '') {
        exportData.missMarks = missRaw;
        if (exportData.settings && typeof exportData.settings === 'object') {
          exportData.settings[MISS_STORAGE_KEY] = missRaw;
        }
      }
      await appendOriginalLessonBackup(exportData);

      // Export planner events from NLStoreDB
      setText && setText('予定データを取得中...');
      setProg && setProg(40);
      try {
        exportData.plannerEvents = await new Promise((resolve) => {
          const req = indexedDB.open('NLStoreDB', 1);
          req.onerror = () => resolve([]);
          req.onsuccess = (e) => {
            const db = e.target.result;
            if (!db.objectStoreNames.contains('events')) {
              resolve([]);
              return;
            }
            const tx = db.transaction('events', 'readonly');
            const store = tx.objectStore('events');
            const getAll = store.getAll();
            getAll.onsuccess = () => resolve(getAll.result || []);
            getAll.onerror = () => resolve([]);
          };
        });
      } catch (e) {
        console.warn('[ExportSettings] Failed to get planner events:', e);
        exportData.plannerEvents = [];
      }

      // Export draws from NLStoreDB
      setText && setText('描画データを取得中...');
      setProg && setProg(60);
      try {
        exportData.draws = await new Promise((resolve) => {
          const req = indexedDB.open('NLStoreDB', 1);
          req.onerror = () => resolve({});
          req.onsuccess = (e) => {
            const db = e.target.result;
            if (!db.objectStoreNames.contains('draws')) {
              resolve({});
              return;
            }
            const tx = db.transaction('draws', 'readonly');
            const store = tx.objectStore('draws');
            const getAll = store.getAll();
            getAll.onsuccess = () => {
              const draws = {};
              (getAll.result || []).forEach(item => {
                if (item && item.id) {
                  draws[item.id] = item;
                }
              });
              resolve(draws);
            };
            getAll.onerror = () => resolve({});
          };
        });
      } catch (e) {
        console.warn('[ExportSettings] Failed to get draws:', e);
        exportData.draws = {};
      }

      // Export TODO items (最新状態を優先: TodoStore -> TodoDB)
      setText && setText('TODOデータを取得中...');
      setProg && setProg(80);
      try {
        const active = (window.TodoStore?.all && window.TodoStore.all()) || [];
        const archived = (window.TodoStore?.archived && window.TodoStore.archived()) || [];
        let dbActive = [];
        let dbArchived = [];
        try {
          dbActive = await TodoDB.loadAll();
          dbArchived = await TodoDB.loadArchived();
        } catch (e) {
          console.warn('[ExportSettings] TodoDB load failed:', e);
        }
        const mergeTodos = (primary, secondary) => {
          const map = new Map();
          (secondary || []).forEach(t => { if (t && t.id) map.set(t.id, t); });
          (primary || []).forEach(t => { if (t && t.id) map.set(t.id, t); });
          return Array.from(map.values());
        };
        exportData.todos = mergeTodos(active, dbActive);
        exportData.todosArchived = mergeTodos(archived, dbArchived);
      } catch (e) {
        console.warn('[ExportSettings] Failed to get todos:', e);
        exportData.todos = [];
        exportData.todosArchived = [];
      }

      // Export boxes (本以外データ)
      setText && setText('ボックスを取得中...');
      setProg && setProg(85);
      try {
        exportData.boxes = await Box.list();
      } catch (e) {
        console.warn('[ExportSettings] Failed to get boxes:', e);
        exportData.boxes = [];
      }

      setProg && setProg(90);
      setText && setText('まとめています...');

      const counts = [];
      if (Object.keys(exportData.settings || {}).length > 0) counts.push('設定');
      const originalLessonCount = countOriginalLessonItems(exportData);
      if (originalLessonCount > 0) counts.push(`オリジナル授業${originalLessonCount}件`);
      if ((exportData.plannerEvents || []).length > 0) counts.push(`予定${exportData.plannerEvents.length}件`);
      const drawCount = Object.keys(exportData.draws || {}).length;
      if (drawCount > 0) counts.push(`描画${drawCount}件`);
      const missCountTotal = countMissMarks(getMissMarksFromBackup(exportData));
      if (missCountTotal > 0) counts.push(`ミス${missCountTotal}件`);
      const todoCount = (exportData.todos || []).length + (exportData.todosArchived || []).length;
      if (todoCount > 0) counts.push(`TODO${todoCount}件`);
      if ((exportData.boxes || []).length > 0) counts.push(`ボックス${exportData.boxes.length}件`);

      return { exportData, counts };
    }

    async function restoreOriginalLessonFromBackup(data) {
      if (!data || typeof data !== 'object') return { restored: false, keys: [] };
      const LS_KEY = 'ol_lessons_v1';
      const SETTINGS_KEY = 'ol_settings_v1';
      const SESSION_KEY = 'ol_session_v1';
      const META_KEY = 'ol_meta_v1';
      const rawValues = {};
      const presentKeys = new Set();
      const hasOwn = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
      if (data.originalLesson && typeof data.originalLesson === 'object') {
        const ol = data.originalLesson;
        if (hasOwn(ol, 'lessons')) { rawValues[LS_KEY] = ol.lessons; presentKeys.add(LS_KEY); }
        if (hasOwn(ol, 'settings')) { rawValues[SETTINGS_KEY] = ol.settings; presentKeys.add(SETTINGS_KEY); }
        if (hasOwn(ol, 'session')) { rawValues[SESSION_KEY] = ol.session; presentKeys.add(SESSION_KEY); }
        if (hasOwn(ol, 'meta')) { rawValues[META_KEY] = ol.meta; presentKeys.add(META_KEY); }
      }
      if (data.settings && typeof data.settings === 'object') {
        [LS_KEY, SETTINGS_KEY, SESSION_KEY, META_KEY].forEach((key) => {
          if (!presentKeys.has(key) && hasOwn(data.settings, key)) {
            rawValues[key] = data.settings[key];
            presentKeys.add(key);
          }
        });
      }
      if (!presentKeys.size) return { restored: false, keys: [] };

      const parseJson = (raw) => {
        if (raw === undefined) return { value: undefined, ok: false };
        if (raw === null) return { value: null, ok: true };
        if (typeof raw === 'string') {
          try { return { value: JSON.parse(raw), ok: true }; } catch (_) { return { value: raw, ok: false }; }
        }
        return { value: raw, ok: true };
      };

      let lessonList = null;
      if (presentKeys.has(LS_KEY)) {
        const parsed = parseJson(rawValues[LS_KEY]);
        if (Array.isArray(parsed.value)) lessonList = parsed.value;
        else if (parsed.value == null) lessonList = [];
      }
      if (!presentKeys.has(META_KEY) && Array.isArray(lessonList)) {
        rawValues[META_KEY] = { updatedAt: Date.now(), count: lessonList.length };
        presentKeys.add(META_KEY);
      }

      const storedKeys = [];
      const storeValue = (key, raw) => {
        if (raw === undefined) return;
        let str = '';
        if (typeof raw === 'string') {
          str = raw;
        } else {
          try { str = JSON.stringify(raw); } catch (_) { str = String(raw); }
        }
        try { localStorage.setItem(key, str); } catch (_) { }
        try { sessionStorage.setItem(key, str); } catch (_) { }
        storedKeys.push(key);
      };
      presentKeys.forEach((key) => storeValue(key, rawValues[key]));

      const entries = [];
      const addEntry = (key, raw, validator) => {
        if (raw === undefined) return;
        const parsed = parseJson(raw);
        if (!parsed.ok && typeof raw === 'string') return;
        const value = parsed.value;
        if (!validator(value)) return;
        entries.push({ key, data: value });
      };
      addEntry(LS_KEY, rawValues[LS_KEY], (v) => Array.isArray(v));
      addEntry(SETTINGS_KEY, rawValues[SETTINGS_KEY], (v) => v && typeof v === 'object' && !Array.isArray(v));
      addEntry(SESSION_KEY, rawValues[SESSION_KEY], (v) => v === null || (v && typeof v === 'object'));
      addEntry(META_KEY, rawValues[META_KEY], (v) => v && typeof v === 'object');

      if (entries.length && typeof indexedDB !== 'undefined') {
        try {
          await new Promise((resolve) => {
            const req = indexedDB.open('OriginalLessonDB');
            req.onupgradeneeded = (e) => {
              const odb = e.target.result;
              if (!odb.objectStoreNames.contains('ol_store')) {
                odb.createObjectStore('ol_store', { keyPath: 'key' });
              }
            };
            req.onerror = () => resolve(false);
            req.onsuccess = (e) => {
              const odb = e.target.result;
              if (!odb.objectStoreNames.contains('ol_store')) { resolve(false); return; }
              const tx = odb.transaction('ol_store', 'readwrite');
              const store = tx.objectStore('ol_store');
              const now = Date.now();
              entries.forEach(item => {
                store.put({ key: item.key, data: item.data, updatedAt: now });
              });
              tx.oncomplete = () => resolve(true);
              tx.onerror = () => resolve(false);
            };
          });
        } catch (_) { }
      }

      if (storedKeys.length) {
        try { window.dispatchEvent(new CustomEvent('settings:restored', { detail: { keys: storedKeys } })); } catch (_) { }
      }
      return { restored: storedKeys.length > 0, keys: storedKeys };
    }

    // Export only settings, planner events, and non-book data
    async function exportSettingsOnly() {
      const progress = createExportProgressModal();
      try {
        progress.setTitle('設定をエクスポート中...');
        const { exportData, counts } = await collectSettingsExportPayload(progress);
        progress.setText('ファイルを保存中...');
        progress.setProgress(92);

        // Generate filename with date
        const date = new Date().toISOString().slice(0, 10).replace(/-/g, '');
        const filename = `study-ebook-settings-${date}.json`;

        await downloadJSONAsync(exportData, filename);

        progress.setProgress(100);
        progress.setText('完了！');
        await new Promise(r => setTimeout(r, 500));
        progress.close();

        showToast(`エクスポート完了: ${counts.join('、') || 'データなし'}`, 'ok');
      } catch (e) {
        progress.close();
        console.error('[ExportSettings] Error:', e);
        showToast('エクスポートに失敗しました: ' + e.message, 'error');
      }
    }

    // Import only settings, planner events, and non-book data
    async function importSettingsOnly(file) {
      if (!file) return;

      const progress = createExportProgressModal();
      try {
        progress.setTitle('設定をインポート中...');
        progress.setText('ファイルを読み込み中...');
        progress.setProgress(10);

        const text = await file.text();
        const data = JSON.parse(text);

        if (!data || typeof data !== 'object') {
          throw new Error('無効なJSONファイルです');
        }

        const results = { settings: 0, plannerEvents: 0, draws: 0, todos: 0, boxes: 0, originalLessons: 0, missMarks: 0 };

        // Import settings to localStorage
        if (data.settings && typeof data.settings === 'object') {
          progress.setText('設定を復元中...');
          progress.setProgress(20);
          results.settings = importAllSettings(data.settings);
          console.log('[ImportSettings] Restored', results.settings, 'settings');
        }
        try { await restoreStudyCalendarFromBackup(data); } catch (e) { console.warn('[ImportSettings] Failed to restore schedules:', e); }
        const missRaw = getMissMarksFromBackup(data);
        const missParsed = parseMissBackupData(missRaw);
        const hasMissBackup = (missRaw !== null && missRaw !== undefined);
        if (hasMissBackup) {
          try {
            const missStr = (typeof missRaw === 'string') ? missRaw : JSON.stringify(missRaw);
            localStorage.setItem(MISS_STORAGE_KEY, missStr);
          } catch (_) { }
          results.missMarks = Math.max(0, countMissMarks(missRaw));
          try {
            window.dispatchEvent(new CustomEvent('settings:restored', { detail: { keys: [MISS_STORAGE_KEY] } }));
          } catch (_) { }
          if (missParsed) {
            if (results.missMarks > 0) {
              progress.setText('ミス目印を復元中...');
              progress.setProgress(26);
            }
            try { await applyMissBackupToBooks(missParsed.raw); } catch (_) { }
          }
        }
        try {
          const restored = await restoreOriginalLessonFromBackup(data);
          if (restored?.restored) {
            results.originalLessons = countOriginalLessonItems(data);
            console.log('[ImportSettings] Restored original lessons:', results.originalLessons);
          }
        } catch (e) {
          console.warn('[ImportSettings] Failed to restore original lessons:', e);
        }

        // Import planner events to NLStoreDB
        if (data.plannerEvents && Array.isArray(data.plannerEvents) && data.plannerEvents.length > 0) {
          progress.setText('予定データを復元中...');
          progress.setProgress(40);
          try {
            await new Promise((resolve, reject) => {
              const req = indexedDB.open('NLStoreDB', 1);
              req.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains('events')) {
                  db.createObjectStore('events', { keyPath: 'id' });
                }
              };
              req.onsuccess = (e) => {
                const db = e.target.result;
                const tx = db.transaction('events', 'readwrite');
                const store = tx.objectStore('events');
                // 既存イベントをクリアしてから復元
                store.clear();
                data.plannerEvents.forEach(ev => {
                  store.put(ev);
                  results.plannerEvents++;
                });
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
              };
              req.onerror = () => reject(req.error);
            });
            console.log('[ImportSettings] Restored', results.plannerEvents, 'planner events');
          } catch (e) {
            console.error('[ImportSettings] Failed to import planner events:', e);
          }
        }

        // Import draws to NLStoreDB
        if (data.draws && typeof data.draws === 'object' && Object.keys(data.draws).length > 0) {
          progress.setText('描画データを復元中...');
          progress.setProgress(60);
          try {
            await new Promise((resolve, reject) => {
              const req = indexedDB.open('NLStoreDB', 1);
              req.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains('draws')) {
                  db.createObjectStore('draws', { keyPath: 'id' });
                }
              };
              req.onsuccess = (e) => {
                const db = e.target.result;
                const tx = db.transaction('draws', 'readwrite');
                const store = tx.objectStore('draws');
                store.clear();
                Object.values(data.draws).forEach(draw => {
                  if (draw && draw.id) {
                    store.put(draw);
                    results.draws++;
                  }
                });
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
              };
              req.onerror = () => reject(req.error);
            });
            console.log('[ImportSettings] Restored', results.draws, 'draws');
          } catch (e) {
            console.error('[ImportSettings] Failed to import draws:', e);
          }
        }

        // Import boxes (本以外データ)
        if (Array.isArray(data.boxes) && data.boxes.length > 0) {
          progress.setText('ボックスを復元中...');
          progress.setProgress(90);
          try {
            for (const box of data.boxes) {
              await Box.put(box);
              results.boxes++;
            }
          } catch (e) {
            console.error('[ImportSettings] Failed to import boxes:', e);
          }
        }

        // Import TODOs to TodoStoreDB (active + archived)
        const todosToImport = Array.isArray(data.todos) ? data.todos : [];
        const archivedToImport = Array.isArray(data.todosArchived) ? data.todosArchived : [];
        if (todosToImport.length > 0 || archivedToImport.length > 0) {
          progress.setText('TODOデータを復元中...');
          progress.setProgress(80);
          const legacyTodoImport = () => new Promise((resolve, reject) => {
            const req = indexedDB.open('TodoStoreDB', 1);
            req.onupgradeneeded = (e) => {
              const db = e.target.result;
              if (!db.objectStoreNames.contains('todos')) {
                db.createObjectStore('todos', { keyPath: 'id' });
              }
              if (!db.objectStoreNames.contains('archived')) {
                db.createObjectStore('archived', { keyPath: 'id' });
              }
            };
            req.onsuccess = (e) => {
              const db = e.target.result;
              const tx = db.transaction(['todos', 'archived'], 'readwrite');
              const store = tx.objectStore('todos');
              const archStore = tx.objectStore('archived');
              // 既存をクリアしてからインポート
              store.clear();
              archStore.clear();
              let count = 0;
              todosToImport.forEach(todo => { store.put(todo); count++; });
              archivedToImport.forEach(todo => { archStore.put(todo); count++; });
              tx.oncomplete = () => resolve(count);
              tx.onerror = () => reject(tx.error);
            };
            req.onerror = () => reject(req.error);
          });
          try {
            if (window.TodoStore?.importAll) {
              const imported = await window.TodoStore.importAll(todosToImport, archivedToImport);
              results.todos = (imported?.active || 0) + (imported?.archived || 0);
            } else {
              results.todos = await legacyTodoImport();
            }
            console.log('[ImportSettings] Restored', results.todos, 'todos (active+archived)');
          } catch (e) {
            console.error('[ImportSettings] Failed to import todos:', e);
            try {
              results.todos = await legacyTodoImport();
              console.log('[ImportSettings] Legacy fallback restored', results.todos, 'todos (active+archived)');
            } catch (legacyErr) {
              console.error('[ImportSettings] Legacy todo import also failed:', legacyErr);
            }
          }
        }

        if (results.todos > 0 && window.TodoUI?.render) {
          try { TodoUI.render(); } catch (_) { }
        }
        if (results.settings > 0 || hasMissBackup) {
          try {
            const keys = Object.keys(data.settings || {});
            if (hasMissBackup && !keys.includes(MISS_STORAGE_KEY)) keys.push(MISS_STORAGE_KEY);
            window.dispatchEvent(new CustomEvent('settings:restored', { detail: { keys } }));
          } catch (_) { }
        }
        if (hasMissBackup) {
          try { window.dispatchEvent(new CustomEvent('miss-marks-updated', { detail: { bookId: null } })); } catch (_) { }
          try { window.__viewerRefreshMiss?.(); } catch (_) { }
        }

        progress.setProgress(100);
        progress.setText('完了！');
        await new Promise(r => setTimeout(r, 500));
        progress.close();

        const resultParts = [];
        if (results.settings > 0) resultParts.push(`設定${results.settings}件`);
        if (results.missMarks > 0) resultParts.push(`ミス${results.missMarks}件`);
        if (results.plannerEvents > 0) resultParts.push(`予定${results.plannerEvents}件`);
        if (results.draws > 0) resultParts.push(`描画${results.draws}件`);
        if (results.todos > 0) resultParts.push(`TODO${results.todos}件`);
        if (results.boxes > 0) resultParts.push(`ボックス${results.boxes}件`);
        if (results.originalLessons > 0) resultParts.push(`オリジナル授業${results.originalLessons}件`);

        if (resultParts.length > 0) {
          showToast(`インポート完了: ${resultParts.join('、')}`, 'ok');
          // Ask for reload if any core data was imported
          if (results.settings > 0 || results.todos > 0 || results.boxes > 0 || results.plannerEvents > 0 || results.draws > 0) {
            setTimeout(() => {
              if (confirm('設定/本以外のデータが更新されました。ページを再読み込みしますか？')) {
                location.reload();
              }
            }, 500);
          }
        } else {
          showToast('インポートするデータが見つかりませんでした', 'error');
        }

      } catch (e) {
        progress.close();
        console.error('[ImportSettings] Error:', e);
        showToast('インポートに失敗しました: ' + e.message, 'error');
      }
    }

    // Lightweight metadata-only backup (no page data) for quick exports
    async function exportLiteMeta() {
      const progress = createExportProgressModal();
      try {
        progress.setTitle('軽量バックアップを作成中...');
        progress.setText('本の目録を収集中...');
        progress.setProgress(10);

        const rawBooks = await Book.listMeta();
        const books = rawBooks.map((b) => {
          const cleaned = Object.assign({}, b);
          cleaned.pageCount = cleaned.pageCount || cleaned.totalPages || (Array.isArray(cleaned.pages) ? cleaned.pages.length : 0);
          cleaned.createdAt = cleaned.createdAt || cleaned.created || Date.now();
          cleaned.lastRead = cleaned.lastRead || 0;
          cleaned.lastPage = typeof cleaned.lastPage === 'number' ? cleaned.lastPage : 0;
          delete cleaned.pages;
          delete cleaned.coverDataUrl;
          delete cleaned.coverThumb;
          delete cleaned.pagePreview;
          delete cleaned.thumbnail;
          return cleaned;
        });

        progress.setText('ボックスと設定を収集中...');
        progress.setProgress(45);
        let boxes = [];
        try { boxes = await Box.list(); } catch (e) { console.warn('[ExportLite] Box list failed:', e); }

        const payload = {
          version: 2,
          type: 'lite-meta',
          exportDate: new Date().toISOString(),
          books,
          boxes,
          settings: exportAllSettings()
        };

        progress.setText('ファイルを作成中...');
        progress.setProgress(80);
        const date = new Date().toISOString().slice(0, 10).replace(/-/g, '');
        await downloadJSONAsync(payload, `study-ebook-lite-${date}.json`);

        progress.setProgress(100);
        progress.setText('完了！');
        await new Promise(r => setTimeout(r, 400));
        showToast(`軽量バックアップを保存しました（本${books.length}冊）`, 'ok');
      } catch (e) {
        console.error('[ExportLite] Error:', e);
        showToast('軽量バックアップに失敗しました: ' + e.message, 'error');
      } finally {
        progress.close();
      }
    }

    // Import metadata-only backup without touching page blobs
    async function importLiteMeta(file) {
      if (!file) return;
      const progress = createExportProgressModal();
      try {
        progress.setTitle('軽量バックアップを読み込み中...');
        progress.setText('ファイルを解析中...');
        progress.setProgress(10);

        const text = await file.text();
        const data = JSON.parse(text);
        if (!data || typeof data !== 'object' || !Array.isArray(data.books)) {
          throw new Error('軽量バックアップ形式ではありません');
        }

        const results = { books: 0, boxes: 0, settings: false };
        const saveMetaOnly = async (bookMeta) => {
          await dbReady;
          return new Promise((resolve, reject) => {
            const t = db.transaction([BOOK_STORE], 'readwrite');
            t.objectStore(BOOK_STORE).put(bookMeta);
            t.oncomplete = () => resolve(true);
            t.onerror = () => reject(t.error);
          });
        };
        const books = data.books || [];
        for (let i = 0; i < books.length; i++) {
          const meta = books[i];
          if (!meta?.id) continue;
          progress.setText(`本 ${i + 1}/${books.length}: メタデータを更新中...`);
          progress.setProgress(10 + (i / Math.max(1, books.length)) * 55);
          try {
            const existing = await Book.get(meta.id, { withPages: false });
            if (!existing) continue;
            const merged = Object.assign({}, existing, meta);
            delete merged.pages;
            await saveMetaOnly(merged);
            results.books++;
          } catch (err) {
            console.warn('[ImportLite] Skip book', meta?.id, err);
          }
          await new Promise(r => setTimeout(r, 0));
        }

        if (Array.isArray(data.boxes) && data.boxes.length) {
          progress.setText('ボックスを更新中...');
          progress.setProgress(70);
          for (const box of data.boxes) {
            try {
              await Box.put(box);
              results.boxes++;
            } catch (err) {
              console.warn('[ImportLite] Box put failed:', err);
            }
          }
        }

        if (data.settings && typeof data.settings === 'object' && Object.keys(data.settings).length > 0) {
          progress.setText('設定を更新中...');
          progress.setProgress(85);
          importAllSettings(data.settings);
          results.settings = true;
        }

        progress.setProgress(100);
        progress.setText('完了！');
        await new Promise(r => setTimeout(r, 400));
        showToast(`軽量バックアップを反映しました（本${results.books}件${results.boxes ? `、ボックス${results.boxes}件` : ''}${results.settings ? '、設定' : ''}）`, 'ok');
        if (results.settings) {
          setTimeout(() => {
            if (confirm('設定が変更されました。ページを再読み込みしますか？')) {
              location.reload();
            }
          }, 400);
        }
      } catch (e) {
        console.error('[ImportLite] Error:', e);
        showToast('軽量バックアップの読み込みに失敗しました: ' + e.message, 'error');
      } finally {
        progress.close();
      }
    }

    async function exportSingleBook(book) {
      if (!book) return;
      const progress = createExportProgressModal();
      try {
        progress.setTitle(`${book.title || '本'}をエクスポート中...`);
        progress.setText('準備中...');
        progress.setProgress(0);

        const full = await materializeBookPages(book, (page, total) => {
          progress.setText(`ページ ${page}/${total} を処理中...`);
          progress.setProgress((page / total) * 90);
        });

        progress.setText('ファイルを作成中...');
        progress.setProgress(95);

        // Use async version for memory safety
        await downloadJSONAsync({ type: 'book', version: 1, book: full || book }, `${(book.title || 'book')}.json`);

        // Clear memory immediately
        if (full && full.pages) {
          full.pages.forEach(p => { p.dataUrl = null; p.blob = null; });
          full.pages = null;
        }

        progress.setProgress(100);
        progress.setText('完了！');
        await new Promise(r => setTimeout(r, 500));
        progress.close();
        showToast('エクスポートが完了しました', 'ok');
      } catch (e) {
        progress.close();
        console.error('Export error:', e);

        // Provide helpful error message
        let errorMsg = 'エクスポートに失敗しました: ';
        if (e.message?.includes('メモリ') || e.message?.includes('memory') || e.name === 'RangeError') {
          errorMsg += 'メモリ不足です。本のページ数が多い場合は、ブラウザを再起動してください。';
        } else {
          errorMsg += e.message;
        }
        showToast(errorMsg, 'error');
      }
    }
    async function exportBooksOnlyDownload() {
      const progress = createExportProgressModal();
      let exportedCount = 0;
      let failedCount = 0;
      try {
        progress.setTitle('本だけをバックアップ中...');
        progress.setText('本の一覧を取得中...');
        progress.setProgress(0);

        const rawBooks = await Book.listMeta();
        const totalBooks = rawBooks.length;
        if (!totalBooks) {
          progress.close();
          showToast('バックアップする本がありません', 'info');
          return;
        }

        progress.setText(`${totalBooks}冊の本を処理します...`);
        progress.setProgress(2);

        for (let i = 0; i < totalBooks; i++) {
          const bookMeta = rawBooks[i];
          progress.setText(`本 ${i + 1}/${totalBooks}: ${bookMeta.title || '無題'}`);
          progress.setProgress(2 + (i / totalBooks) * 88);

          try {
            const b = await Book.get(bookMeta.id);
            if (!b) continue;

            const fullBook = await materializeBookPages(b, (page, total) => {
              progress.setText(`本 ${i + 1}/${totalBooks}: ${bookMeta.title || '無題'} (${page}/${total})`);
            });

            const safeTitle = (bookMeta.title || 'book')
              .replace(/[^a-zA-Z0-9\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/g, '_')
              .slice(0, 30);

            await downloadJSONAsync({ type: 'book', version: 1, book: fullBook || b }, `book-${i + 1}-${safeTitle}.json`);
            exportedCount++;

            if (fullBook && fullBook.pages) {
              fullBook.pages.forEach(p => { p.dataUrl = null; p.blob = null; });
              fullBook.pages = null;
            }

            await gcHint();
            await new Promise(r => setTimeout(r, 200));
          } catch (e) {
            failedCount++;
            console.error(`[BookExport] Book ${i + 1} export failed:`, e);
            if (e.message?.includes('メモリ') || e.message?.includes('memory') || e.name === 'RangeError') {
              progress.setText(`本 ${i + 1}/${totalBooks}: メモリ不足でスキップ`);
              await gcHint();
              await new Promise(r => setTimeout(r, 800));
            }
          }
        }

        progress.setProgress(100);
        progress.setText('完了！');
        await new Promise(r => setTimeout(r, 500));
        progress.close();

        if (failedCount > 0) {
          showToast(`本だけバックアップ完了: ${exportedCount}冊成功、${failedCount}冊失敗`, failedCount > exportedCount ? 'error' : 'ok');
        } else {
          showToast(`本だけバックアップ完了: ${exportedCount}冊`, 'ok');
        }
      } catch (e) {
        progress.close();
        showToast('本だけバックアップに失敗しました: ' + e.message, 'error');
      }
    }
    async function exportSingleBox(box) {
      if (!box) return;
      try {
        await downloadJSONAsync({ type: 'box', version: 1, box }, `${(box.name || 'box')}.json`);
        showToast('ボックスをエクスポートしました', 'ok');
      } catch (e) {
        console.error('Export box error:', e);
        showToast('エクスポートに失敗しました: ' + e.message, 'error');
      }
    }

    // ========== Memory-Efficient Import System ==========
    // Helper: Trigger garbage collection hint
    function gcHint() {
      // Modern browsers don't expose gc(), but we can help by clearing references
      // and yielding to the event loop
      return new Promise(resolve => {
        setTimeout(() => {
          // Try to hint GC by creating and immediately discarding a large allocation
          // This is a heuristic that may help on some engines
          try {
            const dummy = new ArrayBuffer(1024);
            dummy; // prevent optimization removal
          } catch (e) { }
          resolve();
        }, 0);
      });
    }

    // Helper: Read file in chunks using streaming
    async function readFileChunked(file, onChunk) {
      const CHUNK_SIZE = 4 * 1024 * 1024; // 4MB chunks
      const reader = file.stream().getReader();
      const decoder = new TextDecoder('utf-8');
      let buffer = '';
      let totalRead = 0;
      const fileSize = file.size;

      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          totalRead += value.byteLength;

          // Report progress
          const progress = Math.min(100, Math.round((totalRead / fileSize) * 100));
          if (onChunk) await onChunk(buffer.length, fileSize, progress);

          // Yield periodically to prevent freeze
          if (totalRead % (CHUNK_SIZE * 2) < value.byteLength) {
            await new Promise(r => setTimeout(r, 5));
          }
        }
        // Flush remaining bytes
        buffer += decoder.decode();
        return buffer;
      } finally {
        reader.releaseLock();
      }
    }

    // Helper: Parse JSON incrementally for very large files
    async function parseJsonSafely(text, progress) {
      const MAX_SAFE_SIZE = 50 * 1024 * 1024; // 50MB - above this, use incremental parsing

      if (text.length < MAX_SAFE_SIZE) {
        // Small enough to parse directly
        return JSON.parse(text);
      }

      // For very large files, parse in a way that yields periodically
      progress?.setText('大きなJSONを解析中（時間がかかる場合があります）...');
      await new Promise(r => setTimeout(r, 100));

      try {
        // Try standard parse first with a timeout wrapper
        return await new Promise((resolve, reject) => {
          setTimeout(() => {
            try {
              const result = JSON.parse(text);
              resolve(result);
            } catch (e) {
              reject(e);
            }
          }, 0);
        });
      } catch (e) {
        throw e;
      }
    }

    // ========== TRUE STREAMING IMPORT - Extract and import books one at a time ==========
    // This approach never loads the entire parsed JSON into memory

    // Find the end of a JSON object starting at position, handling nested braces and strings
    function findJsonObjectEnd(text, startPos) {
      let braceCount = 0;
      let inString = false;
      let escapeNext = false;
      let started = false;

      for (let i = startPos; i < text.length; i++) {
        const char = text[i];

        if (escapeNext) {
          escapeNext = false;
          continue;
        }

        if (char === '\\' && inString) {
          escapeNext = true;
          continue;
        }

        if (char === '"') {
          inString = !inString;
          continue;
        }

        if (!inString) {
          if (char === '{') {
            braceCount++;
            started = true;
          } else if (char === '}') {
            braceCount--;
            if (started && braceCount === 0) {
              return i + 1; // Return position after the closing brace
            }
          }
        }
      }
      return -1; // Not found or incomplete
    }

    // Extract books from text one at a time using streaming approach
    async function* streamExtractBooks(text, progress) {
      // Find the "books" array
      const booksMatch = text.match(/"books"\s*:\s*\[/);
      if (!booksMatch) {
        return; // No books array found
      }

      const booksArrayStart = text.indexOf(booksMatch[0]) + booksMatch[0].length;
      let pos = booksArrayStart;
      let bookIndex = 0;

      // Skip whitespace
      while (pos < text.length && /\s/.test(text[pos])) pos++;

      while (pos < text.length) {
        // Check if we've reached the end of the array
        if (text[pos] === ']') break;

        // Skip comma if present
        if (text[pos] === ',') {
          pos++;
          while (pos < text.length && /\s/.test(text[pos])) pos++;
          continue;
        }

        // Find the start of the next book object
        if (text[pos] !== '{') {
          pos++;
          continue;
        }

        // Find the end of this book object
        const endPos = findJsonObjectEnd(text, pos);
        if (endPos === -1) {
          console.warn('[StreamImport] Could not find end of book object at position', pos);
          break;
        }

        // Extract and parse just this book
        const bookJson = text.substring(pos, endPos);
        pos = endPos;
        bookIndex++;

        try {
          const book = JSON.parse(bookJson);
          yield { book, index: bookIndex };
        } catch (e) {
          console.error('[StreamImport] Failed to parse book at index', bookIndex, e);
        }

        // Yield to event loop periodically
        if (bookIndex % 2 === 0) {
          await new Promise(r => setTimeout(r, 0));
        }
      }
    }

    // Extract settings and boxes from text (these are usually small)
    function extractSettingsAndBoxes(text) {
      const result = { settings: null, boxes: null, version: null };

      // Extract version
      const versionMatch = text.match(/"version"\s*:\s*(\d+)/);
      if (versionMatch) {
        result.version = parseInt(versionMatch[1]);
      }

      // Extract settings - find the settings object
      const settingsMatch = text.match(/"settings"\s*:\s*\{/);
      if (settingsMatch) {
        const settingsStart = text.indexOf(settingsMatch[0]) + settingsMatch[0].length - 1;
        const settingsEnd = findJsonObjectEnd(text, settingsStart);
        if (settingsEnd > 0) {
          try {
            result.settings = JSON.parse(text.substring(settingsStart, settingsEnd));
          } catch (e) {
            console.error('[StreamImport] Failed to parse settings:', e);
          }
        }
      }

      // Extract boxes array
      const boxesMatch = text.match(/"boxes"\s*:\s*\[/);
      if (boxesMatch) {
        const boxesStart = text.indexOf(boxesMatch[0]) + boxesMatch[0].length - 1;
        // Find the matching closing bracket
        let bracketCount = 0;
        let inString = false;
        let escapeNext = false;

        for (let i = boxesStart; i < text.length; i++) {
          const char = text[i];

          if (escapeNext) { escapeNext = false; continue; }
          if (char === '\\' && inString) { escapeNext = true; continue; }
          if (char === '"') { inString = !inString; continue; }

          if (!inString) {
            if (char === '[') bracketCount++;
            else if (char === ']') {
              bracketCount--;
              if (bracketCount === 0) {
                try {
                  result.boxes = JSON.parse(text.substring(boxesStart, i + 1));
                } catch (e) {
                  console.error('[StreamImport] Failed to parse boxes:', e);
                }
                break;
              }
            }
          }
        }
      }

      return result;
    }

    // ========== HIGH-PERFORMANCE STREAMING IMPORT ==========
    // Uses sliding window approach with batch processing for speed

    async function importDataFileStreaming(file, progress) {
      const fileSizeMB = (file.size / 1024 / 1024).toFixed(2);
      console.log('[StreamImport] Starting high-speed streaming import, file size:', fileSizeMB, 'MB');

      progress.setText(`大きなファイル（${fileSizeMB}MB）を高速処理中...`);
      progress.setProgress(2);

      const CHUNK_SIZE = 4 * 1024 * 1024; // 4MB chunks - larger for speed
      const MAX_BUFFER = 30 * 1024 * 1024; // 30MB buffer limit
      const BATCH_SIZE = 5; // Process 5 books in parallel
      const GC_INTERVAL = 20; // GC every 20 books

      let importedBooks = 0;
      let importedBoxes = 0;
      let failedBooks = 0;
      let processedBytes = 0;

      // State for streaming parser
      let buffer = '';
      let inBooksArray = false;
      let foundBooksStart = false;
      let currentBookStart = -1;
      let braceDepth = 0;
      let inString = false;
      let escapeNext = false;

      // Accumulated data for later
      let settingsJson = null;
      let boxesJson = null;
      let plannerEventsJson = null;

      // Batch queue for parallel processing
      let bookQueue = [];
      let lastProgressUpdate = Date.now();

      // Process batch of books in parallel
      async function processBatch(books) {
        const results = await Promise.allSettled(
          books.map(async (bookJson) => {
            try {
              const book = JSON.parse(bookJson);
              const normalizedBook = normalizeBookShape(book);
              await Book.put(normalizedBook);
              return { success: true, title: book?.title };
            } catch (e) {
              console.error('[StreamImport] Failed to parse/import book:', e);
              return { success: false };
            }
          })
        );

        let succeeded = 0;
        let failed = 0;
        let lastTitle = '';

        for (const result of results) {
          if (result.status === 'fulfilled' && result.value.success) {
            succeeded++;
            lastTitle = result.value.title || '';
          } else {
            failed++;
          }
        }

        return { succeeded, failed, lastTitle };
      }

      try {
        const reader = file.stream().getReader();
        const decoder = new TextDecoder('utf-8');
        let done = false;

        while (!done) {
          const { value, done: streamDone } = await reader.read();
          done = streamDone;

          if (value) {
            buffer += decoder.decode(value, { stream: !done });
            processedBytes += value.byteLength;

            // Update progress less frequently for speed
            const now = Date.now();
            if (now - lastProgressUpdate > 100) { // Every 100ms max
              const pct = Math.round((processedBytes / file.size) * 100);
              progress.setProgress(2 + pct * 0.6);
              lastProgressUpdate = now;
            }
          }

          // Look for books array start if not found yet
          if (!foundBooksStart) {
            const booksMatch = buffer.match(/"books"\s*:\s*\[/);
            if (booksMatch) {
              const matchEnd = buffer.indexOf(booksMatch[0]) + booksMatch[0].length;
              foundBooksStart = true;
              inBooksArray = true;

              // Save the header portion for settings extraction later
              const headerPortion = buffer.substring(0, matchEnd);

              // Look for settings in the header
              const settingsMatch = headerPortion.match(/"settings"\s*:\s*\{/);
              if (settingsMatch) {
                const settingsStart = headerPortion.indexOf(settingsMatch[0]) + settingsMatch[0].length - 1;
                const settingsEnd = findJsonObjectEnd(headerPortion, settingsStart);
                if (settingsEnd > 0) {
                  try {
                    settingsJson = JSON.parse(headerPortion.substring(settingsStart, settingsEnd));
                  } catch (e) { console.warn('[StreamImport] Settings in header parse failed'); }
                }
              }

              // Trim buffer to start from books array content
              buffer = buffer.substring(matchEnd);
              braceDepth = 0;
              inString = false;
              escapeNext = false;
            }
          }

          // Process books in buffer
          if (inBooksArray) {
            let pos = 0;
            while (pos < buffer.length) {
              const char = buffer[pos];

              if (escapeNext) {
                escapeNext = false;
                pos++;
                continue;
              }

              if (char === '\\' && inString) {
                escapeNext = true;
                pos++;
                continue;
              }

              if (char === '"') {
                inString = !inString;
                pos++;
                continue;
              }

              if (!inString) {
                if (char === '{') {
                  if (braceDepth === 0) {
                    currentBookStart = pos;
                  }
                  braceDepth++;
                } else if (char === '}') {
                  braceDepth--;
                  if (braceDepth === 0 && currentBookStart >= 0) {
                    // Found complete book object - add to queue
                    const bookJson = buffer.substring(currentBookStart, pos + 1);
                    currentBookStart = -1;
                    bookQueue.push(bookJson);

                    // Process batch when queue is full
                    if (bookQueue.length >= BATCH_SIZE) {
                      const batch = bookQueue.splice(0, BATCH_SIZE);
                      const result = await processBatch(batch);
                      importedBooks += result.succeeded;
                      failedBooks += result.failed;

                      // Update progress with last book title
                      if (result.lastTitle) {
                        progress.setText(`本 ${importedBooks}: ${result.lastTitle}をインポート中...`);
                      }

                      // Memory management - less frequent
                      if (importedBooks % GC_INTERVAL === 0) {
                        await gcHint();
                      }
                    }

                    // Trim processed portion from buffer
                    buffer = buffer.substring(pos + 1);
                    pos = 0;
                    continue;
                  }
                } else if (char === ']' && braceDepth === 0) {
                  // End of books array - process remaining queue
                  if (bookQueue.length > 0) {
                    const result = await processBatch(bookQueue);
                    importedBooks += result.succeeded;
                    failedBooks += result.failed;
                    bookQueue = [];
                  }

                  inBooksArray = false;

                  // Keep remainder for settings/boxes extraction
                  const remainder = buffer.substring(pos + 1);

                  // Look for settings if not found yet
                  if (!settingsJson) {
                    const settingsMatch = remainder.match(/"settings"\s*:\s*\{/);
                    if (settingsMatch) {
                      const settingsStart = remainder.indexOf(settingsMatch[0]) + settingsMatch[0].length - 1;
                      const settingsEnd = findJsonObjectEnd(remainder, settingsStart);
                      if (settingsEnd > 0) {
                        try {
                          settingsJson = JSON.parse(remainder.substring(settingsStart, settingsEnd));
                        } catch (e) { console.warn('[StreamImport] Settings parse failed'); }
                      }
                    }
                  }

                  // Look for boxes
                  const boxesMatch = remainder.match(/"boxes"\s*:\s*\[/);
                  if (boxesMatch) {
                    const boxesStart = remainder.indexOf(boxesMatch[0]) + boxesMatch[0].length - 1;
                    // Find closing bracket
                    let bracketCount = 0;
                    let boxInString = false;
                    let boxEscapeNext = false;

                    for (let i = boxesStart; i < remainder.length; i++) {
                      const c = remainder[i];
                      if (boxEscapeNext) { boxEscapeNext = false; continue; }
                      if (c === '\\' && boxInString) { boxEscapeNext = true; continue; }
                      if (c === '"') { boxInString = !boxInString; continue; }
                      if (!boxInString) {
                        if (c === '[') bracketCount++;
                        else if (c === ']') {
                          bracketCount--;
                          if (bracketCount === 0) {
                            try {
                              boxesJson = JSON.parse(remainder.substring(boxesStart, i + 1));
                            } catch (e) { console.warn('[StreamImport] Boxes parse failed'); }
                            break;
                          }
                        }
                      }
                    }
                  }

                  // Look for plannerEvents
                  const plannerMatch = remainder.match(/"plannerEvents"\s*:\s*\[/);
                  if (plannerMatch) {
                    const plannerStart = remainder.indexOf(plannerMatch[0]) + plannerMatch[0].length - 1;
                    // Find closing bracket
                    let bracketCount = 0;
                    let plannerInString = false;
                    let plannerEscapeNext = false;

                    for (let i = plannerStart; i < remainder.length; i++) {
                      const c = remainder[i];
                      if (plannerEscapeNext) { plannerEscapeNext = false; continue; }
                      if (c === '\\' && plannerInString) { plannerEscapeNext = true; continue; }
                      if (c === '"') { plannerInString = !plannerInString; continue; }
                      if (!plannerInString) {
                        if (c === '[') bracketCount++;
                        else if (c === ']') {
                          bracketCount--;
                          if (bracketCount === 0) {
                            try {
                              plannerEventsJson = JSON.parse(remainder.substring(plannerStart, i + 1));
                              console.log('[StreamImport] Found plannerEvents:', plannerEventsJson.length);
                            } catch (e) { console.warn('[StreamImport] PlannerEvents parse failed'); }
                            break;
                          }
                        }
                      }
                    }
                  }

                  buffer = '';
                  break;
                }
              }

              pos++;
            }

            // If buffer is getting too large, try to trim it
            if (buffer.length > MAX_BUFFER && currentBookStart >= 0) {
              // We're in the middle of a book object, keep from currentBookStart
              if (currentBookStart > CHUNK_SIZE) {
                buffer = buffer.substring(currentBookStart);
                currentBookStart = 0;
              }
            } else if (buffer.length > MAX_BUFFER && currentBookStart < 0) {
              // No book started yet, safe to trim
              buffer = buffer.substring(buffer.length - CHUNK_SIZE);
            }
          }

          // Yield very briefly to prevent complete freeze (but much less than before)
          if (processedBytes % (10 * 1024 * 1024) < CHUNK_SIZE) {
            await new Promise(r => setTimeout(r, 0));
          }
        }

        reader.releaseLock();

        // Clean up buffer
        buffer = null;
        await gcHint();

        progress.setProgress(75);

        // Import boxes
        if (boxesJson && Array.isArray(boxesJson)) {
          progress.setText(`${boxesJson.length}個のボックスをインポート中...`);

          for (let i = 0; i < boxesJson.length; i++) {
            try {
              const normalizedBox = normalizeBoxShape(boxesJson[i]);
              await Box.put(normalizedBox);
              importedBoxes++;
            } catch (e) {
              console.error('[StreamImport] Failed to import box:', e);
            }
          }
          boxesJson = null;
        }

        progress.setProgress(90);

        // Import settings
        if (settingsJson && typeof settingsJson === 'object') {
          progress.setText('設定を復元中...');
          try {
            const count = importAllSettings(settingsJson);
            console.log('[StreamImport] Restored', count, 'settings');
          } catch (e) {
            console.error('[StreamImport] Failed to import settings:', e);
          }
          try {
            await restoreOriginalLessonFromBackup({ settings: settingsJson });
          } catch (e) {
            console.warn('[StreamImport] Failed to restore original lessons:', e);
          }
          settingsJson = null;
        }

        // Import planner events
        let importedPlannerEvents = 0;
        if (plannerEventsJson && Array.isArray(plannerEventsJson) && plannerEventsJson.length > 0) {
          progress.setText('予定データを復元中...');
          progress.setProgress(95);
          try {
            await new Promise((resolve, reject) => {
              const req = indexedDB.open('NLStoreDB', 1);
              req.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains('events')) {
                  db.createObjectStore('events', { keyPath: 'id' });
                }
              };
              req.onsuccess = (e) => {
                const db = e.target.result;
                const tx = db.transaction('events', 'readwrite');
                const store = tx.objectStore('events');
                plannerEventsJson.forEach(ev => {
                  store.put(ev);
                  importedPlannerEvents++;
                });
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
              };
              req.onerror = () => reject(req.error);
            });
            console.log('[StreamImport] Restored', importedPlannerEvents, 'planner events');
          } catch (e) {
            console.error('[StreamImport] Failed to import planner events:', e);
          }
          plannerEventsJson = null;
        }

        await gcHint();

        progress.setProgress(100);
        progress.setText('完了！');
        await new Promise(r => setTimeout(r, 500));
        progress.close();

        // Show result
        let msg = 'インポート完了: ';
        const parts = [];
        if (importedBooks > 0) parts.push(`${importedBooks}冊の本`);
        if (importedBoxes > 0) parts.push(`${importedBoxes}個のボックス`);
        if (importedPlannerEvents > 0) parts.push(`${importedPlannerEvents}件の予定`);
        msg += parts.join('、');
        if (failedBooks > 0) msg += ` (失敗: ${failedBooks}件)`;

        if (importedBooks > 0 || importedBoxes > 0 || importedPlannerEvents > 0) {
          showToast(msg, 'ok');
          refresh();
        } else {
          showToast('インポートするデータが見つかりませんでした', 'error');
        }

        return true;

      } catch (e) {
        buffer = null;
        settingsJson = null;
        boxesJson = null;
        plannerEventsJson = null;
        await gcHint();
        throw e;
      }
    }

    async function importDataFile(file) {
      const progress = createExportProgressModal();
      progress.setTitle('データをインポート中...');
      progress.setText('ファイルを読み込み中...');
      progress.setProgress(0);

      const fileSizeMB = (file.size / 1024 / 1024).toFixed(2);
      console.log('[Import] Starting import, file size:', fileSizeMB, 'MB');

      // For large files (over 30MB), use streaming import to avoid memory issues
      const STREAMING_THRESHOLD = 30 * 1024 * 1024; // 30MB

      if (file.size > STREAMING_THRESHOLD) {
        console.log('[Import] Using streaming import for large file');
        try {
          await importDataFileStreaming(file, progress);
          return;
        } catch (e) {
          progress.close();
          console.error('[Import] Streaming import failed:', e);

          // Provide helpful error message
          let errorMsg = 'インポートに失敗しました: ';
          if (e.message?.includes('memory') || e.message?.includes('heap') || e.name === 'RangeError') {
            errorMsg += `メモリ不足です。ファイル（${fileSizeMB}MB）が大きすぎます。ブラウザを再起動するか、エクスポート時に分割されたファイルを個別にインポートしてください。`;
          } else {
            errorMsg += e.message;
          }
          showToast(errorMsg, 'error');
          return;
        }
      }

      // For smaller files, use the regular import method
      let text = null;
      let data = null;

      try {
        // ===== Phase 1: Read file with streaming =====
        progress.setText('ファイルを読み込み中...');

        // Use streaming read for large files
        if (file.size > 10 * 1024 * 1024 && file.stream) {
          text = await readFileChunked(file, async (bufferLen, totalSize, pct) => {
            progress.setText(`読み込み中... ${(bufferLen / 1024 / 1024).toFixed(1)}MB / ${(totalSize / 1024 / 1024).toFixed(1)}MB`);
            progress.setProgress(Math.min(15, pct * 0.15));
          });
        } else {
          // Small file - read directly
          text = await file.text();
        }

        progress.setText('JSONを解析中...');
        progress.setProgress(18);

        console.log('[Import] File read complete, size:', text.length, 'bytes');

        // ===== Phase 2: Parse JSON =====
        await gcHint(); // Help GC before heavy operation

        try {
          data = await parseJsonSafely(text, progress);
        } catch (e) {
          // Try to repair truncated JSON
          console.warn('[Import] JSON parse failed, attempting repair:', e.message);
          progress.setText('不完全なJSONを修復中...');

          await gcHint();
          let repaired = text.trim();
          text = null; // Release original text early
          await gcHint();

          // Try to find the last complete book entry
          const booksMatch = repaired.match(/("books"\s*:\s*\[)/);
          if (booksMatch) {
            // Find last complete book object (ends with })
            let lastGoodPos = -1;
            let braceCount = 0;
            let inString = false;
            let escapeNext = false;
            const booksStart = repaired.indexOf(booksMatch[0]) + booksMatch[0].length;

            for (let i = booksStart; i < repaired.length; i++) {
              const char = repaired[i];

              if (escapeNext) {
                escapeNext = false;
                continue;
              }

              if (char === '\\' && inString) {
                escapeNext = true;
                continue;
              }

              if (char === '"' && !escapeNext) {
                inString = !inString;
                continue;
              }

              if (!inString) {
                if (char === '{') braceCount++;
                else if (char === '}') {
                  braceCount--;
                  if (braceCount === 0) {
                    lastGoodPos = i;
                  }
                }
              }

              // Yield periodically during repair scan
              if (i % 1000000 === 0) {
                await new Promise(r => setTimeout(r, 0));
              }
            }

            if (lastGoodPos > 0) {
              repaired = repaired.substring(0, lastGoodPos + 1) + '\n  ]\n}';
              console.log('[Import] Repaired JSON, truncated at position:', lastGoodPos);

              await gcHint();
              try {
                data = JSON.parse(repaired);
                showToast('不完全なファイルを修復してインポートします', 'ok');
              } catch (e2) {
                console.error('[Import] Repair failed:', e2);
              }
            }
          }

          repaired = null; // Release
          await gcHint();

          if (!data) {
            progress.close();
            showToast(`JSONファイルの解析に失敗しました（${fileSizeMB}MB）。ファイルが不完全です。`, 'error');
            return;
          }
        }

        // Release text immediately after parsing
        text = null;
        await gcHint();

        progress.setProgress(25);

        console.log('[Import] Data structure:', {
          version: data.version,
          hasBooks: !!data.books,
          booksCount: data.books?.length || 0,
          hasBoxes: !!data.boxes,
          boxesCount: data.boxes?.length || 0,
          hasSettings: !!data.settings,
          hasBook: !!data.book
        });

        // Handle single book format
        if (data.book && !data.books) {
          data.books = [data.book];
          delete data.book;
        }

        let importedBooks = 0;
        let importedBoxes = 0;
        let failedBooks = 0;
        let failedBoxes = 0;

        // ===== Phase 3: Import books with optimized batch processing =====
        if (data.books && Array.isArray(data.books)) {
          const totalBooks = data.books.length;
          const PARALLEL_BATCH = 4; // Process 4 books at a time
          const GC_INTERVAL = 15; // GC every 15 books
          progress.setText(`${totalBooks}冊の本を高速インポート中...`);

          // Process in parallel batches for speed
          for (let i = 0; i < totalBooks; i += PARALLEL_BATCH) {
            const batchEnd = Math.min(i + PARALLEL_BATCH, totalBooks);
            const batch = data.books.slice(i, batchEnd);

            // Clear references to allow GC
            for (let j = i; j < batchEnd; j++) {
              data.books[j] = null;
            }

            // Process batch in parallel
            const results = await Promise.allSettled(
              batch.map(async (book) => {
                if (!book) return { success: false };
                try {
                  const normalizedBook = normalizeBookShape(book);
                  await Book.put(normalizedBook);
                  return { success: true, title: normalizedBook.title };
                } catch (e) {
                  console.error('[Import] Failed to import book:', book?.title, e);
                  return { success: false };
                }
              })
            );

            // Count results
            for (const result of results) {
              if (result.status === 'fulfilled' && result.value.success) {
                importedBooks++;
              } else {
                failedBooks++;
              }
            }

            // Update progress less frequently
            const lastTitle = results.find(r => r.status === 'fulfilled' && r.value.success)?.value?.title || '';
            progress.setText(`本 ${importedBooks}/${totalBooks}: ${lastTitle}`);
            progress.setProgress(25 + (batchEnd / totalBooks) * 40);

            // Memory management - less frequent
            if (importedBooks % GC_INTERVAL === 0) {
              await gcHint();
              await new Promise(r => setTimeout(r, 0)); // Just yield, no actual delay
            }
          }

          // Clear books array completely
          data.books = null;
          await gcHint();
        }

        progress.setProgress(70);

        // ===== Phase 4: Import boxes =====
        if (data.boxes && Array.isArray(data.boxes)) {
          const totalBoxes = data.boxes.length;
          progress.setText(`${totalBoxes}個のボックスをインポート中...`);

          for (let i = 0; i < totalBoxes; i++) {
            const box = data.boxes[i];
            data.boxes[i] = null; // Allow GC

            progress.setText(`ボックス ${i + 1}/${totalBoxes}: ${box?.name || '無題'}`);
            progress.setProgress(70 + (i / totalBoxes) * 15);

            if (!box) continue;

            try {
              const normalizedBox = normalizeBoxShape(box);
              await Box.put(normalizedBox);
              importedBoxes++;
            } catch (e) {
              console.error('[Import] Failed to import box:', box.name, e);
              failedBoxes++;
            }

            if ((i + 1) % 5 === 0) {
              await new Promise(r => setTimeout(r, 10));
            }
          }

          data.boxes = null;
          await gcHint();
        }

        progress.setProgress(88);

        // ===== Phase 5: Restore settings =====
        if (data.settings && typeof data.settings === 'object') {
          progress.setText('設定を復元中...');
          progress.setProgress(90);
          try {
            const count = importAllSettings(data.settings);
            console.log('[Import] Restored', count, 'settings');
          } catch (e) {
            console.error('[Import] Failed to import settings:', e);
          }
          try {
            await restoreOriginalLessonFromBackup(data);
          } catch (e) {
            console.warn('[Import] Failed to restore original lessons:', e);
          }
          data.settings = null;
        }

        // ===== Phase 6: Restore planner events =====
        let importedPlannerEvents = 0;
        if (data.plannerEvents && Array.isArray(data.plannerEvents)) {
          progress.setText('予定データを復元中...');
          progress.setProgress(95);
          try {
            await new Promise((resolve, reject) => {
              const req = indexedDB.open('NLStoreDB', 1);
              req.onupgradeneeded = (e) => {
                const db = e.target.result;
                if (!db.objectStoreNames.contains('events')) {
                  db.createObjectStore('events', { keyPath: 'id' });
                }
              };
              req.onsuccess = (e) => {
                const db = e.target.result;
                const tx = db.transaction('events', 'readwrite');
                const store = tx.objectStore('events');
                // Don't clear - merge with existing
                data.plannerEvents.forEach(ev => {
                  store.put(ev);
                  importedPlannerEvents++;
                });
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
              };
              req.onerror = () => reject(req.error);
            });
            console.log('[Import] Restored', importedPlannerEvents, 'planner events');
          } catch (e) {
            console.error('[Import] Failed to import planner events:', e);
          }
          data.plannerEvents = null;
        }

        // Final cleanup
        data = null;
        await gcHint();

        progress.setProgress(100);
        progress.setText('完了！');
        await new Promise(r => setTimeout(r, 500));
        progress.close();

        // Show result
        if (importedBooks > 0 || importedBoxes > 0 || importedPlannerEvents > 0) {
          let msg = 'インポート完了: ';
          const parts = [];
          if (importedBooks > 0) parts.push(`${importedBooks}冊の本`);
          if (importedBoxes > 0) parts.push(`${importedBoxes}個のボックス`);
          if (importedPlannerEvents > 0) parts.push(`${importedPlannerEvents}件の予定`);
          msg += parts.join('、');
          if (failedBooks > 0 || failedBoxes > 0) {
            msg += ` (失敗: ${failedBooks + failedBoxes}件)`;
          }
          showToast(msg, 'ok');
          refresh();
        } else {
          showToast('インポートするデータが見つかりませんでした', 'error');
        }

      } catch (e) {
        // Clean up on error
        text = null;
        data = null;
        await gcHint();

        progress.close();
        console.error('[Import] Error:', e);

        // Provide helpful error message
        let errorMsg = 'インポートに失敗しました: ';
        if (e.message?.includes('memory') || e.message?.includes('heap') || e.name === 'RangeError') {
          errorMsg += `メモリ不足です。ブラウザを再起動してから、ファイルを分割してインポートしてください。`;
        } else if (e.message?.includes('quota')) {
          errorMsg += `ストレージ容量が不足しています。不要なデータを削除してください。`;
        } else {
          errorMsg += e.message;
        }
        showToast(errorMsg, 'error');
      }
    }
    function normalizeBookShape(book) {
      book.pages = book.pages || [];
      book.pages.forEach(p => {
        p.id = p.id || uuid();
        p.state = p.state || { fav: false, weak: false, done: false, extra: [] };
        if (!Array.isArray(p.state.extra)) p.state.extra = [];
        p.memo = p.memo || '';
      });
      book.id = book.id || uuid();
      book.createdAt = book.createdAt || Date.now();
      book.customStates = book.customStates || [];
      book.bookmarks = book.bookmarks || [];
      book.answerBookIds = book.answerBookIds || [];
      return book;
    }
    function normalizeBoxShape(box) {
      box.snippets = box.snippets || [];
      box.customStates = box.customStates || [];
      box.snippets.forEach(s => {
        s.id = s.id || uuid();
        s.state = s.state || { fav: false, weak: false, done: false, extra: [] };
        if (!Array.isArray(s.state.extra)) s.state.extra = [];
        s.memo = typeof s.memo === 'string' ? s.memo : (s.note || '');
        if (!s.answer) s.answer = null;
      });
      box.id = box.id || uuid();
      box.createdAt = box.createdAt || Date.now();
      box.tags = box.tags || [];
      return box;
    }
    async function importSingleBookFile(file) {
      if (!file) return;
      const text = await file.text();
      let parsed = null;
      try { parsed = JSON.parse(text); } catch (e) { showToast('JSONを読み込めません', 'error'); return; }
      let book = parsed?.book || parsed;
      if (!book || !book.pages) { showToast('本データではありません', 'error'); return; }
      book = normalizeBookShape(book);
      const existing = await Book.get(book.id);
      if (existing) {
        const overwrite = confirm('同じIDの本があります。上書きしますか？キャンセルで新規IDとして追加します。');
        if (!overwrite) { book.id = uuid(); }
      }
      await Book.put(book);
      showToast('本をインポートしました', 'ok');
      refresh();
    }
    async function importSingleBoxFile(file) {
      if (!file) return;
      const text = await file.text();
      let parsed = null;
      try { parsed = JSON.parse(text); } catch (e) { showToast('JSONを読み込めません', 'error'); return; }
      let box = parsed?.box || parsed;
      if (!box || !Array.isArray(box.snippets)) { showToast('ボックスデータではありません', 'error'); return; }
      box = normalizeBoxShape(box);
      const existing = await Box.get(box.id);
      if (existing) {
        const overwrite = confirm('同じIDのボックスがあります。上書きしますか？キャンセルで新規IDとして追加します。');
        if (!overwrite) { box.id = uuid(); }
      }
      await Box.put(box);
      showToast('ボックスをインポートしました', 'ok');
      renderBoxes();
    }
    async function resetAllData() {
      if (!confirm('全データ（本・ボックス・設定）を完全に削除します。よろしいですか？')) return;
      if (!confirm('本当に全てのデータを削除しますか？この操作は取り消せません。')) return;

      // ========== Phase 1: UIをロックして操作を無効化 ==========
      const lockOverlay = document.createElement('div');
      lockOverlay.id = 'resetLockOverlay';
      lockOverlay.style.cssText = `
        position: fixed;
        inset: 0;
        z-index: 999999;
        background: rgba(0, 0, 0, 0.92);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: #fff;
        font-size: 18px;
        gap: 16px;
      `;
      lockOverlay.innerHTML = `
        <div style="font-size: 28px; font-weight: 700;">🗑️ データをリセット中...</div>
        <div id="resetStatus" style="color: #9ca3af;">準備中...</div>
        <div style="font-size: 13px; color: #6b7280; margin-top: 12px;">ページを閉じないでください</div>
      `;
      document.body.appendChild(lockOverlay);
      const statusEl = document.getElementById('resetStatus');
      const setStatus = (msg) => { if (statusEl) statusEl.textContent = msg; };

      // イベントを完全にブロック
      const blockEvent = (e) => { e.stopPropagation(); e.preventDefault(); };
      ['click', 'mousedown', 'mouseup', 'keydown', 'keyup', 'touchstart', 'touchend'].forEach(type => {
        document.addEventListener(type, blockEvent, true);
      });

      try {
        // ========== Phase 2: 全DBコネクションをクローズ ==========
        setStatus('データベース接続を終了中...');
        await new Promise(r => setTimeout(r, 100));

        // メインDB
        if (typeof db !== 'undefined' && db) {
          try { db.close(); } catch (_) { }
        }
        // NLStore
        if (typeof NLStore !== 'undefined' && NLStore?.idb?.db) {
          try { NLStore.idb.db.close(); } catch (_) { }
        }
        // TodoStoreDB
        if (typeof TodoStoreDB !== 'undefined' && TodoStoreDB?.db) {
          try { TodoStoreDB.db.close(); } catch (_) { }
        }

        // ========== Phase 3: localStorageクリア ==========
        setStatus('ローカル設定を削除中...');
        try { localStorage.clear(); } catch (_) { }
        try { sessionStorage.clear(); } catch (_) { }

        // ========== Phase 4: 全IndexedDBを削除 ==========
        const dbsToDelete = [
          DB_NAME,                    // study-ebook-db-v2-2
          'NLStoreDB',                // プランナー予定
          'TodoStoreDB',              // TODO管理
          'ThumbCacheDB',             // サムネイルキャッシュ
          'CanvasGridCacheDB',        // 描画キャッシュ
          'planner-sounds',           // プランナーサウンド
          'study-ebook-db',           // 旧メインDB
          'study-ebook-db-v2',        // 旧バージョン
        ];

        for (let i = 0; i < dbsToDelete.length; i++) {
          const dbName = dbsToDelete[i];
          setStatus(`データベース削除中 (${i + 1}/${dbsToDelete.length}): ${dbName}`);

          await new Promise((resolve) => {
            try {
              const req = indexedDB.deleteDatabase(dbName);
              const timeout = setTimeout(() => {
                console.warn(`[Reset] DB deletion timeout for: ${dbName}`);
                resolve();
              }, 3000); // 3秒タイムアウト

              req.onsuccess = () => {
                clearTimeout(timeout);
                console.log(`[Reset] Deleted DB: ${dbName}`);
                resolve();
              };
              req.onerror = (e) => {
                clearTimeout(timeout);
                console.warn(`[Reset] Failed to delete DB: ${dbName}`, e);
                resolve();
              };
              req.onblocked = () => {
                // ブロックされても削除待ちを続行
                console.warn(`[Reset] DB deletion blocked: ${dbName} - waiting...`);
              };
            } catch (e) {
              console.warn(`[Reset] Error deleting DB: ${dbName}`, e);
              resolve();
            }
          });
        }

        // ========== Phase 5: 少し待機してからリロード ==========
        setStatus('完了！ページを再読み込みします...');
        await new Promise(r => setTimeout(r, 500));

      } catch (e) {
        console.error('[Reset] Critical error during reset:', e);
        setStatus('エラーが発生しましたが、リロードを試みます...');
        await new Promise(r => setTimeout(r, 1000));
      }

      // ========== Phase 6: 強制リロード ==========
      // キャッシュを無視して完全リロード
      try {
        location.href = location.href.split('#')[0] + '?reset=' + Date.now();
      } catch (_) {
        location.reload(true);
      }
    }
    async function resetLibraryOnly() {
      if (!confirm('ライブラリ内の本をすべて削除します。よろしいですか？')) return;
      const books = await Book.listMeta();
      for (const b of books) { await Book.del(b.id); }
      openTabsState.splice(0, openTabsState.length, ...openTabsState.filter(t => t.type !== 'book' && t.type !== 'completed'));
      activeOpenTabId = openTabsState[0]?.key || null;
      persistOpenTabs(); renderOpenTabs();
      refresh();
      const viewerEl = document.getElementById('viewerView');
      if (viewerEl) { viewerEl.innerHTML = ''; viewerEl.classList.add('hidden'); }
      state.viewerContext = null;
      teardownCompletedKeyHandler();
      showTab('library');
      showToast('ライブラリをリセットしました', 'ok');
    }
    async function resetBoxesOnly() {
      if (!confirm('ボックスをすべて削除します。よろしいですか？')) return;
      const boxes = await Box.list();
      for (const bx of boxes) { await Box.del(bx.id); }
      openTabsState.splice(0, openTabsState.length, ...openTabsState.filter(t => t.type !== 'box'));
      activeOpenTabId = openTabsState[0]?.key || null;
      persistOpenTabs(); renderOpenTabs();
      renderBoxes();
      const viewerEl = document.getElementById('viewerView');
      if (viewerEl) { viewerEl.innerHTML = ''; viewerEl.classList.add('hidden'); }
      state.viewerContext = null;
      teardownCompletedKeyHandler();
      showTab('boxes');
      showToast('ボックスをリセットしました', 'ok');
    }

    /** ===== Dictionary (offline, English/Japanese) ===== */
    const DICT_BASE = [];
    const SUBJECTS = [
      { id: 'english', label: '英語' },
      { id: 'kokugo', label: '国語' },
      { id: 'math', label: '数学' },
      { id: 'science', label: '理科' },
      { id: 'social', label: '社会' }
    ];
    const DICT_CUSTOM_KEY = 'dict_custom_v1';
    function subjectLabel(id) {
      return SUBJECTS.find(s => s.id === id)?.label || id || '';
    }
    function normalizeSubject(subj) {
      const t = (subj || '').toString().trim().toLowerCase();
      if (!t) return 'english';
      if (['英語', 'english', 'eng'].includes(t)) return 'english';
      if (['国語', 'japanese', 'kokugo'].includes(t)) return 'kokugo';
      if (['数学', 'math', '数学科', 'すうがく'].includes(t)) return 'math';
      if (['理科', 'science', 'りか'].includes(t)) return 'science';
      if (['社会', 'social', 'せいしゃかい', 'しゃかい', 'civics', 'history', 'geography'].includes(t)) return 'social';
      return t;
    }
    function normalizeDictEntry(raw, defaultSubject = 'english') {
      if (!raw) return null;
      const word = (raw.word || raw[0] || '').trim();
      const meaning = (raw.meaning || raw[1] || '').trim();
      if (!word || !meaning) return null;
      const subject = normalizeSubject((raw.subject || raw[7] || raw.subjectId || '').trim() || defaultSubject);
      const entry = {
        word,
        meaning,
        reading: (raw.reading || raw[2] || '').trim(),
        pos: (raw.pos || raw[3] || '').trim(),
        examples: Array.isArray(raw.examples)
          ? raw.examples.filter(Boolean).map(x => String(x).trim())
          : (raw.examples || raw[4] || '').split(';;').map(x => x.trim()).filter(Boolean),
        extra: (raw.extra || raw[5] || '').trim(),
        detail: (raw.detail || raw[6] || '').trim(),
        subject
      };
      return entry;
    }
    function dedupeDictEntries(arr) {
      const map = new Map();
      arr.forEach(e => {
        const n = normalizeDictEntry(e, e.subject || 'english');
        if (n) map.set(`${n.subject}::${n.word}`, n);
      });
      return Array.from(map.values());
    }
    function loadCustomDictEntries() {
      try {
        const raw = JSON.parse(localStorage.getItem(DICT_CUSTOM_KEY) || '[]');
        const normalized = Array.isArray(raw) ? raw.map(r => ({ ...r, subject: normalizeSubject(r.subject || 'english') })) : [];
        return dedupeDictEntries(normalized);
      } catch (_) {
        return [];
      }
    }
    function saveCustomDictEntries(list) {
      try { localStorage.setItem(DICT_CUSTOM_KEY, JSON.stringify(list || [])); } catch (_) { }
    }
    let dictCustomEntries = loadCustomDictEntries();
    let DICT_DATA = dedupeDictEntries([...DICT_BASE, ...dictCustomEntries]);

    function parseDictText(text, subject = 'english') {
      const out = [];
      if (!text) return out;
      text.split(/\r?\n/).forEach(line => {
        const raw = line.trim();
        if (!raw || raw.startsWith('#')) return;
        const parts = raw.split('|').map(p => p.trim());
        const entry = normalizeDictEntry(parts, subject);
        if (entry) out.push(entry);
      });
      return out;
    }
    function mergeCustomEntries(newEntries) {
      dictCustomEntries = dedupeDictEntries([...dictCustomEntries, ...newEntries]);
      saveCustomDictEntries(dictCustomEntries);
      DICT_DATA = dedupeDictEntries([...DICT_BASE, ...dictCustomEntries]);
    }
    function resetCustomDictEntries(subject = null) {
      if (subject) {
        const before = dictCustomEntries.length;
        dictCustomEntries = dictCustomEntries.filter(e => (e.subject || 'english') !== subject);
        const removed = before - dictCustomEntries.length;
        saveCustomDictEntries(dictCustomEntries);
        DICT_DATA = dedupeDictEntries([...DICT_BASE, ...dictCustomEntries]);
        renderDictionary();
        showToast && showToast(`${subjectLabel(subject)}のカスタム語彙を${removed}件削除しました`, removed ? 'ok' : 'info');
        return;
      }
      dictCustomEntries = [];
      saveCustomDictEntries(dictCustomEntries);
      DICT_DATA = dedupeDictEntries([...DICT_BASE, ...dictCustomEntries]);
      renderDictionary();
      showToast && showToast('カスタム語彙をリセットしました', 'ok');
    }
    function serializeDictEntry(entry) {
      const ex = Array.isArray(entry.examples) ? entry.examples.join(';; ') : entry.examples || '';
      return [
        entry.word || '',
        entry.meaning || '',
        entry.reading || '',
        entry.pos || '',
        ex,
        entry.extra || '',
        entry.detail || '',
        entry.subject || 'english'
      ].join(' | ');
    }
    function exportCustomDictAsText() {
      const lines = dictCustomEntries.length ? dictCustomEntries : [];
      if (!lines.length) {
        showToast && showToast('カスタム語彙がありません', 'info');
        return;
      }
      const blob = new Blob([lines.map(serializeDictEntry).join('\\n')], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      const date = new Date().toISOString().slice(0, 10);
      a.href = url;
      a.download = `dict-custom-${date}.txt`;
      a.click();
      setTimeout(() => URL.revokeObjectURL(url), 1000);
      showToast && showToast('カスタム語彙をテキスト化しました', 'ok');
    }

    const POS_LABELS_JP = {
      noun: '名詞',
      verb: '動詞',
      adjective: '形容詞',
      adverb: '副詞',
      pronoun: '代名詞',
      preposition: '前置詞',
      conjunction: '接続詞',
      interjection: '間投詞',
      article: '冠詞',
      determiner: '限定詞',
      numeral: '数詞',
      particle: '助詞',
      auxiliary: '助動詞',
      modal: '法助動詞',
      participle: '分詞',
      phrase: '句',
      adverbial: '副詞句',
      prefix: '接頭辞',
      suffix: '接尾辞',
      pron: '代名詞',
      adj: '形容詞',
      adv: '副詞',
      prep: '前置詞',
      conj: '接続詞',
      interj: '間投詞',
      aux: '助動詞',
      det: '限定詞',
      num: '数詞',
      n: '名詞',
      v: '動詞'
    };

    function translatePosLabel(pos) {
      if (!pos) return '';
      const segments = pos.split(/[;,/｜・]/).map(s => s.trim()).filter(Boolean);
      if (!segments.length) return pos;
      const translated = segments.map(segment => {
        const tokens = (segment.match(/[a-z]+/gi) || []);
        const matchToken = tokens.find(token => POS_LABELS_JP[token.toLowerCase()]);
        if (matchToken) return POS_LABELS_JP[matchToken.toLowerCase()];
        return segment;
      });
      return translated.join(' / ');
    }

    const DICT_FAV_KEY = 'dict_favs_v1';
    const DICT_HIS_KEY = 'dict_history_v1';
    let dictFavorites = (() => { try { return new Set(JSON.parse(localStorage.getItem(DICT_FAV_KEY) || '[]')); } catch (_) { return new Set(); } })();
    let dictHistory = (() => { try { const arr = JSON.parse(localStorage.getItem(DICT_HIS_KEY) || '[]'); return Array.isArray(arr) ? arr.slice(0, 50) : []; } catch (_) { return []; } })();
    dictFavorites = new Set(Array.from(dictFavorites).map(k => k.includes('::') ? k : `english::${k}`));
    dictHistory = Array.from(dictHistory).map(k => k.includes('::') ? k : `english::${k}`);
    let dictSelectedId = null;
    const dictSelectors = () => ({
      listEl: document.getElementById('dictResultList'),
      searchInput: document.getElementById('dictSearchInput'),
      modeSel: document.getElementById('dictModeSelect'),
      favOnly: document.getElementById('dictFavoritesOnly'),
      subjectSel: document.getElementById('dictSubjectSelect'),
      importSubjectSel: document.getElementById('dictImportSubject')
    });
    const dictKey = (entry) => `${entry.subject || 'english'}::${entry.word}`;
    function saveDictFavs() { try { localStorage.setItem(DICT_FAV_KEY, JSON.stringify(Array.from(dictFavorites))); } catch (_) { } }
    function saveDictHistory() { try { localStorage.setItem(DICT_HIS_KEY, JSON.stringify(dictHistory.slice(0, 50))); } catch (_) { } }
    function pushDictHistory(id) { dictHistory = [id, ...dictHistory.filter(x => x !== id)].slice(0, 50); saveDictHistory(); }
    function dictMatch(entry, q, mode) {
      const w = entry.word.toLowerCase();
      const m = (entry.meaning || '').toLowerCase();
      const detail = (entry.detail || '').toLowerCase();
      const reading = (entry.reading || '').toLowerCase();
      const query = q.toLowerCase();
      if (!query) return true;
      if (mode === 'en') return w.includes(query);
      if (mode === 'ja') return w.includes(query) || m.includes(query) || detail.includes(query) || reading.includes(query);
      const hasJa = /[ぁ-んァ-ン一-龥]/.test(query);
      if (hasJa) return w.includes(query) || m.includes(query) || detail.includes(query) || reading.includes(query);
      return w.includes(query) || m.includes(query) || detail.includes(query) || reading.includes(query);
    }
    function rankDictEntries(entries, query, favSet = new Set()) {
      const q = (query || '').trim().toLowerCase();
      const favs = favSet instanceof Set ? favSet : new Set(favSet || []);
      const score = (entry) => {
        if (!entry) return -Infinity;
        if (!q) return 0;
        const w = (entry.word || '').toLowerCase();
        const r = (entry.reading || '').toLowerCase();
        const m = (entry.meaning || '').toLowerCase();
        const d = (entry.detail || '').toLowerCase();
        let s = 0;
        if (w === q) s += 10000;
        if (r && r === q) s += 3500;
        if (w.startsWith(q)) s += 1800;
        if (r && r.startsWith(q)) s += 1200;
        if (w.includes(q)) s += 800;
        if (r && r.includes(q)) s += 500;
        if (m.includes(q)) s += 320;
        if (d.includes(q)) s += 140;
        if (favs.has(dictKey(entry))) s += 60;
        s += Math.max(0, 60 - Math.abs((entry.word || '').length - q.length));
        return s;
      };
      return entries.slice().sort((a, b) => {
        const diff = score(b) - score(a);
        if (diff !== 0) return diff;
        return (a.word || '').localeCompare(b.word || '', 'ja');
      });
    }
    function renderDictionary() {
      const { listEl, searchInput, modeSel, favOnly, subjectSel } = dictSelectors();
      if (!listEl) return;
      const q = (searchInput?.value || '').trim();
      const mode = modeSel?.value || 'auto';
      const onlyFav = !!favOnly?.checked;
      const subject = subjectSel?.value || 'english';
      const entries = DICT_DATA
        .filter(e => (e.subject || 'english') === subject)
        .filter(e => dictMatch(e, q, mode))
        .filter(e => !onlyFav || dictFavorites.has(dictKey(e)));
      const ranked = q ? rankDictEntries(entries, q, dictFavorites) : entries.slice().sort((a, b) => (a.word || '').localeCompare(b.word || '', 'ja'));
      listEl.innerHTML = '';
      if (!ranked.length) {
        listEl.innerHTML = `<div class="muted" style="padding:6px;">該当する単語がありません</div>`;
        document.getElementById('dictDetail')?.classList.add('hidden');
        document.getElementById('dictDetailEmpty')?.classList.remove('hidden');
        return;
      }
      ranked.forEach(e => {
        const item = document.createElement('div');
        item.className = 'item';
        item.style.cursor = 'pointer';
        const posLabel = translatePosLabel(e.pos) || e.pos || '';
        item.innerHTML = `<div class="row space" style="gap:6px">
          <div>
            <strong>${escapeHTML(e.word)}</strong>
            <div class="muted" style="font-size:11px">${escapeHTML(e.meaning)}</div>
          </div>
          <div class="row" style="gap:6px;align-items:center;">
            ${posLabel ? `<span class="pill" style="opacity:.8">${escapeHTML(posLabel)}</span>` : ''}
            <span class="pill" style="opacity:.7">${escapeHTML(subjectLabel(e.subject))}</span>
          </div>
        </div>`;
        item.onclick = () => showDictEntry(e);
        listEl.appendChild(item);
      });
    }
    function showDictEntry(entry) {
      const key = dictKey(entry);
      dictSelectedId = key;
      pushDictHistory(key);
      const detail = document.getElementById('dictDetail');
      const empty = document.getElementById('dictDetailEmpty');
      if (detail) detail.classList.remove('hidden');
      if (empty) empty.classList.add('hidden');
      const favBtn = document.getElementById('dictFavBtn');
      const setFavBtn = () => {
        if (!favBtn) return;
        const isFav = dictFavorites.has(key);
        favBtn.textContent = isFav ? '★ お気に入り中' : '☆ お気に入り';
      };
      if (favBtn) favBtn.onclick = () => {
        if (dictFavorites.has(key)) dictFavorites.delete(key); else dictFavorites.add(key);
        saveDictFavs(); setFavBtn(); renderDictionary();
      };
      setFavBtn();
      const wordEl = document.getElementById('dictWord');
      const pronEl = document.getElementById('dictPron');
      const posEl = document.getElementById('dictPos');
      const meaningEl = document.getElementById('dictMeaning');
      const exEl = document.getElementById('dictExampleWrap');
      const extraEl = document.getElementById('dictExtraWrap');
      if (wordEl) wordEl.textContent = entry.word;
      if (pronEl) pronEl.textContent = entry.reading ? `発音/カナ: ${entry.reading}` : '';
      if (meaningEl) meaningEl.textContent = entry.meaning || '';
      if (exEl) {
        const list = Array.isArray(entry.examples) ? entry.examples : [];
        exEl.innerHTML = list.length ? `<div>例文</div><ul style="margin:4px 0 0 16px;">${list.map(x => `<li>${escapeHTML(x)}</li>`).join('')}</ul>` : '';
      }
      if (extraEl) extraEl.textContent = entry.extra || '';
      if (posEl) {
        const posLabel = translatePosLabel(entry.pos) || entry.pos || '';
        posEl.textContent = posLabel || '';
      }
      const subjectBadge = document.getElementById('dictSubjectBadge');
      if (subjectBadge) subjectBadge.textContent = subjectLabel(entry.subject);
    }
    function showDictHistory() {
      const list = dictHistory.map(id => DICT_DATA.find(e => dictKey(e) === id)).filter(Boolean);
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.style.display = 'flex';
      modal.innerHTML = `<div class="box" style="width:min(520px,90vw);max-height:70vh;overflow:auto;">
        <div class="row space" style="align-items:center;margin-bottom:8px;">
          <h3 style="margin:0">閲覧履歴</h3>
          <button class="btn ghost small" data-close>閉じる</button>
        </div>
        <div id="dictHistoryList"></div>
      </div>`;
      document.body.appendChild(modal);
      modal.querySelector('[data-close]')?.addEventListener('click', () => modal.remove());
      const listEl = modal.querySelector('#dictHistoryList');
      if (!list.length) {
        listEl.innerHTML = '<div class="muted">履歴がありません</div>';
      } else {
        listEl.innerHTML = '';
        list.forEach(e => {
          const row = document.createElement('div');
          row.className = 'item';
          row.style.cursor = 'pointer';
          const posLabel = translatePosLabel(e.pos) || e.pos || '';
          row.innerHTML = `<div class="row space"><div><strong>${escapeHTML(e.word)}</strong><div class="muted" style="font-size:11px">${escapeHTML(e.meaning)}</div></div><div class="row" style="gap:6px;align-items:center;">${posLabel ? `<span class="pill">${escapeHTML(posLabel)}</span>` : ''}<span class="pill" style="opacity:.8">${escapeHTML(subjectLabel(e.subject))}</span></div></div>`;
          row.onclick = () => { showDictEntry(e); modal.remove(); };
          listEl.appendChild(row);
        });
      }
    }
    async function importDictTextFile(file, subject = 'english') {
      if (!file) return;
      const text = await file.text();
      const parsed = parseDictText(text, subject);
      if (!parsed.length) { showToast && showToast('有効な行がありませんでした', 'error'); return; }
      mergeCustomEntries(parsed);
      showToast && showToast(`${parsed.length}件の単語を追加しました`, 'ok');
      renderDictionary();
    }

    /** ===== Global Wiring ===== */
    function ensurePageScroll() {
      document.documentElement.style.overflowY = 'auto';
      document.body.style.overflowY = 'auto';
    }
    const BOXES_TAB_KEY = 'boxes_tab_enabled';
    let boxesTabEnabled = (() => { try { return localStorage.getItem(BOXES_TAB_KEY) === '1'; } catch (_) { return false; } })();
    function setBoxesTabEnabled(on) {
      boxesTabEnabled = !!on;
      try { localStorage.setItem(BOXES_TAB_KEY, boxesTabEnabled ? '1' : '0'); } catch (_) { }
      updateBoxesTabVisibility();
    }
    function updateBoxesTabVisibility() {
      const boxTab = document.querySelector('#tabs .tab[data-tab="boxes"]');
      const boxesView = document.getElementById('boxesView');
      if (boxTab) boxTab.classList.toggle('hidden', !boxesTabEnabled);
      if (boxesView && !boxesTabEnabled) boxesView.classList.add('hidden');
    }
    const plannerTabIds = ['planner'];
    function showTab(id, options = {}) {
      const tabIds = ['home', 'library', 'boxes', 'dictionary', 'uploader', 'settings'];
      const readerLayout = document.getElementById('readerLayout');
      const plannerApp = document.getElementById('plannerApp');
      const sidebar = document.getElementById('sidebar');
      const main = document.getElementById('main');
      const preserveOpenTab = !!options.preserveOpenTab;
      const isPlanner = plannerTabIds.includes(id);
      const viewerEl = document.getElementById('viewerView');
      const viewerActive = viewerEl && viewerEl.children.length > 0;
      const leavingBookViewer = viewerActive && state.viewerContext === 'book' && id !== 'library';
      if (leavingBookViewer) {
        try { requestPoseSave?.(); } catch (_) { }
        try { window.__viewerResetView?.({ toast: false }); } catch (_) { }
        try { window.__persistActiveDrawDoc?.(); } catch (_) { }
      }
      const syncOpenTabs = () => {
        if (preserveOpenTab) {
          renderOpenTabs();
          persistOpenTabs();
        } else {
          activeOpenTabId = null;
          renderOpenTabs();
          persistOpenTabs();
        }
      };
      if (isPlanner) {
        state.activeTab = id;
        syncOpenTabs();
      } else if (tabIds.includes(id)) {
        state.activeTab = id;
        syncOpenTabs();
      }
      if (puddingState.active) {
        puddingSetDockActive(id);
      }
      if (tabIds.includes(id)) {
        if (plannerApp) plannerApp.classList.add('hidden');
        if (readerLayout) readerLayout.classList.remove('hidden');
      }
      document.querySelectorAll('#tabs .tab').forEach(t => t.classList.toggle('active', t.dataset.tab === id));
      if (isPlanner) {
        if (readerLayout) readerLayout.classList.add('hidden');
        if (plannerApp) plannerApp.classList.remove('hidden');
        document.body.classList.remove('reading');
        window.__plannerStyles?.enable?.();
        if (window.__setPlannerTheme) window.__setPlannerTheme();
        window.__activatePlannerTab?.(window.__plannerLastTab?.() || id);
        try { renderList(); drawPlanner(); nlRebuildAll && nlRebuildAll(); } catch (_) { }
        if (homeAutoTimer) { clearInterval(homeAutoTimer); homeAutoTimer = null; }
        return;
      }
      const isHome = id === 'home';
      const isLibrary = id === 'library';
      const isBoxes = id === 'boxes';
      const isDictionary = id === 'dictionary';
      const isUploader = id === 'uploader';
      const isSettings = id === 'settings';

      if (isBoxes && !boxesTabEnabled) {
        showToast && showToast('設定からボックス機能を有効化してください', 'error');
        showTab('home', options);
        return;
      }

      // Safety: if moving to library/boxes and viewerは異なる文脈なら閉じて通常表示を強制
      if (isLibrary && state.viewerContext && state.viewerContext !== 'book') {
        const viewerEl = document.getElementById('viewerView');
        if (viewerEl) { viewerEl.innerHTML = ''; viewerEl.classList.add('hidden'); }
        state.viewerContext = null;
        document.body.classList.remove('reading');
      }
      if (isBoxes && state.viewerContext && state.viewerContext !== 'box') {
        const viewerEl = document.getElementById('viewerView');
        if (viewerEl) { viewerEl.innerHTML = ''; viewerEl.classList.add('hidden'); }
        state.viewerContext = null;
        document.body.classList.remove('reading');
      }

      if (readerLayout) readerLayout.classList.toggle('settings-full', isSettings);
      if (sidebar) sidebar.classList.toggle('hidden', isSettings || isHome || isDictionary);
      if (main) main.classList.toggle('fullwidth', sidebar ? sidebar.classList.contains('hidden') : false);

      const homeEl = document.getElementById('homeView');
      const libraryEl = document.getElementById('libraryView');
      const boxesEl = document.getElementById('boxesView');
      const dictEl = document.getElementById('dictionaryView');
      const uploadEl = document.getElementById('uploadView');
      const settingsEl = document.getElementById('settingsView');

      // viewerは対応タブに応じて表示（ライブラリ=book, ボックス=box）
      const showViewer = viewerActive && (
        (isLibrary && state.viewerContext === 'book') ||
        (isBoxes && state.viewerContext === 'box') ||
        (isHome && state.viewerContext === 'completed')
      );
      if (viewerEl) viewerEl.classList.toggle('hidden', !showViewer);
      if (showViewer) {
        try {
          const saved = (typeof loadViewerPose === 'function' && book?.id) ? loadViewerPose(book.id) : null;
          if (saved) {
            if (typeof applySavedPoseInstant === 'function') applySavedPoseInstant(saved);
            else applySavedPose?.(saved);
            poseApplied = true;
            pendingPose = null;
          } else {
            applyViewTransform?.();
          }
          requestAnimationFrame(() => { try { applyViewTransform?.(); } catch (_) { } });
        } catch (_) { }
        if (state.viewerContext === 'completed') {
          try { document.activeElement?.blur?.(); } catch (_) { }
        }
      }

      if (homeEl) homeEl.classList.toggle('hidden', !isHome || showViewer);
      if (libraryEl) libraryEl.classList.toggle('hidden', !isLibrary || showViewer);
      if (boxesEl) boxesEl.classList.toggle('hidden', !isBoxes || showViewer);
      if (dictEl) dictEl.classList.toggle('hidden', !isDictionary);
      if (uploadEl) uploadEl.classList.toggle('hidden', !isUploader);
      if (settingsEl) settingsEl.classList.toggle('hidden', !isSettings);
      if (showViewer) { document.body.classList.add('reading'); } else { document.body.classList.remove('reading'); }
      if (!showViewer) ensurePageScroll();

      if (homeAutoTimer) { clearInterval(homeAutoTimer); homeAutoTimer = null; }
      if (isHome && !showViewer) {
        renderHomeView();
        homeAutoTimer = setInterval(() => {
          if (!homeHoverLock) renderHomeView();
        }, 30000);
      }
      if (isBoxes) renderBoxes();
      if (isDictionary) renderDictionary();
    }

    // ===== PuddingOS (desktop-like shell) =====
    const puddingState = {
      active: false,
      minimized: false,
      anchors: {},
      window: null,
      body: null,
      dock: null,
      desktop: null
    };
    const puddingApps = [
      { id: 'home', label: 'ホーム', icon: '🏠' },
      { id: 'library', label: 'ライブラリ', icon: '📚' },
      { id: 'boxes', label: 'ボックス', icon: '🗃️' },
      { id: 'dictionary', label: '辞書', icon: '📖' },
      { id: 'settings', label: '設定', icon: '⚙️' },
      { id: 'planner', label: 'プランナー', icon: '🗓️' },
    ];
    const puddingLabelFor = (id) => {
      const hit = puddingApps.find(app => app.id === id);
      return hit ? hit.label : id;
    };
    const puddingCaptureAnchor = (el, key) => {
      if (!el || puddingState.anchors[key]) return;
      const anchor = document.createElement('div');
      anchor.id = `pudding-anchor-${key}`;
      anchor.style.display = 'none';
      el.parentNode?.insertBefore(anchor, el);
      puddingState.anchors[key] = anchor;
    };
    const puddingRestore = (el, key) => {
      const anchor = puddingState.anchors[key];
      if (anchor?.parentNode) {
        anchor.parentNode.insertBefore(el, anchor);
        anchor.remove();
      }
      delete puddingState.anchors[key];
    };
    const puddingFocusWindow = () => {
      if (!puddingState.window) return;
      puddingState.window.classList.add('active');
      puddingState.window.style.display = 'grid';
      puddingState.minimized = false;
    };
    const puddingSetDockActive = (id) => {
      if (!puddingState.dock) return;
      const title = document.getElementById('puddingWindowTitle');
      if (title) title.textContent = `PuddingOS - ${puddingLabelFor(id)}`;
      puddingState.dock.querySelectorAll('button').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.tab === id);
      });
    };
    const puddingRenderDock = () => {
      const dock = document.getElementById('puddingDock');
      puddingState.dock = dock;
      if (!dock) return;
      dock.innerHTML = '';
      const activeTab = state.activeTab || 'home';
      const apps = puddingApps.filter(app => app.id !== 'boxes' || boxesTabEnabled);
      apps.forEach(app => {
        const btn = document.createElement('button');
        btn.dataset.tab = app.id;
        btn.innerHTML = `<span class="icon">${app.icon}</span><span class="label">${app.label}</span>`;
        btn.onclick = () => {
          puddingFocusWindow();
          if (app.id === 'planner') showTab('planner', { preserveOpenTab: true });
          else showTab(app.id, { preserveOpenTab: true });
          puddingSetDockActive(app.id);
        };
        if (app.id === activeTab) btn.classList.add('active');
        dock.appendChild(btn);
      });
    };
    const puddingInitDrag = () => {
      const win = document.getElementById('puddingMainWindow');
      const handle = document.getElementById('puddingWindowDrag');
      const resize = document.getElementById('puddingWindowResize');
      puddingState.window = win;
      const clampRect = (rect) => {
        const maxW = window.innerWidth - 40;
        const maxH = window.innerHeight - 40;
        return {
          left: Math.max(8, Math.min(rect.left, window.innerWidth - 120)),
          top: Math.max(8, Math.min(rect.top, window.innerHeight - 120)),
          width: Math.max(420, Math.min(rect.width, maxW)),
          height: Math.max(320, Math.min(rect.height, maxH))
        };
      };
      if (handle && win) {
        let dragging = false;
        let start = { x: 0, y: 0, left: 0, top: 0 };
        const endDrag = () => {
          dragging = false;
          document.removeEventListener('mousemove', onMove);
          document.removeEventListener('mouseup', endDrag);
          document.removeEventListener('touchmove', onMove, { passive: false });
          document.removeEventListener('touchend', endDrag);
        };
        const onMove = (e) => {
          if (!dragging) return;
          const pt = e.touches?.[0] || e;
          const dx = pt.clientX - start.x;
          const dy = pt.clientY - start.y;
          const next = clampRect({ left: start.left + dx, top: start.top + dy, width: win.offsetWidth, height: win.offsetHeight });
          win.style.left = `${next.left}px`;
          win.style.top = `${next.top}px`;
          e.preventDefault();
        };
        const onDown = (e) => {
          const pt = e.touches?.[0] || e;
          dragging = true;
          const rect = win.getBoundingClientRect();
          start = { x: pt.clientX, y: pt.clientY, left: rect.left, top: rect.top };
          document.addEventListener('mousemove', onMove);
          document.addEventListener('mouseup', endDrag);
          document.addEventListener('touchmove', onMove, { passive: false });
          document.addEventListener('touchend', endDrag);
          e.preventDefault();
        };
        handle.addEventListener('mousedown', onDown);
        handle.addEventListener('touchstart', onDown, { passive: false });
      }
      if (resize && win) {
        let resizing = false;
        let start = { x: 0, y: 0, w: 0, h: 0 };
        const endResize = () => {
          resizing = false;
          document.removeEventListener('mousemove', onMove);
          document.removeEventListener('mouseup', endResize);
          document.removeEventListener('touchmove', onMove, { passive: false });
          document.removeEventListener('touchend', endResize);
        };
        const onMove = (e) => {
          if (!resizing) return;
          const pt = e.touches?.[0] || e;
          const dx = pt.clientX - start.x;
          const dy = pt.clientY - start.y;
          const next = clampRect({ left: win.offsetLeft, top: win.offsetTop, width: start.w + dx, height: start.h + dy });
          win.style.width = `${next.width}px`;
          win.style.height = `${next.height}px`;
          e.preventDefault();
        };
        const onDown = (e) => {
          const pt = e.touches?.[0] || e;
          resizing = true;
          start = { x: pt.clientX, y: pt.clientY, w: win.offsetWidth, h: win.offsetHeight };
          document.addEventListener('mousemove', onMove);
          document.addEventListener('mouseup', endResize);
          document.addEventListener('touchmove', onMove, { passive: false });
          document.addEventListener('touchend', endResize);
          e.preventDefault();
        };
        resize.addEventListener('mousedown', onDown);
        resize.addEventListener('touchstart', onDown, { passive: false });
      }
      if (win) {
        win.addEventListener('mousedown', puddingFocusWindow);
      }
    };
    const enterPuddingOs = () => {
      if (puddingState.active) return;
      const body = document.getElementById('puddingWindowBody');
      const desktop = document.querySelector('#puddingOsLayer .pudding-desktop');
      puddingState.body = body;
      puddingState.desktop = desktop;
      if (!body || !desktop) return;
      const readerLayout = document.getElementById('readerLayout');
      const plannerApp = document.getElementById('plannerApp');
      if (readerLayout) puddingCaptureAnchor(readerLayout, 'reader');
      if (plannerApp) puddingCaptureAnchor(plannerApp, 'planner');
      body.innerHTML = '';
      if (readerLayout) body.appendChild(readerLayout);
      if (plannerApp) body.appendChild(plannerApp);
      puddingRenderDock();
      document.body.classList.add('pudding-os-mode');
      document.body.classList.remove('pudding-dock-visible');
      puddingState.active = true;
      puddingFocusWindow();
      showTab(state.activeTab || 'home', { preserveOpenTab: true });
    };
    const exitPuddingOs = () => {
      if (!puddingState.active) return;
      document.body.classList.remove('pudding-os-mode', 'pudding-dock-visible');
      const readerLayout = document.getElementById('readerLayout');
      const plannerApp = document.getElementById('plannerApp');
      if (readerLayout) puddingRestore(readerLayout, 'reader');
      if (plannerApp) puddingRestore(plannerApp, 'planner');
      if (puddingState.body) puddingState.body.innerHTML = '';
      if (puddingState.window) {
        puddingState.window.classList.remove('active');
        puddingState.window.style.display = 'grid';
      }
      puddingState.active = false;
      puddingState.minimized = false;
    };
    const togglePuddingOs = () => {
      if (puddingState.active) exitPuddingOs();
      else enterPuddingOs();
    };
    const puddingHandleDockReveal = (e) => {
      if (!puddingState.active) return;
      const near = (window.innerHeight - e.clientY) < 120;
      if (near) document.body.classList.add('pudding-dock-visible');
      else document.body.classList.remove('pudding-dock-visible');
    };

    // ========== Home View Rendering ==========
    async function renderHomeView(force = false) {
      if (homeHoverLock && !force) {
        setTimeout(() => { if (!homeHoverLock) renderHomeView(); }, 800);
        return;
      }
      try {
        if (!window.__homeActionsBound) {
          window.__homeActionsBound = true;
          const openCalendarTab = () => { showTab('planner'); try { __activatePlannerTab?.('calendar'); PlannerCalendar?.refresh?.(); } catch (_) { } };
          const autoPlanTodo = async () => {
            try {
              if (!window.NLStore || !NLStore.addAbs) { try { showToast && showToast('プランナーが未初期化です', 'error'); } catch (_) { } return; }
              try { await window.TodoStore?.ready?.(); } catch (_) { }
              const todos = (window.TodoStore?.all?.() || []).filter(t => !t.done && Array.isArray(t.pages) && t.pages.length);
              if (!todos.length) { try { showToast && showToast('予定化できるToDoがありません', 'info'); } catch (_) { } return; }
              todos.sort((a, b) => {
                const daRaw = a.due ? new Date(a.due).getTime() : Infinity;
                const dbRaw = b.due ? new Date(b.due).getTime() : Infinity;
                const da = Number.isFinite(daRaw) ? daRaw : Infinity;
                const db = Number.isFinite(dbRaw) ? dbRaw : Infinity;
                return da - db;
              });
              const todo = todos[0];
              const completed = new Set(todo.completedPages || []);
              const page = (todo.pages || []).find(p => !completed.has(p)) ?? todo.pages[0];
              const dur = Math.max(5, Number(todo.perPage) || 5);
              const now = new Date();
              const end = new Date(now.getTime() + dur * 60000);
              const ev = NLStore.addAbs(now, end, `${todo.title || 'ToDo'} p${page}`, todo.color || '#4da3ff', 'study');
              if (ev) { ev.todoId = todo.id; ev.pageNumber = page; NLStore.save && NLStore.save(); }
              drawPlanner && drawPlanner(); nlRebuildAll && nlRebuildAll(); PlannerCalendar?.refresh?.();
              try { showToast && showToast('ToDoを予定に入れました', 'ok'); } catch (_) { }
            } catch (e) { console.warn(e); }
          };
          const hc = (id, fn) => { const el = document.getElementById(id); if (el) el.onclick = fn; };
          hc('homeOpenCalendar', openCalendarTab);
          hc('homeOpenOriginalLesson', () => { showTab('planner'); try { __activatePlannerTab?.('original-lesson'); } catch (_) { } });
          const updateReviewState = (patch) => {
            Object.assign(homeReviewState, patch);
            renderHomeView(true);
          };
          hc('homeReviewToggle', () => setHomeReviewMode(!homeReviewMode));
          hc('homeReviewBack', () => setHomeReviewMode(false));
          hc('homeCompletedPrev', () => {
            const base = homeParseDate(homeCompletedDate || homeFormatDate(new Date()));
            if (isNaN(base)) return;
            base.setDate(base.getDate() - 1);
            setHomeCompletedDate(homeFormatDate(base));
          });
          hc('homeCompletedNext', () => {
            const base = homeParseDate(homeCompletedDate || homeFormatDate(new Date()));
            if (isNaN(base)) return;
            base.setDate(base.getDate() + 1);
            setHomeCompletedDate(homeFormatDate(base));
          });
          const dateInput = document.getElementById('homeCompletedDateInput');
          const dateLabel = document.getElementById('homeCompletedDateLabel');
          if (dateLabel && dateInput) {
            const openPicker = () => {
              if (typeof dateInput.showPicker === 'function') {
                dateInput.showPicker();
              } else {
                dateInput.focus();
                dateInput.click();
              }
            };
            dateLabel.onclick = openPicker;
            dateLabel.addEventListener('keydown', (e) => {
              if (e.key === 'Enter' || e.key === ' ' || e.key === 'Spacebar') {
                e.preventDefault();
                openPicker();
              }
            });
          }
          if (dateInput) {
            dateInput.addEventListener('change', () => {
              if (dateInput.value) setHomeCompletedDate(dateInput.value);
            });
          }
          const rangeModeEl = document.getElementById('homeReviewRangeMode');
          if (rangeModeEl) rangeModeEl.onchange = () => updateReviewState({ rangeMode: rangeModeEl.value });
          const anchorEl = document.getElementById('homeReviewAnchor');
          if (anchorEl) anchorEl.onchange = () => updateReviewState({ anchor: anchorEl.value });
          const startEl = document.getElementById('homeReviewStart');
          if (startEl) startEl.onchange = () => updateReviewState({ start: startEl.value });
          const endEl = document.getElementById('homeReviewEnd');
          if (endEl) endEl.onchange = () => updateReviewState({ end: endEl.value });
          const recentEl = document.getElementById('homeReviewRecentDays');
          if (recentEl) {
            recentEl.onchange = () => {
              const next = Math.max(1, parseInt(recentEl.value, 10) || 1);
              updateReviewState({ recentDays: next });
            };
          }
          const kindEl = document.getElementById('homeReviewKind');
          if (kindEl) kindEl.onchange = () => updateReviewState({ kind: kindEl.value });
          const bookFilterEl = document.getElementById('homeReviewBookFilter');
          if (bookFilterEl) bookFilterEl.onchange = () => updateReviewState({ bookId: bookFilterEl.value });
          const sortEl = document.getElementById('homeReviewSort');
          if (sortEl) sortEl.onchange = () => updateReviewState({ sort: sortEl.value });
          const searchEl = document.getElementById('homeReviewSearch');
          if (searchEl) searchEl.oninput = () => updateReviewState({ search: searchEl.value });
          const searchClearEl = document.getElementById('homeReviewSearchClear');
          if (searchClearEl) {
            searchClearEl.onclick = () => {
              if (searchEl) searchEl.value = '';
              updateReviewState({ search: '' });
            };
          }
          const pageFilterEl = document.getElementById('homeReviewPageFilter');
          if (pageFilterEl) pageFilterEl.oninput = () => updateReviewState({ pageFilter: pageFilterEl.value });
          const pageFilterClearEl = document.getElementById('homeReviewPageFilterClear');
          if (pageFilterClearEl) {
            pageFilterClearEl.onclick = () => {
              if (pageFilterEl) pageFilterEl.value = '';
              updateReviewState({ pageFilter: '' });
            };
          }
          const pageBookEl = document.getElementById('homeReviewPageBook');
          if (pageBookEl) pageBookEl.onchange = () => updateReviewState({ pageMapBookId: pageBookEl.value });
          const pageToggleEl = document.getElementById('homeReviewPageToggle');
          if (pageToggleEl) pageToggleEl.onclick = () => updateReviewState({ pageMapOpen: !homeReviewState.pageMapOpen });
          const completeDateEl = document.getElementById('homeReviewCompleteDate');
          if (completeDateEl) completeDateEl.onchange = () => updateReviewState({ completeDate: completeDateEl.value });
          const completeInputEl = document.getElementById('homeReviewCompleteInput');
          const completeAddBtn = document.getElementById('homeReviewCompleteAdd');
          const addManualCompletion = () => {
            const bookId = homeReviewState.pageMapBookId || homeReviewState.bookId;
            if (!bookId || bookId === '__unknown') {
              showToast && showToast('本を選択してください', 'warn');
              return;
            }
            const raw = completeInputEl?.value || '';
            const pages = homeParsePageList(raw);
            if (!pages.length) {
              showToast && showToast('ページ番号を入力してください', 'info');
              return;
            }
            const dateStr = homeClampToToday(document.getElementById('homeReviewCompleteDate')?.value || homeReviewState.completeDate || '');
            homeReviewState.completeDate = dateStr;
            const pageBookSelect = document.getElementById('homeReviewPageBook');
            const bookTitle = pageBookSelect?.selectedOptions?.[0]?.textContent || document.getElementById('homeReviewPageGrid')?.dataset?.bookTitle || '';
            pages.forEach(p => {
              try { window.StudyCalendar?.recordCompletion?.(bookId, p, bookTitle || '本', dateStr); } catch (_) { }
            });
            if (completeInputEl) completeInputEl.value = '';
            scheduleHomeReviewRefresh();
            showToast && showToast(`完了を${pages.length}件追加しました`, 'ok');
          };
          if (completeAddBtn) completeAddBtn.onclick = () => addManualCompletion();
          if (completeInputEl) {
            completeInputEl.addEventListener('keydown', (e) => {
              if (e.key === 'Enter') {
                e.preventDefault();
                addManualCompletion();
              }
            });
          }
        }
        applyHomePrefs();
        if (window.TodoStore?.ready) {
          try { await window.TodoStore.ready(); } catch (e) { console.warn('[Home] TodoStore ready wait failed', e); }
        }
        const safe = (txt) => (typeof escapeHTML === 'function' ? escapeHTML(txt) : txt);
        const now = new Date();
        const fmtLocalDate = (d) => {
          const y = d.getFullYear();
          const m = String(d.getMonth() + 1).padStart(2, '0');
          const day = String(d.getDate()).padStart(2, '0');
          return `${y}-${m}-${day}`;
        };
        const todayStr = fmtLocalDate(now);
        if (!homeCompletedDate) homeCompletedDate = todayStr;
        homeCompletedDate = homeClampToToday(homeCompletedDate);
        const completedDateStr = homeCompletedDate;
        const hour = now.getHours();
        let greeting = 'こんにちは！';
        if (hour < 6) greeting = 'おやすみなさい';
        else if (hour < 12) greeting = 'おはようございます！';
        else if (hour < 18) greeting = 'こんにちは！';
        else greeting = 'こんばんは！';

        const greetingEl = document.getElementById('homeGreeting');
        const dateEl = document.getElementById('homeDate');
        if (greetingEl) greetingEl.textContent = greeting;
        if (dateEl) {
          const days = ['日', '月', '火', '水', '木', '金', '土'];
          dateEl.textContent = `${now.getFullYear()}年${now.getMonth() + 1}月${now.getDate()}日（${days[now.getDay()]}）`;
        }
        const pad2Home = (n) => String(n).padStart(2, '0');
        const fmtHMHome = (ms) => {
          const d = new Date(ms);
          return `${pad2Home(d.getHours())}:${pad2Home(d.getMinutes())}`;
        };
        const formatMinutesHome = (mins) => {
          if (!Number.isFinite(mins)) return '--';
          const total = Math.max(0, Math.round(mins));
          const h = Math.floor(total / 60);
          const m = total % 60;
          return h ? `${h}時間${m ? `${m}分` : ''}` : `${m}分`;
        };
        const colorToRgbaHome = (hex, alpha = 0.16) => {
          const fallback = `rgba(96,165,250,${alpha})`;
          if (!hex) return fallback;
          let h = String(hex).trim();
          if (h.startsWith('#')) h = h.slice(1);
          if (h.length === 3) h = h.split('').map(c => c + c).join('');
          if (h.length !== 6) return fallback;
          const r = parseInt(h.slice(0, 2), 16);
          const g = parseInt(h.slice(2, 4), 16);
          const b = parseInt(h.slice(4, 6), 16);
          if (![r, g, b].every(Number.isFinite)) return fallback;
          return `rgba(${r},${g},${b},${alpha})`;
        };
        const lessonHost = document.getElementById('homeLessonTimetable');
        if (lessonHost) {
          const lessonData = (window.OriginalLesson?.getLessonsForDate?.(now, { includeDone: true }) || [])
            .sort((a, b) => (a.start || 0) - (b.start || 0));
          const lessonTotalEl = document.getElementById('homeLessonTotal');
          const lessonDoneEl = document.getElementById('homeLessonDone');
          const lessonRemainEl = document.getElementById('homeLessonRemain');
          const totalMin = lessonData.reduce((acc, l) => acc + Math.max(0, (l.end - l.start) / 60000), 0);
          const doneMin = lessonData.reduce((acc, l) => acc + (l.done ? Math.max(0, (l.end - l.start) / 60000) : 0), 0);
          const remainMin = Math.max(0, totalMin - doneMin);
          if (lessonTotalEl) lessonTotalEl.textContent = formatMinutesHome(totalMin);
          if (lessonDoneEl) lessonDoneEl.textContent = formatMinutesHome(doneMin);
          if (lessonRemainEl) lessonRemainEl.textContent = formatMinutesHome(remainMin);
          if (!lessonData.length) {
            lessonHost.innerHTML = '<div class="home-empty">今日の授業はありません</div>';
          } else {
            const lessonHtml = lessonData.map((lesson, idx) => {
              const start = fmtHMHome(lesson.start);
              const end = fmtHMHome(lesson.end);
              const durMin = (lesson.end - lesson.start) / 60000;
              const color = lesson.color || '#60a5fa';
              const bg = colorToRgbaHome(color, 0.16);
              const status = lesson.done ? ' / 完了' : '';
              return `<div class="home-lesson-slot${lesson.done ? ' done' : ''}" style="--lesson-bg:${bg};border-color:${color}">
                <div class="home-lesson-time">${start} - ${end}</div>
                <div class="home-lesson-body">
                  <div class="home-lesson-title"><span class="home-lesson-period">${idx + 1}限</span>${safe(lesson.title || '授業')}</div>
                  <div class="home-lesson-meta">${formatMinutesHome(durMin)}${status}</div>
                </div>
              </div>`;
            }).join('');
            lessonHost.innerHTML = lessonHtml;
          }
        }
        const homeEl = document.getElementById('homeView');
        if (homeEl) homeEl.classList.toggle('home-review-mode', homeReviewMode);
        const completedLabelEl = document.getElementById('homeCompletedDateLabel');
        const completedDateObj = homeParseDate(completedDateStr);
        if (completedLabelEl && !isNaN(completedDateObj)) {
          const days = ['日', '月', '火', '水', '木', '金', '土'];
          const label = `${completedDateObj.getMonth() + 1}/${completedDateObj.getDate()}（${days[completedDateObj.getDay()]}）`;
          completedLabelEl.textContent = (completedDateStr === todayStr) ? `今日 ${label}` : label;
        }
        const completedNext = document.getElementById('homeCompletedNext');
        if (completedNext) completedNext.disabled = completedDateStr >= todayStr;
        const completedInput = document.getElementById('homeCompletedDateInput');
        if (completedInput) {
          completedInput.value = completedDateStr;
          completedInput.max = todayStr;
        }
        const reviewToggle = document.getElementById('homeReviewToggle');
        if (reviewToggle) {
          reviewToggle.textContent = '復';
          reviewToggle.setAttribute('aria-pressed', homeReviewMode ? 'true' : 'false');
          reviewToggle.classList.toggle('active', !!homeReviewMode);
        }

        const loadCompletedDirect = (dateStr) => {
          try {
            const raw = localStorage.getItem('sc-completed');
            if (!raw) return [];
            const parsed = JSON.parse(raw);
            const val = parsed?.[dateStr];
            return Array.isArray(val) ? val : [];
          } catch (e) {
            console.warn('[Home] Failed to read completed records', e);
            return [];
          }
        };

        const getCompletedForDate = (dateStr) => {
          const direct = window.StudyCalendar?.getCompletedForDate?.(dateStr);
          if (Array.isArray(direct) && direct.length) return direct;
          return loadCompletedDirect(dateStr);
        };

        const homeNormalizePage = (v) => {
          const n = typeof v === 'string' ? parseInt(v, 10) : Number(v);
          return Number.isFinite(n) ? n : null;
        };

        const buildTodoCompletedSet = (todo) => {
          const set = new Set((todo?.completedPages || []).map(homeNormalizePage).filter(Number.isFinite));
          return set;
        };

        const todos = window.TodoStore?.all?.() || [];
        let books = [];
        try { books = await Book.list(); } catch (e) { console.warn('[Home] Failed to load books for home view', e); }
        const bookMap = new Map(books.map(b => [b.id, b]));
        const todayCompleted = getCompletedForDate(todayStr);
        const selectedCompleted = completedDateStr === todayStr ? todayCompleted : getCompletedForDate(completedDateStr);
        let remainingPages = 0;
        let remainingMinutes = 0; // 各TODOのperPageを考慮した推定残り時間
        let forcedRetry = false;
        const todaySessionTodos = []; // 今日のセッション用に収集

        // Today's tasks from calendar schedules
        const todayTasks = document.getElementById('homeTodayTasks');
        if (todayTasks) {
          if (!window.StudyCalendar) {
            todayTasks.innerHTML = '<div class="home-empty">カレンダーが未設定です</div>';
            forcedRetry = true;
          } else {
            let schedules = {};
            try {
              const raw = localStorage.getItem('sc-schedules');
              if (raw && raw.trim().startsWith('{')) {
                schedules = JSON.parse(raw) || {};
              } else if (raw) {
                // 破損値（例: "[object Object]"）は消して空扱い
                localStorage.removeItem('sc-schedules');
                schedules = {};
              }
            } catch (e) {
              if (!window.__homeScheduleWarned) {
                console.warn('[Home] Failed to parse schedules', e);
                window.__homeScheduleWarned = true;
              }
              schedules = {};
              forcedRetry = true;
            }
            let taskHtml = '';
            const scheduledIds = new Set();
            const addTaskRow = (todo, pages, kind = 'scheduled') => {
              const completedSet = buildTodoCompletedSet(todo);
              const assignedRaw = Array.isArray(pages) ? pages : [];
              const assigned = assignedRaw.map(homeNormalizePage).filter(Number.isFinite);
              const assignedTotal = assigned.length;
              const pendingPages = assigned.filter(p => !completedSet.has(p));
              const assignedRemaining = pendingPages.length;
              const fallbackRemain = Array.isArray(todo.pages)
                ? Math.max(0, (todo.pages.length - (todo.completedPages?.length || 0)))
                : 0;
              const remainCount = assignedTotal ? assignedRemaining : fallbackRemain;
              remainingPages += remainCount;
              // 各TODOのperPage(分/ページ)を使用して推定時間を計算
              const perPage = Math.max(1, parseInt(todo.perPage, 10) || 5);
              remainingMinutes += remainCount * perPage;
              // 今日セッション用にデータを保存
              if (remainCount > 0 && !todo.done) {
                todaySessionTodos.push({ todo, pendingPages: assignedTotal ? pendingPages : null, pages: assigned });
              }
              const done = todo.done || remainCount === 0;
              const bookLabel = todo.bookTitle ? ` / ${safe(todo.bookTitle)}` : '';
              const ratio = assignedTotal ? `${assignedRemaining}/${assignedTotal}` : `${remainCount}`;
              // 推定時間を表示（1ページあたりの目安 × 残りページ数）
              const taskMinutes = remainCount * perPage;
              const taskTimeLabel = taskMinutes >= 60
                ? `${Math.floor(taskMinutes / 60)}h${taskMinutes % 60 > 0 ? (taskMinutes % 60) + 'm' : ''}`
                : `${taskMinutes}m`;
              taskHtml += `<div class="home-task-item${done ? ' done' : ''}" data-todo="${todo.id}" data-kind="${kind}" title="推定${taskMinutes}分 (${perPage}分/P × ${remainCount}P)">
              <span class="home-task-title">${safe(todo.title || '無題')}${bookLabel}</span>
              <span class="home-task-pages">${ratio}P <span style="opacity:.7;font-size:11px">(${taskTimeLabel})</span></span>
            </div>`;
            };

            for (const [todoId, dateMap] of Object.entries(schedules)) {
              if (dateMap[todayStr]) {
                const todo = todos.find(t => t.id === todoId);
                if (todo) {
                  scheduledIds.add(todoId);
                  addTaskRow(todo, dateMap[todayStr]);
                }
              }
            }

            if (!taskHtml) taskHtml = '<div class="home-empty">今日の予定はありません</div>';
            todayTasks.innerHTML = taskHtml;

            // タスクをクリックすると直接本のビューアを開いてセッション開始
            todayTasks.querySelectorAll('.home-task-item').forEach(item => {
              item.onclick = async () => {
                const todoId = item.dataset.todo;
                // 対応するTODOを取得
                const sessionData = todaySessionTodos.find(s => s.todo.id === todoId);
                if (!sessionData) {
                  showToast && showToast('タスクが見つかりません', 'warn');
                  return;
                }
                const todo = sessionData.todo;
                const pendingPages = sessionData.pendingPages;

                // 本が紐付けられている場合は直接ビューアを開く
                if (todo.bookId) {
                  try {
                    const book = await Book.get(todo.bookId);
                    if (book) {
                      // 最初の未完了ページを開く（またはページリストの最初）
                      let targetPage = 1;
                      if (pendingPages && pendingPages.length > 0) {
                        targetPage = pendingPages[0];
                      } else if (Array.isArray(todo.pages) && todo.pages.length > 0) {
                        targetPage = todo.pages[0];
                      }
                      showTab('library');
                      mountBookViewer(book, { startPage: Math.max(0, targetPage - 1) });
                      showToast && showToast(`${todo.title || '無題'} - P.${targetPage}を開始`, 'ok');
                      return;
                    }
                  } catch (e) {
                    console.warn('[Home] Failed to open book', e);
                  }
                }
                // 本がない場合はプランナーの今日タブを開く
                showTab('planner');
                setTimeout(() => {
                  try { __activatePlannerTab?.('today'); } catch (_) { }
                }, 100);
              };
            });
            if (!Object.keys(schedules).length && !todos.length) forcedRetry = true;
          }
        }
        // 今日セッション用のデータをグローバルに保存
        window.__todaySessionData = { todos: todaySessionTodos, date: todayStr };

        // Stats
        const statCompletedEl = document.getElementById('homeStatCompleted');
        const statRemainEl = document.getElementById('homeStatRemaining');
        const statMinutesEl = document.getElementById('homeStatMinutes');
        const completedArr = Array.isArray(todayCompleted) ? todayCompleted : [];
        if (statCompletedEl) statCompletedEl.textContent = completedArr.length;
        if (statRemainEl) statRemainEl.textContent = remainingPages;
        // 時間表示を改善：60分以上は「X時間Y分」形式
        if (statMinutesEl) {
          const mins = Math.max(0, Math.round(remainingMinutes));
          if (mins >= 60) {
            const h = Math.floor(mins / 60);
            const m = mins % 60;
            statMinutesEl.innerHTML = `<span style="font-size:inherit">${h}</span><span style="font-size:0.65em;opacity:.8">時間</span>${m > 0 ? `<span style="font-size:inherit">${m}</span><span style="font-size:0.65em;opacity:.8">分</span>` : ''}`;
          } else {
            statMinutesEl.textContent = mins;
          }
        }

        // Recent books
        const recentBooks = document.getElementById('homeRecentBooks');
        if (recentBooks) {
          const sorted = [...books].sort((a, b) => (b.lastOpened || 0) - (a.lastOpened || 0)).slice(0, 5);
          let booksHtml = '';
          for (const book of sorted) {
            booksHtml += `<div class="home-book-item" data-book="${book.id}">
            <span class="home-book-title">${safe(book.title || '無題')}</span>
          </div>`;
          }
          if (!booksHtml) booksHtml = '<div class="home-empty">最近使った本がありません</div>';
          recentBooks.innerHTML = booksHtml;

          // Click to open book
          recentBooks.querySelectorAll('.home-book-item').forEach(item => {
            item.onclick = async () => {
              const bookId = item.dataset.book;
              const book = await Book.get(bookId);
              if (book) {
                showTab('library');
                mountBookViewer(book);
              }
            };
          });
          if (!books.length) forcedRetry = true;
        }

        const removeCompletedFallback = (dateStr, bookId, page, ts) => {
          if (!dateStr) return false;
          try {
            const raw = localStorage.getItem('sc-completed');
            if (!raw) return false;
            const parsed = JSON.parse(raw);
            const list = Array.isArray(parsed?.[dateStr]) ? parsed[dateStr] : null;
            if (!list || !list.length) return false;
            const parseNum = (v) => {
              const n = typeof v === 'string' ? parseInt(v, 10) : Number(v);
              return Number.isFinite(n) ? n : null;
            };
            const pageNum = parseNum(page);
            const tsNum = Number(ts);
            const hasTs = Number.isFinite(tsNum);
            let removed = false;
            const nextList = list.filter((rec) => {
              if (removed) return true;
              const sameBook = bookId ? String(rec?.bookId || '') === String(bookId || '') : true;
              const recPage = parseNum(rec?.page);
              const matchPage = pageNum === null
                ? true
                : (recPage !== null && recPage === pageNum) || String(rec?.page || '') === String(page || '');
              const matchTs = hasTs && Number(rec?.timestamp) === tsNum;
              if (matchTs || (sameBook && matchPage)) {
                removed = true;
                return false;
              }
              return true;
            });
            if (!removed && hasTs) {
              const idx = nextList.findIndex(rec => Number(rec?.timestamp) === tsNum);
              if (idx >= 0) {
                nextList.splice(idx, 1);
                removed = true;
              }
            }
            if (!removed && nextList.length && String(bookId || '')) {
              const idx = nextList.findIndex(rec => String(rec?.bookId || '') === String(bookId));
              if (idx >= 0) {
                nextList.splice(idx, 1);
                removed = true;
              }
            }
            if (nextList.length === 0) delete parsed[dateStr]; else parsed[dateStr] = nextList;
            if (removed) localStorage.setItem('sc-completed', JSON.stringify(parsed));
            return removed;
          } catch (err) {
            console.warn('[Home] Failed to remove completed record (fallback)', err);
            return false;
          }
        };

        // Completed pages (selected date)
        const completedList = document.getElementById('homeTodayCompleted');
        if (completedList) {
          const completed = Array.isArray(selectedCompleted) ? [...selectedCompleted] : [];
          let html = '';
          completed.sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0)).forEach(rec => {
            const bookTitle = bookMap.get(rec.bookId)?.title || rec.title || '本';
            const parsedPage = parseInt(rec.page, 10);
            const pageNum = Number.isFinite(rec.page) ? rec.page : (Number.isFinite(parsedPage) ? parsedPage : null);
            const pageLabel = Number.isFinite(pageNum) ? pageNum : '?';
            const ts = Number.isFinite(rec.timestamp) ? rec.timestamp : (Number(rec.timestamp) || '');
            html += `<div class="home-completed-item" data-book="${rec.bookId || ''}" data-page="${pageLabel}" data-date="${completedDateStr}" data-ts="${ts}">
              <div class="home-completed-main">
                <span class="home-completed-title">${safe(bookTitle)}</span>
                <span class="home-completed-pages">P.${pageLabel}</span>
              </div>
              <div class="home-completed-actions">
                <button class="btn ghost small" data-completed-action="delete">削除</button>
              </div>
            </div>`;
          });
          if (!html) {
            html = completedDateStr === todayStr
              ? '<div class="home-empty">今日の完了記録はまだありません</div>'
              : '<div class="home-empty">この日の完了記録はまだありません</div>';
          }
          completedList.innerHTML = html;
          completedList.onclick = (e) => {
            const targetItem = e.target.closest('.home-completed-item');
            if (!targetItem) return;
            const page = parseInt(targetItem.dataset.page, 10);
            const date = targetItem.dataset.date;
            const bookId = targetItem.dataset.book;
            const ts = parseInt(targetItem.dataset.ts, 10);
            if (e.target.closest('[data-completed-action="delete"]')) {
              e.stopPropagation();
              const safePage = Number.isFinite(page) ? page : null;
              let removed = false;
              if (window.StudyCalendar?.removeCompletedForDate) {
                removed = StudyCalendar.removeCompletedForDate(date, bookId, safePage, ts);
              }
              if (!removed) removed = removeCompletedFallback(date, bookId, safePage, ts);
              if (removed) {
                showToast && showToast('完了ページを削除しました', 'ok');
                renderHomeView(true);
                return;
              }
              showToast && showToast('削除に失敗しました', 'error');
              return;
            }
            openCompletedViewer(null, {
              date,
              page,
              bookId,
              focusTs: Number.isFinite(ts) ? ts : null,
              focusDate: date,
              dateList: [completedDateStr],
              rangeLabel: completedDateStr,
              rangeKey: completedDateStr,
              rangeMode: 'day'
            });
          };
          if (!completedArr.length) forcedRetry = true;
        }

        // Review mode: completed pages range
        const reviewList = document.getElementById('homeReviewList');
        const reviewSummary = document.getElementById('homeReviewSummary');
        const reviewRangeModeEl = document.getElementById('homeReviewRangeMode');
        const reviewAnchorEl = document.getElementById('homeReviewAnchor');
        const reviewRangeWrap = document.getElementById('homeReviewRangeWrap');
        const reviewStartEl = document.getElementById('homeReviewStart');
        const reviewEndEl = document.getElementById('homeReviewEnd');
        const reviewRecentWrap = document.getElementById('homeReviewRecentWrap');
        const reviewRecentEl = document.getElementById('homeReviewRecentDays');
        const reviewBookFilterEl = document.getElementById('homeReviewBookFilter');
        const reviewSortEl = document.getElementById('homeReviewSort');
        const reviewKindEl = document.getElementById('homeReviewKind');
        const reviewSearchEl = document.getElementById('homeReviewSearch');
        const reviewPageFilterEl = document.getElementById('homeReviewPageFilter');
        const reviewCompleteDateEl = document.getElementById('homeReviewCompleteDate');
        const reviewPageBookEl = document.getElementById('homeReviewPageBook');
        const reviewPagePanelEl = document.getElementById('homeReviewPagePanel');
        const reviewPageToggleEl = document.getElementById('homeReviewPageToggle');
        const reviewPageMetaEl = document.getElementById('homeReviewPageMeta');
        const reviewPageGridEl = document.getElementById('homeReviewPageGrid');
        if (reviewList && reviewSummary) {
          const getWeekStart = () => {
            try {
              const raw = localStorage.getItem('sc-settings');
              if (!raw) return 1;
              const parsed = JSON.parse(raw);
              const ws = Number(parsed?.weekStart ?? 1);
              return Number.isFinite(ws) ? ws : 1;
            } catch (_) { return 1; }
          };
          const allCompletedMap = (() => {
            const snap = window.StudyCalendar?.getCompletedSnapshot?.();
            if (snap && Object.keys(snap).length) return snap;
            try {
              const raw = localStorage.getItem('sc-completed');
              if (!raw) return {};
              const parsed = JSON.parse(raw);
              return parsed && typeof parsed === 'object' ? parsed : {};
            } catch (_) { return {}; }
          })();
          const hiddenAnswerIds = collectHiddenAnswerIds(books);
          const clampDateObj = (d) => {
            const today = homeParseDate(todayStr);
            if (!(d instanceof Date) || isNaN(d)) return today;
            return d > today ? today : d;
          };

          if (!homeReviewState.anchor) homeReviewState.anchor = todayStr;
          homeReviewState.anchor = homeClampToToday(homeReviewState.anchor);
          if (!homeReviewState.start) homeReviewState.start = homeReviewState.anchor;
          if (!homeReviewState.end) homeReviewState.end = homeReviewState.anchor;
          if (!homeReviewState.recentDays) homeReviewState.recentDays = 7;
          if (!homeReviewState.rangeMode) homeReviewState.rangeMode = 'all';
          if (!homeReviewState.sort) homeReviewState.sort = 'newest';
          if (!homeReviewState.kind) homeReviewState.kind = 'completed';
          if (homeReviewState.search == null) homeReviewState.search = '';
          if (homeReviewState.pageFilter == null) homeReviewState.pageFilter = '';
          if (homeReviewState.pageMapBookId == null) homeReviewState.pageMapBookId = '';
          if (homeReviewState.pageMapOpen == null) homeReviewState.pageMapOpen = false;
          if (!homeReviewState.completeDate) homeReviewState.completeDate = todayStr;
          homeReviewState.completeDate = homeClampToToday(homeReviewState.completeDate);

          if (reviewRangeModeEl) reviewRangeModeEl.value = homeReviewState.rangeMode;
          if (reviewAnchorEl) { reviewAnchorEl.value = homeReviewState.anchor; reviewAnchorEl.max = todayStr; }
          if (reviewStartEl) { reviewStartEl.value = homeReviewState.start; reviewStartEl.max = todayStr; }
          if (reviewEndEl) { reviewEndEl.value = homeReviewState.end; reviewEndEl.max = todayStr; }
          if (reviewRecentEl) reviewRecentEl.value = String(homeReviewState.recentDays);
          if (reviewSortEl) reviewSortEl.value = homeReviewState.sort;
          if (reviewKindEl) reviewKindEl.value = homeReviewState.kind;
          if (reviewSearchEl) reviewSearchEl.value = homeReviewState.search || '';
          if (reviewPageFilterEl) reviewPageFilterEl.value = homeReviewState.pageFilter || '';

          if (reviewRangeWrap) reviewRangeWrap.style.display = homeReviewState.rangeMode === 'range' ? 'inline-flex' : 'none';
          if (reviewRecentWrap) reviewRecentWrap.style.display = homeReviewState.rangeMode === 'recent' ? 'inline-flex' : 'none';

          const useMiss = homeReviewState.kind === 'miss';
          let missDateMap = null;
          if (useMiss) {
            missDateMap = new Map();
            const allMiss = MissStore.listMarksForBooks(books);
            allMiss.forEach(mark => {
              const dateKey = homeFormatDate(new Date(mark.createdAt));
              if (!dateKey) return;
              const list = missDateMap.get(dateKey) || [];
              list.push(mark);
              missDateMap.set(dateKey, list);
            });
          }

          const anchorDate = clampDateObj(homeParseDate(homeReviewState.anchor));
          let rangeStart = new Date(anchorDate);
          let rangeEnd = new Date(anchorDate);
          let rangeDates = [];
          if (homeReviewState.rangeMode === 'all') {
            rangeDates = useMiss
              ? Array.from(missDateMap?.keys?.() || []).sort()
              : Object.keys(allCompletedMap || {}).sort();
            if (rangeDates.length) {
              rangeStart = homeParseDate(rangeDates[0]);
              rangeEnd = homeParseDate(rangeDates[rangeDates.length - 1]);
            } else {
              rangeStart = new Date(anchorDate);
              rangeEnd = new Date(anchorDate);
              rangeDates = [homeFormatDate(rangeStart)];
            }
          } else {
            if (homeReviewState.rangeMode === 'week') {
              const ws = getWeekStart();
              const dayOfWeek = (anchorDate.getDay() - ws + 7) % 7;
              rangeStart = new Date(anchorDate);
              rangeStart.setDate(anchorDate.getDate() - dayOfWeek);
              rangeEnd = new Date(rangeStart);
              rangeEnd.setDate(rangeStart.getDate() + 6);
            } else if (homeReviewState.rangeMode === 'month') {
              rangeStart = new Date(anchorDate.getFullYear(), anchorDate.getMonth(), 1);
              rangeEnd = new Date(anchorDate.getFullYear(), anchorDate.getMonth() + 1, 0);
            } else if (homeReviewState.rangeMode === 'range') {
              const s = clampDateObj(homeParseDate(homeReviewState.start));
              const e = clampDateObj(homeParseDate(homeReviewState.end));
              rangeStart = s <= e ? s : e;
              rangeEnd = s <= e ? e : s;
            } else if (homeReviewState.rangeMode === 'recent') {
              const days = Math.max(1, parseInt(homeReviewState.recentDays, 10) || 7);
              rangeEnd = clampDateObj(homeParseDate(todayStr));
              rangeStart = new Date(rangeEnd);
              rangeStart.setDate(rangeEnd.getDate() - (days - 1));
            } else {
              rangeStart = new Date(anchorDate);
              rangeEnd = new Date(anchorDate);
            }
            rangeEnd = clampDateObj(rangeEnd);
            const walk = new Date(rangeStart);
            while (walk <= rangeEnd) {
              rangeDates.push(homeFormatDate(walk));
              walk.setDate(walk.getDate() + 1);
            }
          }
          const rangeStartStr = homeFormatDate(rangeStart);
          const rangeEndStr = homeFormatDate(rangeEnd);
          if (homeReviewState.rangeMode !== 'all') {
            const withinRange = homeReviewState.completeDate >= rangeStartStr && homeReviewState.completeDate <= rangeEndStr;
            if (!withinRange) {
              homeReviewState.completeDate = rangeEndStr;
            }
          }
          if (reviewCompleteDateEl) {
            reviewCompleteDateEl.value = homeReviewState.completeDate;
            reviewCompleteDateEl.max = todayStr;
          }
          if (reviewPagePanelEl) {
            reviewPagePanelEl.classList.toggle('collapsed', !homeReviewState.pageMapOpen);
          }
          if (reviewPageToggleEl) {
            reviewPageToggleEl.textContent = homeReviewState.pageMapOpen ? '折りたたみ' : '開く';
          }
          const dir = homeReviewState.sort === 'newest' ? -1 : 1;
          const orderedDates = rangeDates.slice().sort((a, b) => a.localeCompare(b) * dir);
          const hasUnknown = !useMiss && orderedDates.some(dateStr => (allCompletedMap?.[dateStr] || []).some(r => !r?.bookId));
          const sortedBooks = [...books]
            .filter(book => !hiddenAnswerIds.has(book.id))
            .sort((a, b) => (a.title || '').localeCompare(b.title || ''));
          if (!homeReviewState.pageMapBookId && homeReviewState.bookId && homeReviewState.bookId !== '__unknown') {
            homeReviewState.pageMapBookId = homeReviewState.bookId;
          }
          if (reviewBookFilterEl) {
            const selected = homeReviewState.bookId || '';
            let options = '<option value="">すべて</option>';
            if (hasUnknown) options += '<option value="__unknown">不明</option>';
            sortedBooks.forEach(book => {
              options += `<option value="${book.id}">${safe(book.title || '無題')}</option>`;
            });
            reviewBookFilterEl.innerHTML = options;
            const validSelected = selected === '__unknown' || sortedBooks.some(book => String(book.id) === String(selected));
            reviewBookFilterEl.value = validSelected ? selected : '';
            if (!validSelected) {
              homeReviewState.bookId = '';
            }
          }
          if (reviewPageBookEl) {
            const selected = homeReviewState.pageMapBookId || '';
            let options = '<option value="">本を選択</option>';
            sortedBooks.forEach(book => {
              options += `<option value="${book.id}">${safe(book.title || '無題')}</option>`;
            });
            reviewPageBookEl.innerHTML = options;
            const validSelected = sortedBooks.some(book => String(book.id) === String(selected));
            reviewPageBookEl.value = validSelected ? selected : '';
            if (!validSelected) {
              homeReviewState.pageMapBookId = '';
            }
          }

          const searchRaw = String(homeReviewState.search || '').trim();
          const searchPages = homeParsePageList(searchRaw);
          const searchSet = searchPages.length ? new Set(searchPages) : null;
          const searchText = searchSet ? '' : searchRaw.toLowerCase();
          const matchesSearch = (bookTitle, pageNum, extraText = '') => {
            if (searchSet) return Number.isFinite(pageNum) ? searchSet.has(pageNum) : false;
            if (!searchText) return true;
            const hay = `${bookTitle || ''} ${Number.isFinite(pageNum) ? pageNum : ''} ${extraText || ''}`.toLowerCase();
            return hay.includes(searchText);
          };

          const pageBookId = homeReviewState.pageMapBookId
            || ((homeReviewState.bookId && homeReviewState.bookId !== '__unknown') ? homeReviewState.bookId : '');
          const rangeCompletedSet = new Set();
          if (pageBookId && !useMiss) {
            rangeDates.forEach(dateStr => {
              const list = Array.isArray(allCompletedMap?.[dateStr]) ? allCompletedMap[dateStr] : [];
              list.forEach(rec => {
                if (String(rec?.bookId || '') !== String(pageBookId)) return;
                const pageNum = homeParsePageNumber(rec?.page);
                if (Number.isFinite(pageNum)) rangeCompletedSet.add(pageNum);
              });
            });
          }

          let totalCount = 0;
          const bookSet = new Set();
          let html = '';
          if (useMiss) {
            orderedDates.forEach(dateStr => {
              let list = (missDateMap && missDateMap.get(dateStr)) ? [...missDateMap.get(dateStr)] : [];
              if (homeReviewState.bookId) {
                list = list.filter(mark => String(mark.bookId || '') === String(homeReviewState.bookId));
              }
              if (!list.length) return;
              const dayObj = homeParseDate(dateStr);
              const dayLabel = !isNaN(dayObj)
                ? `${dayObj.getMonth() + 1}/${dayObj.getDate()}（${['日', '月', '火', '水', '木', '金', '土'][dayObj.getDay()]}）`
                : dateStr;
              let dayHtml = '';
              list.sort((a, b) => dir * ((Number(a?.createdAt) || 0) - (Number(b?.createdAt) || 0))).forEach(mark => {
                const bookTitle = bookMap.get(mark.bookId)?.title || mark.bookTitle || '本';
                const pageLabel = Number.isFinite(mark.realPage) ? mark.realPage : '?';
                const typeInfo = MISS_TYPE_MAP[mark.type] || MISS_TYPE_MAP.important;
                const nameLabel = mark.name || typeInfo.label;
                const reason = mark.reason ? safe(mark.reason) : '';
                const created = Number(mark.createdAt) || 0;
                const createdDate = created ? new Date(created) : null;
                const timeLabel = createdDate && !isNaN(createdDate)
                  ? `${String(createdDate.getHours()).padStart(2, '0')}:${String(createdDate.getMinutes()).padStart(2, '0')}`
                  : '';
                if (!matchesSearch(bookTitle, Number.isFinite(mark.realPage) ? mark.realPage : null, `${nameLabel} ${mark.reason || ''}`)) return;
                totalCount++;
                if (mark.bookId) bookSet.add(String(mark.bookId));
                dayHtml += `<div class="home-completed-item home-miss-item" data-book="${mark.bookId || ''}" data-page-index="${mark.pageIndex}" data-miss-id="${mark.id}" data-x="${mark.x}" data-y="${mark.y}">
                  <div class="home-completed-main">
                    <span class="home-completed-title">${safe(bookTitle)} / ${safe(nameLabel)}</span>
                    <span class="home-completed-pages">P.${pageLabel}</span>
                    ${reason ? `<div class="muted" style="font-size:11px;opacity:.85">${reason}</div>` : ''}
                  </div>
                  <div class="home-completed-actions" style="gap:6px;align-items:center;">
                    <span class="pill" style="background:${typeInfo.color};color:#fff;border:none;">${typeInfo.short}</span>
                    <span class="muted" style="font-size:11px;">確認${mark.checks || 0}${timeLabel ? `・${timeLabel}` : ''}</span>
                  </div>
                </div>`;
              });
              if (dayHtml) {
                html += `<div class="home-review-date">${dayLabel}</div>`;
                html += dayHtml;
              }
            });
            if (!html) html = '<div class="home-empty">該当するミスがありません</div>';
          } else {
            orderedDates.forEach(dateStr => {
              let list = Array.isArray(allCompletedMap?.[dateStr]) ? [...allCompletedMap[dateStr]] : [];
              if (homeReviewState.bookId) {
                if (homeReviewState.bookId === '__unknown') {
                  list = list.filter(rec => !rec?.bookId);
                } else {
                  list = list.filter(rec => String(rec?.bookId || '') === String(homeReviewState.bookId));
                }
              }
              if (!list.length) return;
              const dayObj = homeParseDate(dateStr);
              const dayLabel = !isNaN(dayObj)
                ? `${dayObj.getMonth() + 1}/${dayObj.getDate()}（${['日', '月', '火', '水', '木', '金', '土'][dayObj.getDay()]}）`
                : dateStr;
              let dayHtml = '';
              list.sort((a, b) => {
                const at = Number(a?.timestamp) || 0;
                const bt = Number(b?.timestamp) || 0;
                return dir * (at - bt);
              }).forEach(rec => {
                const bookTitle = bookMap.get(rec.bookId)?.title || rec.title || '本';
                const parsedPage = parseInt(rec.page, 10);
                const pageNum = Number.isFinite(rec.page) ? rec.page : (Number.isFinite(parsedPage) ? parsedPage : null);
                const pageLabel = Number.isFinite(pageNum) ? pageNum : '?';
                const ts = Number.isFinite(rec.timestamp) ? rec.timestamp : (Number(rec.timestamp) || '');
                if (!matchesSearch(bookTitle, Number.isFinite(pageNum) ? pageNum : null)) return;
                totalCount++;
                if (rec.bookId) bookSet.add(String(rec.bookId));
                dayHtml += `<div class="home-completed-item" data-book="${rec.bookId || ''}" data-page="${pageLabel}" data-date="${dateStr}" data-ts="${ts}">
                  <div class="home-completed-main">
                    <span class="home-completed-title">${safe(bookTitle)}</span>
                    <span class="home-completed-pages">P.${pageLabel}</span>
                  </div>
                  <div class="home-completed-actions">
                    <button class="btn ghost small" data-completed-action="delete">削除</button>
                  </div>
                </div>`;
              });
              if (dayHtml) {
                html += `<div class="home-review-date">${dayLabel}</div>`;
                html += dayHtml;
              }
            });
            if (!html) html = '<div class="home-empty">該当する完了記録がありません</div>';
          }
          reviewList.innerHTML = html;
          const rangeLabel = homeReviewState.rangeMode === 'all'
            ? '全期間'
            : `${homeFormatDate(rangeStart)}〜${homeFormatDate(rangeEnd)}`;
          const rangeKey = homeReviewState.rangeMode === 'all'
            ? 'all'
            : `${homeFormatDate(rangeStart)}_${homeFormatDate(rangeEnd)}`;
          reviewSummary.innerHTML = `
            <div class="home-review-stat">期間 ${rangeLabel}</div>
            <div class="home-review-stat">${useMiss ? 'ミス' : '完了'} ${totalCount}件</div>
            <div class="home-review-stat">本 ${bookSet.size}冊</div>
          `;
          if (reviewPageGridEl && reviewPageMetaEl) {
            if (useMiss) {
              reviewPageMetaEl.textContent = '完了ページモードで表示します';
              reviewPageGridEl.innerHTML = '<div class="home-empty">完了ページモードで利用できます</div>';
              reviewPageGridEl.onclick = null;
            } else if (!pageBookId) {
              reviewPageMetaEl.textContent = '本を選択するとページマップが表示されます';
              reviewPageGridEl.innerHTML = '<div class="home-empty">本を選択してください</div>';
              reviewPageGridEl.onclick = null;
            } else {
              const pageBook = bookMap.get(pageBookId);
              if (!pageBook || !Array.isArray(pageBook.pages) || !pageBook.pages.length) {
                reviewPageMetaEl.textContent = 'ページ情報がありません';
                reviewPageGridEl.innerHTML = '<div class="home-empty">ページ情報がありません</div>';
                reviewPageGridEl.onclick = null;
              } else {
                const filterPages = homeParsePageList(homeReviewState.pageFilter || '');
                const filterSet = filterPages.length ? new Set(filterPages) : null;
                let shown = 0;
                let gridHtml = '';
                for (let i = 0; i < pageBook.pages.length; i++) {
                  const pageNum = homeRealPageOf(pageBook, i);
                  const label = Number.isFinite(pageNum) ? pageNum : i + 1;
                  if (filterSet && !filterSet.has(label)) continue;
                  const done = rangeCompletedSet.has(label);
                  gridHtml += `<button class="home-review-page-btn${done ? ' completed-range' : ''}" data-page="${label}">${label}</button>`;
                  shown++;
                }
                if (!gridHtml) {
                  gridHtml = '<div class="home-empty">該当ページがありません</div>';
                }
                reviewPageGridEl.innerHTML = gridHtml;
                reviewPageGridEl.dataset.bookTitle = pageBook.title || '本';
                reviewPageGridEl.dataset.bookId = pageBook.id || '';
                const baseMeta = `${pageBook.title || '本'} / ${pageBook.pages.length}P`;
                const rangeMeta = `範囲 ${rangeLabel}・完了 ${rangeCompletedSet.size}P`;
                const filterMeta = filterSet ? `・表示 ${shown}P` : '';
                reviewPageMetaEl.textContent = `${baseMeta} / ${rangeMeta}${filterMeta}・クリックで完了記録`;
                reviewPageGridEl.onclick = (e) => {
                  const btn = e.target.closest('.home-review-page-btn');
                  if (!btn) return;
                  const page = homeParsePageNumber(btn.dataset.page);
                  if (!Number.isFinite(page)) return;
                  const bookTitle = reviewPageGridEl.dataset.bookTitle || '';
                  const dateStr = homeClampToToday(reviewCompleteDateEl?.value || homeReviewState.completeDate || '');
                  homeReviewState.completeDate = dateStr;
                  try { window.StudyCalendar?.recordCompletion?.(pageBookId, page, bookTitle || '本', dateStr); } catch (_) { }
                  scheduleHomeReviewRefresh();
                };
              }
            }
          }
          reviewList.onclick = (e) => {
            const targetItem = e.target.closest('.home-completed-item');
            if (!targetItem) return;
            if (useMiss) {
              const bookId = targetItem.dataset.book;
              const pageIndex = parseInt(targetItem.dataset.pageIndex, 10);
              const missId = targetItem.dataset.missId;
              const x = parseFloat(targetItem.dataset.x);
              const y = parseFloat(targetItem.dataset.y);
              if (window.__jumpToMissMarker) {
                window.__jumpToMissMarker({ bookId, pageIndex, missId, x, y });
              }
              return;
            }
            const page = parseInt(targetItem.dataset.page, 10);
            const date = targetItem.dataset.date;
            const bookId = targetItem.dataset.book;
            const ts = parseInt(targetItem.dataset.ts, 10);
            if (e.target.closest('[data-completed-action="delete"]')) {
              e.stopPropagation();
              const safePage = Number.isFinite(page) ? page : null;
              let removed = false;
              if (window.StudyCalendar?.removeCompletedForDate) {
                removed = StudyCalendar.removeCompletedForDate(date, bookId, safePage, ts);
              }
              if (!removed) removed = removeCompletedFallback(date, bookId, safePage, ts);
              if (removed) {
                showToast && showToast('完了ページを削除しました', 'ok');
                renderHomeView(true);
                return;
              }
              showToast && showToast('削除に失敗しました', 'error');
              return;
            }
            openCompletedViewer(null, {
              date,
              page,
              bookId,
              focusTs: Number.isFinite(ts) ? ts : null,
              focusDate: date,
              dateList: rangeDates,
              rangeLabel,
              rangeKey,
              rangeMode: homeReviewState.rangeMode,
              bookFilter: homeReviewState.bookId
            });
          };
        }

        // 自動再更新（データが空なら少し後でリトライ）
        if (forcedRetry) {
          setTimeout(() => { renderHomeView(); }, 1200);
        }
      } catch (err) {
        console.error('[Home] render failed', err);
        const msg = '<div class="home-empty">ホーム情報の取得に失敗しました</div>';
        const setMsg = (id) => {
          const el = document.getElementById(id);
          if (el) el.innerHTML = msg;
        };
        setMsg('homeTodayTasks');
        setMsg('homeRecentBooks');
        setMsg('homeTodayCompleted');
      }
    }

    function applyHomePrefs() {
      const home = document.getElementById('homeView');
      if (home) {
        home.classList.remove('home-compact');
        home.style.setProperty('--home-accent', '#7dd3fc');
      }
    }

    // ================================
    // Today Session Tab (今日セッション)
    // ================================
    (function initTodaySession() {
      const fmtLocalDate = (d) => {
        const y = d.getFullYear();
        const m = String(d.getMonth() + 1).padStart(2, '0');
        const day = String(d.getDate()).padStart(2, '0');
        return `${y}-${m}-${day}`;
      };
      const safe = (txt) => (typeof escapeHTML === 'function' ? escapeHTML(txt) : txt);

      // 今日セッションタブの更新
      async function updateTodaySessionTab() {
        const dateEl = document.getElementById('todaySessionDate');
        const remainEl = document.getElementById('todaySessionRemainPages');
        const completedEl = document.getElementById('todaySessionCompletedPages');
        const estTimeEl = document.getElementById('todaySessionEstTime');
        const taskListEl = document.getElementById('todaySessionTaskList');
        const emptyEl = document.getElementById('todaySessionEmpty');

        if (!taskListEl) return;

        const now = new Date();
        const todayStr = fmtLocalDate(now);
        const days = ['日', '月', '火', '水', '木', '金', '土'];
        if (dateEl) dateEl.textContent = `${now.getFullYear()}年${now.getMonth() + 1}月${now.getDate()}日（${days[now.getDay()]}）`;

        // スケジュールとTODOを取得
        const todos = window.TodoStore?.all?.() || [];
        let schedules = {};
        try {
          const raw = localStorage.getItem('sc-schedules');
          if (raw && raw.trim().startsWith('{')) {
            schedules = JSON.parse(raw) || {};
          }
        } catch (e) { schedules = {}; }

        // 完了セットを構築
        const buildCompletedSet = (todo) => {
          const set = new Set();
          if (Array.isArray(todo.completedPages)) {
            todo.completedPages.forEach(p => {
              const n = typeof p === 'number' ? p : parseInt(p, 10);
              if (Number.isFinite(n)) set.add(n);
            });
          }
          return set;
        };

        // 今日のタスクを収集
        const sessionTasks = [];
        let totalRemaining = 0;
        let totalCompleted = 0;
        let totalMinutes = 0;

        for (const [todoId, dateMap] of Object.entries(schedules)) {
          if (dateMap[todayStr]) {
            const todo = todos.find(t => t.id === todoId);
            if (todo && !todo.done) {
              const completedSet = buildCompletedSet(todo);
              const assigned = (Array.isArray(dateMap[todayStr]) ? dateMap[todayStr] : [])
                .map(p => typeof p === 'number' ? p : parseInt(p, 10))
                .filter(Number.isFinite);
              const pending = assigned.filter(p => !completedSet.has(p));
              const completed = assigned.filter(p => completedSet.has(p));
              const perPage = Math.max(1, parseInt(todo.perPage, 10) || 5);

              if (pending.length > 0 || completed.length > 0) {
                sessionTasks.push({
                  todo,
                  assigned,
                  pending,
                  completed,
                  perPage
                });
                totalRemaining += pending.length;
                totalCompleted += completed.length;
                totalMinutes += pending.length * perPage;
              }
            }
          }
        }

        // 統計を更新
        if (remainEl) remainEl.textContent = totalRemaining;
        if (completedEl) completedEl.textContent = totalCompleted;
        if (estTimeEl) {
          if (totalMinutes >= 60) {
            const h = Math.floor(totalMinutes / 60);
            const m = totalMinutes % 60;
            estTimeEl.innerHTML = `${h}<span style="font-size:0.6em">h</span>${m > 0 ? m + '<span style="font-size:0.6em">m</span>' : ''}`;
          } else {
            estTimeEl.innerHTML = `${totalMinutes}<span style="font-size:0.6em">m</span>`;
          }
        }

        // タスク一覧を描画
        if (sessionTasks.length === 0) {
          taskListEl.innerHTML = '';
          if (emptyEl) emptyEl.style.display = 'block';
        } else {
          if (emptyEl) emptyEl.style.display = 'none';
          let html = '';
          for (const task of sessionTasks) {
            const { todo, pending, assigned, perPage } = task;
            const done = pending.length === 0;
            const bookLabel = todo.bookTitle ? ` / ${safe(todo.bookTitle)}` : '';
            const taskMins = pending.length * perPage;
            const timeLabel = taskMins >= 60
              ? `${Math.floor(taskMins / 60)}h${taskMins % 60 > 0 ? (taskMins % 60) + 'm' : ''}`
              : `${taskMins}m`;
            html += `<div class="home-task-item${done ? ' done' : ''}" data-todo="${todo.id}" data-bookid="${todo.bookId || ''}" style="cursor:pointer" title="クリックで本を開く">
              <span class="home-task-title">${safe(todo.title || '無題')}${bookLabel}</span>
              <span class="home-task-pages">${pending.length}/${assigned.length}P <span style="opacity:.7;font-size:11px">(${timeLabel})</span></span>
            </div>`;
          }
          taskListEl.innerHTML = html;

          // タスククリックで本を開く
          taskListEl.querySelectorAll('.home-task-item').forEach(item => {
            item.onclick = async () => {
              const todoId = item.dataset.todo;
              const bookId = item.dataset.bookid;
              if (bookId) {
                const book = await Book.get(bookId);
                if (book) {
                  // 最初の未完了ページを開く
                  const task = sessionTasks.find(t => t.todo.id === todoId);
                  const targetPage = task?.pending?.[0] || 1;
                  showTab('library');
                  mountBookViewer(book, { startPage: targetPage - 1 });
                }
              }
            };
          });
        }

        // グローバルデータを更新
        window.__todaySessionData = { tasks: sessionTasks, date: todayStr };
      }

      // セッション開始：今日の未完了ページを順番にこなす
      async function startTodaySession(specificTodoId = null) {
        const data = window.__todaySessionData;
        if (!data || !data.tasks || data.tasks.length === 0) {
          showToast && showToast('今日の予定がありません', 'warn');
          return;
        }

        let targetTask = null;
        let targetPage = null;

        if (specificTodoId) {
          targetTask = data.tasks.find(t => t.todo.id === specificTodoId);
        }
        if (!targetTask) {
          // 最初の未完了タスクを選択
          targetTask = data.tasks.find(t => t.pending.length > 0);
        }

        if (!targetTask || targetTask.pending.length === 0) {
          showToast && showToast('今日の予定はすべて完了しています！', 'ok');
          return;
        }

        targetPage = targetTask.pending[0];
        const bookId = targetTask.todo.bookId;

        if (!bookId) {
          showToast && showToast('本が紐付けられていません', 'warn');
          return;
        }

        const book = await Book.get(bookId);
        if (!book) {
          showToast && showToast('本が見つかりません', 'error');
          return;
        }

        showTab('library');
        mountBookViewer(book, { startPage: Math.max(0, targetPage - 1) });
        showToast && showToast(`${targetTask.todo.title || '無題'} - P.${targetPage}を開始`, 'ok');
      }

      // グローバルに公開
      window.__startTodaySession = startTodaySession;
      window.__updateTodaySessionTab = updateTodaySessionTab;

      // 今日タブのイベントリスナー
      document.addEventListener('DOMContentLoaded', () => {
        const startBtn = document.getElementById('todaySessionStartBtn');
        const refreshBtn = document.getElementById('todaySessionRefreshBtn');

        if (startBtn) {
          startBtn.onclick = () => startTodaySession();
        }
        if (refreshBtn) {
          refreshBtn.onclick = () => {
            updateTodaySessionTab();
            showToast && showToast('更新しました', 'ok');
          };
        }
      });

      // タブ切り替え時に更新
      const origActivate = window.__activatePlannerTab;
      window.__activatePlannerTab = function (tabId) {
        if (typeof origActivate === 'function') {
          origActivate(tabId);
        }
        if (tabId === 'today') {
          setTimeout(() => updateTodaySessionTab(), 50);
        }
      };
    })();


    function teardownCompletedKeyHandler() {
      if (window.__completedKeyHandler) {
        document.removeEventListener('keydown', window.__completedKeyHandler);
        window.__completedKeyHandler = null;
      }
    }

    async function openCompletedViewer(bookId, opts = {}) {
      const dateStr = opts.date || new Date().toISOString().slice(0, 10);
      const pageHint = Number.isFinite(parseInt(opts.page, 10)) ? parseInt(opts.page, 10) : null;
      const bookHint = opts.bookId || bookId || null;
      const focusTs = Number.isFinite(parseInt(opts.focusTs, 10)) ? parseInt(opts.focusTs, 10) : null;
      const focusDate = opts.focusDate ? String(opts.focusDate) : null;
      const dateList = Array.isArray(opts.dateList) ? opts.dateList.filter(Boolean).map(String) : null;
      const bookFilter = (opts.bookFilter != null && opts.bookFilter !== '') ? String(opts.bookFilter) : '';
      const dates = (dateList && dateList.length) ? Array.from(new Set(dateList)) : [String(dateStr)];
      const sortedDates = dates.slice().sort();
      const rangeStart = sortedDates[0] || String(dateStr);
      const rangeEnd = sortedDates[sortedDates.length - 1] || rangeStart;
      const rangeMode = opts.rangeMode || '';
      const rangeLabel = opts.rangeLabel
        || (rangeMode === 'all' ? '全期間' : (sortedDates.length > 1 ? `${rangeStart}〜${rangeEnd}` : rangeStart));
      const rangeKey = opts.rangeKey
        || (rangeMode === 'all' ? 'all' : (sortedDates.length > 1 ? `${rangeStart}_${rangeEnd}` : rangeStart));
      const completedAll = [];
      sortedDates.forEach(d => {
        const list = (window.StudyCalendar?.getCompletedForDate?.(d) || []).filter(r => r && r.bookId);
        list.forEach(rec => { completedAll.push(Object.assign({ _date: d }, rec)); });
      });
      let filteredAll = completedAll;
      if (bookFilter) {
        if (bookFilter === '__unknown') {
          filteredAll = completedAll.filter(r => !r?.bookId);
        } else {
          filteredAll = completedAll.filter(r => String(r.bookId || '') === String(bookFilter));
        }
      }
      if (!filteredAll.length) { showToast && showToast('指定範囲の完了ページがありません', 'warn'); return; }
      const sorted = [...filteredAll].sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
      const uniqBookIds = [...new Set(sorted.map(r => r.bookId).filter(Boolean))];
      const bookMap = new Map();
      for (const id of uniqBookIds) {
        const b = await Book.get(id);
        if (b && Array.isArray(b.pages) && b.pages.length) bookMap.set(id, b);
      }
      const pages = [];
      const answerLinkMap = {};
      const idxFromRealPage = (base, realPage) => {
        if (!base || !Array.isArray(base.pages) || !base.pages.length) return 0;
        if (Array.isArray(base.pageNumberMap)) {
          const found = base.pageNumberMap.indexOf(realPage);
          if (found >= 0) return found;
        }
        const startNumber = Number.isFinite(base.firstPageNumber) ? base.firstPageNumber : parseInt(base.firstPageNumber || '1', 10) || 1;
        return Math.max(0, Math.min(base.pages.length - 1, realPage - startNumber));
      };
      for (const rec of sorted) {
        const base = bookMap.get(rec.bookId);
        if (!base) continue;
        const startNumber = Number.isFinite(base.firstPageNumber) ? base.firstPageNumber : parseInt(base.firstPageNumber || '1', 10) || 1;
        const realPage = Number.isFinite(rec.page) ? rec.page : startNumber;
        const idx = idxFromRealPage(base, realPage);
        const url = await ensurePageData(base, idx);
        const answers = Array.isArray(base.answerBookIds) ? base.answerBookIds.filter(id => id && id !== base.id) : [];
        if (answers.length) answerLinkMap[realPage] = answers;
        pages.push({
          id: `${rec.bookId}|${rec._date || rangeStart}|${realPage}|${idx}|${rec.timestamp || 0}`,
          dataUrl: url || '',
          state: { fav: false, weak: false, done: true, extra: [] },
          memo: '',
          _sourceTitle: base.title || '本',
          _sourceBookId: rec.bookId,
          _sourcePage: realPage,
          _sourcePageIndex: idx,
          _sourceDate: rec._date || rangeStart,
          _sourceTimestamp: rec.timestamp || 0
        });
      }
      if (!pages.length) { showToast && showToast('完了ページのデータがありません', 'warn'); return; }

      const pageNumberMap = pages.map(p => p._sourcePage);
      let initialIdx = 0;
      if (focusTs !== null) {
        const found = pages.findIndex(p => Number(p._sourceTimestamp) === focusTs);
        if (found >= 0) initialIdx = found;
      }
      if (initialIdx === 0 && focusDate) {
        const found = pages.findIndex(p => p._sourceDate === focusDate && (!bookHint || p._sourceBookId === bookHint) && (pageHint === null || p._sourcePage === pageHint));
        if (found >= 0) initialIdx = found;
      }
      if (initialIdx === 0 && (bookHint || pageHint !== null)) {
        const found = pages.findIndex(p => (!bookHint || p._sourceBookId === bookHint) && (pageHint === null || p._sourcePage === pageHint));
        if (found >= 0) initialIdx = found;
      }

      const forceInitialPage = (focusTs !== null) || (pageHint !== null) || !!bookHint;
      const completedId = `completed-${rangeKey}`;
      const completedTitle = `完了ページ (${rangeLabel})`;
      const pseudoBook = {
        id: completedId,
        title: completedTitle,
        firstPageNumber: 1,
        pageNumberMap,
        pages,
        customStates: [],
        bookmarks: [],
        createdAt: Date.now(),
        _ephemeral: true,
        _initialPage: initialIdx,
        _forceInitialPage: forceInitialPage,
        _openTabType: 'completed',
        _openTabId: completedId,
        _openTabTitle: completedTitle,
        _sourceBookMap: bookMap,
        _sourceAnswerLinkMap: answerLinkMap,
        _sourceRangeLabel: rangeLabel,
        _sourceRangeDates: sortedDates
      };

      state.viewerContext = 'completed';
      await mountBookViewer(pseudoBook);
      state.viewerContext = 'completed';
      state.activeTab = 'home';
      showTab('home', { preserveOpenTab: true });
      try { document.activeElement?.blur?.(); } catch (_) { }

      // Ensure the requested page opens even if同じまとめが開いていた場合
      const targetRealPage = (pageHint !== null ? pageHint : pageNumberMap[initialIdx]) ?? null;
      const hasDuplicatePages = new Set(pageNumberMap).size !== pageNumberMap.length;
      if (targetRealPage !== null && !focusTs && !hasDuplicatePages) {
        const jumpTo = async (realPage) => {
          for (let i = 0; i < 30; i++) {
            const input = document.getElementById('jumpInput');
            const btn = document.getElementById('jumpGo');
            if (input && btn) {
              input.value = String(realPage);
              btn.click();
              return true;
            }
            await new Promise(res => setTimeout(res, 80));
          }
          return false;
        };
        jumpTo(targetRealPage);
      }
    }

    function wireGlobal() {
      try {
        ensurePageScroll();
        applyViewerControlsPosition(viewerControlsBottom);
        const sortSel = document.getElementById('sortSelect');
        if (sortSel) sortSel.onchange = (e) => { state.sort = e.target.value; refresh(); };
        document.querySelectorAll('.toggle .btn').forEach(b => b.onclick = () => { state.viewMode = b.dataset.view; refresh(); });
        const showAnswersToggle = document.getElementById('showAnswersToggle');
        if (showAnswersToggle) {
          showAnswersToggle.checked = state.showAnswers;
          showAnswersToggle.onchange = (e) => {
            state.showAnswers = e.target.checked;
            saveStoredBool(LIBRARY_SHOW_ANSWERS_KEY, state.showAnswers);
            refresh();
          };
        }
        document.getElementById('quickMake')?.addEventListener('click', () => showTab('uploader'));
        document.getElementById('resetAllBtn')?.addEventListener('click', resetAllData);
        document.getElementById('resetLibraryBtn')?.addEventListener('click', resetLibraryOnly);
        document.getElementById('resetBoxesBtn')?.addEventListener('click', resetBoxesOnly);
        document.getElementById('importBookSingleBtn')?.addEventListener('click', () => document.getElementById('importBookSingleFile')?.click());
        const importBookSingleFile = document.getElementById('importBookSingleFile');
        if (importBookSingleFile) importBookSingleFile.onchange = (e) => e.target.files[0] && importSingleBookFile(e.target.files[0]);
        document.getElementById('importBoxSingleBtn')?.addEventListener('click', () => document.getElementById('importBoxSingleFile')?.click());
        const importBoxSingleFile = document.getElementById('importBoxSingleFile');
        if (importBoxSingleFile) importBoxSingleFile.onchange = (e) => e.target.files[0] && importSingleBoxFile(e.target.files[0]);
        document.getElementById('analyzeStorageBtn')?.addEventListener('click', analyzeStorageUsage);
        document.getElementById('optimizeThumbBtn')?.addEventListener('click', optimizeThumbnailsLossy);
        // Settings backup/restore buttons
        document.getElementById('backupSettingsBtn')?.addEventListener('click', async () => {
          await backupSettingsToIDB();
          showToast('設定をバックアップしました', 'ok');
        });
        document.getElementById('restoreSettingsBtn')?.addEventListener('click', async () => {
          // Force restore all settings from backup (overwrite existing)
          try {
            await dbReady;
            const t = db.transaction('settings', 'readonly');
            const req = t.objectStore('settings').get(SETTINGS_BACKUP_KEY);
            req.onsuccess = () => {
              const result = req.result;
              if (result && result.data && typeof result.data === 'object') {
                const count = importAllSettings(result.data);
                showToast(`${count}件の設定を復元しました`, 'ok');
                setTimeout(() => location.reload(), 1000);
              } else {
                showToast('バックアップが見つかりません', 'error');
              }
            };
          } catch (e) {
            showToast('復元に失敗しました', 'error');
          }
        });
        // Settings-only export/import buttons
        document.getElementById('exportSettingsOnlyBtn')?.addEventListener('click', exportSettingsOnly);
        document.getElementById('importSettingsOnlyBtn')?.addEventListener('click', () => {
          document.getElementById('importSettingsOnlyFile')?.click();
        });
        const importSettingsOnlyFile = document.getElementById('importSettingsOnlyFile');
        if (importSettingsOnlyFile) {
          importSettingsOnlyFile.onchange = (e) => {
            if (e.target.files[0]) {
              importSettingsOnly(e.target.files[0]);
              e.target.value = ''; // Reset for re-import
            }
          };
        }
        // Lightweight meta-only export/import buttons
        // Initialize external storage UI (File System Access API)
        initExternalStorageUI();
        initOptimizeControls();
        if (typeof installStudyMenuHotkeyGlobal !== 'function') {
          window.installStudyMenuHotkeyGlobal = () => {
            const normKey = (s) => (s || '').toLowerCase().trim();
            const keyNavKey = (typeof KEY_NAV_CONFIG_KEY !== 'undefined') ? KEY_NAV_CONFIG_KEY : 'viewer-key-nav-config';
            const loadKeyConfig = () => {
              try { return JSON.parse(localStorage.getItem(keyNavKey) || 'null') || {}; } catch (_) { return {}; }
            };
            const handler = (e) => {
              const typing = typeof isTypingTarget === 'function'
                ? isTypingTarget(e.target)
                : !!e.target?.closest?.('input, textarea, select, [contenteditable=\"true\"]');
              if (typing) return;
              const cfg = loadKeyConfig();
              const defaults = (typeof DEFAULT_KEY_NAV_CONFIG !== 'undefined') ? DEFAULT_KEY_NAV_CONFIG : {};
              const keys = Array.isArray(cfg.studyMenuKeys) ? cfg.studyMenuKeys : (defaults.studyMenuKeys || []);
              const codes = Array.isArray(cfg.studyMenuCodes) ? cfg.studyMenuCodes : (defaults.studyMenuCodes || []);
              const match = (list, val) => list.map(normKey).includes(normKey(val));
              if (!match(keys, e.key) && !match(codes, e.code)) return;
              e.preventDefault(); e.stopPropagation();
              try { StudyActionMenu && StudyActionMenu.toggle && StudyActionMenu.toggle({ source: 'global-key' }); renderPageProgressOverlay && renderPageProgressOverlay(); } catch (_) { }
            };
            if (window.__studyMenuHotkey) document.removeEventListener('keydown', window.__studyMenuHotkey);
            window.__studyMenuHotkey = handler;
            document.addEventListener('keydown', handler);
          };
        }
        if (typeof installStudyMenuHotkeyGlobal === 'function') {
          installStudyMenuHotkeyGlobal();
        }

        // Font Settings Logic (IndexedDB for Large Files)
        const appFontInput = document.getElementById('appFontInput');
        const missFontInput = document.getElementById('missFontInput');
        const appFontReset = document.getElementById('appFontReset');
        const missFontReset = document.getElementById('missFontReset');
        const DEFAULT_FONT = "system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";

        // IndexedDB Helpers
        const openFontDB = () => {
          return new Promise((resolve, reject) => {
            const req = indexedDB.open('ViewerFontDB', 1);
            req.onupgradeneeded = (e) => {
              const db = e.target.result;
              if (!db.objectStoreNames.contains('fonts')) {
                db.createObjectStore('fonts', { keyPath: 'type' });
              }
            };
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error);
          });
        };
        const saveFontToDB = async (type, dataUrl) => {
          const db = await openFontDB();
          return new Promise((resolve, reject) => {
            const tx = db.transaction('fonts', 'readwrite');
            const store = tx.objectStore('fonts');
            store.put({ type, dataUrl });
            tx.oncomplete = () => resolve();
            tx.onerror = () => reject(tx.error);
          });
        };
        const getFontFromDB = async (type) => {
          const db = await openFontDB();
          return new Promise((resolve, reject) => {
            const tx = db.transaction('fonts', 'readonly');
            const store = tx.objectStore('fonts');
            const req = store.get(type);
            req.onsuccess = () => resolve(req.result ? req.result.dataUrl : null);
            req.onerror = () => reject(req.error);
          });
        };
        const deleteFontFromDB = async (type) => {
          const db = await openFontDB();
          return new Promise((resolve, reject) => {
            const tx = db.transaction('fonts', 'readwrite');
            const store = tx.objectStore('fonts');
            store.delete(type);
            tx.oncomplete = () => resolve();
            tx.onerror = () => reject(tx.error);
          });
        };

        const loadCustomFont = (name, dataUrl) => {
          if (!dataUrl) return;
          const styleId = `font-style-${name}`;
          let style = document.getElementById(styleId);
          if (!style) {
            style = document.createElement('style');
            style.id = styleId;
            document.head.appendChild(style);
          }
          style.textContent = `
            @font-face {
              font-family: '${name}';
              src: url('${dataUrl}');
            }
          `;
        };

        const applyFontPreference = async (type, dataUrl, persist = false) => {
          let varName = '--app-font';
          let fontName = 'CustomAppFont';
          let defaultFont = DEFAULT_FONT;

          if (type === 'miss') {
            varName = '--miss-font';
            fontName = 'CustomMissFont';
          } else if (type === 'clock') {
            varName = '--clock-font';
            fontName = 'CustomClockFont';
            defaultFont = "'SFMono-Regular', 'Menlo', 'Consolas', monospace";
          }

          if (!dataUrl) {
            document.documentElement.style.setProperty(varName, defaultFont);
            if (persist) {
              try { await deleteFontFromDB(type); showToast('フォント設定をリセットしました', 'ok'); } catch (e) { console.error(e); }
            }
            return;
          }

          loadCustomFont(fontName, dataUrl);
          document.documentElement.style.setProperty(varName, `'${fontName}', ${defaultFont}`);

          if (persist) {
            try {
              await saveFontToDB(type, dataUrl);
              showToast('フォントを保存しました', 'ok');
            } catch (e) {
              console.error(e);
              showToast('保存に失敗しました(サイズ過大などの可能性があります)', 'warn');
            }
          }
        };

        // Initialize from DB
        (async () => {
          try {
            const savedApp = await getFontFromDB('app');
            if (savedApp) applyFontPreference('app', savedApp, false);
            const savedMiss = await getFontFromDB('miss');
            if (savedMiss) applyFontPreference('miss', savedMiss, false);
            const savedClock = await getFontFromDB('clock');
            if (savedClock) applyFontPreference('clock', savedClock, false);
          } catch (e) { console.log('No saved fonts or IDB error', e); }
        })();

        const handleFontUpload = (e, type) => {
          const file = e.target.files?.[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (evt) => {
            const res = evt.target.result;
            applyFontPreference(type, res, true);
          };
          reader.readAsDataURL(file);
          e.target.value = '';
        };

        // Wire up font inputs
        if (appFontInput) appFontInput.onchange = (e) => handleFontUpload(e, 'app');
        if (missFontInput) missFontInput.onchange = (e) => handleFontUpload(e, 'miss');
        if (appFontReset) appFontReset.onclick = () => applyFontPreference('app', null, true);
        if (missFontReset) missFontReset.onclick = () => applyFontPreference('miss', null, true);

        // Viewer Clock Font
        const viewerClockFontUpload = document.getElementById('viewerClockFontUpload');
        const viewerClockFontReset = document.getElementById('viewerClockFontReset');
        if (viewerClockFontUpload) viewerClockFontUpload.onchange = (e) => handleFontUpload(e, 'clock');
        if (viewerClockFontReset) viewerClockFontReset.onclick = () => applyFontPreference('clock', null, true);

        if (typeof installStudyMenuHotkeyGlobal === 'function') {
          installStudyMenuHotkeyGlobal();
        }
        const searchInput = document.getElementById('searchInput');
        if (searchInput) {
          searchInput.oninput = (e) => { state.search = e.target.value; refresh(); };
        }
        // Dictionary wiring
        const dictSearch = document.getElementById('dictSearchInput');
        const dictMode = document.getElementById('dictModeSelect');
        const dictFavOnly = document.getElementById('dictFavoritesOnly');
        const dictClear = document.getElementById('dictClearBtn');
        const dictHistoryBtn = document.getElementById('dictHistoryBtn');
        const dictImportBtn = document.getElementById('dictImportBtn');
        const dictImportFile = document.getElementById('dictImportFile');
        const dictImportSubject = document.getElementById('dictImportSubject');
        const dictSubjectSel = document.getElementById('dictSubjectSelect');
        const dictClearCustomBtn = document.getElementById('dictClearCustomBtn');
        const dictExportCustomBtn = document.getElementById('dictExportCustomBtn');
        const dictClearSubjectBtn = document.getElementById('dictClearSubjectBtn');
        const nonBookBackupBtn = document.getElementById('nonBookBackupBtn');
        const nonBookRestoreBtn = document.getElementById('nonBookRestoreBtn');
        const nonBookRestoreFile = document.getElementById('nonBookRestoreFile');
        const bookDlBackupBtn = document.getElementById('bookDlBackupBtn');
        const bookFolderImportBtn = document.getElementById('bookFolderImportBtn');
        const bookFolderImportInput = document.getElementById('bookFolderImportInput');
        const homeView = document.getElementById('homeView');
        if (dictImportSubject && dictSubjectSel) dictImportSubject.value = dictSubjectSel.value;
        if (dictSearch) dictSearch.oninput = renderDictionary;
        if (dictMode) dictMode.onchange = renderDictionary;
        if (dictFavOnly) dictFavOnly.onchange = renderDictionary;
        if (dictSubjectSel) dictSubjectSel.onchange = () => {
          if (dictImportSubject) dictImportSubject.value = dictSubjectSel.value;
          renderDictionary();
        };
        if (dictClear) dictClear.onclick = () => { if (dictSearch) dictSearch.value = ''; renderDictionary(); };
        if (dictHistoryBtn) dictHistoryBtn.onclick = showDictHistory;
        if (dictImportBtn && dictImportFile) {
          dictImportBtn.onclick = () => dictImportFile.click();
          dictImportFile.onchange = (e) => {
            const f = e.target.files?.[0];
            if (f) { importDictTextFile(f, dictImportSubject?.value || 'english'); }
            e.target.value = '';
          };
        }
        if (dictClearCustomBtn) { dictClearCustomBtn.onclick = (e) => { e.preventDefault(); resetCustomDictEntries(); }; }
        if (dictClearSubjectBtn) {
          dictClearSubjectBtn.onclick = (e) => {
            e.preventDefault();
            const subj = dictSubjectSel?.value || 'english';
            if (confirm(`${subjectLabel(subj)}のカスタム語彙をすべて削除します。よろしいですか？`)) {
              resetCustomDictEntries(subj);
            }
          };
        }
        if (dictExportCustomBtn) { dictExportCustomBtn.onclick = (e) => { e.preventDefault(); exportCustomDictAsText(); }; }
        if (nonBookBackupBtn) {
          nonBookBackupBtn.onclick = async (e) => {
            e.preventDefault();
            await exportSettingsOnly();
          };
        }
        if (nonBookRestoreBtn && nonBookRestoreFile) {
          nonBookRestoreBtn.onclick = (e) => { e.preventDefault(); nonBookRestoreFile.click(); };
          nonBookRestoreFile.onchange = (e) => {
            const f = e.target.files?.[0];
            if (f) importSettingsOnly(f);
            e.target.value = '';
          };
        }
        if (bookDlBackupBtn) {
          bookDlBackupBtn.onclick = async (e) => {
            e.preventDefault();
            await exportBooksOnlyDownload();
          };
        }
        if (bookFolderImportBtn && bookFolderImportInput) {
          bookFolderImportBtn.onclick = (e) => {
            e.preventDefault();
            bookFolderImportInput.click();
          };
          bookFolderImportInput.onchange = async (e) => {
            const files = e.target.files;
            if (files && files.length) await importBooksOnlyFromFolder(files);
            e.target.value = '';
          };
        }
        if (homeView) {
          homeView.addEventListener('mouseenter', () => { homeHoverLock = true; });
          homeView.addEventListener('mouseleave', () => { homeHoverLock = false; });
        }
        // 初期表示
        renderDictionary();
        // Boxes tab toggle
        const boxesToggle = document.getElementById('boxesTabToggle');
        if (boxesToggle) {
          boxesToggle.checked = boxesTabEnabled;
          boxesToggle.onchange = (e) => {
            setBoxesTabEnabled(!!e.target.checked);
            if (!boxesTabEnabled && state.activeTab === 'boxes') {
              showTab('home');
            }
          };
        }
        updateBoxesTabVisibility();
        document.addEventListener('keydown', (e) => { if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'k') { e.preventDefault(); searchInput && searchInput.focus(); } });
        const perfToggle = document.getElementById('perfModeToggle');
        if (perfToggle) { perfToggle.checked = loadStoredBool(PERF_MODE_KEY, false); perfToggle.onchange = (e) => applyPerfMode(e.target.checked); }
        const stageBgInput = document.getElementById('stageBgColor');
        const stageBgPreset = document.getElementById('stageBgPreset');
        const stageBgReset = document.getElementById('stageBgReset');
        const savedPreset = (() => {
          try { return localStorage.getItem(STAGE_BG_PRESET_KEY) || 'default'; } catch (_) { return 'default'; }
        })();
        const savedBase = (() => {
          try { return localStorage.getItem(STAGE_BG_KEY) || STAGE_BG_DEFAULT; } catch (_) { return STAGE_BG_DEFAULT; }
        })();
        const currentBg = stageParseHex(window.stageBgBase || savedBase);
        if (stageBgPreset) {
          stageBgPreset.value = STAGE_BG_PRESETS[savedPreset] ? savedPreset : 'default';
          stageBgPreset.onchange = (e) => {
            const val = e.target.value;
            if (val === 'custom') {
              if (stageBgInput) stageBgInput.disabled = false;
              applyStageBackground(stageBgInput?.value || currentBg || STAGE_BG_DEFAULT);
              try { localStorage.setItem(STAGE_BG_PRESET_KEY, 'custom'); } catch (_) { }
            } else {
              if (stageBgInput) stageBgInput.disabled = true;
              applyStagePreset(val);
            }
            reapplyStageToDom();
          };
        }
        if (stageBgInput) {
          stageBgInput.value = currentBg;
          stageBgInput.disabled = (stageBgPreset && stageBgPreset.value !== 'custom');
          stageBgInput.oninput = (e) => {
            applyStageBackground(e.target.value || STAGE_BG_DEFAULT);
            try { localStorage.setItem(STAGE_BG_PRESET_KEY, 'custom'); } catch (_) { }
            reapplyStageToDom();
          };
        }
        if (stageBgReset) {
          stageBgReset.onclick = () => {
            if (stageBgPreset) { stageBgPreset.value = 'default'; }
            if (stageBgInput) { stageBgInput.value = STAGE_BG_DEFAULT; stageBgInput.disabled = true; }
            applyStagePreset('default');
            reapplyStageToDom();
          };
        }
        const todoColorMode = document.getElementById('todoColorMode');
        const todoColorGrid = document.getElementById('todoColorGrid');
        const todoColorAdd = document.getElementById('todoColorAdd');
        const todoColorReset = document.getElementById('todoColorReset');
        const todoColorCustomWrap = document.getElementById('todoColorCustomWrap');
        const todoDefaultPalette = (Array.isArray(window.__todoDefaultPalette) && window.__todoDefaultPalette.length)
          ? window.__todoDefaultPalette.slice()
          : ['#4da3ff', '#51cf66', '#ffd43b', '#a78bfa', '#fb7185', '#38bdf8', '#fb923c'];
        const normalizeTodoColors = (list) => {
          const seen = new Set();
          const items = Array.isArray(list) ? list : [];
          return items.map(c => String(c || '').trim()).filter(c => {
            if (!/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(c)) return false;
            const key = c.toLowerCase();
            if (seen.has(key)) return false;
            seen.add(key);
            return true;
          }).map(c => c.toLowerCase());
        };
        const loadTodoPaletteCfg = () => {
          if (typeof window.__getTodoPaletteConfig === 'function') return window.__getTodoPaletteConfig();
          let mode = 'default';
          let colors = [];
          try { mode = localStorage.getItem('todo-color-mode') || 'default'; } catch (_) { }
          try { colors = JSON.parse(localStorage.getItem('todo-custom-colors') || '[]'); } catch (_) { colors = []; }
          return { mode: mode === 'custom' ? 'custom' : 'default', colors: normalizeTodoColors(colors) };
        };
        const saveTodoMode = (mode) => {
          if (typeof window.__setTodoPaletteMode === 'function') {
            window.__setTodoPaletteMode(mode);
          } else {
            try { localStorage.setItem('todo-color-mode', mode === 'custom' ? 'custom' : 'default'); } catch (_) { }
          }
        };
        const saveTodoColors = (colors) => {
          const normalized = normalizeTodoColors(colors);
          if (typeof window.__setTodoCustomColors === 'function') {
            window.__setTodoCustomColors(normalized);
          } else {
            try { localStorage.setItem('todo-custom-colors', JSON.stringify(normalized)); } catch (_) { }
          }
        };
        const renderTodoColorSettings = () => {
          if (!todoColorMode || !todoColorGrid) return;
          const cfg = loadTodoPaletteCfg();
          const mode = cfg.mode === 'custom' ? 'custom' : 'default';
          let colors = normalizeTodoColors(cfg.colors);
          todoColorMode.value = mode;
          if (todoColorCustomWrap) todoColorCustomWrap.classList.toggle('hidden', mode !== 'custom');
          if (mode === 'custom' && !colors.length) {
            colors = todoDefaultPalette.slice();
            saveTodoColors(colors);
          }
          if (mode !== 'custom') {
            todoColorGrid.innerHTML = '';
            return;
          }
          todoColorGrid.innerHTML = colors.map((c, idx) => `
            <div class="todo-color-item" data-idx="${idx}">
              <input type="color" value="${c}" aria-label="色 ${idx + 1}">
              <span class="todo-color-hex">${c.toUpperCase()}</span>
              <button class="btn ghost small todo-color-remove" data-idx="${idx}">削除</button>
            </div>
          `).join('');
          todoColorGrid.querySelectorAll('input[type="color"]').forEach(input => {
            input.oninput = (e) => {
              const wrap = e.target.closest('.todo-color-item');
              const idx = parseInt(wrap?.dataset.idx || '-1', 10);
              const cfgNow = loadTodoPaletteCfg();
              const list = normalizeTodoColors(cfgNow.colors);
              if (idx >= 0 && idx < list.length) {
                list[idx] = e.target.value;
                saveTodoColors(list);
                const hex = wrap.querySelector('.todo-color-hex');
                if (hex) hex.textContent = String(e.target.value || '').toUpperCase();
              }
            };
          });
          todoColorGrid.querySelectorAll('.todo-color-remove').forEach(btn => {
            btn.onclick = (e) => {
              const idx = parseInt(e.currentTarget?.dataset.idx || '-1', 10);
              const cfgNow = loadTodoPaletteCfg();
              let list = normalizeTodoColors(cfgNow.colors);
              if (idx >= 0 && idx < list.length) {
                list.splice(idx, 1);
                if (!list.length) list = todoDefaultPalette.slice();
                saveTodoColors(list);
                renderTodoColorSettings();
              }
            };
          });
        };
        renderTodoColorSettings();
        if (todoColorMode) {
          todoColorMode.onchange = (e) => {
            const mode = e.target.value === 'custom' ? 'custom' : 'default';
            if (mode === 'custom') {
              const cfg = loadTodoPaletteCfg();
              if (!normalizeTodoColors(cfg.colors).length) saveTodoColors(todoDefaultPalette);
            }
            saveTodoMode(mode);
            renderTodoColorSettings();
          };
        }
        if (todoColorAdd) {
          todoColorAdd.onclick = () => {
            const cfg = loadTodoPaletteCfg();
            const list = normalizeTodoColors(cfg.colors);
            const next = list.length ? list.slice() : todoDefaultPalette.slice();
            const last = next[next.length - 1] || '#4da3ff';
            next.push(last);
            saveTodoColors(next);
            renderTodoColorSettings();
          };
        }
        if (todoColorReset) {
          todoColorReset.onclick = () => {
            saveTodoColors(todoDefaultPalette);
            saveTodoMode('default');
            renderTodoColorSettings();
          };
        }
        const autoToneToggle = document.getElementById('autoToneToggle');
        const autoToneMode = document.getElementById('autoToneMode');
        const autoToneKey = (typeof AUTO_TONE_KEY !== 'undefined') ? AUTO_TONE_KEY : 'viewer-auto-tone';
        const loadAutoToneCfg = () => {
          try { return Object.assign({ enabled: false, mode: 'red' }, JSON.parse(localStorage.getItem(autoToneKey) || 'null') || {}); } catch (_) { return { enabled: false, mode: 'red' }; }
        };
        const saveAutoToneCfg = (next) => {
          const cfg = Object.assign({ enabled: false, mode: 'red' }, next || {});
          try { localStorage.setItem(autoToneKey, JSON.stringify(cfg)); } catch (_) { }
          if (typeof window.__refreshAutoToneConfig === 'function') window.__refreshAutoToneConfig();
        };
        const syncAutoToneUI = () => {
          const cfg = loadAutoToneCfg();
          if (autoToneToggle) autoToneToggle.checked = !!cfg.enabled;
          if (autoToneMode) autoToneMode.value = cfg.mode || 'red';
        };
        syncAutoToneUI();
        if (autoToneToggle) autoToneToggle.onchange = (e) => saveAutoToneCfg({ enabled: !!e.target.checked, mode: autoToneMode?.value || 'red' });
        if (autoToneMode) autoToneMode.onchange = (e) => saveAutoToneCfg({ enabled: autoToneToggle?.checked, mode: e.target.value || 'red' });
        tapDrawAlways = loadTapDraw();
        if (tapDrawToggle) {
          tapDrawToggle.checked = tapDrawAlways;
          tapDrawToggle.onchange = (e) => {
            tapDrawAlways = !!e.target.checked;
            saveTapDraw(tapDrawAlways);
          };
        }
      } catch (_) { }
      try {
        const hpBarToggle = document.getElementById('hpBarEnable');
        const hpBarStepSel = document.getElementById('hpBarStep');
        const hpKeyEnable = window.HP_BAR_ENABLED_KEY || 'reader-hpbar-enabled';
        const hpKeyStep = window.HP_BAR_STEP_KEY || 'reader-hpbar-step-ms';
        const hpBarDesignSel = document.getElementById('hpBarDesign');
        const hpBarSizeSel = document.getElementById('hpBarSize');
        const hpBarShakeSel = document.getElementById('hpBarShake');
        const hpBarAlignSel = document.getElementById('hpBarAlign');
        const hpStepChoices = Array.isArray(window.HP_BAR_STEP_CHOICES) ? window.HP_BAR_STEP_CHOICES : [60000, 30000, 10000, 5000, 1000];
        const syncHpBarUI = () => {
          const enabled = (typeof window.hpBarEnabled === 'boolean')
            ? window.hpBarEnabled
            : (typeof window.hpLoadBool === 'function' ? window.hpLoadBool(hpKeyEnable, true) : true);
          const step = (typeof window.hpBarStepMs === 'number')
            ? window.hpBarStepMs
            : (typeof window.clampHpStepMs === 'function' ? window.clampHpStepMs(hpStepChoices[0]) : hpStepChoices[0]);
          const designVal = (typeof window.hpBarDesign === 'string') ? window.hpBarDesign : (typeof window.hpLoadString === 'function' ? window.hpLoadString(HP_BAR_DESIGN_KEY, 'standard') : 'standard');
          const sizeVal = (typeof window.hpBarSize === 'string') ? window.hpBarSize : (typeof window.hpLoadString === 'function' ? window.hpLoadString(HP_BAR_SIZE_KEY, 'normal') : 'normal');
          const shakeVal = (typeof window.hpBarShake === 'string') ? window.hpBarShake : (typeof window.hpLoadString === 'function' ? window.hpLoadString(HP_BAR_SHAKE_KEY, 'shake-x') : 'shake-x');
          const alignVal = (typeof window.hpBarAlign === 'string') ? window.hpBarAlign : (typeof window.hpLoadString === 'function' ? window.hpLoadString(HP_BAR_ALIGN_KEY, 'center') : 'center');
          if (hpBarToggle) hpBarToggle.checked = enabled;
          if (hpBarStepSel) hpBarStepSel.value = String(step);
          if (hpBarDesignSel) hpBarDesignSel.value = designVal;
          if (hpBarSizeSel) hpBarSizeSel.value = sizeVal;
          if (hpBarShakeSel) hpBarShakeSel.value = shakeVal;
          if (hpBarAlignSel) hpBarAlignSel.value = alignVal;
        };
        syncHpBarUI();
        if (hpBarToggle) {
          hpBarToggle.onchange = (e) => {
            const enabled = !!e.target.checked;
            if (typeof window.setHpBarEnabled === 'function') { window.setHpBarEnabled(enabled); }
            else { window.hpBarEnabled = enabled; }
            if (typeof window.hpSaveBool === 'function') window.hpSaveBool(hpKeyEnable, enabled);
            if (!enabled) ReaderHpBar.hide();
            else ReaderHpBar.update(studyNowMs());
          };
        }
        if (hpBarStepSel) {
          hpBarStepSel.onchange = (e) => {
            const clamp = (typeof window.clampHpStepMs === 'function') ? window.clampHpStepMs : (v) => parseInt(v, 10) || hpStepChoices[0];
            const ms = clamp(e.target.value);
            e.target.value = String(ms);
            if (typeof window.hpSaveNumber === 'function') window.hpSaveNumber(hpKeyStep, ms);
            if (typeof window.setHpBarStepMs === 'function') { window.setHpBarStepMs(ms); }
            else { window.hpBarStepMs = ms; }
            ReaderHpBar.update(studyNowMs());
          };
        }
        if (hpBarDesignSel) {
          hpBarDesignSel.onchange = (e) => {
            const val = e.target.value;
            if (typeof window.setHpBarDesign === 'function') window.setHpBarDesign(val);
            syncHpBarUI();
            ReaderHpBar.update(studyNowMs());
          };
        }
        if (hpBarSizeSel) {
          hpBarSizeSel.onchange = (e) => {
            const val = e.target.value;
            if (typeof window.setHpBarSize === 'function') window.setHpBarSize(val);
            syncHpBarUI();
            ReaderHpBar.update(studyNowMs());
          };
        }
        if (hpBarShakeSel) {
          hpBarShakeSel.onchange = (e) => {
            const val = e.target.value;
            if (typeof window.setHpBarShake === 'function') window.setHpBarShake(val);
            syncHpBarUI();
            ReaderHpBar.update(studyNowMs());
          };
        }
        if (hpBarAlignSel) {
          hpBarAlignSel.onchange = (e) => {
            const val = e.target.value;
            if (typeof window.setHpBarAlign === 'function') window.setHpBarAlign(val);
            syncHpBarUI();
            ReaderHpBar.update(studyNowMs());
          };
        }
        const controlsBottomToggle = document.getElementById('controlsBottomToggle');
        if (controlsBottomToggle) {
          controlsBottomToggle.checked = viewerControlsBottom;
          controlsBottomToggle.onchange = (e) => applyViewerControlsPosition(!!e.target.checked);
        }
        const pageAnimSelect = document.getElementById('pageAnimSelect');
        if (pageAnimSelect) {
          pageAnimSelect.value = 'none';
          pageAnimSelect.disabled = true;
          pageAnimSelect.title = 'ページめくりアニメーションは無効化されています';
        }
        const pageSpeedNormal = document.getElementById('pageSpeedNormal');
        const pageSpeedShift = document.getElementById('pageSpeedShift');
        const pageSpeedNormalVal = document.getElementById('pageSpeedNormalVal');
        const pageSpeedShiftVal = document.getElementById('pageSpeedShiftVal');
        const pageSpeedReset = document.getElementById('pageSpeedReset');
        const syncPageSpeedUI = () => {
          if (pageSpeedNormal) { pageSpeedNormal.value = String(pageTurboNormalPps); }
          if (pageSpeedShift) { pageSpeedShift.value = String(pageTurboShiftPps); }
          if (pageSpeedNormalVal) pageSpeedNormalVal.textContent = `${pageTurboNormalPps.toFixed(1)} p/s`;
          if (pageSpeedShiftVal) pageSpeedShiftVal.textContent = `${pageTurboShiftPps.toFixed(1)} p/s`;
        };
        const setPageSpeed = ({ normal, shift }) => {
          if (typeof normal !== 'undefined') {
            pageTurboNormalPps = clampPageSpeed(normal, PAGE_SPEED_DEFAULT_NORMAL);
            saveStoredNumber(PAGE_TURBO_NORMAL_PPS_KEY, pageTurboNormalPps);
          }
          if (typeof shift !== 'undefined') {
            pageTurboShiftPps = clampPageSpeed(shift, PAGE_SPEED_DEFAULT_SHIFT);
            saveStoredNumber(PAGE_TURBO_SHIFT_PPS_KEY, pageTurboShiftPps);
          }
          syncPageSpeedUI();
        };
        syncPageSpeedUI();
        if (pageSpeedNormal) pageSpeedNormal.oninput = (e) => setPageSpeed({ normal: parseFloat(e.target.value) });
        if (pageSpeedShift) pageSpeedShift.oninput = (e) => setPageSpeed({ shift: parseFloat(e.target.value) });
        if (pageSpeedReset) pageSpeedReset.onclick = () => setPageSpeed({ normal: PAGE_SPEED_DEFAULT_NORMAL, shift: PAGE_SPEED_DEFAULT_SHIFT });
      } catch (err) {
        console.error('[wireGlobal] UI setup failed (hp/page speed)', err);
      }

      // tabs
      try {
        document.querySelectorAll('#tabs .tab').forEach(t => t.onclick = async () => {
          const id = t.dataset.tab;
          if (plannerTabIds.includes(id)) {
            showTab(id);
            return;
          }
          const viewerEl = document.getElementById('viewerView');
          const completedViewerOpen = state.viewerContext === 'completed' && viewerEl && viewerEl.children.length > 0;
          if (id === 'home' && completedViewerOpen) {
            // ホームタブを押したら完了ビューアを閉じてホーム表示に戻す（タブ情報は保持）
            if (viewerEl) { viewerEl.classList.add('hidden'); }
            document.body.classList.remove('reading');
            state.viewerContext = null;
            showTab('home', { preserveOpenTab: true });
            return;
          }
          const currentlyOnLibrary = state.activeTab === 'library';
          const currentlyOnBoxes = state.activeTab === 'boxes';
          const libraryViewerOpen = state.viewerContext === 'book' && currentlyOnLibrary;
          const boxViewerOpen = state.viewerContext === 'box' && currentlyOnBoxes;

          // ライブラリで閲覧中に再度ライブラリを押した場合のみ一覧へ戻す（状態は閉じる）
          if (id === 'library' && libraryViewerOpen) {
            viewerMemory.book.closed = true;
            viewerMemory.book.id = null;
            viewerMemory.book.ref = null;
            viewerMemory.book.page = 0;
            state.viewerContext = null;
            const viewerEl = document.getElementById('viewerView');
            if (viewerEl) { viewerEl.innerHTML = ''; }
            document.body.classList.remove('reading');
            showTab('library');
            return;
          }
          // ボックスで閲覧中に再度ボックスを押した場合は一覧へ戻す（状態は閉じる）
          if (id === 'boxes' && boxViewerOpen) {
            viewerMemory.box.closed = true;
            viewerMemory.box.id = null;
            state.viewerContext = null;
            const viewerEl = document.getElementById('viewerView');
            if (viewerEl) { viewerEl.innerHTML = ''; }
            showTab('boxes');
            return;
          }

          showTab(id);

          // タブ切り替え後に前回のビューを自動復帰
          if (id === 'library' && viewerMemory.book.id && !viewerMemory.book.closed && state.viewerContext !== 'book') {
            const book = await Book.get(viewerMemory.book.id);
            if (book) mountBookViewer(book);
          }
          if (id === 'boxes' && viewerMemory.box.id && !viewerMemory.box.closed && state.viewerContext !== 'box') {
            const box = await Box.get(viewerMemory.box.id);
            if (box) window.mountBoxViewer && mountBoxViewer(box);
          }
        });
      } catch (err) {
        console.error('[wireGlobal] Tab binding failed', err);
      }

      // Boxes toolbar
      const bs = document.getElementById('boxSearch');
      const bsort = document.getElementById('boxSort');
      const bweak = document.getElementById('onlyWeakBox');
      const bnew = document.getElementById('newBoxToolbar');
      if (bs) { bs.oninput = () => renderBoxes(); }
      if (bsort) { bsort.onchange = () => renderBoxes(); }
      if (bweak) { bweak.onchange = () => renderBoxes(); }
      if (bnew) { bnew.onclick = () => { document.getElementById('newBoxModal').style.display = 'flex'; }; }

      // delegate clicks in main
      const mainEl = document.getElementById('main');
      if (mainEl) mainEl.addEventListener('click', async (e) => {
        const btn = e.target.closest('button'); if (!btn) return;
        if (btn.dataset.open) {
          const book = await Book.get(btn.dataset.open);
          if (book) { mountBookViewer(book); }
          else { console.error('[main click] Book not found:', btn.dataset.open); showToast('本が見つかりません', 'error'); }
        }
        if (btn.dataset.edit) {
          const book = await Book.get(btn.dataset.edit);
          if (book) { editBookMeta(book); }
          else { showToast('本が見つかりません', 'error'); }
        }
        if (btn.dataset.del) {
          const id = btn.dataset.del;
          const target = await Book.get(id);
          if (confirm('本を削除しますか？')) {
            showToast('削除を行っています...', 'info');
            try {
              await Book.del(id);
              await removeAnswerReferences(id);
              refresh(); showToast('削除しました', 'ok');
            } catch (e) {
              console.error(e);
              showToast('削除に失敗しました', 'error');
            }
          }
        }

        if (btn.dataset.dup) {
          const id = btn.dataset.dup;
          const original = await Book.get(id);
          if (!original) { showToast('本が見つかりません', 'error'); return; }
          const copy = structuredClone(original);
          copy.id = uuid();
          copy.title = (original.title || '無題') + ' のコピー';
          copy.createdAt = Date.now();
          // ensure page ids are unique
          const pageIdMap = new Map();
          copy.pages = [];
          for (let i = 0; i < (original.pages || []).length; i++) {
            const p = original.pages[i];
            const newId = uuid();
            pageIdMap.set(p.id, newId);
            const url = await ensurePageData(original, i);
            copy.pages.push({ id: newId, dataUrl: url, state: structuredClone(p.state || { fav: false, weak: false, done: false, extra: [] }), memo: p.memo || '' });
          }
          copy.customStates = structuredClone(original.customStates || []);
          copy.bookmarks = (original.bookmarks || []).map(bm => ({
            id: uuid(),
            label: bm.label,
            page: bm.page || 0,
            pageId: bm.pageId && pageIdMap.get(bm.pageId) || null
          }));
          await Book.add(copy);
          showToast('複製を作成しました', 'ok');
          refresh();
        }

        if (btn.dataset.openBox) { const box = await Box.get(btn.dataset.openBox); mountBoxViewer(box); }
        if (btn.dataset.editBox) { const box = await Box.get(btn.dataset.editBox); editBoxMeta(box); }
        if (btn.dataset.delBox) {
          const id = btn.dataset.delBox;
          const bx = await Box.get(id);
          if (confirm('ボックスを削除しますか？')) {
            await Box.del(id);
            renderBoxes();
          }
        }
      });

      // main mode button（通常/メイン の2状態）
      const mainBtn = document.getElementById('mainModeBtn');
      const toggleMain = () => {
        const active = document.body.classList.toggle('mainmode2');
        document.body.classList.remove('mainmode');
        mainBtn.textContent = active ? '通常' : 'メイン';
        const fb = document.getElementById('floatbar');
        if (fb) { fb.classList.add('hidden'); }
        const restore = document.getElementById('topbarRestore');
        if (restore) { restore.style.display = active ? 'grid' : 'none'; }
      };
      mainBtn.onclick = toggleMain;
      const restoreTopbarBtn = document.getElementById('restoreTopbarBtn');
      if (restoreTopbarBtn) { restoreTopbarBtn.onclick = () => { if (document.body.classList.contains('mainmode2')) toggleMain(); }; }
      document.addEventListener('keydown', (e) => { if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'm') { e.preventDefault(); toggleMain(); } });
      window.__toggleMainMode = toggleMain;

      // PuddingOS shell controls
      puddingInitDrag();
      const logo = document.querySelector('.logo');
      if (logo) {
        logo.title = 'PuddingOSを起動/終了';
        logo.onclick = (e) => { e.preventDefault(); togglePuddingOs(); };
      }
      document.getElementById('puddingExitBtn')?.addEventListener('click', (e) => { e.preventDefault(); exitPuddingOs(); });
      document.getElementById('puddingMinimizeBtn')?.addEventListener('click', (e) => {
        e.preventDefault();
        if (!puddingState.window) return;
        puddingState.window.style.display = 'none';
        puddingState.minimized = true;
      });
      document.addEventListener('mousemove', puddingHandleDockReveal);
      const puddingDock = document.getElementById('puddingDock');
      if (puddingDock) {
        puddingDock.addEventListener('mouseenter', () => document.body.classList.add('pudding-dock-visible'));
        puddingDock.addEventListener('mouseleave', () => document.body.classList.remove('pudding-dock-visible'));
      }
    }

    function editBookMeta(book) {
      const m = document.createElement('div'); m.className = 'modal'; m.style.display = 'flex';
      const b = document.createElement('div'); b.className = 'box'; b.style.width = 'min(700px,96vw)';
      b.innerHTML = `<h3>本の情報を編集</h3>
  <label>タイトル</label><input id="t" class="input" value="${escapeHTML(book.title)}" style="margin-bottom:8px"/>
  <label>タグ（カンマ区切り）</label><input id="g" class="input" value="${escapeHTML((book.tags || []).join(', '))}" style="margin-bottom:8px"/>
  <label>フォルダ</label><input id="f" class="input" value="${escapeHTML(book.folder || '')}" style="margin-bottom:8px"/>
  <label>実ページの開始番号（最初は何ページ目か）</label><input id="p0" type="number" class="input" value="${book.firstPageNumber || 1}" style="margin-bottom:8px"/>
  <label>表紙画像（任意）</label><input id="coverFile" type="file" accept="image/*" class="input" style="margin-bottom:8px"/>
  <label>全ページ画像の差し替え（複数選択）</label><input id="replaceAllFiles" type="file" accept="image/*" multiple class="input" style="margin-bottom:4px"/>
  <div class="tiny" id="replaceAllNote" style="margin:0 0 6px">※保存時に選択した順で全ページを置き換えます（状態/メモ/描画はリセット）</div>
  <div class="tiny" id="replaceAllStatus" style="margin-bottom:8px"></div>
  <div class="row" style="gap:6px;margin-top:6px">
    <button class="btn" id="recalcReal">実ページ番号を再表示</button>
  </div>
  <div class="row" style="justify-content:space-between;gap:8px;margin-top:8px">
    <button class="btn ghost" data-close>閉じる</button>
    <div class="row" style="gap:8px">
      <button class="btn ghost" id="exportThisBook">この本をエクスポート</button>
      <button class="btn primary" data-save>保存</button>
    </div>
  </div>`;
      m.appendChild(b); document.body.appendChild(m);
      b.querySelector('[data-close]').onclick = () => m.remove();
      b.querySelector('#recalcReal').onclick = () => { showToast('ページ一覧の表示を更新します'); };
      b.querySelector('#exportThisBook').onclick = () => exportSingleBook(book);
      const replaceAllInput = b.querySelector('#replaceAllFiles');
      const replaceAllStatus = b.querySelector('#replaceAllStatus');
      if (replaceAllInput) {
        replaceAllInput.onchange = () => {
          const count = replaceAllInput.files?.length || 0;
          if (replaceAllStatus) replaceAllStatus.textContent = count ? `${count}枚選択` : '';
        };
      }
      const saveBtn = b.querySelector('[data-save]');
      let saving = false;
      saveBtn.onclick = async () => {
        if (saving) return;
        saving = true;
        saveBtn.disabled = true;
        try {
          book.title = b.querySelector('#t').value.trim();
          book.tags = b.querySelector('#g').value.split(',').map(s => s.trim()).filter(Boolean);
          book.folder = b.querySelector('#f').value.trim();
          book.firstPageNumber = parseInt(b.querySelector('#p0').value, 10) || 1;
          const file = b.querySelector('#coverFile').files?.[0];
          const replaceFiles = Array.from(replaceAllInput?.files || []);
          if (replaceFiles.length) {
            const prevCount = Array.isArray(book.pages) ? book.pages.length : 0;
            if (!confirm(`全${replaceFiles.length}枚で現在の${prevCount}ページを差し替えます。\n\n状態・メモ・描画はリセットされます。よろしいですか？`)) {
              saveBtn.disabled = false;
              saving = false;
              return;
            }
            const ordered = replaceFiles.slice();
            const nextPages = [];
            for (let i = 0; i < ordered.length; i++) {
              if (replaceAllStatus) replaceAllStatus.textContent = `読み込み中... ${i + 1}/${ordered.length}`;
              const dataUrl = await fileToDataURL(ordered[i]);
              nextPages.push({ id: uuid(), dataUrl, state: { fav: false, weak: false, done: false, extra: [] }, memo: '' });
              if (i % 3 === 0) await new Promise(res => setTimeout(res, 10));
            }
            (book.pages || []).forEach(p => dropPageCache(p?.id));
            nextPages.forEach(p => touchPageCache(p.id, p.dataUrl));
            book.pages = nextPages;
            delete book.pageNumberMap;
            if (!file) book.coverDataUrl = nextPages[0]?.dataUrl || null;
            if (replaceAllInput) replaceAllInput.value = '';
            if (replaceAllStatus) replaceAllStatus.textContent = `${nextPages.length}枚で差し替えました`;
          }
          if (file) { book.coverDataUrl = await fileToDataURL(file); }
          await Book.put(book); m.remove(); refresh(); showToast('更新しました', 'ok');
        } catch (err) {
          console.error(err);
          showToast('更新に失敗しました', 'error');
        } finally {
          if (m.isConnected) {
            saveBtn.disabled = false;
            saving = false;
          }
        }
      };
    }

    async function refresh() {
      const books = await Book.listMeta();
      window.__allBooksCache = books;
      hiddenAnswerIdsCache = collectHiddenAnswerIds(books);
      const visible = state.showAnswers ? books : books.filter(b => !hiddenAnswerIdsCache.has(b.id));
      renderTags(visible);
      renderFolders(visible);
      renderLibrary(visible);
      updateHiddenAnswersInfo(hiddenAnswerIdsCache.size);
    }

    // boot
    dbReady.then(async () => {
      wireGlobal();
      setupUploadUI();
      await refresh();
      const restored = await restoreOpenTabs();
      if (!restored) renderOpenTabs();
      showTab('home');
    }).catch(e => {
      console.error('[DB Init] Failed:', e);
      wireGlobal();
      setupUploadUI();
      showTab('home');
      showToast('データベースエラーが発生しました。再読み込みしてください。', 'error');
    });
  </script>

  <div class="modal" id="newBookFromSelModal">
    <div class="box">
      <h3>選択ページから新しい本を作成</h3>
      <input id="nbTitle" class="input" placeholder="タイトル（必須）" style="margin-bottom:8px" />
      <input id="nbTags" class="input" placeholder="タグ（カンマ区切り, 任意）" style="margin-bottom:8px" />
      <input id="nbFolder" class="input" placeholder="フォルダ（任意）" style="margin-bottom:8px" />
      <label class="row" style="gap:8px;margin:6px 0"><input id="nbRemove" type="checkbox" /> 元の本から選択ページを削除する</label>
      <div class="row space" style="margin-top:10px">
        <button class="btn ghost" data-close>閉じる</button>
        <button class="btn primary" id="nbCreate">作成</button>
      </div>
    </div>
  </div>

  <div id="daiOverlay">
    <div id="daiPanel">
      <div class="dai-input-wrap">
        <input id="daiInput" type="text">
        <button id="daiSendBtn">検索</button>
      </div>
      <div id="daiContent">
        <div id="daiResultList"></div>
        <div id="daiDetail" class="hidden">
          <div id="daiWord" style="font-size:20px;font-weight:700;">-</div>
          <div id="daiPron" style="margin-top:4px;color:#c7d4f0;"></div>
          <div id="daiPos" style="margin-top:4px;color:#8fa3c8;"></div>
          <div id="daiMeaning" style="margin-top:8px;white-space:pre-wrap;"></div>
          <div id="daiExampleWrap" style="margin-top:8px;white-space:pre-wrap;"></div>
          <div id="daiExtraWrap" style="margin-top:8px;white-space:pre-wrap;color:#c7d4f0;"></div>
          <button id="daiFavBtn" class="btn ghost small" style="margin-top:10px;">☆ お気に入り</button>
        </div>
      </div>
      <div class="dai-resize-handle dai-resize-e" data-resize="e"></div>
      <div class="dai-resize-handle dai-resize-s" data-resize="s"></div>
      <div class="dai-resize-handle dai-resize-se" data-resize="se"></div>
    </div>
  </div>

  <!-- Box viewer parity override -->
  <script>
    (function () {
      const overlay = document.getElementById('daiOverlay');
      const panel = document.getElementById('daiPanel');
      const input = document.getElementById('daiInput');
      const list = document.getElementById('daiResultList');
      const sendBtn = document.getElementById('daiSendBtn');
      const detail = document.getElementById('daiDetail');
      const wordEl = document.getElementById('daiWord');
      const pronEl = document.getElementById('daiPron');
      const posEl = document.getElementById('daiPos');
      const meaningEl = document.getElementById('daiMeaning');
      const exEl = document.getElementById('daiExampleWrap');
      const extraEl = document.getElementById('daiExtraWrap');
      const favBtn = document.getElementById('daiFavBtn');
      const resizeHandles = panel ? panel.querySelectorAll('[data-resize]') : [];
      if (!overlay || !input || !list) return;
      let open = false;
      let activeIdx = 0;
      const FAV_KEY = 'daigpt_fav';
      let favorites = [];
      let currentMatches = [];
      let currentSelected = null;
      let panelHasCustomPos = false;
      let panelHasCustomSize = false;
      let compactPrevSize = null;
      let dragging = false;
      let resizing = null;
      const dragOffset = { x: 0, y: 0 };
      const panelSize = { w: null, h: null };
      const minPanelW = 520;
      const minPanelH = 200;
      const defaultPanelSize = () => ({
        w: Math.min(820, Math.max(640, Math.floor(window.innerWidth * 0.78))),
        h: Math.min(320, Math.max(240, Math.floor(window.innerHeight * 0.38)))
      });
      const entryKey = (e) => `${e.subject || 'english'}::${e.word}`;
      const isTyping = (el) => {
        if (!el) return false;
        const tag = el.tagName;
        if (tag === 'INPUT' || tag === 'TEXTAREA' || el.isContentEditable) return true;
        return false;
      };
      function resetPanelPosition() {
        if (!panel) return;
        panelHasCustomPos = false;
        panelHasCustomSize = false;
        panel.classList.remove('dragging');
        panel.classList.remove('dai-no-trans');
        panel.style.left = '50%';
        panel.style.top = '14vh';
        const def = defaultPanelSize();
        panel.style.width = `${def.w}px`;
        panel.style.height = `${def.h}px`;
      }
      function clampPanelPosition() {
        if (!panel || (!panelHasCustomPos && !dragging)) return;
        const rect = panel.getBoundingClientRect();
        if (!rect.width || !rect.height) return;
        const maxX = Math.max(8, window.innerWidth - rect.width - 8);
        const maxY = Math.max(8, window.innerHeight - rect.height - 8);
        const nextX = Math.min(Math.max(rect.left, 8), maxX);
        const nextY = Math.min(Math.max(rect.top, 8), maxY);
        panel.style.left = `${nextX}px`;
        panel.style.top = `${nextY}px`;
      }
      function clampPanelSize() {
        if (!panel) return;
        const visible = overlay?.classList.contains('open') || overlay?.style.display === 'flex';
        if (!visible && !panelHasCustomSize && !resizing) return;
        const rect = panel.getBoundingClientRect();
        const def = defaultPanelSize();
        const compact = panel.classList.contains('dai-compact');
        const effMinH = compact ? 90 : minPanelH;
        let w = rect.width || panelSize.w || def.w || minPanelW;
        let h = rect.height || panelSize.h || def.h || minPanelH;
        const maxW = Math.max(minPanelW, window.innerWidth - 16);
        const maxH = Math.max(effMinH, window.innerHeight - 16);
        if (compact) {
          h = Math.min(h, effMinH + 12);
          w = Math.min(w, def.w);
        }
        w = Math.min(Math.max(w, minPanelW), maxW);
        h = Math.min(Math.max(h, effMinH), maxH);
        panel.style.width = `${w}px`;
        panel.style.height = `${h}px`;
        panelSize.w = w; panelSize.h = h;
      }
      function loadPrefs() {
        try { favorites = JSON.parse(localStorage.getItem(FAV_KEY) || '[]') || []; } catch (_) { favorites = []; }
        favorites = favorites.map(k => k.includes('::') ? k : `english::${k}`);
      }
      function savePrefs() {
        try { localStorage.setItem(FAV_KEY, JSON.stringify(favorites.slice(0, 200))); } catch (_) { }
      }
      function favIds() { return new Set(favorites || []); }
      function toggleFav(entry) {
        if (!entry) return;
        const key = entryKey(entry);
        const set = favIds();
        if (set.has(key)) { favorites = favorites.filter(x => x !== key); }
        else { favorites = [key, ...favorites.filter(x => x !== key)].slice(0, 200); }
        savePrefs();
        renderResults(input.value);
        updateDetailFav();
      }
      function updateDetailFav() {
        if (!favBtn || !currentSelected) return;
        const isFav = favIds().has(entryKey(currentSelected));
        favBtn.textContent = isFav ? '★ お気に入り中' : '☆ お気に入り';
      }
      function close() {
        open = false;
        overlay.classList.remove('open');
        setTimeout(() => { overlay.style.display = 'none'; }, 180);
        panel.classList.remove('exec');
        input.value = '';
        list.innerHTML = '';
        activeIdx = 0;
        currentMatches = [];
        currentSelected = null;
        if (detail) detail.classList.add('hidden');
      }
      function openBox() {
        open = true;
        overlay.style.display = 'flex';
        if (!panelHasCustomPos) {
          resetPanelPosition();
        } else {
          panel.classList.add('dragging');
          clampPanelPosition();
        }
        clampPanelSize();
        requestAnimationFrame(() => overlay.classList.add('open'));
        panel.classList.remove('exec');
        input.value = '';
        activeIdx = 0;
        setTimeout(() => input.focus(), 10);
        const shouldCompact = !(input.value || '').trim();
        renderResults('', { noAnim: shouldCompact });
      }
      function showEntry(entry) {
        if (!entry || !detail) return;
        currentSelected = entry;
        detail.classList.remove('hidden');
        if (wordEl) wordEl.textContent = entry.word || '';
        if (pronEl) pronEl.textContent = entry.reading ? `発音/カナ: ${entry.reading}` : '';
        if (posEl) {
          const posLabel = translatePosLabel(entry.pos) || entry.pos || '';
          const subj = subjectLabel(entry.subject || 'english');
          posEl.textContent = [posLabel, subj].filter(Boolean).join(' / ');
        }
        if (meaningEl) meaningEl.textContent = entry.meaning || '';
        if (exEl) {
          const listEx = Array.isArray(entry.examples) ? entry.examples : [];
          exEl.innerHTML = listEx.length ? `<div>例文</div><ul style="margin:4px 0 0 16px;">${listEx.map(x => `<li>${escapeHTML(x)}</li>`).join('')}</ul>` : '';
        }
        if (extraEl) {
          const extras = [entry.extra, entry.detail].filter(Boolean).join(' / ');
          extraEl.textContent = extras || '';
        }
        updateDetailFav();
      }
      function renderResults(q, opts = {}) {
        const query = (q || '').trim();
        const noAnim = !!opts.noAnim;
        const endNoAnim = () => { if (noAnim && panel) requestAnimationFrame(() => panel.classList.remove('dai-no-trans')); };
        const compactMode = () => {
          if (!panel) return;
          if (noAnim) panel.classList.add('dai-no-trans');
          if (panelHasCustomSize && !compactPrevSize) {
            const rect = panel.getBoundingClientRect();
            compactPrevSize = { w: rect.width, h: rect.height };
          }
          panel.classList.add('dai-compact');
          panel.style.height = '';
          panel.style.minHeight = '90px';
          if (!panelHasCustomSize) {
            const def = defaultPanelSize();
            panel.style.width = `${def.w}px`;
            panel.style.height = `${def.h}px`;
          } else {
            const rect = panel.getBoundingClientRect();
            const def = defaultPanelSize();
            if (rect.width > def.w) panel.style.width = `${def.w}px`;
          }
          clampPanelSize();
          endNoAnim();
        };
        const expandMode = () => {
          if (!panel) return;
          if (noAnim) panel.classList.add('dai-no-trans');
          panel.classList.remove('dai-compact');
          panel.style.minHeight = `${minPanelH}px`;
          if (panelHasCustomSize && compactPrevSize) {
            panel.style.width = `${compactPrevSize.w}px`;
            panel.style.height = `${compactPrevSize.h}px`;
          } else if (!panelHasCustomSize) {
            const def = defaultPanelSize();
            panel.style.height = `${def.h}px`;
            panel.style.width = `${def.w}px`;
          } else if (compactPrevSize) {
            panel.style.width = `${compactPrevSize.w}px`;
            panel.style.height = `${compactPrevSize.h}px`;
          }
          compactPrevSize = null;
          clampPanelSize();
          endNoAnim();
        };
        if (!query) {
          list.innerHTML = '';
          detail?.classList.add('hidden');
          currentMatches = [];
          currentSelected = null;
          compactMode();
          return;
        }
        const mode = /[ぁ-んァ-ン一-龥]/.test(query) ? 'ja' : 'auto';
        const favSet = favIds();
        const matched = DICT_DATA.filter(e => dictMatch(e, query, mode));
        currentMatches = rankDictEntries(matched, query, favSet);
        if (!currentMatches.length) {
          list.innerHTML = '<div class="muted" style="padding:8px;">単語が見つかりません</div>';
          detail?.classList.add('hidden');
          currentSelected = null;
          compactMode();
          return;
        }
        expandMode();
        list.innerHTML = currentMatches.slice(0, 60).map((e, i) => {
          const isFav = favIds().has(entryKey(e));
          const posLabel = translatePosLabel(e.pos) || e.pos || '';
          const subj = subjectLabel(e.subject || 'english');
          return `<div class="item ${i === activeIdx ? 'active' : ''}" data-word="${escapeHTML(e.word)}" style="cursor:pointer;">
            <div class="row space" style="gap:6px;">
              <div>
                <strong>${escapeHTML(e.word)}</strong>
                <div class="muted" style="font-size:11px">${escapeHTML(e.meaning || '')}</div>
              </div>
              ${posLabel ? `<span class="pill" style="opacity:.85">${escapeHTML(posLabel)}</span>` : ''}
              <span class="pill" style="opacity:.75">${escapeHTML(subj)}</span>
              ${isFav ? '<span class="pill" style="opacity:.7">★</span>' : ''}
            </div>
          </div>`;
        }).join('');
        activeIdx = Math.min(activeIdx, currentMatches.length - 1);
        showEntry(currentMatches[activeIdx]);
      }
      function setActive(idx) {
        activeIdx = Math.max(0, Math.min(idx, currentMatches.length - 1));
        const items = Array.from(list.querySelectorAll('.item'));
        items.forEach((li, i) => li.classList.toggle('active', i === activeIdx));
        if (currentMatches[activeIdx]) showEntry(currentMatches[activeIdx]);
      }
      const normalizeCmd = (s) => (s || '').trim();
      const isBookCommand = (s) => {
        const m = normalizeCmd(s).match(/^\/本[\s　]+(.+)/);
        return m ? m[1].trim() : null;
      };
      async function openBookByTitle(name) {
        const q = (name || '').trim();
        if (!q || !window.Book || !Book.listMeta) return false;
        let metas = [];
        try { metas = await Book.listMeta(); } catch (_) { metas = []; }
        if (!metas.length) return false;
        const norm = (t) => (t || '').replace(/[\\s　]+/g, '').toLowerCase();
        const exact = metas.find(b => norm(b.title) === norm(q));
        const target = exact || metas.find(b => norm(b.title).includes(norm(q)));
        if (!target) return false;
        const full = await Book.get(target.id).catch(() => null);
        if (!full) return false;
        if (typeof showTab === 'function') showTab('library', { preserveOpenTab: true });
        if (typeof mountBookViewer === 'function') {
          const res = mountBookViewer(full);
          if (res && typeof res.then === 'function') await res;
        }
        return true;
      }
      async function runCommandIfAny(val) {
        const bookName = isBookCommand(val);
        if (!bookName) return false;
        close();
        const ok = await openBookByTitle(bookName);
        if (!ok) { try { showToast && showToast('本が見つかりません', 'error'); } catch (_) { alert('本が見つかりません'); } }
        return true;
      }
      function runSearch() { renderResults(input.value); }
      function startResize(dir, e) {
        if (!panel || !dir) return;
        const rect = panel.getBoundingClientRect();
        panelHasCustomPos = true;
        panelHasCustomSize = true;
        compactPrevSize = null;
        panel.classList.add('dai-no-trans');
        panel.classList.add('dragging');
        panel.style.left = `${rect.left}px`;
        panel.style.top = `${rect.top}px`;
        panel.style.width = `${rect.width}px`;
        panel.style.height = `${rect.height}px`;
        resizing = {
          dir,
          startX: e.clientX,
          startY: e.clientY,
          startW: rect.width,
          startH: rect.height
        };
        e.preventDefault();
        e.stopPropagation();
      }
      function handleResize(e) {
        if (!resizing || !panel) return;
        const dx = e.clientX - resizing.startX;
        const dy = e.clientY - resizing.startY;
        let nextW = resizing.startW;
        let nextH = resizing.startH;
        if (resizing.dir.includes('e')) nextW += dx;
        if (resizing.dir.includes('s')) nextH += dy;
        const maxW = Math.max(minPanelW, window.innerWidth - 16);
        const maxH = Math.max(minPanelH, window.innerHeight - 16);
        nextW = Math.min(Math.max(nextW, minPanelW), maxW);
        nextH = Math.min(Math.max(nextH, minPanelH), maxH);
        panel.style.width = `${nextW}px`;
        panel.style.height = `${nextH}px`;
        panelSize.w = nextW; panelSize.h = nextH;
        clampPanelPosition();
        e.preventDefault();
      }
      function endResize() {
        if (!resizing) return;
        resizing = null;
        panelHasCustomSize = true;
        compactPrevSize = null;
        panel.classList.remove('dai-no-trans');
      }
      function startDrag(e) {
        if (!panel) return;
        if (resizing) return;
        if (e.target.closest('input, textarea, button, select, a, label, #daiResultList, #daiDetail, [data-resize]')) return;
        const rect = panel.getBoundingClientRect();
        dragging = true;
        panelHasCustomPos = true;
        panel.classList.add('dai-no-trans');
        panel.classList.add('dragging');
        panel.style.left = `${rect.left}px`;
        panel.style.top = `${rect.top}px`;
        dragOffset.x = e.clientX - rect.left;
        dragOffset.y = e.clientY - rect.top;
        e.preventDefault();
      }
      function handleDrag(e) {
        if (resizing) return;
        if (!dragging || !panel) return;
        const nextX = Math.min(Math.max(e.clientX - dragOffset.x, 8), Math.max(8, window.innerWidth - panel.offsetWidth - 8));
        const nextY = Math.min(Math.max(e.clientY - dragOffset.y, 8), Math.max(8, window.innerHeight - panel.offsetHeight - 8));
        panel.style.left = `${nextX}px`;
        panel.style.top = `${nextY}px`;
      }
      function endDrag() { dragging = false; panel.classList.remove('dai-no-trans'); }
      document.addEventListener('keydown', (e) => {
        if (open) {
          if (e.key === 'Escape') { e.preventDefault(); close(); return; }
          if (e.key === ' ' && !e.repeat && !(input.value || '').trim()) { e.preventDefault(); close(); return; }
          if (e.key === 'ArrowDown') { e.preventDefault(); setActive(activeIdx + 1); return; }
          if (e.key === 'ArrowUp') { e.preventDefault(); setActive(activeIdx - 1); return; }
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            runCommandIfAny(input.value).then((handled) => { if (!handled) runSearch(); });
            return;
          }
          return;
        }
        if (e.key === ' ' && !e.repeat && !isTyping(e.target)) {
          e.preventDefault();
          openBox();
          renderResults('');
        }
      });
      input.addEventListener('input', () => renderResults(input.value));
      sendBtn?.addEventListener('click', (e) => { e.preventDefault(); runSearch(); });
      list.addEventListener('click', (e) => {
        const item = e.target.closest('.item');
        if (!item) return;
        const idx = Array.from(list.querySelectorAll('.item')).indexOf(item);
        setActive(idx);
      });
      favBtn?.addEventListener('click', () => { if (currentSelected) toggleFav(currentSelected); });
      panel?.addEventListener('pointerdown', startDrag);
      resizeHandles.forEach(h => h?.addEventListener('pointerdown', (e) => startResize(h.dataset.resize, e)));
      window.addEventListener('pointermove', (e) => { handleResize(e); handleDrag(e); });
      window.addEventListener('pointerup', () => { endResize(); endDrag(); });
      window.addEventListener('pointercancel', () => { endResize(); endDrag(); });
      window.addEventListener('resize', () => { clampPanelSize(); clampPanelPosition(); });
      clampPanelSize();
      loadPrefs();
      renderResults('');
    })();
  </script>

  <div id="todoPageOverlay" class="todo-page-overlay">
    <div class="todo-page-sheet">
      <div class="row" style="justify-content:space-between;align-items:center;gap:6px;flex-wrap:wrap;">
        <h3 style="margin:0">ページ表</h3>
        <div class="row" style="gap:6px;align-items:center;">
          <span class="tiny" style="color:var(--muted)">スクロールで追加読み込み</span>
          <button class="btn ghost small" id="todoPageOverlayClose">閉じる</button>
        </div>
      </div>
      <div class="todo-page-grid" id="todoPageOverlayGrid"></div>
    </div>
  </div>

  <div id="todoEditOverlay" class="todo-page-overlay">
    <div class="todo-page-sheet">
      <div class="row" style="justify-content:space-between;align-items:center;gap:6px;flex-wrap:wrap;">
        <h3 style="margin:0">ToDo編集</h3>
        <div class="row" style="gap:6px;align-items:center;">
          <button class="btn ghost small" id="todoEditClose">キャンセル</button>
          <button class="btn small" id="todoEditSave">保存</button>
        </div>
      </div>
      <input id="todoEditTitle" class="input" placeholder="やること">
      <div class="row" style="align-items:center;gap:8px;">
        <input id="todoEditRange" class="input" placeholder="ページ (12,15-20 など)" style="flex:1;">
        <label>1ページ(分)</label><input id="todoEditPer" type="number" min="1" value="5" class="input" style="width:80px">
      </div>
      <div class="row" style="align-items:center;gap:8px;flex-wrap:wrap;">
        <label style="min-width:70px">本と紐付け</label>
        <input id="todoEditBookSearch" class="input" placeholder="タイトル/タグを検索" style="flex:1;min-width:160px">
        <select id="todoEditBookSelect" class="input" style="min-width:220px">
          <option value="">紐付けなし</option>
        </select>
        <button class="btn ghost small" id="todoEditBookReload">再読込</button>
      </div>
      <div class="page-blocks" id="todoEditPageBlocks"></div>
      <div class="row" style="gap:8px; align-items:center; flex-wrap:wrap;">
        <input id="todoEditDue" type="date" class="input" style="max-width:150px">
        <input id="todoEditDueTime" type="time" class="input" style="max-width:110px">
        <span class="tiny" id="todoEditRangeCount" style="color:var(--muted)">0ページ</span>
      </div>
      <textarea id="todoEditNote" class="input" placeholder="メモ" style="min-height:70px;"></textarea>
    </div>
  </div>
  <div class="timer-finish-toast" id="timerFinishToast" aria-live="polite">
    <div class="timer-finish-head">
      <div>
        <div class="timer-finish-title" id="timerFinishTitle">タイマー終了</div>
        <div class="timer-finish-sub" id="timerFinishSub">続行しますか？</div>
      </div>
      <button class="timer-finish-close" id="timerFinishClose" aria-label="閉じる">×</button>
    </div>
    <div class="timer-finish-body">
      <div class="timer-finish-time" id="timerFinishTime">00:00</div>
      <div class="timer-finish-meta" id="timerFinishMeta">経過 00:00</div>
    </div>
    <div class="timer-finish-actions">
      <button class="btn ghost small" id="timerFinishStop">停止</button>
      <button class="btn primary small" id="timerFinishContinue">続行</button>
    </div>
  </div>
  <div class="timer-finish-toast lesson-toast" id="lessonToast" aria-live="polite">
    <div class="timer-finish-head">
      <div>
        <div class="timer-finish-title" id="lessonToastTitle">授業のお知らせ</div>
        <div class="timer-finish-sub" id="lessonToastSub">--</div>
      </div>
      <button class="timer-finish-close" id="lessonToastClose" aria-label="閉じる">×</button>
    </div>
    <div class="timer-finish-body">
      <div class="timer-finish-time" id="lessonToastTime">--</div>
      <div class="timer-finish-meta" id="lessonToastMeta">--</div>
    </div>
    <div class="timer-finish-actions" id="lessonToastActions"></div>
  </div>
</body>

</html>
